{
  "dataset": "commons-csv",
  "classes": {
    "org.apache.commons.csv.Constants": {
      "Javadoc": "\r\n * Constants for this package.\r\n "
    },
    "org.apache.commons.csv.CSVFormat": {
      "Javadoc": "\r\n * Specifies the format of a CSV file for parsing and writing.\r\n *\r\n * <h2>Using predefined formats</h2>\r\n *\r\n * <p>\r\n * You can use one of the predefined formats:\r\n * </p>\r\n *\r\n * <ul>\r\n * <li>{@link #DEFAULT}</li>\r\n * <li>{@link #EXCEL}</li>\r\n * <li>{@link #INFORMIX_UNLOAD}</li>\r\n * <li>{@link #INFORMIX_UNLOAD_CSV}</li>\r\n * <li>{@link #MYSQL}</li>\r\n * <li>{@link #RFC4180}</li>\r\n * <li>{@link #ORACLE}</li>\r\n * <li>{@link #POSTGRESQL_CSV}</li>\r\n * <li>{@link #POSTGRESQL_TEXT}</li>\r\n * <li>{@link #TDF}</li>\r\n * </ul>\r\n *\r\n * <p>\r\n * For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVFormat.EXCEL.parse(reader);\r\n * </pre>\r\n *\r\n * <p>\r\n * The {@link CSVParser} provides static methods to parse other input types, for example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVParser parser = CSVParser.parse(file, StandardCharsets.US_ASCII, CSVFormat.EXCEL);\r\n * </pre>\r\n *\r\n * <h2>Defining formats</h2>\r\n *\r\n * <p>\r\n * You can extend a format by calling the {@code set} methods. For example:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withNullString(&quot;N/A&quot;).withIgnoreSurroundingSpaces(true);\r\n * </pre>\r\n *\r\n * <h2>Defining column names</h2>\r\n *\r\n * <p>\r\n * To define the column names you want to use to access records, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * Calling {@link Builder#setHeader(String...)} lets you use the given names to address values in a {@link CSVRecord}, and assumes that your CSV source does not\r\n * contain a first record that also defines column names.\r\n *\r\n * If it does, then you are overriding this metadata with your names and you should skip the first record by calling\r\n * {@link Builder#setSkipHeaderRecord(boolean)} with {@code true}.\r\n * </p>\r\n *\r\n * <h2>Parsing</h2>\r\n *\r\n * <p>\r\n * You can use a format directly to parse a reader. For example, to parse an Excel file with columns header, write:\r\n * </p>\r\n *\r\n * <pre>\r\n * Reader in = ...;\r\n * CSVFormat.EXCEL.withHeader(&quot;Col1&quot;, &quot;Col2&quot;, &quot;Col3&quot;).parse(in);\r\n * </pre>\r\n *\r\n * <p>\r\n * For other input types, like resources, files, and URLs, use the static methods on {@link CSVParser}.\r\n * </p>\r\n *\r\n * <h2>Referencing columns safely</h2>\r\n *\r\n * <p>\r\n * If your source contains a header record, you can simplify your code and safely reference columns, by using {@link Builder#setHeader(String...)} with no\r\n * arguments:\r\n * </p>\r\n *\r\n * <pre>\r\n * CSVFormat.EXCEL.withHeader();\r\n * </pre>\r\n *\r\n * <p>\r\n * This causes the parser to read the first record and use its values as column names.\r\n *\r\n * Then, call one of the {@link CSVRecord} get method that takes a String column name argument:\r\n * </p>\r\n *\r\n * <pre>\r\n * String value = record.get(&quot;Col1&quot;);\r\n * </pre>\r\n *\r\n * <p>\r\n * This makes your code impervious to changes in column order in the CSV file.\r\n * </p>\r\n *\r\n * <h2>Serialization</h2>\r\n * <p>\r\n *   This class implements the {@link Serializable} interface with the following caveats:\r\n * </p>\r\n * <ul>\r\n *   <li>This class will no longer implement Serializable in 2.0.</li>\r\n *   <li>Serialization is not supported from one version to the next.</li>\r\n * </ul>\r\n * <p>\r\n *   The {@code serialVersionUID} values are:\r\n * </p>\r\n * <ul>\r\n *   <li>Version 1.10.0: {@code 2L}</li>\r\n *   <li>Version 1.9.0 through 1.0: {@code 1L}</li>\r\n * </ul>\r\n *\r\n * <h2>Notes</h2>\r\n * <p>\r\n * This class is immutable.\r\n * </p>\r\n * <p>\r\n * Not all settings are used for both parsing and writing.\r\n * </p>\r\n ",
      "methods": {
        "clone": {
          "Javadoc": "* Null-safe clone of an array.\r\n     *\r\n     * @param <T>    The array element type.\r\n     * @param values the source array\r\n     * @return the cloned array."
        },
        "contains": {
          "Javadoc": "* Returns true if the given string contains the search char.\r\n     *\r\n     * @param source the string to check.\r\n     * @param searchCh the character to search.\r\n     *\r\n     * @return true if {@code c} contains a line break character"
        },
        "containsLineBreak": {
          "Javadoc": "* Returns true if the given string contains a line break character.\r\n     *\r\n     * @param source the string to check.\r\n     *\r\n     * @return true if {@code c} contains a line break character."
        },
        "isLineBreak": {
          "Javadoc": "* Returns true if the given character is a line break character.\r\n     *\r\n     * @param c the character to check, may be null.\r\n     *\r\n     * @return true if {@code c} is a line break character (and not null)."
        },
        "isTrimChar": {
          "Javadoc": "Same test as in as {@link String#trim()}."
        },
        "newFormat": {
          "Javadoc": "* Creates a new CSV format with the specified delimiter.\r\n     *\r\n     * <p>\r\n     * Use this method if you want to create a CSVFormat from scratch. All fields but the delimiter will be initialized with null/false.\r\n     * </p>\r\n     *\r\n     * @param delimiter the char used for value separation, must not be a line break character\r\n     * @return a new CSV format.\r\n     * @throws IllegalArgumentException if the delimiter is a line break character\r\n     *\r\n     * @see #DEFAULT\r\n     * @see #RFC4180\r\n     * @see #MYSQL\r\n     * @see #EXCEL\r\n     * @see #TDF"
        },
        "valueOf": {
          "Javadoc": "* Gets one of the predefined formats from {@link CSVFormat.Predefined}.\r\n     *\r\n     * @param format name\r\n     * @return one of the predefined formats\r\n     * @since 1.2"
        },
        "builder": {
          "Javadoc": "* Creates a new Builder for this instance.\r\n     *\r\n     * @return a new Builder."
        },
        "copy": {
          "Javadoc": "* Creates a copy of this instance.\r\n     *\r\n     * @return a copy of this instance."
        },
        "format": {
          "Javadoc": "* Formats the specified values.\r\n     *\r\n     * @param values the values to format\r\n     * @return the formatted values"
        },
        "getAllowDuplicateHeaderNames": {
          "Javadoc": "* Gets whether duplicate names are allowed in the headers.\r\n     *\r\n     * @return whether duplicate header names are allowed\r\n     * @since 1.7\r\n     * @deprecated Use {@link #getDuplicateHeaderMode()}."
        },
        "getAllowMissingColumnNames": {
          "Javadoc": "* Gets whether missing column names are allowed when parsing the header line.\r\n     *\r\n     * @return {@code true} if missing column names are allowed when parsing the header line, {@code false} to throw an {@link IllegalArgumentException}."
        },
        "getAutoFlush": {
          "Javadoc": "* Gets whether to flush on close.\r\n     *\r\n     * @return whether to flush on close.\r\n     * @since 1.6"
        },
        "getCommentMarker": {
          "Javadoc": "* Gets the character marking the start of a line comment.\r\n     *\r\n     * @return the comment start marker, may be {@code null}"
        },
        "getDelimiter": {
          "Javadoc": "* Gets the first character delimiting the values (typically ';', ',' or '\\t').\r\n     *\r\n     * @return the first delimiter character.\r\n     * @deprecated Use {@link #getDelimiterString()}."
        },
        "getDelimiterString": {
          "Javadoc": "* Gets the character delimiting the values (typically \";\", \",\" or \"\\t\").\r\n     *\r\n     * @return the delimiter.\r\n     * @since 1.9.0"
        },
        "getDuplicateHeaderMode": {
          "Javadoc": "* Gets how duplicate headers are handled.\r\n     *\r\n     * @return if duplicate header values are allowed, allowed conditionally, or disallowed.\r\n     * @since 1.10.0"
        },
        "getEscapeCharacter": {
          "Javadoc": "* Gets the escape character.\r\n     *\r\n     * @return the escape character, may be {@code null}"
        },
        "getHeader": {
          "Javadoc": "* Gets a copy of the header array.\r\n     *\r\n     * @return a copy of the header array; {@code null} if disabled, the empty array if to be read from the file"
        },
        "getHeaderComments": {
          "Javadoc": "* Gets a copy of the header comment array.\r\n     *\r\n     * @return a copy of the header comment array; {@code null} if disabled."
        },
        "getIgnoreEmptyLines": {
          "Javadoc": "* Gets whether empty lines between records are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if empty lines between records are ignored, {@code false} if they are turned into empty records."
        },
        "getIgnoreHeaderCase": {
          "Javadoc": "* Gets whether header names will be accessed ignoring case when parsing input.\r\n     *\r\n     * @return {@code true} if header names cases are ignored, {@code false} if they are case sensitive.\r\n     * @since 1.3"
        },
        "getIgnoreSurroundingSpaces": {
          "Javadoc": "* Gets whether spaces around values are ignored when parsing input.\r\n     *\r\n     * @return {@code true} if spaces around values are ignored, {@code false} if they are treated as part of the value."
        },
        "getNullString": {
          "Javadoc": "* Gets the String to convert to and from {@code null}.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @return the String to convert to and from {@code null}. No substitution occurs if {@code null}"
        },
        "getQuoteCharacter": {
          "Javadoc": "* Gets the character used to encapsulate values containing special characters.\r\n     *\r\n     * @return the quoteChar character, may be {@code null}"
        },
        "getQuoteMode": {
          "Javadoc": "* Gets the quote policy output fields.\r\n     *\r\n     * @return the quote policy"
        },
        "getRecordSeparator": {
          "Javadoc": "* Gets the record separator delimiting output records.\r\n     *\r\n     * @return the record separator"
        },
        "getSkipHeaderRecord": {
          "Javadoc": "* Gets whether to skip the header record.\r\n     *\r\n     * @return whether to skip the header record."
        },
        "getTrailingDelimiter": {
          "Javadoc": "* Gets whether to add a trailing delimiter.\r\n     *\r\n     * @return whether to add a trailing delimiter.\r\n     * @since 1.3"
        },
        "getTrim": {
          "Javadoc": "* Gets whether to trim leading and trailing blanks. This is used by {@link #print(Object, Appendable, boolean)} Also by\r\n     * {CSVParser#addRecordValue(boolean)}\r\n     *\r\n     * @return whether to trim leading and trailing blanks."
        },
        "isCommentMarkerSet": {
          "Javadoc": "* Tests whether comments are supported by this format.\r\n     *\r\n     * Note that the comment introducer character is only recognized at the start of a line.\r\n     *\r\n     * @return {@code true} is comments are supported, {@code false} otherwise"
        },
        "isDelimiter": {
          "Javadoc": "* Tests whether the next characters constitute a delimiter\r\n     *\r\n     * @param ch\r\n     *            the current char\r\n     * @param charSeq\r\n     *            the match char sequence\r\n     * @param startIndex\r\n     *            where start to match\r\n     * @param delimiter\r\n     *            the delimiter\r\n     * @param delimiterLength\r\n     *            the delimiter length\r\n     * @return true if the match is successful"
        },
        "isEscapeCharacterSet": {
          "Javadoc": "* Tests whether escape are being processed.\r\n     *\r\n     * @return {@code true} if escapes are processed"
        },
        "isNullStringSet": {
          "Javadoc": "* Tests whether a nullString has been defined.\r\n     *\r\n     * @return {@code true} if a nullString is defined"
        },
        "isQuoteCharacterSet": {
          "Javadoc": "* Tests whether a quoteChar has been defined.\r\n     *\r\n     * @return {@code true} if a quoteChar is defined"
        },
        "parse": {
          "Javadoc": "* Parses the specified content.\r\n     *\r\n     * <p>\r\n     * See also the various static parse methods on {@link CSVParser}.\r\n     * </p>\r\n     *\r\n     * @param reader the input stream\r\n     * @return a parser over a stream of {@link CSVRecord}s.\r\n     * @throws IOException If an I/O error occurs"
        },
        "print": {
          "Javadoc": "* Prints to the specified output, returns a {@code CSVPrinter} which the caller MUST close.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param out     the output.\r\n     * @param charset A charset.\r\n     * @return a printer to an output.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5"
        },
        "printer": {
          "Javadoc": "* Prints to the {@link System#out}.\r\n     *\r\n     * <p>\r\n     * See also {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @return a printer to {@link System#out}.\r\n     * @throws IOException thrown if the optional header cannot be printed.\r\n     * @since 1.5"
        },
        "println": {
          "Javadoc": "* Outputs the trailing delimiter (if set) followed by the record separator (if set).\r\n     *\r\n     * @param appendable where to write\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4"
        },
        "printRecord": {
          "Javadoc": "* Prints the given {@code values} to {@code out} as a single record of delimiter separated values followed by the record separator.\r\n     *\r\n     * <p>\r\n     * The values will be quoted if needed. Quotes and new-line characters will be escaped. This method adds the record separator to the output after printing\r\n     * the record, so there is no need to call {@link #println(Appendable)}.\r\n     * </p>\r\n     *\r\n     * @param appendable    where to write.\r\n     * @param values values to output.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @since 1.4"
        },
        "printWithQuotes": {
          "Javadoc": "* Always use quotes unless QuoteMode is NONE, so we not have to look ahead.\r\n     *\r\n     * @param reader What to print\r\n     * @param appendable Where to print it\r\n     * @throws IOException If an I/O error occurs"
        },
        "validate": {
          "Javadoc": "* Verifies the validity and consistency of the attributes, and throws an {@link IllegalArgumentException} if necessary.\r\n     * <p>\r\n     * Because an instance can be used for both writing an parsing, not all conditions can be tested here. For example allowMissingColumnNames is only used for\r\n     * parsing, so it cannot be used here.\r\n     * </p>\r\n     *\r\n     * @throws IllegalArgumentException Throw when any attribute is invalid or inconsistent with other attributes."
        },
        "withAllowDuplicateHeaderNames": {
          "Javadoc": "* Builds a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     *\r\n     * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n     * @return a new {@code CSVFormat} with duplicate header names behavior set to the given value.\r\n     * @since 1.7\r\n     * @deprecated Use {@link Builder#setAllowDuplicateHeaderNames(boolean)}"
        },
        "withAllowMissingColumnNames": {
          "Javadoc": "* Builds a new {@code CSVFormat} with the missing column names behavior of the format set to the given value.\r\n     *\r\n     * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause\r\n     *                                an {@link IllegalArgumentException} to be thrown.\r\n     * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\r\n     * @deprecated Use {@link Builder#setAllowMissingColumnNames(boolean)}"
        },
        "withAutoFlush": {
          "Javadoc": "* Builds a new {@code CSVFormat} with whether to flush on close.\r\n     *\r\n     * @param autoFlush whether to flush on close.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified autoFlush setting.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setAutoFlush(boolean)}"
        },
        "withCommentMarker": {
          "Javadoc": "* Builds a new {@code CSVFormat} with the comment start marker of the format set to the specified character.\r\n     *\r\n     * Note that the comment start character is only recognized at the start of a line.\r\n     *\r\n     * @param commentMarker the comment start marker, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setCommentMarker(Character)}"
        },
        "withDelimiter": {
          "Javadoc": "* Builds a new {@code CSVFormat} with the delimiter of the format set to the specified character.\r\n     *\r\n     * @param delimiter the delimiter character\r\n     * @return A new CSVFormat that is equal to this with the specified character as delimiter\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setDelimiter(char)}"
        },
        "withEscape": {
          "Javadoc": "* Builds a new {@code CSVFormat} with the escape character of the format set to the specified character.\r\n     *\r\n     * @param escape the escape character, use {@code null} to disable\r\n     * @return A new CSVFormat that is equal to this but with the specified character as the escape character\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setEscape(Character)}"
        },
        "withFirstRecordAsHeader": {
          "Javadoc": "* Builds a new {@code CSVFormat} using the first record as header.\r\n     *\r\n     * <p>\r\n     * Calling this method is equivalent to calling:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aFormat.withHeader().withSkipHeaderRecord();\r\n     * </pre>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but using the first record as header.\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @see Builder#setHeader(String...)\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setHeader(String...) Builder#setHeader()}.{@link Builder#setSkipHeaderRecord(boolean) setSkipHeaderRecord(true)}."
        },
        "withHeader": {
          "Javadoc": "* Builds a new {@code CSVFormat} with the header of the format set to the given values. The header can either be parsed automatically from the input file\r\n     * with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader();\r\n     * </pre>\r\n     *\r\n     * or specified manually with:\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n     * </pre>\r\n     * <p>\r\n     * The header is also used by the {@link CSVPrinter}.\r\n     * </p>\r\n     *\r\n     * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @deprecated Use {@link Builder#setHeader(String...)}"
        },
        "withHeaderComments": {
          "Javadoc": "* Builds a new {@code CSVFormat} with the header comments of the format set to the given values. The comments will be printed first, before the headers.\r\n     * This setting is ignored by the parser.\r\n     *\r\n     * <pre>\r\n     * CSVFormat format = aformat.withHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n     * </pre>\r\n     *\r\n     * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n     * @return A new CSVFormat that is equal to this but with the specified header\r\n     * @see Builder#setSkipHeaderRecord(boolean)\r\n     * @since 1.1\r\n     * @deprecated Use {@link Builder#setHeaderComments(Object...)}"
        },
        "withIgnoreEmptyLines": {
          "Javadoc": "* Builds a new {@code CSVFormat} with the empty line skipping behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty\r\n     *                         lines to empty records.\r\n     * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreEmptyLines(boolean)}"
        },
        "withIgnoreHeaderCase": {
          "Javadoc": "* Builds a new {@code CSVFormat} with whether header names should be accessed ignoring case.\r\n     *\r\n     * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n     * @return A new CSVFormat that will ignore case header name if specified as {@code true}\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setIgnoreHeaderCase(boolean)}"
        },
        "withIgnoreSurroundingSpaces": {
          "Javadoc": "* Builds a new {@code CSVFormat} with the parser trimming behavior of the format set to the given value.\r\n     *\r\n     * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n     * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\r\n     * @deprecated Use {@link Builder#setIgnoreSurroundingSpaces(boolean)}"
        },
        "withNullString": {
          "Javadoc": "* Builds a new {@code CSVFormat} with conversions to and from null for strings on input and output.\r\n     * <ul>\r\n     * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n     * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n     * </ul>\r\n     *\r\n     * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}\r\n     * @return A new CSVFormat that is equal to this but with the specified null conversion string.\r\n     * @deprecated Use {@link Builder#setNullString(String)}"
        },
        "withQuote": {
          "Javadoc": "* Builds a new {@code CSVFormat} with the quoteChar of the format set to the specified character.\r\n     *\r\n     * @param quoteChar the quote character, use {@code null} to disable.\r\n     * @return A new CSVFormat that is equal to this but with the specified character as quoteChar\r\n     * @throws IllegalArgumentException thrown if the specified character is a line break\r\n     * @deprecated Use {@link Builder#setQuote(Character)}"
        },
        "withQuoteMode": {
          "Javadoc": "* Builds a new {@code CSVFormat} with the output quote policy of the format set to the specified value.\r\n     *\r\n     * @param quoteMode the quote policy to use for output.\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the specified quote policy\r\n     * @deprecated Use {@link Builder#setQuoteMode(QuoteMode)}"
        },
        "withRecordSeparator": {
          "Javadoc": "* Builds a new {@code CSVFormat} with the record separator of the format set to the specified String.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @param recordSeparator the record separator to use for output.\r\n     * @return A new CSVFormat that is equal to this but with the specified output record separator\r\n     * @throws IllegalArgumentException if recordSeparator is none of CR, LF or CRLF\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String)}"
        },
        "withSkipHeaderRecord": {
          "Javadoc": "* Builds a new {@code CSVFormat} with whether to skip the header record.\r\n     *\r\n     * @param skipHeaderRecord whether to skip the header record.\r\n     * @return A new CSVFormat that is equal to this but with the specified skipHeaderRecord setting.\r\n     * @see Builder#setHeader(String...)\r\n     * @deprecated Use {@link Builder#setSkipHeaderRecord(boolean)}"
        },
        "withSystemRecordSeparator": {
          "Javadoc": "* Builds a new {@code CSVFormat} with the record separator of the format set to the operating system's line separator string, typically CR+LF on Windows\r\n     * and LF on Linux.\r\n     *\r\n     * <p>\r\n     * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r' and\r\n     * \"\\r\\n\"\r\n     * </p>\r\n     *\r\n     * @return A new CSVFormat that is equal to this but with the operating system's line separator string.\r\n     * @since 1.6\r\n     * @deprecated Use {@link Builder#setRecordSeparator(String) setRecordSeparator(System.lineSeparator())}"
        },
        "withTrailingDelimiter": {
          "Javadoc": "* Builds a new {@code CSVFormat} with whether to add a trailing delimiter.\r\n     *\r\n     * @param trailingDelimiter whether to add a trailing delimiter.\r\n     * @return A new CSVFormat that is equal to this but with the specified trailing delimiter setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrailingDelimiter(boolean)}"
        },
        "withTrim": {
          "Javadoc": "* Builds a new {@code CSVFormat} with whether to trim leading and trailing blanks. See {@link #getTrim()} for details of where this is used.\r\n     *\r\n     * @param trim whether to trim leading and trailing blanks.\r\n     * @return A new CSVFormat that is equal to this but with the specified trim setting.\r\n     * @since 1.3\r\n     * @deprecated Use {@link Builder#setTrim(boolean)}"
        }
      }
    },
    "org.apache.commons.csv.Builder": {
      "Javadoc": "\r\n     * Builds CSVFormat instances.\r\n     *\r\n     * @since 1.9.0\r\n     ",
      "methods": {
        "create": {
          "Javadoc": "* Creates a new builder for the given format.\r\n         *\r\n         * @param csvFormat the source format.\r\n         * @return a copy of the builder"
        },
        "build": {
          "Javadoc": "* Builds a new CSVFormat instance.\r\n         *\r\n         * @return a new CSVFormat instance."
        },
        "setAllowDuplicateHeaderNames": {
          "Javadoc": "* Sets the duplicate header names behavior, true to allow, false to disallow.\r\n         *\r\n         * @param allowDuplicateHeaderNames the duplicate header names behavior, true to allow, false to disallow.\r\n         * @return This instance.\r\n         * @deprecated Use {@link #setDuplicateHeaderMode(DuplicateHeaderMode)}."
        },
        "setAllowMissingColumnNames": {
          "Javadoc": "* Sets the parser missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to cause an\r\n         * {@link IllegalArgumentException} to be thrown.\r\n         *\r\n         * @param allowMissingColumnNames the missing column names behavior, {@code true} to allow missing column names in the header line, {@code false} to\r\n         *                                cause an {@link IllegalArgumentException} to be thrown.\r\n         * @return This instance."
        },
        "setAutoFlush": {
          "Javadoc": "* Sets whether to flush on close.\r\n         *\r\n         * @param autoFlush whether to flush on close.\r\n         * @return This instance."
        },
        "setCommentMarker": {
          "Javadoc": "* Sets the comment start marker, use {@code null} to disable.\r\n         *\r\n         * Note that the comment start character is only recognized at the start of a line.\r\n         *\r\n         * @param commentMarker the comment start marker, use {@code null} to disable.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break"
        },
        "setDelimiter": {
          "Javadoc": "* Sets the delimiter character.\r\n         *\r\n         * @param delimiter the delimiter character.\r\n         * @return This instance."
        },
        "setDuplicateHeaderMode": {
          "Javadoc": "* Sets the duplicate header names behavior.\r\n         *\r\n         * @param duplicateHeaderMode the duplicate header names behavior\r\n         * @return This instance.\r\n         * @since 1.10.0"
        },
        "setEscape": {
          "Javadoc": "* Sets the escape character.\r\n         *\r\n         * @param escapeCharacter the escape character.\r\n         * @return This instance.\r\n         * @throws IllegalArgumentException thrown if the specified character is a line break"
        },
        "setHeader": {
          "Javadoc": "* Sets the header to the given values. The header can either be parsed automatically from the input file with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader();\r\n         * </pre>\r\n         *\r\n         * or specified manually with:\r\n         *\r\n         * <pre>\r\n         * builder.setHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\r\n         * </pre>\r\n         * <p>\r\n         * The header is also used by the {@link CSVPrinter}.\r\n         * </p>\r\n         *\r\n         * @param header the header, {@code null} if disabled, empty if parsed automatically, user specified otherwise.\r\n         * @return This instance."
        },
        "setHeaderComments": {
          "Javadoc": "* Sets the header comments set to the given values. The comments will be printed first, before the headers. This setting is ignored by the parser.\r\n         *\r\n         * <pre>\r\n         * Builder.setHeaderComments(&quot;Generated by Apache Commons CSV.&quot;, Instant.now());\r\n         * </pre>\r\n         *\r\n         * @param headerComments the headerComments which will be printed by the Printer before the actual CSV data.\r\n         * @return This instance."
        },
        "setIgnoreEmptyLines": {
          "Javadoc": "* Sets the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate empty lines to empty\r\n         * records.\r\n         *\r\n         * @param ignoreEmptyLines the empty line skipping behavior, {@code true} to ignore the empty lines between the records, {@code false} to translate\r\n         *                         empty lines to empty records.\r\n         * @return This instance."
        },
        "setIgnoreHeaderCase": {
          "Javadoc": "* Sets the parser case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         *\r\n         * @param ignoreHeaderCase the case mapping behavior, {@code true} to access name/values, {@code false} to leave the mapping as is.\r\n         * @return This instance."
        },
        "setIgnoreSurroundingSpaces": {
          "Javadoc": "* Sets the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         *\r\n         * @param ignoreSurroundingSpaces the parser trimming behavior, {@code true} to remove the surrounding spaces, {@code false} to leave the spaces as is.\r\n         * @return This instance."
        },
        "setNullString": {
          "Javadoc": "* Sets the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         *\r\n         * <ul>\r\n         * <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading records.</li>\r\n         * <li><strong>Writing:</strong> Writes {@code null} as the given {@code nullString} when writing records.</li>\r\n         * </ul>\r\n         *\r\n         * @param nullString the String to convert to and from {@code null}. No substitution occurs if {@code null}.\r\n         * @return This instance."
        },
        "setQuote": {
          "Javadoc": "* Sets the quote character, use {@code null} to disable.\r\n         *\r\n         * @param quoteCharacter the quote character, use {@code null} to disable.\r\n         * @return This instance."
        },
        "setQuoteMode": {
          "Javadoc": "* Sets the quote policy to use for output.\r\n         *\r\n         * @param quoteMode the quote policy to use for output.\r\n         * @return This instance."
        },
        "setRecordSeparator": {
          "Javadoc": "* Sets the record separator to use for output.\r\n         *\r\n         * <p>\r\n         * <strong>Note:</strong> This setting is only used during printing and does not affect parsing. Parsing currently only works for inputs with '\\n', '\\r'\r\n         * and \"\\r\\n\"\r\n         * </p>\r\n         *\r\n         * @param recordSeparator the record separator to use for output.\r\n         * @return This instance."
        },
        "setSkipHeaderRecord": {
          "Javadoc": "* Sets whether to skip the header record.\r\n         *\r\n         * @param skipHeaderRecord whether to skip the header record.\r\n         * @return This instance."
        },
        "setTrailingDelimiter": {
          "Javadoc": "* Sets whether to add a trailing delimiter.\r\n         *\r\n         * @param trailingDelimiter whether to add a trailing delimiter.\r\n         * @return This instance."
        },
        "setTrim": {
          "Javadoc": "* Sets whether to trim leading and trailing blanks.\r\n         *\r\n         * @param trim whether to trim leading and trailing blanks.\r\n         * @return This instance."
        }
      }
    },
    "org.apache.commons.csv.CSVParser": {
      "Javadoc": "\n * Parses CSV files according to the specified format.\n *\n * Because CSV appears in many different dialects, the parser supports many formats by allowing the\n * specification of a {@link CSVFormat}.\n *\n * The parser works record wise. It is not possible to go back, once a record has been parsed from the input stream.\n *\n * <h2>Creating instances</h2>\n * <p>\n * There are several static factory methods that can be used to create instances for various types of resources:\n * </p>\n * <ul>\n *     <li>{@link #parse(java.io.File, Charset, CSVFormat)}</li>\n *     <li>{@link #parse(String, CSVFormat)}</li>\n *     <li>{@link #parse(java.net.URL, java.nio.charset.Charset, CSVFormat)}</li>\n * </ul>\n * <p>\n * Alternatively parsers can also be created by passing a {@link Reader} directly to the sole constructor.\n *\n * For those who like fluent APIs, parsers can be created using {@link CSVFormat#parse(java.io.Reader)} as a shortcut:\n * </p>\n * <pre>\n * for(CSVRecord record : CSVFormat.EXCEL.parse(in)) {\n *     ...\n * }\n * </pre>\n *\n * <h2>Parsing record wise</h2>\n * <p>\n * To parse a CSV input from a file, you write:\n * </p>\n *\n * <pre>\n * File csvData = new File(&quot;/path/to/csv&quot;);\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.RFC4180);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * This will read the parse the contents of the file using the\n * <a href=\"http://tools.ietf.org/html/rfc4180\" target=\"_blank\">RFC 4180</a> format.\n * </p>\n *\n * <p>\n * To parse CSV input in a format like Excel, you write:\n * </p>\n *\n * <pre>\n * CSVParser parser = CSVParser.parse(csvData, CSVFormat.EXCEL);\n * for (CSVRecord csvRecord : parser) {\n *     ...\n * }\n * </pre>\n *\n * <p>\n * If the predefined formats don't match the format at hands, custom formats can be defined. More information about\n * customising CSVFormats is available in {@link CSVFormat CSVFormat Javadoc}.\n * </p>\n *\n * <h2>Parsing into memory</h2>\n * <p>\n * If parsing record wise is not desired, the contents of the input can be read completely into memory.\n * </p>\n *\n * <pre>\n * Reader in = new StringReader(&quot;a;b\\nc;d&quot;);\n * CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);\n * List&lt;CSVRecord&gt; list = parser.getRecords();\n * </pre>\n *\n * <p>\n * There are two constraints that have to be kept in mind:\n * </p>\n *\n * <ol>\n *     <li>Parsing into memory starts at the current position of the parser. If you have already parsed records from\n *     the input, those records will not end up in the in memory representation of your CSV data.</li>\n *     <li>Parsing into memory may consume a lot of system resources depending on the input. For example if you're\n *     parsing a 150MB file of CSV data the contents will be read completely into memory.</li>\n * </ol>\n *\n * <h2>Notes</h2>\n * <p>\n * Internal parser state is completely covered by the format and the reader-state.\n * </p>\n *\n * @see <a href=\"package-summary.html\">package documentation for more details</a>\n ",
      "methods": {
        "parse": {
          "Javadoc": "* Creates and returns a parser for the given URL, which the caller MUST close.\n     *\n     * <p>\n     * If you do not read all records from the given {@code url}, you should call {@link #close()} on the parser, unless\n     * you close the {@code url}.\n     * </p>\n     *\n     * @param url\n     *            a URL. Must not be null.\n     * @param charset\n     *            the charset for the resource. Must not be null.\n     * @param format\n     *            the CSVFormat used for CSV parsing. Must not be null.\n     * @return a new parser\n     * @throws IllegalArgumentException\n     *             If the parameters of the format are inconsistent or if either url, charset or format are null.\n     * @throws IOException\n     *             If an I/O error occurs"
        },
        "close": {
          "Javadoc": "* Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs"
        },
        "createHeaders": {
          "Javadoc": "* Creates the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record"
        },
        "getCurrentLineNumber": {
          "Javadoc": "* Gets the current line number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the record number.\n     * </p>\n     *\n     * @return current line number"
        },
        "getFirstEndOfLine": {
          "Javadoc": "* Gets the first end-of-line string encountered.\n     *\n     * @return the first end-of-line string\n     * @since 1.5"
        },
        "getHeaderComment": {
          "Javadoc": "* Gets the header comment, if any.\n     * The header comment appears before the header record.\n     *\n     * @return the header comment for this stream, or null if no comment is available.\n     * @since 1.10.0"
        },
        "getHeaderMap": {
          "Javadoc": "* Gets a copy of the header map as defined in the CSVFormat's header.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * <p>\n     * Note: The map can only provide a one-to-one mapping when the format did not\n     * contain null or duplicate column names.\n     * </p>\n     *\n     * @return a copy of the header map."
        },
        "getHeaderMapRaw": {
          "Javadoc": "* Gets the underlying header map.\n     *\n     * @return the underlying header map."
        },
        "getHeaderNames": {
          "Javadoc": "* Gets a read-only list of header names that iterates in column order as defined in the CSVFormat's header.\n     * <p>\n     * Note: The list provides strings that can be used as keys in the header map.\n     * The list will not contain null column names if they were present in the input\n     * format.\n     * </p>\n     *\n     * @return read-only list of header names that iterates in column order.\n     * @see #getHeaderMap()\n     * @since 1.7"
        },
        "getRecordNumber": {
          "Javadoc": "* Gets the current record number in the input stream.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the line number.\n     * </p>\n     *\n     * @return current record number"
        },
        "getRecords": {
          "Javadoc": "* Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     *\n     * <p>\n     * The returned content starts at the current parse-position in the stream.\n     * </p>\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws UncheckedIOException\n     *             on parse error or input read-failure"
        },
        "getTrailerComment": {
          "Javadoc": "* Gets the trailer comment, if any.\n     * Trailer comments are located between the last record and EOF\n     *\n     * @return the trailer comment for this stream, or null if no comment is available.\n     * @since 1.10.0"
        },
        "handleNull": {
          "Javadoc": "* Handle whether input is parsed as null\n     *\n     * @param input\n     *           the cell data to further processed\n     * @return null if input is parsed as null, or input itself if input isn't parsed as null"
        },
        "hasHeaderComment": {
          "Javadoc": "* Checks whether there is a header comment.\n     * The header comment appears before the header record.\n     * Note that if the parser's format has been given an explicit header\n     * (with {@link CSVFormat.Builder#setHeader(String... )} or another overload)\n     * and the header record is not being skipped\n     * ({@link CSVFormat.Builder#setSkipHeaderRecord} is false) then any initial comments\n     * will be associated with the first record, not the header.\n     *\n     * @return true if this parser has seen a header comment, false otherwise\n     * @since 1.10.0"
        },
        "hasTrailerComment": {
          "Javadoc": "* Checks whether there is a trailer comment.\n     * Trailer comments are located between the last record and EOF.\n     * The trailer comments will only be available after the parser has\n     * finished processing this stream.\n     *\n     * @return true if this parser has seen a trailer comment, false otherwise\n     * @since 1.10.0"
        },
        "isClosed": {
          "Javadoc": "* Tests whether this parser is closed.\n     *\n     * @return whether this parser is closed."
        },
        "isStrictQuoteMode": {
          "Javadoc": "* Tests whether the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or {@link QuoteMode#NON_NUMERIC}.\n     *\n     * @return true if the format's {@link QuoteMode} is {@link QuoteMode#ALL_NON_NULL} or\n     *         {@link QuoteMode#NON_NUMERIC}."
        },
        "iterator": {
          "Javadoc": "* Returns the record iterator.\n     *\n     * <p>\n     * An {@link IOException} caught during the iteration are re-thrown as an\n     * {@link IllegalStateException}.\n     * </p>\n     * <p>\n     * If the parser is closed, the iterator will not yield any more records.\n     * A call to {@link Iterator#hasNext()} will return {@code false} and\n     * a call to {@link Iterator#next()} will throw a\n     * {@link NoSuchElementException}.\n     * </p>\n     * <p>\n     * If it is necessary to construct an iterator which is usable after the\n     * parser is closed, one option is to extract all records as a list with\n     * {@link #getRecords()}, and return an iterator to that list.\n     * </p>"
        },
        "nextRecord": {
          "Javadoc": "* Parses the next record from the current point in the stream.\n     *\n     * @return the record as an array of values, or {@code null} if the end of the stream has been reached\n     * @throws IOException\n     *             on parse error or input read-failure"
        },
        "stream": {
          "Javadoc": "* Returns a sequential {@code Stream} with this collection as its source.\n     * <p>\n     * If the parser is closed, the stream will not produce any more values.\n     * See the comments in {@link #iterator()}.\n     * </p>\n     * @return a sequential {@code Stream} with this collection as its source.\n     * @since 1.9.0"
        }
      }
    },
    "org.apache.commons.csv.CSVRecordIterator": {
      "Javadoc": ""
    },
    "org.apache.commons.csv.Headers": {
      "Javadoc": "\n     * Header information based on name and position.\n     "
    },
    "org.apache.commons.csv.CSVPrinter": {
      "Javadoc": "\r\n * Prints values in a {@link CSVFormat CSV format}.\r\n *\r\n * <p>Values can be appended to the output by calling the {@link #print(Object)} method.\r\n * Values are printed according to {@link String#valueOf(Object)}.\r\n * To complete a record the {@link #println()} method has to be called.\r\n * Comments can be appended by calling {@link #printComment(String)}.\r\n * However a comment will only be written to the output if the {@link CSVFormat} supports comments.\r\n * </p>\r\n *\r\n * <p>The printer also supports appending a complete record at once by calling {@link #printRecord(Object...)}\r\n * or {@link #printRecord(Iterable)}.\r\n * Furthermore {@link #printRecords(Object...)}, {@link #printRecords(Iterable)} and {@link #printRecords(ResultSet)}\r\n * methods can be used to print several records at once.\r\n * </p>\r\n *\r\n * <p>Example:</p>\r\n *\r\n * <pre>\r\n * try (CSVPrinter printer = new CSVPrinter(new FileWriter(\"csv.txt\"), CSVFormat.EXCEL)) {\r\n *     printer.printRecord(\"id\", \"userName\", \"firstName\", \"lastName\", \"birthday\");\r\n *     printer.printRecord(1, \"john73\", \"John\", \"Doe\", LocalDate.of(1973, 9, 15));\r\n *     printer.println();\r\n *     printer.printRecord(2, \"mary\", \"Mary\", \"Meyer\", LocalDate.of(1985, 3, 29));\r\n * } catch (IOException ex) {\r\n *     ex.printStackTrace();\r\n * }\r\n * </pre>\r\n *\r\n * <p>This code will write the following to csv.txt:</p>\r\n * <pre>\r\n * id,userName,firstName,lastName,birthday\r\n * 1,john73,John,Doe,1973-09-15\r\n *\r\n * 2,mary,Mary,Meyer,1985-03-29\r\n * </pre>\r\n ",
      "methods": {
        "close": {
          "Javadoc": "* Closes the underlying stream with an optional flush first.\r\n     * @param flush whether to flush before the actual close.\r\n     *\r\n     * @throws IOException\r\n     *             If an I/O error occurs\r\n     * @since 1.6"
        },
        "flush": {
          "Javadoc": "* Flushes the underlying stream.\r\n     *\r\n     * @throws IOException\r\n     *             If an I/O error occurs"
        },
        "getOut": {
          "Javadoc": "* Gets the target Appendable.\r\n     *\r\n     * @return the target Appendable."
        },
        "print": {
          "Javadoc": "* Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\r\n     *\r\n     * @param value\r\n     *            value to be output.\r\n     * @throws IOException\r\n     *             If an I/O error occurs"
        },
        "printComment": {
          "Javadoc": "* Prints a comment on a new line among the delimiter separated values.\r\n     *\r\n     * <p>\r\n     * Comments will always begin on a new line and occupy at least one full line. The character specified to start\r\n     * comments and a space will be inserted at the beginning of each new line in the comment.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * If comments are disabled in the current CSV format this method does nothing.\r\n     * </p>\r\n     *\r\n     * <p>This method detects line breaks inside the comment string and inserts {@link CSVFormat#getRecordSeparator()}\r\n     * to start a new line of the comment. Note that this might produce unexpected results for formats that do not use\r\n     * line breaks as record separator.</p>\r\n     *\r\n     * @param comment\r\n     *            the comment to output\r\n     * @throws IOException\r\n     *             If an I/O error occurs"
        },
        "printHeaders": {
          "Javadoc": "* Prints headers for a result set based on its metadata.\r\n     *\r\n     * @param resultSet The result set to query for metadata.\r\n     * @throws IOException If an I/O error occurs.\r\n     * @throws SQLException If a database access error occurs or this method is called on a closed result set.\r\n     * @since 1.9.0"
        },
        "println": {
          "Javadoc": "* Outputs the record separator.\r\n     *\r\n     * @throws IOException\r\n     *             If an I/O error occurs"
        },
        "printRecord": {
          "Javadoc": "* Prints the given values as a single record of delimiter separated values followed by the record separator.\r\n     *\r\n     * <p>\r\n     * The values will be quoted if needed. Quotes and newLine characters will be escaped. This method adds the record\r\n     * separator to the output after printing the record, so there is no need to call {@link #println()}.\r\n     * </p>\r\n     *\r\n     * @param values\r\n     *            values to output.\r\n     * @throws IOException\r\n     *             If an I/O error occurs\r\n     * @since 1.10.0"
        },
        "printRecords": {
          "Javadoc": "* Prints all the objects in the given {@link Stream} handling nested collections/arrays as records.\r\n     *\r\n     * <p>\r\n     * If the given Stream only contains simple objects, this method will print a single record like\r\n     * {@link #printRecord(Iterable)}. If the given Stream contains nested collections/arrays those nested elements\r\n     * will each be printed as records using {@link #printRecord(Object...)}.\r\n     * </p>\r\n     *\r\n     * <p>\r\n     * Given the following data structure:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * <code>\r\n     * List&lt;String[]&gt; data = new ArrayList&lt;&gt;();\r\n     * data.add(new String[]{ \"A\", \"B\", \"C\" });\r\n     * data.add(new String[]{ \"1\", \"2\", \"3\" });\r\n     * data.add(new String[]{ \"A1\", \"B2\", \"C3\" });\r\n     * Stream&lt;String[]&gt; stream = data.stream();\r\n     * </code>\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * Calling this method will print:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * <code>\r\n     * A, B, C\r\n     * 1, 2, 3\r\n     * A1, B2, C3\r\n     * </code>\r\n     * </pre>\r\n     *\r\n     * @param values\r\n     *            the values to print.\r\n     * @throws IOException\r\n     *             If an I/O error occurs\r\n     * @since 1.10.0"
        }
      }
    },
    "org.apache.commons.csv.CSVRecord": {
      "Javadoc": "\n * A CSV record parsed from a CSV file.\n *\n * <p>\n * Note: Support for {@link Serializable} is scheduled to be removed in version 2.0.\n * In version 1.8 the mapping between the column header and the column index was\n * removed from the serialised state. The class maintains serialization compatibility\n * with versions pre-1.8 for the record values; these must be accessed by index\n * following deserialization. There will be loss of any functionally linked to the header\n * mapping when transferring serialised forms pre-1.8 to 1.8 and vice versa.\n * </p>\n ",
      "methods": {
        "get": {
          "Javadoc": "* Returns a value by name.\n     *\n     * <p>\n     * Note: This requires a field mapping obtained from the original parser.\n     * A check using {@link #isMapped(String)} should be used to determine if a\n     * mapping exists from the provided {@code name} to a field index. In this case an\n     * exception will only be thrown if the record does not contain a field corresponding\n     * to the mapping, that is the record length is not consistent with the mapping size.\n     * </p>\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return the column value, maybe null depending on {@link CSVFormat#getNullString()}.\n     * @throws IllegalStateException\n     *             if no header mapping was provided\n     * @throws IllegalArgumentException\n     *             if {@code name} is not mapped or if the record is inconsistent\n     * @see #isMapped(String)\n     * @see #isConsistent()\n     * @see #getParser()\n     * @see CSVFormat.Builder#setNullString(String)"
        },
        "getCharacterPosition": {
          "Javadoc": "* Returns the start position of this record as a character position in the source stream. This may or may not\n     * correspond to the byte position depending on the character set.\n     *\n     * @return the position of this record in the source stream."
        },
        "getComment": {
          "Javadoc": "* Returns the comment for this record, if any.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF)\n     * the comment will be ignored.\n     *\n     * @return the comment for this record, or null if no comment for this record is available."
        },
        "getParser": {
          "Javadoc": "* Returns the parser.\n     *\n     * <p>\n     * Note: The parser is not part of the serialized state of the record. A null check\n     * should be used when the record may have originated from a serialized form.\n     * </p>\n     *\n     * @return the parser.\n     * @since 1.7"
        },
        "getRecordNumber": {
          "Javadoc": "* Returns the number of this record in the parsed CSV file.\n     *\n     * <p>\n     * <strong>ATTENTION:</strong> If your CSV input has multi-line values, the returned number does not correspond to\n     * the current line number of the parser that created this record.\n     * </p>\n     *\n     * @return the number of this record.\n     * @see CSVParser#getCurrentLineNumber()"
        },
        "hasComment": {
          "Javadoc": "* Checks whether this record has a comment, false otherwise.\n     * Note that comments are attached to the following record.\n     * If there is no following record (i.e. the comment is at EOF)\n     * the comment will be ignored.\n     *\n     * @return true if this record has a comment, false otherwise\n     * @since 1.3"
        },
        "isConsistent": {
          "Javadoc": "* Tells whether the record size matches the header size.\n     *\n     * <p>\n     * Returns true if the sizes for this record match and false if not. Some programs can export files that fail this\n     * test but still produce parsable files.\n     * </p>\n     *\n     * @return true of this record is valid, false if not"
        },
        "isMapped": {
          "Javadoc": "* Checks whether a given column is mapped, i.e. its name has been defined to the parser.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given column is mapped."
        },
        "isSet": {
          "Javadoc": "* Checks whether a given columns is mapped and has a value.\n     *\n     * @param name\n     *            the name of the column to be retrieved.\n     * @return whether a given columns is mapped and has a value"
        },
        "iterator": {
          "Javadoc": "* Returns an iterator over the values of this record.\n     *\n     * @return an iterator over the values of this record."
        },
        "putIn": {
          "Javadoc": "* Puts all values of this record into the given Map.\n     *\n     * @param <M> the map type\n     * @param map The Map to populate.\n     * @return the given map.\n     * @since 1.9.0"
        },
        "size": {
          "Javadoc": "* Returns the number of values in this record.\n     *\n     * @return the number of values."
        },
        "stream": {
          "Javadoc": "* Returns a sequential ordered stream whose elements are the values.\n     *\n     * @return the new stream.\n     * @since 1.9.0"
        },
        "toList": {
          "Javadoc": "* Converts the values to a new List.\n     * <p>\n     * Editing the list does not update this instance.\n     * </p>\n     *\n     * @return a new List\n     * @since 1.9.0"
        },
        "toMap": {
          "Javadoc": "* Copies this record into a new Map of header name to record value.\n     * <p>\n     * Editing the map does not update this instance.\n     * </p>\n     *\n     * @return A new Map. The map is empty if the record has no headers."
        },
        "toString": {
          "Javadoc": "* Returns a string representation of the contents of this record. The result is constructed by comment, mapping,\n     * recordNumber and by passing the internal values array to {@link Arrays#toString(Object[])}.\n     *\n     * @return a String representation of this record."
        },
        "values": {
          "Javadoc": "* Gets the values for this record. This is not a copy.\n     *\n     * @return the values for this record.\n     * @since 1.10.0"
        }
      }
    },
    "org.apache.commons.csv.ExtendedBufferedReader": {
      "Javadoc": "\n * A special buffered reader which supports sophisticated read access.\n * <p>\n * In particular the reader supports a look-ahead option, which allows you to see the next char returned by\n * {@link #read()}. This reader also tracks how many characters have been read with {@link #getPosition()}.\n * </p>\n ",
      "methods": {
        "close": {
          "Javadoc": "* Closes the stream.\n     *\n     * @throws IOException\n     *             If an I/O error occurs"
        },
        "getCurrentLineNumber": {
          "Javadoc": "* Returns the current line number\n     *\n     * @return the current line number"
        },
        "getLastChar": {
          "Javadoc": "* Returns the last character that was read as an integer (0 to 65535). This will be the last character returned by\n     * any of the read methods. This will not include a character read using the {@link #lookAhead()} method. If no\n     * character has been read then this will return {@link Constants#UNDEFINED}. If the end of the stream was reached\n     * on the last read then this will return {@link Constants#END_OF_STREAM}.\n     *\n     * @return the last character that was read"
        },
        "getPosition": {
          "Javadoc": "* Gets the character position in the reader.\n     *\n     * @return the current position in the reader (counting characters, not bytes since this is a Reader)"
        },
        "lookAhead": {
          "Javadoc": "* Returns the next n characters in the current reader without consuming them. The next call to {@link #read()} will still return the next value. This\n     * doesn't affect line number or last character.\n     *\n     * @param n the number characters look ahead.\n     * @return the next n characters.\n     * @throws IOException If an I/O error occurs"
        },
        "readLine": {
          "Javadoc": "* Gets the next line, dropping the line terminator(s). This method should only be called when processing a\n     * comment, otherwise information can be lost.\n     * <p>\n     * Increments {@link #eolCounter} and updates {@link #position}.\n     * </p>\n     * <p>\n     * Sets {@link #lastChar} to {@link Constants#END_OF_STREAM} at EOF, otherwise the last EOL character.\n     * </p>\n     *\n     * @return the line that was read, or null if reached EOF."
        }
      }
    },
    "org.apache.commons.csv.IOUtils": {
      "Javadoc": " Copied from Apache Commons IO. ",
      "methods": {
        "copy": {
          "Javadoc": "* Copies chars from a large (over 2GB) {@code Reader} to an {@code Appendable}.\r\n     * <p>\r\n     * This method uses the provided buffer, so there is no need to use a\r\n     * {@code BufferedReader}.\r\n     * </p>\r\n     *\r\n     * @param input the {@code Reader} to read from\r\n     * @param output the {@code Appendable} to write to\r\n     * @param buffer the buffer to be used for the copy\r\n     * @return the number of characters copied\r\n     * @throws NullPointerException if the input or output is null\r\n     * @throws IOException          if an I/O error occurs\r\n     * @since 2.7"
        },
        "copyLarge": {
          "Javadoc": "* Copies chars from a large (over 2GB) {@code Reader} to a {@code Writer}.\r\n     * <p>\r\n     * This method uses the provided buffer, so there is no need to use a\r\n     * {@code BufferedReader}.\r\n     * </p>\r\n     *\r\n     * @param input the {@code Reader} to read from\r\n     * @param output the {@code Writer} to write to\r\n     * @param buffer the buffer to be used for the copy\r\n     * @return the number of characters copied\r\n     * @throws NullPointerException if the input or output is null\r\n     * @throws IOException          if an I/O error occurs\r\n     * @since 2.2"
        },
        "rethrow": {
          "Javadoc": "* Throws the given throwable.\r\n     *\r\n     * @param <T> The throwable cast type.\r\n     * @param throwable The throwable to rethrow.\r\n     * @return nothing because we throw.\r\n     * @throws T Always thrown."
        }
      }
    },
    "org.apache.commons.csv.Lexer": {
      "Javadoc": "\n * Lexical analyzer.\n ",
      "methods": {
        "close": {
          "Javadoc": "* Closes resources.\n     *\n     * @throws IOException\n     *             If an I/O error occurs"
        },
        "getCharacterPosition": {
          "Javadoc": "* Returns the current character position\n     *\n     * @return the current character position"
        },
        "getCurrentLineNumber": {
          "Javadoc": "* Returns the current line number\n     *\n     * @return the current line number"
        },
        "isDelimiter": {
          "Javadoc": "* Determine whether the next characters constitute a delimiter through {@link ExtendedBufferedReader#lookAhead(char[])}.\n     *\n     * @param ch\n     *             the current character.\n     * @return true if the next characters constitute a delimiter.\n     * @throws IOException If an I/O error occurs."
        },
        "isEndOfFile": {
          "Javadoc": "* Tests if the given character indicates end of file.\n     *\n     * @return true if the given character indicates end of file."
        },
        "isEscape": {
          "Javadoc": "* Tests if the given character is the escape character.\n     *\n     * @return true if the given character is the escape character."
        },
        "isEscapeDelimiter": {
          "Javadoc": "* Tests if the next characters constitute a escape delimiter through {@link ExtendedBufferedReader#lookAhead(char[])}.\n     *\n     * For example, for delimiter \"[|]\" and escape '!', return true if the next characters constitute \"![!|!]\".\n     *\n     * @return true if the next characters constitute a escape delimiter.\n     * @throws IOException If an I/O error occurs."
        },
        "isStartOfLine": {
          "Javadoc": "* Tests if the current character represents the start of a line: a CR, LF or is at the start of the file.\n     *\n     * @param ch the character to check\n     * @return true if the character is at the start of a line."
        },
        "nextToken": {
          "Javadoc": "* Returns the next token.\n     * <p>\n     * A token corresponds to a term, a record change or an end-of-file indicator.\n     * </p>\n     *\n     * @param token\n     *            an existing Token object to reuse. The caller is responsible to initialize the Token.\n     * @return the next token found.\n     * @throws IOException on stream access error."
        },
        "parseEncapsulatedToken": {
          "Javadoc": "* Parses an encapsulated token.\n     * <p>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * </p>\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>\n     * <li>end of stream has been reached (EOF)</li> </ul>\n     *\n     * @param token\n     *            the current token\n     * @return a valid token object\n     * @throws IOException\n     *             on invalid state: EOF before closing encapsulator or invalid character before delimiter or EOL"
        },
        "parseSimpleToken": {
          "Javadoc": "* Parses a simple token.\n     * <p>\n     * Simple token are tokens which are not surrounded by encapsulators. A simple token might contain escaped\n     * delimiters (as \\, or \\;). The token is finished when one of the following conditions become true:\n     * </p>\n     * <ul>\n     * <li>end of line has been reached (EORECORD)</li>\n     * <li>end of stream has been reached (EOF)</li>\n     * <li>an unescaped delimiter has been reached (TOKEN)</li>\n     * </ul>\n     *\n     * @param token\n     *            the current token\n     * @param ch\n     *            the current character\n     * @return the filled token\n     * @throws IOException\n     *             on stream access error"
        },
        "readEndOfLine": {
          "Javadoc": "* Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n     *\n     * @return true if the given or next character is a line-terminator"
        },
        "readEscape": {
          "Javadoc": "* Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     *\n     * @return the unescaped character (as an int) or {@link Constants#END_OF_STREAM} if char following the escape is\n     *      invalid.\n     * @throws IOException if there is a problem reading the stream or the end of stream is detected:\n     *      the escape character is not allowed at end of stream"
        }
      }
    },
    "org.apache.commons.csv.Token": {
      "Javadoc": "\n * Internal token representation.\n * <p/>\n * It is used as contract between the lexer and the parser.\n ",
      "methods": {
        "toString": {
          "Javadoc": "* Eases IDE debugging.\n     *\n     * @return a string helpful for debugging."
        }
      }
    },
    "org.apache.commons.csv.LexerTest": {
      "Javadoc": ""
    }
  }
}