{
  "dataset": "commons-collections",
  "classes": {
    "org.apache.commons.collections4.bidimap.TreeBidiMap_doRedBlackDelete_16_2_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bidimap.Node": {
      "Javadoc": "\n     * A node used to store the data.\n     ",
      "methods": {
        "copyColor": {
          "Javadoc": "* Makes this node the same color as another.\n         *\n         * @param node  the node whose color we're adopting\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}."
        },
        "equals": {
          "Javadoc": "* Compares the specified object with this entry for equality.\n         * Returns true if the given object is also a map entry and\n         * the two entries represent the same mapping.\n         *\n         * @param obj  the object to be compared for equality with this entry.\n         * @return true if the specified object is equal to this entry."
        },
        "getKey": {
          "Javadoc": "* Gets the key.\n         *\n         * @return the key corresponding to this entry."
        },
        "getParent": {
          "Javadoc": "* Gets the parent node.\n         *\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         * @return the parent node, may be null"
        },
        "getValue": {
          "Javadoc": "* Gets the value.\n         *\n         * @return the value corresponding to this entry."
        },
        "hashCode": {
          "Javadoc": "* @return the hash code value for this map entry."
        },
        "isBlack": {
          "Javadoc": "* Is this node black?\n         *\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         * @return true if black (which is represented as a true boolean)"
        },
        "isRed": {
          "Javadoc": "* Is this node red?\n         *\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         * @return true if non-black"
        },
        "setBlack": {
          "Javadoc": "* Makes this node black.\n         *\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}."
        },
        "setParent": {
          "Javadoc": "* Sets this node's parent node.\n         *\n         * @param node  the new parent node\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}."
        },
        "setRed": {
          "Javadoc": "* Makes this node red.\n         *\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}."
        },
        "setValue": {
          "Javadoc": "* Optional operation that is not permitted in this implementation.\n         *\n         * @param ignored this parameter is ignored.\n         * @return does not return\n         * @throws UnsupportedOperationException always"
        },
        "swapColors": {
          "Javadoc": "* Exchanges colors with another node.\n         *\n         * @param node  the node to swap with\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}."
        }
      }
    },
    "org.apache.commons.collections4.bidimap.TreeBidiMap_doRedBlackDelete_16_5_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bidimap.TreeBidiMap_swapPosition_59_1_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.IteratorUtils_getIterator_38_0_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.IteratorUtils_getIterator_38_1_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.IteratorUtils_getIterator_38_2_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.IteratorUtils_getIterator_38_3_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.IteratorUtils_getIterator_38_4_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_containsKey_2_1_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_containsKey_2_4_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_containsValue_3_0_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_containsValue_3_1_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_containsValue_3_2_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_containsValue_3_3_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_containsValue_3_4_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_containsValue_3_5_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_equals_7_0_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_equals_7_1_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_equals_7_2_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_equals_7_3_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_equals_7_4_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_equals_7_5_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_get_8_0_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_get_8_1_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_get_8_2_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_get_8_3_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_get_8_4_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_get_8_5_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_put_13_0_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_put_13_1_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_put_13_3_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_remove_16_0_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_remove_16_1_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_remove_16_2_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_remove_16_3_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_remove_16_4_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Flat3Map_remove_16_5_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.trie.AbstractPatriciaTrie_put_33_2_Test": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.ArrayStack": {
      "Javadoc": "\n * An implementation of the {@link java.util.Stack} API that is based on an\n * {@code ArrayList} instead of a {@code Vector}, so it is not\n * synchronized to protect against multithreaded access.  The implementation\n * is therefore operates faster in environments where you do not need to\n * worry about multiple thread contention.\n * <p>\n * The removal order of an {@code ArrayStack} is based on insertion\n * order: The most recently added element is removed first.  The iteration\n * order is <i>not</i> the same as the removal order.  The iterator returns\n * elements from the bottom up.\n * </p>\n * <p>\n * Unlike {@code Stack}, {@code ArrayStack} accepts null entries.\n * <p>\n * <b>Note:</b> From version 4.0 onwards, this class does not implement the\n * removed {@code Buffer} interface anymore.\n * </p>\n *\n * @param <E> the type of elements in this list\n * @see java.util.Stack\n * @since 1.0\n * @deprecated use {@link java.util.ArrayDeque} instead (available from Java 1.6)\n ",
      "methods": {
        "empty": {
          "Javadoc": "* Return {@code true} if this stack is currently empty.\n     * <p>\n     * This method exists for compatibility with {@link java.util.Stack}.\n     * New users of this class should use {@code isEmpty} instead.\n     *\n     * @return true if the stack is currently empty"
        },
        "peek": {
          "Javadoc": "* Returns the n'th item down (zero-relative) from the top of this\n     * stack without removing it.\n     *\n     * @param n  the number of items down to go\n     * @return the n'th item on the stack, zero relative\n     * @throws EmptyStackException  if there are not enough items on the\n     *  stack to satisfy this request"
        },
        "pop": {
          "Javadoc": "* Pops the top item off of this stack and return it.\n     *\n     * @return the top item on the stack\n     * @throws EmptyStackException  if the stack is empty"
        },
        "push": {
          "Javadoc": "* Pushes a new item onto the top of this stack. The pushed item is also\n     * returned. This is equivalent to calling {@code add}.\n     *\n     * @param item  the item to be added\n     * @return the item just pushed"
        },
        "search": {
          "Javadoc": "* Returns the one-based position of the distance from the top that the\n     * specified object exists on this stack, where the top-most element is\n     * considered to be at distance {@code 1}.  If the object is not\n     * present on the stack, return {@code -1} instead.  The\n     * {@code equals()} method is used to compare to the items\n     * in this stack.\n     *\n     * @param object  the object to be searched for\n     * @return the 1-based depth into the stack of the object, or -1 if not found"
        }
      }
    },
    "org.apache.commons.collections4.ArrayUtils": {
      "Javadoc": "\n * <p>\n * Operations on arrays, primitive arrays (like {@code int[]}) and primitive wrapper arrays (like {@code Integer[]}).\n * </p>\n * <p>\n * This class tries to handle {@code null} input gracefully. An exception will not be thrown for a {@code null} array input. However, an Object array that\n * contains a {@code null} element may throw an exception. Each method documents its behavior.\n * </p>\n * <p>\n * Package private, might move to an internal package if this needs to be public.\n * </p>\n * <p>\n * #ThreadSafe#\n * </p>\n *\n * @since 4.2 (Copied from Apache Commons Lang.)\n ",
      "methods": {
        "contains": {
          "Javadoc": "* <p>\n     * Checks if the object is in the given array.\n     * </p>\n     * <p>\n     * The method returns {@code false} if a {@code null} array is passed in.\n     * </p>\n     *\n     * @param array        the array to search through\n     * @param objectToFind the object to find\n     * @return {@code true} if the array contains the object"
        },
        "indexOf": {
          "Javadoc": "* <p>\n     * Finds the index of the given object in the array.\n     * </p>\n     * <p>\n     * This method returns {@link CollectionUtils#INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.\n     * </p>\n     *\n     * @param array        the array to search through for the object, may be {@code null}\n     * @param objectToFind the object to find, may be {@code null}\n     * @return the index of the object within the array, {@link CollectionUtils#INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input"
        }
      }
    },
    "org.apache.commons.collections4.bag.AbstractBagDecorator": {
      "Javadoc": "\n * Decorates another {@code Bag} to provide additional behavior.\n * <p>\n * Methods are forwarded directly to the decorated bag.\n * </p>\n *\n * @param <E> the type of elements in this bag\n * @since 3.0\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the bag being decorated.\n     *\n     * @return the decorated bag"
        }
      }
    },
    "org.apache.commons.collections4.bag.AbstractMapBag": {
      "Javadoc": "\n * Abstract implementation of the {@link Bag} interface to simplify the creation\n * of subclass implementations.\n * <p>\n * Subclasses specify a Map implementation to use as the internal storage. The\n * map will be used to map bag elements to a number; the number represents the\n * number of occurrences of that element in the bag.\n * </p>\n *\n * @param <E> the type of elements in this bag\n * @since 3.0 (previously DefaultMapBag v2.0)\n ",
      "methods": {
        "add": {
          "Javadoc": "* Adds a new element to the bag, incrementing its count in the map.\n     *\n     * @param object the object to search for\n     * @param nCopies the number of copies to add\n     * @return {@code true} if the object was not already in the {@code uniqueSet}"
        },
        "addAll": {
          "Javadoc": "* Invokes {@link #add(Object)} for each element in the given collection.\n     *\n     * @param coll the collection to add\n     * @return {@code true} if this call changed the bag"
        },
        "clear": {
          "Javadoc": "* Clears the bag by clearing the underlying map."
        },
        "contains": {
          "Javadoc": "* Determines if the bag contains the given element by checking if the\n     * underlying map contains the element as a key.\n     *\n     * @param object the object to search for\n     * @return true if the bag contains the given element"
        },
        "containsAll": {
          "Javadoc": "* Determines if the bag contains the given elements.\n     *\n     * @param coll the collection to check against\n     * @return {@code true} if the Bag contains all the collection"
        },
        "doReadObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     * @param map the map to use\n     * @param in the input stream\n     * @throws IOException any of the usual I/O related exceptions\n     * @throws ClassNotFoundException if the stream contains an object which class can not be loaded\n     * @throws ClassCastException if the stream does not contain the correct objects"
        },
        "doWriteObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     * @param out the output stream\n     * @throws IOException any of the usual I/O related exceptions"
        },
        "equals": {
          "Javadoc": "* Compares this Bag to another. This Bag equals another Bag if it contains\n     * the same number of occurrences of the same elements.\n     *\n     * @param object the Bag to compare to\n     * @return true if equal"
        },
        "getCount": {
          "Javadoc": "* Returns the number of occurrence of the given element in this bag by\n     * looking up its count in the underlying map.\n     *\n     * @param object the object to search for\n     * @return the number of occurrences of the object, zero if not found"
        },
        "getMap": {
          "Javadoc": "* Utility method for implementations to access the map that backs this bag.\n     * Not intended for interactive use outside of subclasses.\n     *\n     * @return the map being used by the Bag"
        },
        "hashCode": {
          "Javadoc": "* Gets a hash code for the Bag compatible with the definition of equals.\n     * The hash code is defined as the sum total of a hash code for each\n     * element. The per element hash code is defined as\n     * {@code (e==null ? 0 : e.hashCode()) ^ noOccurrences)}. This hash code\n     * is compatible with the Set interface.\n     *\n     * @return the hash code of the Bag"
        },
        "isEmpty": {
          "Javadoc": "* Returns true if the underlying map is empty.\n     *\n     * @return true if bag is empty"
        },
        "iterator": {
          "Javadoc": "* Gets an iterator over the bag elements. Elements present in the Bag more\n     * than once will be returned repeatedly.\n     *\n     * @return the iterator"
        },
        "remove": {
          "Javadoc": "* Removes a specified number of copies of an object from the bag.\n     *\n     * @param object the object to remove\n     * @param nCopies the number of copies to remove\n     * @return true if the bag changed"
        },
        "removeAll": {
          "Javadoc": "* Removes objects from the bag according to their count in the specified\n     * collection.\n     *\n     * @param coll the collection to use\n     * @return true if the bag changed"
        },
        "retainAll": {
          "Javadoc": "* Remove any members of the bag that are not in the given bag, respecting\n     * cardinality.\n     *\n     * @param coll the collection to retain\n     * @return true if this call changed the collection"
        },
        "size": {
          "Javadoc": "* Returns the number of elements in this bag.\n     *\n     * @return current size of the bag"
        },
        "toArray": {
          "Javadoc": "* Returns an array of all of this bag's elements.\n     * If the input array has more elements than are in the bag,\n     * trailing elements will be set to null.\n     *\n     * @param <T> the type of the array elements\n     * @param array the array to populate\n     * @return an array of all of this bag's elements\n     * @throws ArrayStoreException if the runtime type of the specified array is not\n     *   a supertype of the runtime type of the elements in this list\n     * @throws NullPointerException if the specified array is null"
        },
        "toString": {
          "Javadoc": "* Implement a toString() method suitable for debugging.\n     *\n     * @return a debugging toString"
        },
        "uniqueSet": {
          "Javadoc": "* Returns an unmodifiable view of the underlying map's key set.\n     *\n     * @return the set of unique elements in this bag"
        }
      }
    },
    "org.apache.commons.collections4.bag.BagIterator": {
      "Javadoc": "\n     * Inner class iterator for the Bag.\n     ",
      "methods": {
        "hasNext": {
          "Javadoc": "{@inheritDoc}"
        },
        "next": {
          "Javadoc": "{@inheritDoc}"
        },
        "remove": {
          "Javadoc": "{@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.bag.MutableInteger": {
      "Javadoc": "\n     * Mutable integer class for storing the data.\n     "
    },
    "org.apache.commons.collections4.bag.AbstractSortedBagDecorator": {
      "Javadoc": "\n * Decorates another {@code SortedBag} to provide additional behavior.\n * <p>\n * Methods are forwarded directly to the decorated bag.\n * </p>\n *\n * @param <E> the type of elements in this bag\n * @since 3.0\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the bag being decorated.\n     *\n     * @return the decorated bag"
        }
      }
    },
    "org.apache.commons.collections4.bag.CollectionBag": {
      "Javadoc": "\n * Decorates another {@link Bag} to comply with the Collection contract.\n * <p>\n * By decorating an existing {@link Bag} instance with a {@link CollectionBag},\n * it can be safely passed on to methods that require Collection types that\n * are fully compliant with the Collection contract.\n * </p>\n * <p>\n * The method Javadoc highlights the differences compared to the original Bag interface.\n * </p>\n *\n * @see Bag\n * @param <E> the type of elements in this bag\n * @since 4.0\n ",
      "methods": {
        "collectionBag": {
          "Javadoc": "* Factory method to create a bag that complies to the Collection contract.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null"
        },
        "add": {
          "Javadoc": "* <i>(Change)</i>\n     * Adds {@code count} copies of the specified object to the Bag.\n     * <p>\n     * Since this method always increases the size of the bag, it\n     * will always return {@code true}.\n     *\n     * @param object  the object to add\n     * @param count  the number of copies to add\n     * @return {@code true}, always"
        },
        "containsAll": {
          "Javadoc": "* <i>(Change)</i>\n     * Returns {@code true} if the bag contains all elements in\n     * the given collection, <b>not</b> respecting cardinality. That is,\n     * if the given collection {@code coll} contains at least one of\n     * every object contained in this object.\n     *\n     * @param coll  the collection to check against\n     * @return {@code true} if the Bag contains at least one of every object in the collection"
        },
        "readObject": {
          "Javadoc": "* Read the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @throws ClassCastException if deserialized object has wrong type"
        },
        "remove": {
          "Javadoc": "* <i>(Change)</i>\n     * Removes the first occurrence of the given object from the bag.\n     * <p>\n     * This will also remove the object from the {@link #uniqueSet()} if the\n     * bag contains no occurrence anymore of the object after this operation.\n     *\n     * @param object  the object to remove\n     * @return {@code true} if this call changed the collection"
        },
        "removeAll": {
          "Javadoc": "* <i>(Change)</i>\n     * Remove all elements represented in the given collection,\n     * <b>not</b> respecting cardinality. That is, remove <i>all</i>\n     * occurrences of every object contained in the given collection.\n     *\n     * @param coll  the collection to remove\n     * @return {@code true} if this call changed the collection"
        },
        "retainAll": {
          "Javadoc": "* <i>(Change)</i>\n     * Remove any members of the bag that are not in the given collection,\n     * <i>not</i> respecting cardinality. That is, any object in the given\n     * collection {@code coll} will be retained in the bag with the same\n     * number of copies prior to this operation. All other objects will be\n     * completely removed from this bag.\n     * <p>\n     * This implementation iterates over the elements of this bag, checking\n     * each element in turn to see if it's contained in {@code coll}.\n     * If it's not contained, it's removed from this bag. As a consequence,\n     * it is advised to use a collection type for {@code coll} that provides\n     * a fast (e.g. O(1)) implementation of {@link Collection#contains(Object)}.\n     *\n     * @param coll  the collection to retain\n     * @return {@code true} if this call changed the collection"
        },
        "writeObject": {
          "Javadoc": "* Write the collection out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.bag.CollectionSortedBag": {
      "Javadoc": "\n * Decorates another {@link SortedBag} to comply with the Collection contract.\n *\n * @param <E> the type of elements in this bag\n * @since 4.0\n ",
      "methods": {
        "collectionSortedBag": {
          "Javadoc": "* Factory method to create a sorted bag that complies to the Collection contract.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the sorted bag to decorate, must not be null\n     * @return a SortedBag that complies to the Collection contract\n     * @throws NullPointerException if bag is null"
        },
        "readObject": {
          "Javadoc": "* Read the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @throws ClassCastException if deserialized object has wrong type"
        },
        "writeObject": {
          "Javadoc": "* Write the collection out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.bag.HashBag": {
      "Javadoc": "\n * Implements {@code Bag}, using a {@link HashMap} to provide the\n * data storage. This is the standard implementation of a bag.\n * <p>\n * A {@code Bag} stores each object in the collection together with a\n * count of occurrences. Extra methods on the interface allow multiple copies\n * of an object to be added or removed at once. It is important to read the\n * interface Javadoc carefully as several methods violate the\n * {@link Collection} interface specification.\n * </p>\n *\n * @param <E> the type of elements in this bag\n * @since 3.0 (previously in main package v2.0)\n ",
      "methods": {
        "readObject": {
          "Javadoc": "* Read the bag in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "writeObject": {
          "Javadoc": "* Write the bag out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.bag.PredicatedBag": {
      "Javadoc": "\n * Decorates another {@link Bag} to validate that additions\n * match a specified predicate.\n * <p>\n * This bag exists to provide validation for the decorated bag.\n * It is normally created to decorate an empty bag.\n * If an object cannot be added to the bag, an {@link IllegalArgumentException} is thrown.\n * </p>\n * <p>\n * One usage would be to ensure that no null entries are added to the bag.\n * </p>\n * <pre>\n * Bag bag = PredicatedBag.predicatedBag(new HashBag(), NotNullPredicate.INSTANCE);\n * </pre>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <E> the type of elements in this bag\n * @since 3.0\n ",
      "methods": {
        "predicatedBag": {
          "Javadoc": "* Factory method to create a predicated (validating) bag.\n     * <p>\n     * If there are any elements already in the bag being decorated, they\n     * are validated.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated Bag\n     * @throws NullPointerException if bag or predicate is null\n     * @throws IllegalArgumentException if the bag contains invalid elements\n     * @since 4.0"
        },
        "decorated": {
          "Javadoc": "* Gets the decorated bag.\n     *\n     * @return the decorated bag"
        }
      }
    },
    "org.apache.commons.collections4.bag.PredicatedSortedBag": {
      "Javadoc": "\n * Decorates another {@link SortedBag} to validate that additions\n * match a specified predicate.\n * <p>\n * This bag exists to provide validation for the decorated bag.\n * It is normally created to decorate an empty bag.\n * If an object cannot be added to the bag, an {@link IllegalArgumentException} is thrown.\n * </p>\n * <p>\n * One usage would be to ensure that no null entries are added to the bag.\n * <pre>\n * SortedBag bag = PredicatedSortedBag.predicatedSortedBag(new TreeBag(), NotNullPredicate.INSTANCE);\n * </pre>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <E> the type of elements in this bag\n * @since 3.0\n ",
      "methods": {
        "predicatedSortedBag": {
          "Javadoc": "* Factory method to create a predicated (validating) bag.\n     * <p>\n     * If there are any elements already in the bag being decorated, they\n     * are validated.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated SortedBag\n     * @throws NullPointerException if bag or predicate is null\n     * @throws IllegalArgumentException if the bag contains invalid elements\n     * @since 4.0"
        },
        "decorated": {
          "Javadoc": "* Gets the decorated sorted bag.\n     *\n     * @return the decorated bag"
        }
      }
    },
    "org.apache.commons.collections4.bag.SynchronizedBag": {
      "Javadoc": "\n * Decorates another {@link Bag} to synchronize its behavior\n * for a multithreaded environment.\n * <p>\n * Methods are synchronized, then forwarded to the decorated bag.\n * Iterators must be separately synchronized around the loop.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <E> the type of elements in this bag\n * @since 3.0\n ",
      "methods": {
        "synchronizedBag": {
          "Javadoc": "* Factory method to create a synchronized bag.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @return a new synchronized Bag\n     * @throws NullPointerException if bag is null\n     * @since 4.0"
        },
        "getBag": {
          "Javadoc": "* Gets the bag being decorated.\n     *\n     * @return the decorated bag"
        }
      }
    },
    "org.apache.commons.collections4.bag.SynchronizedBagSet": {
      "Javadoc": "\n     * Synchronized Set for the Bag class.\n     "
    },
    "org.apache.commons.collections4.bag.SynchronizedSortedBag": {
      "Javadoc": "\n * Decorates another {@link SortedBag} to synchronize its behavior\n * for a multithreaded environment.\n * <p>\n * Methods are synchronized, then forwarded to the decorated bag.\n * Iterators must be separately synchronized around the loop.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <E> the type of elements in this bag\n * @since 3.0\n ",
      "methods": {
        "synchronizedSortedBag": {
          "Javadoc": "* Factory method to create a synchronized sorted bag.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @return a new synchronized SortedBag\n     * @throws NullPointerException if bag is null\n     * @since 4.0"
        },
        "getSortedBag": {
          "Javadoc": "* Gets the bag being decorated.\n     *\n     * @return the decorated bag"
        }
      }
    },
    "org.apache.commons.collections4.bag.TransformedBag": {
      "Javadoc": "\n * Decorates another {@link Bag} to transform objects that are added.\n * <p>\n * The add methods are affected by this class.\n * Thus objects must be removed or searched for using their transformed form.\n * For example, if the transformation converts Strings to Integers, you must\n * use the Integer form to remove objects.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <E> the type of elements in this bag\n * @since 3.0\n ",
      "methods": {
        "transformedBag": {
          "Javadoc": "* Factory method to create a transforming bag that will transform\n     * existing contents of the specified bag.\n     * <p>\n     * If there are any elements already in the bag being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingBag(Bag, Transformer)}.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed Bag\n     * @throws NullPointerException if bag or transformer is null\n     * @since 4.0"
        },
        "transformingBag": {
          "Javadoc": "* Factory method to create a transforming bag.\n     * <p>\n     * If there are any elements already in the bag being decorated, they\n     * are NOT transformed. Contrast this with {@link #transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed Bag\n     * @throws NullPointerException if bag or transformer is null\n     * @since 4.0"
        },
        "getBag": {
          "Javadoc": "* Gets the decorated bag.\n     *\n     * @return the decorated bag"
        }
      }
    },
    "org.apache.commons.collections4.bag.TransformedSortedBag": {
      "Javadoc": "\n * Decorates another {@link SortedBag} to transform objects that are added.\n * <p>\n * The add methods are affected by this class.\n * Thus objects must be removed or searched for using their transformed form.\n * For example, if the transformation converts Strings to Integers, you must\n * use the Integer form to remove objects.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <E> the type of elements in this bag\n * @since 3.0\n ",
      "methods": {
        "transformedSortedBag": {
          "Javadoc": "* Factory method to create a transforming sorted bag that will transform\n     * existing contents of the specified sorted bag.\n     * <p>\n     * If there are any elements already in the bag being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed SortedBag\n     * @throws NullPointerException if bag or transformer is null\n     * @since 4.0"
        },
        "transformingSortedBag": {
          "Javadoc": "* Factory method to create a transforming sorted bag.\n     * <p>\n     * If there are any elements already in the bag being decorated, they\n     * are NOT transformed. Contrast this with {@link #transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed SortedBag\n     * @throws NullPointerException if bag or transformer is null\n     * @since 4.0"
        },
        "getSortedBag": {
          "Javadoc": "* Gets the decorated bag.\n     *\n     * @return the decorated bag"
        }
      }
    },
    "org.apache.commons.collections4.bag.TreeBag": {
      "Javadoc": "\n * Implements {@link SortedBag}, using a {@link TreeMap} to provide the data storage.\n * This is the standard implementation of a sorted bag.\n * <p>\n * Order will be maintained among the bag members and can be viewed through the iterator.\n * </p>\n * <p>\n * A {@link org.apache.commons.collections4.Bag Bag} stores each object in the collection\n * together with a count of occurrences. Extra methods on the interface allow multiple\n * copies of an object to be added or removed at once. It is important to read the interface\n * Javadoc carefully as several methods violate the {@link Collection} interface specification.\n * </p>\n *\n * @param <E> the type of elements in this bag\n * @since 3.0 (previously in main package v2.0)\n ",
      "methods": {
        "add": {
          "Javadoc": "* {@inheritDoc}\n     *\n     * @throws IllegalArgumentException if the object to be added does not implement\n     * {@link Comparable} and the {@link TreeBag} is using natural ordering\n     * @throws NullPointerException if the specified key is null and this bag uses\n     * natural ordering, or its comparator does not permit null keys"
        },
        "readObject": {
          "Javadoc": "* Read the bag in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "writeObject": {
          "Javadoc": "* Write the bag out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.bag.UnmodifiableBag": {
      "Javadoc": "\n * Decorates another {@link Bag} to ensure it can't be altered.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <E> the type of elements in this bag\n * @since 3.0\n ",
      "methods": {
        "unmodifiableBag": {
          "Javadoc": "* Factory method to create an unmodifiable bag.\n     * <p>\n     * If the bag passed in is already unmodifiable, it is returned.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @return an unmodifiable Bag\n     * @throws NullPointerException if bag is null\n     * @since 4.0"
        },
        "readObject": {
          "Javadoc": "* Read the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @throws ClassCastException if deserialized object has wrong type"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        },
        "writeObject": {
          "Javadoc": "* Write the collection out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.bag.UnmodifiableSortedBag": {
      "Javadoc": "\n * Decorates another {@link SortedBag} to ensure it can't be altered.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <E> the type of elements in this bag\n * @since 3.0\n ",
      "methods": {
        "unmodifiableSortedBag": {
          "Javadoc": "* Factory method to create an unmodifiable bag.\n     * <p>\n     * If the bag passed in is already unmodifiable, it is returned.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @return an unmodifiable SortedBag\n     * @throws NullPointerException if bag is null\n     * @since 4.0"
        },
        "readObject": {
          "Javadoc": "* Read the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @throws ClassCastException if deserialized object has wrong type"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        },
        "writeObject": {
          "Javadoc": "* Write the collection out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.Bag": {
      "Javadoc": "\n * Defines a collection that counts the number of times an object appears in\n * the collection.\n * <p>\n * Suppose you have a Bag that contains {@code {a, a, b, c}}.\n * Calling {@link #getCount(Object)} on {@code a} would return 2, while\n * calling {@link #uniqueSet()} would return {@code {a, b, c}}.\n * </p>\n * <p>\n * <i>NOTE: This interface violates the {@link Collection} contract.</i>\n * The behavior specified in many of these methods is <i>not</i> the same\n * as the behavior specified by {@code Collection}.\n * The non-compliant methods are clearly marked with \"(Violation)\".\n * Exercise caution when using a bag as a {@code Collection}.\n * </p>\n * <p>\n * This violation resulted from the original specification of this interface.\n * In an ideal world, the interface would be changed to fix the problems, however\n * it has been decided to maintain backwards compatibility instead.\n * </p>\n *\n * @param <E> the type of elements in this bag\n * @since 2.0\n ",
      "methods": {
        "add": {
          "Javadoc": "* Adds {@code nCopies} copies of the specified object to the Bag.\n     * <p>\n     * If the object is already in the {@link #uniqueSet()} then increment its\n     * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n     * {@link #uniqueSet()} and report its count as {@code nCopies}.\n     * </p>\n     *\n     * @param object  the object to add\n     * @param nCopies  the number of copies to add\n     * @return {@code true} if the object was not already in the {@code uniqueSet}"
        },
        "containsAll": {
          "Javadoc": "* <i>(Violation)</i>\n     * Returns {@code true} if the bag contains all elements in\n     * the given collection, respecting cardinality.  That is, if the\n     * given collection {@code coll} contains {@code n} copies\n     * of a given object, calling {@link #getCount(Object)} on that object must\n     * be {@code &gt;= n} for all {@code n} in {@code coll}.\n     *\n     * <p>\n     * The {@link Collection#containsAll(Collection)} method specifies\n     * that cardinality should <i>not</i> be respected; this method should\n     * return true if the bag contains at least one of every object contained\n     * in the given collection.\n     * </p>\n     *\n     * @param coll  the collection to check against\n     * @return {@code true} if the Bag contains all the collection"
        },
        "getCount": {
          "Javadoc": "* Returns the number of occurrences (cardinality) of the given\n     * object currently in the bag. If the object does not exist in the\n     * bag, return 0.\n     *\n     * @param object  the object to search for\n     * @return the number of occurrences of the object, zero if not found"
        },
        "iterator": {
          "Javadoc": "* Returns an {@link Iterator} over the entire set of members,\n     * including copies due to cardinality. This iterator is fail-fast\n     * and will not tolerate concurrent modifications.\n     *\n     * @return iterator over all elements in the Bag"
        },
        "remove": {
          "Javadoc": "* Removes {@code nCopies} copies of the specified object from the Bag.\n     * <p>\n     * If the number of copies to remove is greater than the actual number of\n     * copies in the Bag, no error is thrown.\n     * </p>\n     *\n     * @param object  the object to remove\n     * @param nCopies  the number of copies to remove\n     * @return {@code true} if this call changed the collection"
        },
        "removeAll": {
          "Javadoc": "* <i>(Violation)</i>\n     * Remove all elements represented in the given collection,\n     * respecting cardinality.  That is, if the given collection\n     * {@code coll} contains {@code n} copies of a given object,\n     * the bag will have {@code n} fewer copies, assuming the bag\n     * had at least {@code n} copies to begin with.\n     *\n     * <p>\n     * The {@link Collection#removeAll(Collection)} method specifies\n     * that cardinality should <i>not</i> be respected; this method should\n     * remove <i>all</i> occurrences of every object contained in the\n     * given collection.\n     * </p>\n     *\n     * @param coll  the collection to remove\n     * @return {@code true} if this call changed the collection"
        },
        "retainAll": {
          "Javadoc": "* <i>(Violation)</i>\n     * Remove any members of the bag that are not in the given\n     * collection, respecting cardinality.  That is, if the given\n     * collection {@code coll} contains {@code n} copies of a\n     * given object and the bag has {@code m &gt; n} copies, then\n     * delete {@code m - n} copies from the bag.  In addition, if\n     * {@code e} is an object in the bag but\n     * {@code !coll.contains(e)}, then remove {@code e} and any\n     * of its copies.\n     *\n     * <p>\n     * The {@link Collection#retainAll(Collection)} method specifies\n     * that cardinality should <i>not</i> be respected; this method should\n     * keep <i>all</i> occurrences of every object contained in the\n     * given collection.\n     * </p>\n     *\n     * @param coll  the collection to retain\n     * @return {@code true} if this call changed the collection"
        },
        "size": {
          "Javadoc": "* Returns the total number of items in the bag across all types.\n     *\n     * @return the total size of the Bag"
        },
        "uniqueSet": {
          "Javadoc": "* Returns a {@link Set} of unique elements in the Bag.\n     * <p>\n     * Uniqueness constraints are the same as those in {@link java.util.Set}.\n     * </p>\n     *\n     * @return the Set of unique Bag elements"
        }
      }
    },
    "org.apache.commons.collections4.BagUtils": {
      "Javadoc": "\n * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n *\n * @since 2.1\n ",
      "methods": {
        "collectionBag": {
          "Javadoc": "* Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0"
        },
        "emptyBag": {
          "Javadoc": "* Gets an empty {@code Bag}.\n     *\n     * @param <E> the element type\n     * @return an empty Bag"
        },
        "emptySortedBag": {
          "Javadoc": "* Gets an empty {@code SortedBag}.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag"
        },
        "predicatedBag": {
          "Javadoc": "* Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null"
        },
        "predicatedSortedBag": {
          "Javadoc": "* Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null"
        },
        "synchronizedBag": {
          "Javadoc": "* Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     * </p>\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null"
        },
        "synchronizedSortedBag": {
          "Javadoc": "* Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     * </p>\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null"
        },
        "transformingBag": {
          "Javadoc": "* Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * </p>\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behavior, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null"
        },
        "transformingSortedBag": {
          "Javadoc": "* Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * </p>\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behavior, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null"
        },
        "unmodifiableBag": {
          "Javadoc": "* Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null"
        },
        "unmodifiableSortedBag": {
          "Javadoc": "* Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.AbstractBidiMapDecorator": {
      "Javadoc": "\n * Provides a base decorator that enables additional functionality to be added\n * to a BidiMap via decoration.\n * <p>\n * Methods are forwarded directly to the decorated map.\n * </p>\n * <p>\n * This implementation does not perform any special processing with the map views.\n * Instead it simply returns the set/collection from the wrapped map. This may be\n * undesirable, for example if you are trying to write a validating implementation\n * it would provide a loophole around the validation.\n * But, you might want that loophole, so this class is kept simple.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the map being decorated.\n     *\n     * @return the decorated map"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.AbstractDualBidiMap": {
      "Javadoc": "\n * Abstract {@link BidiMap} implemented using two maps.\n * <p>\n * An implementation can be written simply by implementing the\n * {@link #createBidiMap(Map, Map, BidiMap)} method.\n * </p>\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n *\n * @see DualHashBidiMap\n * @see DualTreeBidiMap\n * @since 3.0\n ",
      "methods": {
        "createBidiMap": {
          "Javadoc": "* Creates a new instance of the subclass.\n     *\n     * @param normalMap  the normal direction map\n     * @param reverseMap  the reverse direction map\n     * @param inverseMap  this map, which is the inverse in the new map\n     * @return the bidi map"
        },
        "createEntrySetIterator": {
          "Javadoc": "* Creates an entry set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @param iterator  the iterator to decorate\n     * @return the entrySet iterator"
        },
        "createKeySetIterator": {
          "Javadoc": "* Creates a key set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @param iterator  the iterator to decorate\n     * @return the keySet iterator"
        },
        "createValuesIterator": {
          "Javadoc": "* Creates a values iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @param iterator  the iterator to decorate\n     * @return the values iterator"
        },
        "entrySet": {
          "Javadoc": "* Gets an entrySet view of the map.\n     * Changes made on the set are reflected in the map.\n     * The set supports remove and clear but not add.\n     * <p>\n     * The Map Entry setValue() method only allow a new value to be set.\n     * If the value being set is already in the map, an IllegalArgumentException\n     * is thrown (as setValue cannot change the size of the map).\n     *\n     * @return the entrySet view"
        },
        "keySet": {
          "Javadoc": "* Gets a keySet view of the map.\n     * Changes made on the view are reflected in the map.\n     * The set supports remove and clear but not add.\n     *\n     * @return the keySet view"
        },
        "mapIterator": {
          "Javadoc": "* Obtains a {@code MapIterator} over the map.\n     * The iterator implements {@link BidiMapIterator}.\n     * This implementation relies on the entrySet iterator.\n     * <p>\n     *\n     * @return a map iterator"
        },
        "values": {
          "Javadoc": "* Gets a values view of the map.\n     * Changes made on the view are reflected in the map.\n     * The set supports remove and clear but not add.\n     *\n     * @return the values view"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.BidiMapIterator": {
      "Javadoc": "\n     * Inner class MapIterator.\n     *\n     * @param <K> the type of the keys.\n     * @param <V> the type of the values.\n     "
    },
    "org.apache.commons.collections4.bidimap.EntrySet": {
      "Javadoc": "\n     * Inner class EntrySet.\n     *\n     * @param <K> the type of the keys.\n     * @param <V> the type of the values.\n     "
    },
    "org.apache.commons.collections4.bidimap.EntrySetIterator": {
      "Javadoc": "\n     * Inner class EntrySetIterator.\n     *\n     * @param <K> the type of the keys.\n     * @param <V> the type of the values.\n     "
    },
    "org.apache.commons.collections4.bidimap.KeySet": {
      "Javadoc": "\n     * Inner class KeySet.\n     *\n     * @param <K> the type of elements maintained by this set\n     "
    },
    "org.apache.commons.collections4.bidimap.KeySetIterator": {
      "Javadoc": "\n     * Inner class KeySetIterator.\n     *\n     * @param <K> the key type.\n     "
    },
    "org.apache.commons.collections4.bidimap.MapEntry": {
      "Javadoc": "\n     * Inner class MapEntry.\n     *\n     * @param <K> the type of the keys.\n     * @param <V> the type of the values.\n     "
    },
    "org.apache.commons.collections4.bidimap.Values": {
      "Javadoc": "\n     * Inner class Values.\n     *\n     * @param <V> the type of the values.\n     "
    },
    "org.apache.commons.collections4.bidimap.ValuesIterator": {
      "Javadoc": "\n     * Inner class ValuesIterator.\n     *\n     * @param <V> the value type.\n     "
    },
    "org.apache.commons.collections4.bidimap.View": {
      "Javadoc": "\n     * Inner class View.\n     *\n     * @param <K> the type of the keys in the map.\n     * @param <V> the type of the values in the map.\n     * @param <E> the type of the elements in the collection.\n     ",
      "methods": {
        "removeIf": {
          "Javadoc": "* @since 4.4"
        },
        "retainAll": {
          "Javadoc": "* {@inheritDoc}\n         * <p>\n         * This implementation iterates over the elements of this bidi map, checking each element in\n         * turn to see if it's contained in {@code coll}. If it's not contained, it's removed\n         * from this bidi map. As a consequence, it is advised to use a collection type for\n         * {@code coll} that provides a fast (e.g. O(1)) implementation of\n         * {@link Collection#contains(Object)}."
        }
      }
    },
    "org.apache.commons.collections4.bidimap.AbstractOrderedBidiMapDecorator": {
      "Javadoc": "\n * Provides a base decorator that enables additional functionality to be added\n * to an OrderedBidiMap via decoration.\n * <p>\n * Methods are forwarded directly to the decorated map.\n * </p>\n * <p>\n * This implementation does not perform any special processing with the map views.\n * Instead it simply returns the inverse from the wrapped map. This may be\n * undesirable, for example if you are trying to write a validating implementation\n * it would provide a loophole around the validation.\n * But, you might want that loophole, so this class is kept simple.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the map being decorated.\n     *\n     * @return the decorated map"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.AbstractSortedBidiMapDecorator": {
      "Javadoc": "\n * Provides a base decorator that enables additional functionality to be added\n * to a SortedBidiMap via decoration.\n * <p>\n * Methods are forwarded directly to the decorated map.\n * </p>\n * <p>\n * This implementation does not perform any special processing with the map views.\n * Instead it simply returns the inverse from the wrapped map. This may be\n * undesirable, for example if you are trying to write a validating implementation\n * it would provide a loophole around the validation.\n * But, you might want that loophole, so this class is kept simple.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the map being decorated.\n     *\n     * @return the decorated map"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.DualHashBidiMap": {
      "Javadoc": "\n * Implementation of {@link BidiMap} that uses two {@link HashMap} instances.\n * <p>\n * Two {@link HashMap} instances are used in this class.\n * This provides fast lookups at the expense of storing two sets of map entries.\n * Commons Collections would welcome the addition of a direct hash-based\n * implementation of the {@link BidiMap} interface.\n * </p>\n * <p>\n * NOTE: From Commons Collections 3.1, all subclasses will use {@link HashMap}\n * and the flawed {@code createMap} method is ignored.\n * </p>\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n *\n * @since 3.0\n ",
      "methods": {
        "createBidiMap": {
          "Javadoc": "* Creates a new instance of this object.\n     *\n     * @param normalMap  the normal direction map\n     * @param reverseMap  the reverse direction map\n     * @param inverseBidiMap  the inverse BidiMap\n     * @return new bidi map"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.DualLinkedHashBidiMap": {
      "Javadoc": "\n * Implementation of {@link BidiMap} that uses two {@link LinkedHashMap} instances.\n * <p>\n * Two {@link LinkedHashMap} instances are used in this class.\n * This provides fast lookups at the expense of storing two sets of map entries and two linked lists.\n * </p>\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n *\n * @since 4.0\n ",
      "methods": {
        "createBidiMap": {
          "Javadoc": "* Creates a new instance of this object.\n     *\n     * @param normalMap      the normal direction map\n     * @param reverseMap     the reverse direction map\n     * @param inverseBidiMap the inverse BidiMap\n     * @return new bidi map"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.DualTreeBidiMap": {
      "Javadoc": "\n * Implementation of {@link BidiMap} that uses two {@link TreeMap} instances.\n * <p>\n * The setValue() method on iterators will succeed only if the new value being set is\n * not already in the bidi map.\n * </p>\n * <p>\n * When considering whether to use this class, the {@link TreeBidiMap} class should\n * also be considered. It implements the interface using a dedicated design, and does\n * not store each object twice, which can save on memory use.\n * </p>\n * <p>\n * NOTE: From Commons Collections 3.1, all subclasses will use {@link TreeMap}\n * and the flawed {@code createMap} method is ignored.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "createBidiMap": {
          "Javadoc": "* Creates a new instance of this object.\n     *\n     * @param normalMap  the normal direction map\n     * @param reverseMap  the reverse direction map\n     * @param inverseMap  the inverse BidiMap\n     * @return new bidi map"
        },
        "mapIterator": {
          "Javadoc": "* Obtains an ordered map iterator.\n     * <p>\n     * This implementation copies the elements to an ArrayList in order to\n     * provide the forward/backward behavior.\n     *\n     * @return a new ordered map iterator"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.BidiOrderedMapIterator": {
      "Javadoc": "\n     * Inner class MapIterator.\n     *\n     * @param <K> the type of the keys.\n     * @param <V> the type of the values.\n     "
    },
    "org.apache.commons.collections4.bidimap.ViewMap": {
      "Javadoc": "\n     * Internal sorted map view.\n     *\n     * @param <K> the type of the keys.\n     * @param <V> the type of the values.\n     "
    },
    "org.apache.commons.collections4.bidimap.TreeBidiMap": {
      "Javadoc": "\n * Red-Black tree-based implementation of BidiMap where all objects added\n * implement the {@code Comparable} interface.\n * <p>\n * This class guarantees that the map will be in both ascending key order\n * and ascending value order, sorted according to the natural order for\n * the key's and value's classes.\n * </p>\n * <p>\n * This Map is intended for applications that need to be able to look\n * up a key-value pairing by either key or value, and need to do so\n * with equal efficiency.\n * </p>\n * <p>\n * While that goal could be accomplished by taking a pair of TreeMaps\n * and redirecting requests to the appropriate TreeMap (e.g.,\n * containsKey would be directed to the TreeMap that maps values to\n * keys, containsValue would be directed to the TreeMap that maps keys\n * to values), there are problems with that implementation.\n * If the data contained in the TreeMaps is large, the cost of redundant\n * storage becomes significant. The {@link DualTreeBidiMap} and\n * {@link DualHashBidiMap} implementations use this approach.\n * </p>\n * <p>\n * This solution keeps minimizes the data storage by holding data only once.\n * The red-black algorithm is based on {@link java.util.TreeMap}, but has been modified\n * to simultaneously map a tree node by key and by value. This doubles the\n * cost of put operations (but so does using two TreeMaps), and nearly doubles\n * the cost of remove operations (there is a savings in that the lookup of the\n * node to be removed only has to be performed once). And since only one node\n * contains the key and value, storage is significantly less than that\n * required by two TreeMaps.\n * </p>\n * <p>\n * The Map.Entry instances returned by the appropriate methods will\n * not allow setValue() and will throw an\n * UnsupportedOperationException on attempts to call that method.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n *\n * @since 3.0 (previously DoubleOrderedMap v2.0)\n ",
      "methods": {
        "checkKey": {
          "Javadoc": "* Checks a key for validity (non-null and implements Comparable)\n     *\n     * @param key the key to be checked\n     *\n     * @throws NullPointerException if key is null\n     * @throws ClassCastException if key is not Comparable"
        },
        "checkKeyAndValue": {
          "Javadoc": "* Checks a key and a value for validity (non-null and implements\n     * Comparable)\n     *\n     * @param key the key to be checked\n     * @param value the value to be checked\n     *\n     * @throws NullPointerException if key or value is null\n     * @throws ClassCastException if key or value is not Comparable"
        },
        "checkNonNullComparable": {
          "Javadoc": "* Checks if an object is fit to be proper input ... has to be\n     * Comparable and non-null.\n     *\n     * @param obj the object being checked\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     *\n     * @throws NullPointerException if o is null\n     * @throws ClassCastException if o is not Comparable"
        },
        "checkValue": {
          "Javadoc": "* Checks a value for validity (non-null and implements Comparable)\n     *\n     * @param value the value to be checked\n     *\n     * @throws NullPointerException if value is null\n     * @throws ClassCastException if value is not Comparable"
        },
        "compare": {
          "Javadoc": "* Compares two objects.\n     *\n     * @param o1  the first object\n     * @param o2  the second object\n     *\n     * @return negative value if o1 &lt; o2; 0 if o1 == o2; positive\n     *         value if o1 &gt; o2"
        },
        "isBlack": {
          "Javadoc": "* Is the specified black red? If the node does not exist, sure,\n     * it's black, thank you.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}."
        },
        "isRed": {
          "Javadoc": "* Is the specified node red? If the node does not exist, no, it's\n     * black, thank you.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}."
        },
        "makeBlack": {
          "Javadoc": "* Forces a node (if it exists) black.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}."
        },
        "makeRed": {
          "Javadoc": "* Forces a node (if it exists) red.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}."
        },
        "clear": {
          "Javadoc": "* Removes all mappings from this map."
        },
        "containsKey": {
          "Javadoc": "* Checks whether this map contains a mapping for the specified key.\n     * <p>\n     * The key must implement {@code Comparable}.\n     *\n     * @param key  key whose presence in this map is to be tested\n     * @return true if this map contains a mapping for the specified key\n     * @throws ClassCastException if the key is of an inappropriate type\n     * @throws NullPointerException if the key is null"
        },
        "containsValue": {
          "Javadoc": "* Checks whether this map contains a mapping for the specified value.\n     * <p>\n     * The value must implement {@code Comparable}.\n     *\n     * @param value  value whose presence in this map is to be tested\n     * @return true if this map contains a mapping for the specified value\n     * @throws ClassCastException if the value is of an inappropriate type\n     * @throws NullPointerException if the value is null"
        },
        "copyColor": {
          "Javadoc": "* Copies the color from one node to another, dealing with the fact\n     * that one or both nodes may, in fact, be null.\n     *\n     * @param from the node whose color we're copying; may be null\n     * @param to the node whose color we're changing; may be null\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}."
        },
        "doEquals": {
          "Javadoc": "* Compares for equals as per the API.\n     *\n     * @param obj  the object to compare to\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return true if equal"
        },
        "doHashCode": {
          "Javadoc": "* Gets the hash code value for this map as per the API.\n     *\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return the hash code value for this map"
        },
        "doPut": {
          "Javadoc": "* Puts logic.\n     *\n     * @param key  the key, always the main map key\n     * @param value  the value, always the main map value"
        },
        "doRedBlackDelete": {
          "Javadoc": "* Complicated red-black delete stuff. Based on Sun's TreeMap\n     * implementation, though it's barely recognizable anymore.\n     *\n     * @param deletedNode the node to be deleted"
        },
        "doRedBlackDeleteFixup": {
          "Javadoc": "* Complicated red-black delete stuff. Based on Sun's TreeMap\n     * implementation, though it's barely recognizable anymore. This\n     * rebalances the tree (somewhat, as red-black trees are not\n     * perfectly balanced -- perfect balancing takes longer)\n     *\n     * @param replacementNode the node being replaced\n     * @param dataElement  the KEY or VALUE int"
        },
        "doRedBlackInsert": {
          "Javadoc": "* Complicated red-black insert stuff. Based on Sun's TreeMap\n     * implementation, though it's barely recognizable anymore.\n     *\n     * @param insertedNode the node to be inserted\n     * @param dataElement  the KEY or VALUE int"
        },
        "doToString": {
          "Javadoc": "* Gets the string form of this map as per AbstractMap.\n     *\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return the string form of this map"
        },
        "entrySet": {
          "Javadoc": "* Returns a set view of the entries contained in this map in key order.\n     * For simple iteration through the map, the MapIterator is quicker.\n     * <p>\n     * The set is backed by the map, so changes to the map are reflected in\n     * the set, and vice-versa. If the map is modified while an iteration over\n     * the set is in progress, the results of the iteration are undefined.\n     * <p>\n     * The set supports element removal, which removes the corresponding mapping\n     * from the map. It does not support the add or addAll operations.\n     * The returned MapEntry objects do not support setValue.\n     *\n     * @return a set view of the values contained in this map."
        },
        "equals": {
          "Javadoc": "* Compares for equals as per the API.\n     *\n     * @param obj  the object to compare to\n     * @return true if equal"
        },
        "firstKey": {
          "Javadoc": "* Gets the first (lowest) key currently in this map.\n     *\n     * @return the first (lowest) key currently in this sorted map\n     * @throws NoSuchElementException if this map is empty"
        },
        "get": {
          "Javadoc": "* Gets the value to which this map maps the specified key.\n     * Returns null if the map contains no mapping for this key.\n     * <p>\n     * The key must implement {@code Comparable}.\n     *\n     * @param key  key whose associated value is to be returned\n     * @return the value to which this map maps the specified key,\n     *  or null if the map contains no mapping for this key\n     * @throws ClassCastException if the key is of an inappropriate type\n     * @throws NullPointerException if the key is null"
        },
        "getGrandParent": {
          "Javadoc": "* Gets a node's grandparent. mind you, the node, its parent, or\n     * its grandparent may not exist. No problem.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}."
        },
        "getKey": {
          "Javadoc": "* Returns the key to which this map maps the specified value.\n     * Returns null if the map contains no mapping for this value.\n     * <p>\n     * The value must implement {@code Comparable}.\n     *\n     * @param value  value whose associated key is to be returned.\n     * @return the key to which this map maps the specified value,\n     *  or null if the map contains no mapping for this value.\n     * @throws ClassCastException if the value is of an inappropriate type\n     * @throws NullPointerException if the value is null"
        },
        "getLeftChild": {
          "Javadoc": "* Gets a node's left child. mind you, the node may not exist. no\n     * problem.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}."
        },
        "getParent": {
          "Javadoc": "* Gets a node's parent. mind you, the node, or its parent, may not\n     * exist. no problem.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}."
        },
        "getRightChild": {
          "Javadoc": "* Gets a node's right child. mind you, the node may not exist. no\n     * problem.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}."
        },
        "greatestNode": {
          "Javadoc": "* Finds the greatest node from a given node.\n     *\n     * @param node  the node from which we will start searching\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return the greatest node, from the specified node"
        },
        "grow": {
          "Javadoc": "* Bumps up the size and note that the map has changed."
        },
        "hashCode": {
          "Javadoc": "* Gets the hash code value for this map as per the API.\n     *\n     * @return the hash code value for this map"
        },
        "insertValue": {
          "Javadoc": "* Inserts a node by its value.\n     *\n     * @param newNode the node to be inserted\n     *\n     * @throws IllegalArgumentException if the node already exists\n     *                                     in the value mapping"
        },
        "inverseBidiMap": {
          "Javadoc": "* Gets the inverse map for comparison.\n     *\n     * @return the inverse map"
        },
        "isEmpty": {
          "Javadoc": "* Checks whether the map is empty or not.\n     *\n     * @return true if the map is empty"
        },
        "keySet": {
          "Javadoc": "* Returns a set view of the keys contained in this map in key order.\n     * <p>\n     * The set is backed by the map, so changes to the map are reflected in\n     * the set, and vice-versa. If the map is modified while an iteration over\n     * the set is in progress, the results of the iteration are undefined.\n     * <p>\n     * The set supports element removal, which removes the corresponding mapping\n     * from the map. It does not support the add or addAll operations.\n     *\n     * @return a set view of the keys contained in this map."
        },
        "lastKey": {
          "Javadoc": "* Gets the last (highest) key currently in this map.\n     *\n     * @return the last (highest) key currently in this sorted map\n     * @throws NoSuchElementException if this map is empty"
        },
        "leastNode": {
          "Javadoc": "* Finds the least node from a given node.\n     *\n     * @param node  the node from which we will start searching\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return the smallest node, from the specified node, in the\n     *         specified mapping"
        },
        "lookup": {
          "Javadoc": "* Does the actual lookup of a piece of data.\n     *\n     * @param data the key or value to be looked up\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return the desired Node, or null if there is no mapping of the\n     *         specified data"
        },
        "modify": {
          "Javadoc": "* Increments the modification count -- used to check for\n     * concurrent modification of the map through the map and through\n     * an Iterator from one of its Set or Collection views."
        },
        "nextGreater": {
          "Javadoc": "* Gets the next larger node from the specified node.\n     *\n     * @param node the node to be searched from\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return the specified node"
        },
        "nextKey": {
          "Javadoc": "* Gets the next key after the one specified.\n     * <p>\n     * The key must implement {@code Comparable}.\n     *\n     * @param key the key to search for next from\n     * @return the next key, null if no match or at end"
        },
        "nextSmaller": {
          "Javadoc": "* Gets the next smaller node from the specified node.\n     *\n     * @param node the node to be searched from\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return the specified node"
        },
        "previousKey": {
          "Javadoc": "* Gets the previous key before the one specified.\n     * <p>\n     * The key must implement {@code Comparable}.\n     *\n     * @param key the key to search for previous from\n     * @return the previous key, null if no match or at start"
        },
        "put": {
          "Javadoc": "* Puts the key-value pair into the map, replacing any previous pair.\n     * <p>\n     * When adding a key-value pair, the value may already exist in the map\n     * against a different key. That mapping is removed, to ensure that the\n     * value only occurs once in the inverse map.\n     * <pre>\n     *  BidiMap map1 = new TreeBidiMap();\n     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n     *  map.put(\"A\",\"C\");  // contains A mapped to C, as per Map\n     *\n     *  BidiMap map2 = new TreeBidiMap();\n     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n     *  map.put(\"C\",\"B\");  // contains C mapped to B, key A is removed\n     * </pre>\n     * <p>\n     * Both key and value must implement {@code Comparable}.\n     *\n     * @param key  key with which the specified value is to be  associated\n     * @param value  value to be associated with the specified key\n     * @return the previous value for the key\n     * @throws ClassCastException if the key is of an inappropriate type\n     * @throws NullPointerException if the key is null"
        },
        "putAll": {
          "Javadoc": "* Puts all the mappings from the specified map into this map.\n     * <p>\n     * All keys and values must implement {@code Comparable}.\n     *\n     * @param map  the map to copy from"
        },
        "readObject": {
          "Javadoc": "* Reads the content of the stream.\n     *\n     * @param stream the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "remove": {
          "Javadoc": "* Removes the mapping for this key from this map if present.\n     * <p>\n     * The key must implement {@code Comparable}.\n     *\n     * @param key  key whose mapping is to be removed from the map.\n     * @return previous value associated with specified key,\n     *  or null if there was no mapping for key.\n     * @throws ClassCastException if the key is of an inappropriate type\n     * @throws NullPointerException if the key is null"
        },
        "removeValue": {
          "Javadoc": "* Removes the mapping for this value from this map if present.\n     * <p>\n     * The value must implement {@code Comparable}.\n     *\n     * @param value  value whose mapping is to be removed from the map\n     * @return previous key associated with specified value,\n     *  or null if there was no mapping for value.\n     * @throws ClassCastException if the value is of an inappropriate type\n     * @throws NullPointerException if the value is null"
        },
        "rotateLeft": {
          "Javadoc": "* Does a rotate left. standard fare in the world of balanced trees.\n     *\n     * @param node the node to be rotated\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}."
        },
        "rotateRight": {
          "Javadoc": "* Does a rotate right. standard fare in the world of balanced trees.\n     *\n     * @param node the node to be rotated\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}."
        },
        "shrink": {
          "Javadoc": "* Decrements the size and note that the map has changed."
        },
        "size": {
          "Javadoc": "* Returns the number of key-value mappings in this map.\n     *\n     * @return the number of key-value mappings in this map"
        },
        "swapPosition": {
          "Javadoc": "* Swaps two nodes (except for their content), taking care of\n     * special cases where one is the other's parent ... hey, it\n     * happens.\n     *\n     * @param x one node\n     * @param y another node\n     * @param dataElement  the KEY or VALUE int"
        },
        "toString": {
          "Javadoc": "* Returns a string version of this Map in standard format.\n     *\n     * @return a standard format string version of the map"
        },
        "values": {
          "Javadoc": "* Returns a set view of the values contained in this map in key order.\n     * The returned object can be cast to a Set.\n     * <p>\n     * The set is backed by the map, so changes to the map are reflected in\n     * the set, and vice-versa. If the map is modified while an iteration over\n     * the set is in progress, the results of the iteration are undefined.\n     * <p>\n     * The set supports element removal, which removes the corresponding mapping\n     * from the map. It does not support the add or addAll operations.\n     *\n     * @return a set view of the values contained in this map."
        },
        "writeObject": {
          "Javadoc": "* Writes the content to the stream for serialization.\n     *\n     * @param stream  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.AbstractView": {
      "Javadoc": "\n     * A view of this map.\n     "
    },
    "org.apache.commons.collections4.bidimap.AbstractViewIterator": {
      "Javadoc": "\n     * An iterator over the map.\n     "
    },
    "org.apache.commons.collections4.bidimap.EntryView": {
      "Javadoc": "\n     * A view of this map.\n     "
    },
    "org.apache.commons.collections4.bidimap.Inverse": {
      "Javadoc": "\n     * The inverse map implementation.\n     "
    },
    "org.apache.commons.collections4.bidimap.InverseEntryView": {
      "Javadoc": "\n     * A view of this map.\n     "
    },
    "org.apache.commons.collections4.bidimap.InverseViewMapEntryIterator": {
      "Javadoc": "\n     * An iterator over the inverse map entries.\n     "
    },
    "org.apache.commons.collections4.bidimap.InverseViewMapIterator": {
      "Javadoc": "\n     * An iterator over the map.\n     "
    },
    "org.apache.commons.collections4.bidimap.KeyView": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bidimap.ValueView": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bidimap.ViewMapEntryIterator": {
      "Javadoc": "\n     * An iterator over the map entries.\n     "
    },
    "org.apache.commons.collections4.bidimap.ViewMapIterator": {
      "Javadoc": "\n     * An iterator over the map.\n     "
    },
    "org.apache.commons.collections4.bidimap.UnmodifiableBidiMap": {
      "Javadoc": "\n * Decorates another {@link BidiMap} to ensure it can't be altered.\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "unmodifiableBidiMap": {
          "Javadoc": "* Factory method to create an unmodifiable map.\n     * <p>\n     * If the map passed in is already unmodifiable, it is returned.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the map to decorate, must not be null\n     * @return an unmodifiable BidiMap\n     * @throws NullPointerException if map is null\n     * @since 4.0"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.UnmodifiableOrderedBidiMap": {
      "Javadoc": "\n * Decorates another {@link OrderedBidiMap} to ensure it can't be altered.\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "unmodifiableOrderedBidiMap": {
          "Javadoc": "* Factory method to create an unmodifiable map.\n     * <p>\n     * If the map passed in is already unmodifiable, it is returned.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the map to decorate, must not be null\n     * @return an unmodifiable OrderedBidiMap\n     * @throws NullPointerException if map is null\n     * @since 4.0"
        },
        "inverseOrderedBidiMap": {
          "Javadoc": "* Gets an unmodifiable view of this map where the keys and values are reversed.\n     *\n     * @return an inverted unmodifiable bidirectional map"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.UnmodifiableSortedBidiMap": {
      "Javadoc": "\n * Decorates another {@link SortedBidiMap} to ensure it can't be altered.\n * <p>\n * Attempts to modify it will result in an {@link UnsupportedOperationException}.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "unmodifiableSortedBidiMap": {
          "Javadoc": "* Factory method to create an unmodifiable map.\n     * <p>\n     * If the map passed in is already unmodifiable, it is returned.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the map to decorate, must not be null\n     * @return an unmodifiable SortedBidiMap\n     * @throws NullPointerException if map is null\n     * @since 4.0"
        }
      }
    },
    "org.apache.commons.collections4.BidiMap": {
      "Javadoc": "\n * Defines a map that allows bidirectional lookup between key and values.\n * <p>\n * This extended {@code Map} represents a mapping where a key may\n * lookup a value and a value may lookup a key with equal ease.\n * This interface extends {@code Map} and so may be used anywhere a map\n * is required. The interface provides an inverse map view, enabling\n * full access to both directions of the {@code BidiMap}.\n * </p>\n * <p>\n * Implementations should allow a value to be looked up from a key and\n * a key to be looked up from a value with equal performance.\n * </p>\n * <p>\n * This map enforces the restriction that there is a 1:1 relation between\n * keys and values, meaning that multiple keys cannot map to the same value.\n * This is required so that \"inverting\" the map results in a map without\n * duplicate keys. See the {@link #put} method description for more information.\n * </p>\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n *\n * @since 3.0\n ",
      "methods": {
        "getKey": {
          "Javadoc": "* Gets the key that is currently mapped to the specified value.\n     * <p>\n     * If the value is not contained in the map, {@code null} is returned.\n     * </p>\n     * <p>\n     * Implementations should seek to make this method perform equally as well\n     * as {@code get(Object)}.\n     * </p>\n     *\n     * @param value  the value to find the key for\n     * @return the mapped key, or {@code null} if not found\n     *\n     * @throws ClassCastException (optional) if the map limits the type of the\n     *  value and the specified value is inappropriate\n     * @throws NullPointerException (optional) if the map limits the values to\n     *  non-null and null was specified"
        },
        "inverseBidiMap": {
          "Javadoc": "* Gets a view of this map where the keys and values are reversed.\n     * <p>\n     * Changes to one map will be visible in the other and vice versa.\n     * This enables both directions of the map to be accessed as a {@code Map}.\n     * </p>\n     * <p>\n     * Implementations should seek to avoid creating a new object every time this\n     * method is called. See {@code AbstractMap.values()} etc. Calling this\n     * method on the inverse map should return the original.\n     * </p>\n     *\n     * @return an inverted bidirectional map"
        },
        "put": {
          "Javadoc": "* Puts the key-value pair into the map, replacing any previous pair.\n     * <p>\n     * When adding a key-value pair, the value may already exist in the map\n     * against a different key. That mapping is removed, to ensure that the\n     * value only occurs once in the inverse map.\n     * </p>\n     * <pre>\n     *  BidiMap map1 = new DualHashBidiMap();\n     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n     *  map.put(\"A\",\"C\");  // contains A mapped to C, as per Map\n     *\n     *  BidiMap map2 = new DualHashBidiMap();\n     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n     *  map.put(\"C\",\"B\");  // contains C mapped to B, key A is removed\n     * </pre>\n     *\n     * @param key  the key to store\n     * @param value  the value to store\n     * @return the previous value mapped to this key\n     *\n     * @throws UnsupportedOperationException if the {@code put} method is not supported\n     * @throws ClassCastException (optional) if the map limits the type of the\n     *  value and the specified value is inappropriate\n     * @throws IllegalArgumentException (optional) if the map limits the values\n     *  in some way and the value was invalid\n     * @throws NullPointerException (optional) if the map limits the values to\n     *  non-null and null was specified"
        },
        "removeValue": {
          "Javadoc": "* Removes the key-value pair that is currently mapped to the specified\n     * value (optional operation).\n     * <p>\n     * If the value is not contained in the map, {@code null} is returned.\n     * </p>\n     * <p>\n     * Implementations should seek to make this method perform equally as well\n     * as {@code remove(Object)}.\n     * </p>\n     *\n     * @param value  the value to find the key-value pair for\n     * @return the key that was removed, {@code null} if nothing removed\n     *\n     * @throws ClassCastException (optional) if the map limits the type of the\n     *  value and the specified value is inappropriate\n     * @throws NullPointerException (optional) if the map limits the values to\n     *  non-null and null was specified\n     * @throws UnsupportedOperationException if this method is not supported\n     *  by the implementation"
        },
        "values": {
          "Javadoc": "* Returns a {@link Set} view of the values contained in this map.\n     * The set is backed by the map, so changes to the map are reflected\n     * in the set, and vice-versa.  If the map is modified while an iteration\n     * over the set is in progress (except through the iterator's own\n     * {@code remove} operation), the results of the iteration are undefined.\n     * The set supports element removal, which removes the corresponding\n     * mapping from the map, via the {@code Iterator.remove},\n     * {@code Collection.remove}, {@code removeAll},\n     * {@code retainAll} and {@code clear} operations.  It does not\n     * support the {@code add} or {@code addAll} operations.\n     *\n     * @return a set view of the values contained in this map"
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.ArrayCountingBloomFilter": {
      "Javadoc": "\n * A counting Bloom filter using an int array to track cells for each enabled bit.\n *\n * <p>Any operation that results in negative counts or integer overflow of\n * counts will mark this filter as invalid. This transition is not reversible.\n * The operation is completed in full, no exception is raised and the state is\n * set to invalid. This allows the cells for the filter immediately prior to the\n * operation that created the invalid state to be recovered. See the documentation\n * in {@link #isValid()} for details.</p>\n *\n * <p>All the operations in the filter assume the cells are currently valid,\n * for example {@code cardinality} or {@code contains} operations. Behavior of an invalid\n * filter is undefined. It will no longer function identically to a standard\n * Bloom filter that is the merge of all the Bloom filters that have been added\n * to and not later subtracted from the counting Bloom filter.</p>\n *\n * <p>The maximum supported number of items that can be stored in the filter is\n * limited by the maximum array size combined with the {@link Shape}. For\n * example an implementation using a {@link Shape} with a false-positive\n * probability of 1e-6 and {@link Integer#MAX_VALUE} bits can reversibly store\n * approximately 75 million items using 20 hash functions per item with a memory\n * consumption of approximately 8 GB.\n *\n * @see Shape\n * @see CellProducer\n * @since 4.5\n ",
      "methods": {
        "add": {
          "Javadoc": "* Add to the cell for the bit index.\n     *\n     * @param idx the index\n     * @param addend the amount to add\n     * @return {@code true} always."
        },
        "isValid": {
          "Javadoc": "* {@inheritDoc}\n     *\n     * <p><em>Implementation note</em>\n     *\n     * <p>The state transition to invalid is permanent.</p>\n     *\n     * <p>This implementation does not correct negative cells to zero or integer\n     * overflow cells to {@link Integer#MAX_VALUE}. Thus the operation that\n     * generated invalid cells can be reversed by using the complement of the\n     * original operation with the same Bloom filter. This will restore the cells\n     * to the state prior to the invalid operation. Cells can then be extracted\n     * using {@link #forEachCell(CellConsumer)}.</p>"
        },
        "subtract": {
          "Javadoc": "* Subtract from the cell for the bit index.\n     *\n     * @param idx the index\n     * @param subtrahend the amount to subtract\n     * @return {@code true} always."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.BitMap": {
      "Javadoc": "\n * Contains functions to convert {@code int} indices into Bloom filter bit positions and visa versa.\n *\n * <p>The functions view an array of longs as a collection of bit maps each containing 64 bits. The bits are arranged\n * in memory as a little-endian long value. This matches the requirements of the BitMapProducer interface.</p>\n *\n * @since 4.5\n ",
      "methods": {
        "contains": {
          "Javadoc": "* Checks if the specified index bit is enabled in the array of bit maps.\n     *\n     * If the bit specified by bitIndex is not in the bit map false is returned.\n     *\n     * @param bitMaps  The array of bit maps.\n     * @param bitIndex the index of the bit to locate.\n     * @return {@code true} if the bit is enabled, {@code false} otherwise.\n     * @throws IndexOutOfBoundsException if bitIndex specifies a bit not in the range being tracked."
        },
        "getLongBit": {
          "Javadoc": "* Gets the filter bit mask for the specified bit index assuming the filter is using 64-bit\n     * longs to store bits starting at index 0. The returned value is a {@code long} with only\n     * 1 bit set.\n     *\n     * <p>The index is assumed to be positive. For a positive index the result will match\n     * {@code 1L << (bitIndex % 64)}.</p>\n     *\n     * <p><em>If the input is negative the behavior is not defined.</em></p>\n     *\n     * @param bitIndex the bit index (assumed to be positive)\n     * @return the filter bit"
        },
        "getLongIndex": {
          "Javadoc": "* Gets the filter index for the specified bit index assuming the filter is using 64-bit longs\n     * to store bits starting at index 0.\n     *\n     * <p>The index is assumed to be positive. For a positive index the result will match\n     * {@code bitIndex / 64}.</p>\n     *\n     * <p><em>The divide is performed using bit shifts. If the input is negative the behavior\n     * is not defined.</em></p>\n     *\n     * @param bitIndex the bit index (assumed to be positive)\n     * @return the index of the bit map in an array of bit maps."
        },
        "mod": {
          "Javadoc": "* Performs a modulus calculation on an unsigned long and a positive integer divisor.\n     *\n     * <p>This method computes the same result as {@link Long#remainderUnsigned(long, long)}\n     * but assumes that the divisor is an integer in the range 1 to 2<sup>31</sup> - 1 inclusive,\n     * that is a strictly positive integer size.\n     *\n     * <p><em>If the divisor is negative the behavior is not defined.</em></p>\n     *\n     * @param dividend an unsigned long value to calculate the modulus of.\n     * @param divisor the divisor for the modulus calculation, must be strictly positive.\n     * @return the remainder or modulus value.\n     * @throws ArithmeticException if the divisor is zero\n     * @see Long#remainderUnsigned(long, long)"
        },
        "numberOfBitMaps": {
          "Javadoc": "* Calculates the number of bit maps (longs) required for the numberOfBits parameter.\n     *\n     * <p><em>If the input is negative the behavior is not defined.</em></p>\n     *\n     * @param numberOfBits the number of bits to store in the array of bit maps.\n     * @return the number of bit maps necessary."
        },
        "set": {
          "Javadoc": "* Sets the bit in the bit maps.\n     * <p><em>Does not perform range checking</em></p>\n     *\n     * @param bitMaps  The array of bit maps.\n     * @param bitIndex the index of the bit to set.\n     * @throws IndexOutOfBoundsException if bitIndex specifies a bit not in the range being tracked."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.BitMapProducer": {
      "Javadoc": "\n * Produces bit map longs for a Bloom filter.\n *\n * Each bit map is a little-endian long value representing a block of bits of in a filter.\n *\n * <p>The returned array will have length {@code ceil(m / 64)} where {@code m} is the\n * number of bits in the filter and {@code ceil} is the ceiling function.\n * Bits 0-63 are in the first long. A value of 1 at a bit position indicates the bit\n * index is enabled.\n * </p><p><em>\n * The default implementations of the {@code makePredicate()} and {@code asBitMapArray} methods\n * are slow and should be reimplemented in the implementing classes where possible.</em></p>\n *\n * @since 4.5\n ",
      "methods": {
        "fromBitMapArray": {
          "Javadoc": "* Creates a BitMapProducer from an array of Long.\n     * @param bitMaps the bit maps to return.\n     * @return a BitMapProducer."
        },
        "fromIndexProducer": {
          "Javadoc": "* Creates a BitMapProducer from an IndexProducer.\n     * @param producer the IndexProducer that specifies the indexes of the bits to enable.\n     * @param numberOfBits the number of bits in the Bloom filter.\n     * @return A BitMapProducer that produces the bit maps equivalent of the Indices from the producer."
        },
        "asBitMapArray": {
          "Javadoc": "* Return a copy of the BitMapProducer data as a bit map array.\n     * <p>\n     * The default implementation of this method is slow. It is recommended\n     * that implementing classes reimplement this method.\n     * </p>\n     * @return An array of bit map data."
        },
        "forEachBitMap": {
          "Javadoc": "* Each bit map is passed to the predicate in order. The predicate is applied to each\n     * bit map value, if the predicate returns {@code false} the execution is stopped, {@code false}\n     * is returned, and no further bit maps are processed.\n     *\n     * <p>If the producer is empty this method will return true.</p>\n     *\n     * <p>Any exceptions thrown by the action are relayed to the caller.</p>\n     *\n     * @param predicate the function to execute\n     * @return {@code true} if all bit maps returned {@code true}, {@code false} otherwise.\n     * @throws NullPointerException if the specified consumer is null"
        },
        "forEachBitMapPair": {
          "Javadoc": "* Applies the {@code func} to each bit map pair in order. Will apply all of the bit maps from the other\n     * BitMapProducer to this producer. If this producer does not have as many bit maps it will provide 0 (zero)\n     * for all excess calls to the LongBiPredicate.\n     * <p>\n     * <em>The default implementation of this method uses {@code asBitMapArray()}. It is recommended that implementations\n     * of BitMapProducer that have local arrays reimplement this method.</em></p>\n     *\n     * @param other The other BitMapProducer that provides the y values in the (x,y) pair.\n     * @param func The function to apply.\n     * @return A LongPredicate that tests this BitMapProducers bitmap values in order."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.Bits": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.BloomFilter": {
      "Javadoc": "\n * The interface that describes a Bloom filter.\n * <p>\n * <em>See implementation notes for BitMapProducer and IndexProducer.</em>\n * </p>\n * @see BitMapProducer\n * @see IndexProducer\n * @since 4.5\n ",
      "methods": {
        "cardinality": {
          "Javadoc": "* Gets the cardinality (number of enabled bits) of this Bloom filter.\n     *\n     * <p>This is also known as the Hamming value or Hamming number.</p>\n     *\n     * @return the cardinality of this filter"
        },
        "characteristics": {
          "Javadoc": "* Returns the characteristics of the filter.\n     * <p>\n     * Characteristics are defined as bits within the characteristics integer.\n     * @return the characteristics for this bloom filter."
        },
        "clear": {
          "Javadoc": "* Resets the filter to its initial, unpopulated state."
        },
        "contains": {
          "Javadoc": "* Returns {@code true} if this filter contains the indices specified IndexProducer.\n     *\n     * <p>Specifically this returns {@code true} if this filter is enabled for all bit indexes\n     * identified by the {@code IndexProducer}.</p>\n     *\n     * @param indexProducer the IndexProducer to provide the indexes\n     * @return {@code true} if this filter is enabled for all bits specified by the IndexProducer"
        },
        "copy": {
          "Javadoc": "* Creates a new instance of the BloomFilter with the same properties as the current one.\n     * @return a copy of this BloomFilter"
        },
        "estimateIntersection": {
          "Javadoc": "* Estimates the number of items in the intersection of this Bloom filter with the other bloom filter.\n     *\n     * <p>This method produces estimate is roughly equivalent to the number of unique Hashers that have been merged into both\n     * of the filters by rounding the value from the calculation described in the {@link Shape} class Javadoc.</p>\n     *\n     * <p><em>{@code estimateIntersection} should only be called with Bloom filters of the same Shape.  If called on Bloom\n     * filters of differing shape this method is not symmetric. If {@code other} has more bits an {@code IllegalArgumentException}\n     * may be thrown.</em></p>\n     *\n     * @param other The other Bloom filter\n     * @return an estimate of the number of items in the intersection. If the calculated estimate is larger than Integer.MAX_VALUE then MAX_VALUE is returned.\n     * @throws IllegalArgumentException if the estimated N for the union of the filters is infinite.\n     * @see #estimateN()\n     * @see Shape"
        },
        "estimateN": {
          "Javadoc": "* Estimates the number of items in the Bloom filter.\n     *\n     * <p>By default this is the rounding of the {@code Shape.estimateN(cardinality)} calculation for the\n     * shape and cardinality of this filter.</p>\n     *\n     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter\n     * by rounding the value from the calculation described in the {@link Shape} class Javadoc.</p>\n     *\n     * <p><em>Note:</em></p>\n     * <ul>\n     * <li>if cardinality == numberOfBits, then result is Integer.MAX_VALUE.</li>\n     * <li>if cardinality &gt; numberOfBits, then an IllegalArgumentException is thrown.</li>\n     * </ul>\n     *\n     * @return an estimate of the number of items in the bloom filter.  Will return Integer.MAX_VALUE if the\n     * estimate is larger than Integer.MAX_VALUE.\n     * @throws IllegalArgumentException if the cardinality is &gt; numberOfBits as defined in Shape.\n     * @see Shape#estimateN(int)\n     * @see Shape"
        },
        "estimateUnion": {
          "Javadoc": "* Estimates the number of items in the union of this Bloom filter with the other bloom filter.\n     *\n     * <p>This produces an estimate roughly equivalent to the number of unique Hashers that have been merged into either\n     * of the filters by rounding the value from the calculation described in the {@link Shape} class Javadoc.</p>\n     *\n     * <p><em>{@code estimateUnion} should only be called with Bloom filters of the same Shape.  If called on Bloom\n     * filters of differing shape this method is not symmetric. If {@code other} has more bits an {@code IllegalArgumentException}\n     * may be thrown.</em></p>\n     *\n     * @param other The other Bloom filter\n     * @return an estimate of the number of items in the union.  Will return Integer.MAX_VALUE if the\n     * estimate is larger than Integer.MAX_VALUE.\n     * @see #estimateN()\n     * @see Shape"
        },
        "getShape": {
          "Javadoc": "* Gets the shape that was used when the filter was built.\n     * @return The shape the filter was built with."
        },
        "isEmpty": {
          "Javadoc": "* Determines if all the bits are off. This is equivalent to\n     * {@code cardinality() == 0}.\n     *\n     * <p>\n     * <em>Note: This method is optimised for non-sparse filters.</em> Implementers\n     * are encouraged to implement faster checks if possible.\n     * </p>\n     *\n     * @return {@code true} if no bits are enabled, {@code false} otherwise."
        },
        "isFull": {
          "Javadoc": "* Determines if the bloom filter is \"full\".\n     *\n     * <p>Full is defined as having no unset bits.</p>\n     *\n     * @return {@code true} if the filter is full, {@code false} otherwise."
        },
        "merge": {
          "Javadoc": "* Merges the specified IndexProducer into this Bloom filter. Specifically all\n     * bit indexes that are identified by the {@code producer} will be enabled in this filter.\n     *\n     * <p><em>Note: This method should return {@code true} even if no additional bit indexes were\n     * enabled. A {@code false} result indicates that this filter may or may not contain all the indexes of\n     * the {@code producer}.</em>  This state may occur in complex Bloom filter implementations like\n     * counting Bloom filters.</p>\n     *\n     * @param indexProducer The IndexProducer to merge.\n     * @return true if the merge was successful\n     * @throws IllegalArgumentException if producer sends illegal value."
        },
        "uniqueIndices": {
          "Javadoc": "* Most Bloom filters create unique IndexProducers."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.BloomFilterProducer": {
      "Javadoc": "\n * Produces Bloom filters from a collection (e.g. LayeredBloomFilter).\n *\n * @since 4.5\n ",
      "methods": {
        "fromBloomFilterArray": {
          "Javadoc": "* Creates a BloomFilterProducer from an array of Bloom filters.\n     *\n     * <ul>\n     * <li>The asBloomFilterArray() method returns a copy of the original array\n     * with references to the original filters.</li>\n     * <li>The forEachBloomFilterPair() method uses references to the original filters.</li>\n     * </ul>\n     * <p><em>All modifications to the Bloom filters are reflected in the original filters</em></p>\n     *\n     * @param filters The filters to be returned by the producer.\n     * @return THe BloomFilterProducer containing the filters."
        },
        "asBloomFilterArray": {
          "Javadoc": "* Return an array of the Bloom filters in the collection.\n     * <p><em>Implementations should specify if the array contains deep copies, immutable instances,\n     * or references to the filters in the collection.</em></p>\n     * <p>The default method returns a deep copy of the enclosed filters.</p>\n     *\n     * @return An array of Bloom filters."
        },
        "flatten": {
          "Javadoc": "* Create a standard (non-layered) Bloom filter by merging all of the layers. If\n     * the filter is empty this method will return an empty Bloom filter.\n     *\n     * @return the merged bloom filter."
        },
        "forEachBloomFilter": {
          "Javadoc": "* Executes a Bloom filter Predicate on each Bloom filter in the collection. The\n     * ordering of the Bloom filters is not specified by this interface.\n     *\n     * @param bloomFilterPredicate the predicate to evaluate each Bloom filter with.\n     * @return {@code false} when the first filter fails the predicate test. Returns\n     *         {@code true} if all filters pass the test."
        },
        "forEachBloomFilterPair": {
          "Javadoc": "* Applies the {@code func} to each Bloom filter pair in order. Will apply all\n     * of the Bloom filters from the other BloomFilterProducer to this producer. If\n     * either {@code this} producer or {@code other} producer has fewer BloomFilters\n     * ths method will provide {@code null} for all excess calls to the {@code func}.\n     *\n     * <p><em>This implementation returns references to the Bloom filter.  Other implementations\n     * should specify if the array contains deep copies, immutable instances,\n     * or references to the filters in the collection.</em></p>\n     *\n     * @param other The other BloomFilterProducer that provides the y values in the\n     *              (x,y) pair.\n     * @param func  The function to apply.\n     * @return {@code true} if the {@code func} returned {@code true} for every pair,\n     *         {@code false} otherwise."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.CellProducer": {
      "Javadoc": "\n * Some Bloom filter implementations use a count rather than a bit flag. The term {@code Cell} is used to\n * refer to these counts and their associated index.  This class is the equivalent of the index producer except\n * that it produces cells.\n *\n * <p>Note that a CellProducer must not return duplicate indices and must be ordered.</p>\n *\n * <p>Implementations must guarantee that:</p>\n *\n * <ul>\n * <li>The IndexProducer implementation returns unique ordered indices.</li>\n * <li>The cells are produced in IndexProducer order.</li>\n * <li>For every value produced by the IndexProducer there will be only one matching\n * cell produced by the CellProducer.</li>\n * <li>The CellProducer will not generate cells with indices that are not output by the IndexProducer.</li>\n * <li>The IndexProducer will not generate indices that have a zero count for the cell.</li>\n * </ul>\n *\n * @since 4.5\n ",
      "methods": {
        "from": {
          "Javadoc": "* Creates a CellProducer from an IndexProducer.\n     *\n     * <p>Note the following properties:\n     * <ul>\n     * <li>Each index returned from the IndexProducer is assumed to have a cell value of 1.</li>\n     * <li>The CellProducer aggregates duplicate indices from the IndexProducer.</li>\n     * </ul>\n     *\n     * <p>A CellProducer that outputs the mapping [(1,2),(2,3),(3,1)] can be created from many combinations\n     * of indices including:\n     * <pre>\n     * [1, 1, 2, 2, 2, 3]\n     * [1, 3, 1, 2, 2, 2]\n     * [3, 2, 1, 2, 1, 2]\n     * ...\n     * </pre>\n     *\n     * @param producer An index producer.\n     * @return A CellProducer with the same indices as the IndexProducer."
        },
        "forEachCell": {
          "Javadoc": "* Performs the given action for each {@code cell}  where the cell count is non-zero.\n     *\n     * <p>Some Bloom filter implementations use a count rather than a bit flag.  The term {@code Cell} is used to\n     * refer to these counts.</p>\n     *\n     * <p>Any exceptions thrown by the action are relayed to the caller. The consumer is applied to each\n     * cell. If the consumer returns {@code false} the execution is stopped, {@code false}\n     * is returned, and no further pairs are processed.</p>\n     *\n     * @param consumer the action to be performed for each non-zero cell.\n     * @return {@code true} if all cells return true from consumer, {@code false} otherwise.\n     * @throws NullPointerException if the specified consumer is null"
        },
        "forEachIndex": {
          "Javadoc": "* The default implementation returns distinct and ordered indices for all cells with a non-zero count."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.CellConsumer": {
      "Javadoc": "\n     * Represents an operation that accepts an {@code <index, count>} pair.\n     * Returns {@code true} if processing should continue, {@code false} otherwise.\n     *\n     * <p>Note: This is a functional interface as a specialization of\n     * {@link java.util.function.BiPredicate} for {@code int}.</p>\n     ",
      "methods": {
        "test": {
          "Javadoc": "* Performs an operation on the given {@code <index, count>} pair.\n         *\n         * @param index the bit index.\n         * @param count the cell value at the specified bit index.\n         * @return {@code true} if processing should continue, {@code false} if processing should stop."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.CounterCell": {
      "Javadoc": "\n             * Class to track cell values in the TreeMap.\n             "
    },
    "org.apache.commons.collections4.bloomfilter.CountingBloomFilter": {
      "Javadoc": "\n * The interface that describes a Bloom filter that associates a count with each\n * bit index rather than a bit.  This allows reversal of merge operations with\n * remove operations.\n *\n * <p>A counting Bloom filter is expected to function identically to a standard\n * Bloom filter that is the merge of all the Bloom filters that have been added\n * to and not later subtracted from the counting Bloom filter. The functional\n * state of a CountingBloomFilter at the start and end of a series of merge and\n * subsequent remove operations of the same Bloom filters, irrespective of\n * remove order, is expected to be the same.</p>\n *\n * <p>Removal of a filter that has not previously been merged results in an\n * invalid state where the cells no longer represent a sum of merged Bloom\n * filters. It is impossible to validate merge and remove exactly without\n * explicitly storing all filters. Consequently such an operation may go\n * undetected. The CountingBloomFilter maintains a state flag that is used as a\n * warning that an operation was performed that resulted in invalid cells and\n * thus an invalid state. For example this may occur if a cell for an index was\n * set to negative following a remove operation.</p>\n *\n * <p>Implementations should document the expected state of the filter after an\n * operation that generates invalid cells, and any potential recovery options.\n * An implementation may support a reversal of the operation to restore the\n * state to that prior to the operation. In the event that invalid cells are\n * adjusted to a valid range then it should be documented if there has been\n * irreversible information loss.</p>\n *\n * <p>Implementations may choose to throw an exception during an operation that\n * generates invalid cells. Implementations should document the expected state\n * of the filter after such an operation. For example are the cells not updated,\n * partially updated or updated entirely before the exception is raised.</p>\n *\n * @see CellProducer\n * @since 4.5\n ",
      "methods": {
        "add": {
          "Javadoc": "* Adds the specified CellProducer to this Bloom filter.\n     *\n     * <p>Specifically\n     * all cells for the indexes identified by the {@code other} will be incremented\n     * by their corresponding values in the {@code other}.</p>\n     *\n     * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n     *\n     * @param other the CellProducer to add.\n     * @return {@code true} if the addition was successful and the state is valid\n     * @see #isValid()\n     * @see #subtract(CellProducer)"
        },
        "copy": {
          "Javadoc": "* Creates a new instance of the CountingBloomFilter with the same properties as the current one.\n     * @return a copy of this CountingBloomFilter"
        },
        "getMaxCell": {
          "Javadoc": "* Returns the maximum allowable value for a cell count in this Counting filter.\n     * @return the maximum allowable value for a cell count in this Counting filter."
        },
        "getMaxInsert": {
          "Javadoc": "* Determines the maximum number of times the IndexProducer could have been merged\n     * into this counting filter.\n     * <p>To determine how many times an indxProducer could have been added create a CellProducer\n     * from the indexProducer and check that</p>\n     * @param idxProducer the producer to drive the count check.\n     * @return the maximum number of times the IndexProducer could have been inserted.\n     * @see #getMaxInsert(CellProducer)"
        },
        "isValid": {
          "Javadoc": "* Returns {@code true} if the internal state is valid.\n     *\n     * <p>This flag is a warning that an addition or\n     * subtraction of cells from this filter resulted in an invalid cell for one or more\n     * indexes. For example this may occur if a cell for an index was\n     * set to negative following a subtraction operation, or overflows the value specified by {@code getMaxCell()} following an\n     * addition operation.</p>\n     *\n     * <p>A counting Bloom filter that has an invalid state is no longer ensured to function\n     * identically to a standard Bloom filter instance that is the merge of all the Bloom filters\n     * that have been added to and not later subtracted from this counting Bloom filter.</p>\n     *\n     * <p>Note: The change to an invalid state may or may not be reversible. Implementations\n     * are expected to document their policy on recovery from an addition or removal operation\n     * that generated an invalid state.</p>\n     *\n     * @return {@code true} if the state is valid"
        },
        "merge": {
          "Javadoc": "* Merges the specified index producer into this Bloom filter.\n     *\n     * <p>Specifically: all unique cells for the indices identified by the {@code indexProducer} will be incremented by 1.</p>\n     *\n     * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n     *\n     * <p>Note: If indices that are returned multiple times should be incremented multiple times convert the IndexProducer\n     * to a CellProducer and add that.</p>\n     *\n     * @param indexProducer the IndexProducer\n     * @return {@code true} if the removal was successful and the state is valid\n     * @see #isValid()\n     * @see #add(CellProducer)"
        },
        "remove": {
          "Javadoc": "* Removes the values from the specified IndexProducer from the Bloom filter from this Bloom filter.\n     *\n     * <p>Specifically all cells for the unique indices produced by the {@code hasher} will be\n     * decremented by 1.</p>\n     *\n     * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n     *\n     * <p>Note: If indices that are returned multiple times should be decremented multiple times convert the IndexProducer\n     * to a CellProducer and subtract that.</p>\n     *\n     * @param indexProducer the IndexProducer to provide the indexes\n     * @return {@code true} if the removal was successful and the state is valid\n     * @see #isValid()\n     * @see #subtract(CellProducer)"
        },
        "subtract": {
          "Javadoc": "* Adds the specified CellProducer to this Bloom filter.\n     *\n     * <p>Specifically\n     * all cells for the indexes identified by the {@code other} will be decremented\n     * by their corresponding values in the {@code other}.</p>\n     *\n     * <p>This method will return true if the filter is valid after the operation.</p>\n     *\n     * @param other the CellProducer to subtract.\n     * @return {@code true} if the subtraction was successful and the state is valid\n     * @see #isValid()\n     * @see #add(CellProducer)"
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.CountingLongPredicate": {
      "Javadoc": "\n * A long predicate that applies the test func to each member of the {@code ary} in sequence for each call to {@code test()}.\n * if the {@code ary} is exhausted, the subsequent calls to {@code test} are executed with a zero value.\n * If the calls to {@code test} do not exhaust the {@code ary} the {@code forEachRemaining} method can be called to\n * execute the @{code test} with a zero value for each remaining {@code idx} value.\n * @since 4.5\n ",
      "methods": {
        "forEachRemaining": {
          "Javadoc": "* Call the long-long consuming bi-predicate for each remaining unpaired long in\n     * the input array. This method should be invoked after the predicate has been\n     * passed to {@link BitMapProducer#forEachBitMap(LongPredicate)} to consume any\n     * unpaired bitmaps. The second argument to the bi-predicate will be zero.\n     *\n     * @return true if all calls the predicate were successful"
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.CountingPredicate": {
      "Javadoc": "\n * A predicate that applies the test {@code func} to each member of the {@code ary} in\n * sequence for each call to {@code test()}. if the {@code ary} is exhausted,\n * the subsequent calls to {@code test} are executed with a {@code null} value.\n * If the calls to {@code test} do not exhaust the {@code ary} the {@code\n * forEachRemaining} method can be called to execute the @{code test} with a\n * {@code null} value for each remaining {@code idx} value.\n *\n * @param <T> the type of object being compared.\n * @since 4.5\n ",
      "methods": {
        "forEachRemaining": {
          "Javadoc": "* Call {@code BiPredicate<T, T>} for each remaining unpaired {@code <T>} in the\n     * input array. This method should be invoked after the predicate has been\n     * passed to a {@code Producer.forEach<T>(BiPredicate<T, T>)} to consume any\n     * unpaired {@code <T>}s. The second argument to the BiPredicate will be {@code null}.\n     *\n     * @return true if all calls the predicate were successful"
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.EnhancedDoubleHasher": {
      "Javadoc": "\n * A Hasher that implements combinatorial hashing as described by\n * <a href=\"https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf\">Krisch and Mitzenmacher</a> using the enhanced double hashing technique\n * described in the wikipedia article  <a href=\"https://en.wikipedia.org/wiki/Double_hashing#Enhanced_double_hashing\">Double Hashing</a>.\n * <p>\n * Common use for this hasher is to generate bit indices from a byte array output of a hashing\n * or MessageDigest algorithm.</p>\n *\n * <h2>Thoughts on the hasher input</h2>\n *\n *<p>Note that it is worse to create smaller numbers for the {@code initial} and {@code increment}. If the {@code initial} is smaller than\n * the number of bits in a filter then hashing will start at the same point when the size increases; likewise the {@code increment} will be\n * the same if it remains smaller than the number of bits in the filter and so the first few indices will be the same if the number of bits\n * changes (but is still larger than the {@code increment}). In a worse case scenario with small {@code initial} and {@code increment} for\n * all items, hashing may not create indices that fill the full region within a much larger filter. Imagine hashers created with {@code initial}\n * and {@code increment} values less than 255 with a filter size of 30000 and number of hash functions as 5. Ignoring the\n * tetrahedral addition (a maximum of 20 for k=5) the max index is 255 * 4 + 255 = 1275, this covers 4.25% of the filter. This also\n * ignores the negative wrapping but the behavior is the same, some bits cannot be reached.\n * </p><p>\n * So this needs to be avoided as the filter probability assumptions will be void. If the {@code initial} and {@code increment} are larger\n * than the number of bits then the modulus will create a 'random' position and increment within the size.\n * </p>\n *\n * @since 4.5\n ",
      "methods": {
        "toLong": {
          "Javadoc": "* Convert bytes to big-endian long filling with zero bytes as necessary..\n     * @param byteArray the byte array to extract the values from.\n     * @param offset the offset to start extraction from.\n     * @param len the length of the extraction, may be longer than 8.\n     * @return"
        },
        "getIncrement": {
          "Javadoc": "* Gets the increment value for the hash calculation.\n     * @return the increment value for the hash calculation."
        },
        "getInitial": {
          "Javadoc": "* Gets the initial value for the hash calculation.\n     * @return the initial value for the hash calculation."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.Hasher": {
      "Javadoc": "\n * A Hasher creates IndexProducer based on the hash implementation and the\n * provided Shape.\n *\n * @since 4.5\n ",
      "methods": {
        "indices": {
          "Javadoc": "* Creates an IndexProducer for this hasher based on the Shape.\n     *\n     * <p>The {@code IndexProducer} will create indices within the range defined by the number of bits in\n     * the shape. The total number of indices will respect the number of hash functions per item\n     * defined by the shape. However the count of indices may not be a multiple of the number of\n     * hash functions if the implementation has removed duplicates.</p>\n     *\n     * <p>This IndexProducer must be deterministic in that it must return the same indices for the\n     * same Shape.</p>\n     *\n     * <p>No guarantee is made as to order of indices.</p>\n     * <p>Duplicates indices for a single item may be produced.</p>\n     *\n     * @param shape the shape of the desired Bloom filter.\n     * @return the iterator of integers"
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.IndexFilter": {
      "Javadoc": "\n * A convenience class for Hasher implementations to filter out duplicate indices.\n *\n * <p><em>If the index is negative the behavior is not defined.</em></p>\n *\n * <p>This is conceptually a unique filter implemented as an {@code IntPredicate}.</p>\n * @since 4.5\n ",
      "methods": {
        "create": {
          "Javadoc": "* Creates an instance optimized for the specified shape.\n     * @param shape The shape that is being generated.\n     * @param consumer The consumer to accept the values.\n     * @return an IndexFilter optimized for the specified shape."
        },
        "test": {
          "Javadoc": "* Test if the number should be processed by the {@code consumer}.\n     *\n     * <p>If the number has <em>not</em> been seen before it is passed to the {@code consumer} and the result returned.\n     * If the number has been seen before the {@code consumer} is not called and {@code true} returned.</p>\n     *\n     * <p><em>If the input is not in the range [0,size) an IndexOutOfBoundsException exception is thrown.</em></p>\n     *\n     * @param number the number to check.\n     * @return {@code true} if processing should continue, {@code false} otherwise."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.ArrayTracker": {
      "Javadoc": "\n     * An IndexTracker implementation that uses an array of integers to track whether or not a\n     * number has been seen. Suitable for Shapes that have few hash functions.\n     * @since 4.5\n     "
    },
    "org.apache.commons.collections4.bloomfilter.BitMapTracker": {
      "Javadoc": "\n     * An IndexTracker implementation that uses an array of bit maps to track whether or not a\n     * number has been seen.\n     * @since 4.5\n     "
    },
    "org.apache.commons.collections4.bloomfilter.IndexProducer": {
      "Javadoc": "\n * An object that produces indices of a Bloom filter.\n * <p><em>\n * The default implementation of {@code asIndexArray} is slow. Implementers should reimplement the\n * method where possible.</em></p>\n *\n * @since 4.5\n ",
      "methods": {
        "fromBitMapProducer": {
          "Javadoc": "* Creates an IndexProducer from a {@code BitMapProducer}.\n     * @param producer the {@code BitMapProducer}\n     * @return a new {@code IndexProducer}."
        },
        "fromIndexArray": {
          "Javadoc": "* Creates an IndexProducer from an array of integers.\n     * @param values the index values\n     * @return an IndexProducer that uses the values."
        },
        "asIndexArray": {
          "Javadoc": "* Return a copy of the IndexProducer data as an int array.\n     *\n     * <p>Indices ordering and uniqueness is not guaranteed.</p>\n     *\n     * <p><em>\n     * The default implementation of this method creates an array and populates\n     * it.  Implementations that have access to an index array should consider\n     * returning a copy of that array if possible.\n     * </em></p>\n     *\n     * @return An int array of the data."
        },
        "forEachIndex": {
          "Javadoc": "* Each index is passed to the predicate. The predicate is applied to each\n     * index value, if the predicate returns {@code false} the execution is stopped, {@code false}\n     * is returned, and no further indices are processed.\n     *\n     * <p>Any exceptions thrown by the action are relayed to the caller.</p>\n     *\n     * <p>Indices ordering and uniqueness is not guaranteed.</p>\n     *\n     * @param predicate the action to be performed for each non-zero bit index.\n     * @return {@code true} if all indexes return true from consumer, {@code false} otherwise.\n     * @throws NullPointerException if the specified action is null"
        },
        "uniqueIndices": {
          "Javadoc": "* Creates an IndexProducer comprising the unique indices for this producer.\n     *\n     * <p>By default creates a new producer with some overhead to remove\n     * duplicates.  IndexProducers that return unique indices by default\n     * should override this to return {@code this}.</p>\n     *\n     * <p>The default implementation will filter the indices from this instance\n     * and return them in ascending order.</p>\n     *\n     * @return the IndexProducer of unique values.\n     * @throws IndexOutOfBoundsException if any index is less than zero."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.Indices": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.IndexUtils": {
      "Javadoc": "\n * Provides functions to assist in IndexProducer creation and manipulation.\n * @see IndexProducer\n ",
      "methods": {
        "ensureCapacityForAdd": {
          "Javadoc": "* Ensure the array can add an element at the specified index.\n     * @param array the array to check.\n     * @param index the index to add at.\n     * @return the array or a newly allocated copy of the array."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.LayeredBloomFilter": {
      "Javadoc": "\n * Layered Bloom filters are described in Zhiwang, Cen; Jungang, Xu; Jian, Sun\n * (2010), \"A multi-layer Bloom filter for duplicated URL detection\", Proc. 3rd\n * International Conference on Advanced Computer Theory and Engineering (ICACTE\n * 2010), vol. 1, pp. V1-586-V1-591, doi:10.1109/ICACTE.2010.5578947, ISBN\n * 978-1-4244-6539-2, S2CID 3108985\n * <p>\n * In short, Layered Bloom filter contains several bloom filters arranged in\n * layers.\n * </p>\n * <ul>\n * <li>When membership in the filter is checked each layer in turn is checked\n * and if a match is found {@code true} is returned.</li>\n * <li>When merging each bloom filter is merged into the newest filter in the\n * list of layers.</li>\n * <li>When questions of cardinality are asked the cardinality of the union of\n * the enclosed Bloom filters is used.</li>\n * </ul>\n * <p>\n * The net result is that the layered Bloom filter can be populated with more\n * items than the Shape would indicate and yet still return a false positive\n * rate in line with the Shape and not the over population.\n * </p>\n * <p>\n * This implementation uses a LayerManager to handle the manipulation of the\n * layers.\n * </p>\n * <ul>\n * <li>Level 0 is the oldest layer and the highest level is the newest.</li>\n * <li>There is always at least one enclosed filter.</li>\n * <li>The newest filter is the {@code target} into which merges are performed.\n * <li>Whenever the target is retrieved, or a {@code merge} operation is\n * performed the code checks if any older layers should be removed, and if so\n * removes them. It also checks it a new layer should be added, and if so adds\n * it and sets the {@code target} before the operation.</li>\n * </ul>\n * @since 4.5\n ",
      "methods": {
        "fixed": {
          "Javadoc": "* Creates a fixed size layered bloom filter that adds new filters to the list,\n     * but never merges them. List will never exceed maxDepth. As additional filters\n     * are added earlier filters are removed.\n     *\n     * @param shape    The shape for the enclosed Bloom filters.\n     * @param maxDepth The maximum depth of layers.\n     * @return An empty layered Bloom filter of the specified shape and depth."
        },
        "contains": {
          "Javadoc": "* Returns {@code true} if each filter within the {@code producer} exits within\n     * this filter.\n     *\n     * @param producer the BloomFilterProducer that provides the filters to check\n     *                 for.\n     * @return {@code true} if this filter contains all of the filters contained in\n     *         the {@code producer}."
        },
        "createFilter": {
          "Javadoc": "* Creates a Bloom filter from an IndexProducer.\n     *\n     * @param indexProducer the IndexProducer to create the filter from.\n     * @return the BloomFilter."
        },
        "find": {
          "Javadoc": "* Finds the layers in which the IndexProducer is found.\n     *\n     * @param indexProducer the Index producer to search for.\n     * @return an array of layer indices in which the Bloom filter is found."
        },
        "flatten": {
          "Javadoc": "* Create a standard (non-layered) Bloom filter by merging all of the layers. If\n     * the filter is empty this method will return an empty Bloom filter.\n     *\n     * @return the merged bloom filter."
        },
        "forEachBloomFilter": {
          "Javadoc": "* Processes the Bloom filters in depth order with the most recent filters\n     * first. Each filter is passed to the predicate in turn. The function exits on\n     * the first {@code false} returned by the predicate.\n     *\n     * @param bloomFilterPredicate the predicate to execute.\n     * @return {@code true} if all filters passed the predicate, {@code false}\n     *         otherwise."
        },
        "get": {
          "Javadoc": "* Gets the Bloom filter at the specified depth\n     *\n     * @param depth the depth of the filter to return.\n     * @return the Bloom filter at the specified depth.\n     * @throws NoSuchElementException if depth is not in the range [0,getDepth())"
        },
        "getDepth": {
          "Javadoc": "* Gets the depth of the deepest layer. The minimum value returned by this\n     * method is 1.\n     *\n     * @return the depth of the deepest layer."
        },
        "next": {
          "Javadoc": "* Forces and advance to the next layer. Executes the same logic as when\n     * LayerManager.extendCheck returns {@code true}\n     *\n     * @see LayerManager"
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.Finder": {
      "Javadoc": "\n     * A class used to locate matching filters across all the layers.\n     "
    },
    "org.apache.commons.collections4.bloomfilter.LayerManager": {
      "Javadoc": "\n * Implementation of the methods to manage the layers in a layered Bloom filter.\n * <p>\n * The manager comprises a list of Bloom filters that are managed based on\n * various rules. The last filter in the list is known as the {@code target} and\n * is the filter into which merges are performed. The Layered manager utilizes\n * three methods to manage the list.\n * </p>\n * <ul>\n * <li>ExtendCheck - A Predicate that if true causes a new Bloom filter to be\n * created as the new target.</li>\n * <li>FilterSupplier - A Supplier that produces empty Bloom filters to be used\n * as a new target.</li>\n * <li>Cleanup - A Consumer of a {@code LinkedList} of BloomFilter that removes any\n * expired or out dated filters from the list.</li>\n * </ul>\n * <p>\n * When extendCheck returns {@code true} the following steps are taken:\n * </p>\n * <ol>\n * <li>{@code Cleanup} is called</li>\n * <li>{@code FilterSuplier} is executed and the new filter added to the list as\n * the {@code target} filter.</li>\n * </ol>\n *\n * @since 4.5\n ",
      "methods": {
        "builder": {
          "Javadoc": "* Creates a new Builder with defaults of {@code ExtendCheck.neverAdvance()} and\n     * {@code Cleanup.noCleanup()}.\n     *\n     * @return A builder.\n     * @see ExtendCheck#neverAdvance()\n     * @see Cleanup#noCleanup()"
        },
        "addFilter": {
          "Javadoc": "* Adds a new Bloom filter to the list."
        },
        "clear": {
          "Javadoc": "* Removes all the filters from the layer manager, and sets up a new one as the\n     * target."
        },
        "copy": {
          "Javadoc": "* Creates a deep copy of this LayerManager.\n     * <p><em>Filters in the copy are deep copies, not references, so changes in the copy\n     * are NOT reflected in the original.</em></p>\n     * <p>The {@code filterSupplier}, {@code extendCheck}, and the {@code filterCleanup} are shared between\n     * the copy and this instance.</p>\n     *\n     * @return a copy of this layer Manager."
        },
        "forEachBloomFilter": {
          "Javadoc": "* Executes a Bloom filter Predicate on each Bloom filter in the manager in\n     * depth order. Oldest filter first.\n     *\n     * @param bloomFilterPredicate the predicate to evaluate each Bloom filter with.\n     * @return {@code false} when the a filter fails the predicate test. Returns\n     *         {@code true} if all filters pass the test."
        },
        "get": {
          "Javadoc": "* Gets the Bloom filter at the specified depth. The filter at depth 0 is the\n     * oldest filter.\n     *\n     * @param depth the depth at which the desired filter is to be found.\n     * @return the filter.\n     * @throws NoSuchElementException if depth is not in the range\n     *                                [0,filters.size())"
        },
        "getDepth": {
          "Javadoc": "* Returns the number of filters in the LayerManager.  In the default LayerManager implementation\n     * there is alwasy at least one layer.\n     *\n     * @return the current depth."
        },
        "getTarget": {
          "Javadoc": "* Returns the current target filter. If a new filter should be created based on\n     * {@code extendCheck} it will be created before this method returns.\n     *\n     * @return the current target filter after any extension."
        },
        "next": {
          "Javadoc": "* Forces an advance to the next depth. This method will clean-up the current\n     * layers and generate a new filter layer. In most cases is it unnecessary to\n     * call this method directly.\n     * <p>\n     * Ths method is used within {@link #getTarget()} when the configured\n     * {@code ExtendCheck} returns {@code true}.\n     * </p>"
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.Builder": {
      "Javadoc": "\n     * Builder to create Layer Manager\n     ",
      "methods": {
        "build": {
          "Javadoc": "* Builds the layer manager with the specified properties.\n         *\n         * @return a new LayerManager."
        },
        "setCleanup": {
          "Javadoc": "* Sets the Consumer that cleans the list of Bloom filters.\n         *\n         * @param cleanup the Consumer that will modify the list of filters removing out\n         *                dated or stale filters.\n         * @return this for chaining."
        },
        "setExtendCheck": {
          "Javadoc": "* Sets the extendCheck predicate. When the predicate returns {@code true} a new\n         * target will be created.\n         *\n         * @param extendCheck The predicate to determine if a new target should be\n         *                    created.\n         * @return this for chaining."
        },
        "setSupplier": {
          "Javadoc": "* Sets the supplier of Bloom filters. When extendCheck creates a new target,\n         * the supplier provides the instance of the Bloom filter.\n         *\n         * @param supplier The supplier of new Bloom filter instances.\n         * @return this for chaining."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.Cleanup": {
      "Javadoc": "\n     * Static methods to create a Consumer of a LinkedList of BloomFilter perform\n     * tests on whether to reduce the collection of Bloom filters.\n     ",
      "methods": {
        "noCleanup": {
          "Javadoc": "* A Cleanup that never removes anything.\n         * @return A Consumer suitable for the LayerManager {@code cleanup} parameter."
        },
        "onMaxSize": {
          "Javadoc": "* Removes the earliest filters in the list when the the number of filters\n         * exceeds maxSize.\n         *\n         * @param maxSize the maximum number of filters for the list. Must be greater\n         *                than 0\n         * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n         * @throws IllegalArgumentException if {@code maxSize <= 0}."
        },
        "removeEmptyTarget": {
          "Javadoc": "* Removes the last added target if it is empty.  Useful as the first in a chain\n         * of cleanup consumers.  (e.g. {@code Cleanup.removeEmptyTarget.andThen( otherConsumer )})\n         *\n         * @return A Consumer suitable for the LayerManager {@code cleanup} parameter."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.ExtendCheck": {
      "Javadoc": "\n     * A collection of common ExtendCheck implementations to test whether to extend\n     * the depth of a LayerManager.\n     ",
      "methods": {
        "advanceOnCount": {
          "Javadoc": "* Creates a new target after a specific number of filters have been added to\n         * the current target.\n         *\n         * @param breakAt the number of filters to merge into each filter in the list.\n         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n         * @throws IllegalArgumentException if {@code breakAt <= 0}"
        },
        "advanceOnPopulated": {
          "Javadoc": "* Advances the target once a merge has been performed.\n         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter."
        },
        "advanceOnSaturation": {
          "Javadoc": "* Creates a new target after the current target is saturated. Saturation is\n         * defined as the {@code Bloom filter estimated N >= maxN}.\n         *\n         * <p>An example usage is advancing on a calculated saturation by calling:\n         * {@code ExtendCheck.advanceOnSaturation(shape.estimateMaxN()) }</p>\n         *\n         * @param maxN the maximum number of estimated items in the filter.\n         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n         * @throws IllegalArgumentException if {@code maxN <= 0}"
        },
        "neverAdvance": {
          "Javadoc": "* Does not automatically advance the target. @{code next()} must be called directly to\n         * perform the advance.\n         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.LongBiPredicate": {
      "Javadoc": "\n * Represents a function that accepts a two long-valued argument and produces a binary result.\n * This is the long-consuming primitive specialization for {@code BiPredicate}.\n *\n * This is a functional interface whose functional method is {@code test(long,long)}.\n *\n * @since 4.5\n ",
      "methods": {
        "test": {
          "Javadoc": "* A function that takes to long arguments and returns a boolean.\n     * @param x the first long argument.\n     * @param y the second long argument.\n     * @return true or false."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.SetOperations": {
      "Javadoc": "\n * Implementations of set operations on BitMapProducers.\n *\n * @since 4.5\n ",
      "methods": {
        "andCardinality": {
          "Javadoc": "* Calculates the cardinality of the logical {@code AND} of the bit maps for the two filters.\n     * @param first the first BitMapProducer.\n     * @param second the second BitMapProducer\n     * @return the cardinality of the {@code AND} of the filters."
        },
        "cardinality": {
          "Javadoc": "* Calculates the cardinality of the result of a LongBinaryOperator using the\n     * {@code BitMapProducer.makePredicate} method.\n     * @param first the first BitMapProducer\n     * @param second the second BitMapProducer\n     * @param op a long binary operation on where x = {@code first} and y = {@code second} bitmap producers.\n     * @return the calculated cardinality."
        },
        "cosineDistance": {
          "Javadoc": "* Calculates the Cosine distance between two BitMapProducer.\n     *\n     * <p>Cosine distance is defined as {@code 1 - Cosine similarity}</p>\n     *\n     * @param first the first BitMapProducer.\n     * @param second the second BitMapProducer.\n     * @return the jaccard distance."
        },
        "cosineSimilarity": {
          "Javadoc": "* Calculates the Cosine similarity between two Bloom filters.\n     * <p> Also known as Orchini similarity and the Tucker coefficient of congruence or\n     * Ochiai similarity.</p>\n     *\n     * <p>If either filter is empty (no enabled bits) the result is 0 (zero)</p>\n     *\n     * <p>This is a version of cosineSimilarity optimized for Bloom filters.</p>\n     *\n     * @param first the first Bloom filter.\n     * @param second the second Bloom filter.\n     * @return the Cosine similarity."
        },
        "hammingDistance": {
          "Javadoc": "* Calculates the Hamming distance between two BitMapProducers.\n     *\n     * @param first the first BitMapProducer.\n     * @param second the second BitMapProducer.\n     * @return the Hamming distance."
        },
        "jaccardDistance": {
          "Javadoc": "* Calculates the Jaccard distance between two BitMapProducer.\n     *\n     * <p>Jaccard distance is defined as {@code 1 - Jaccard similarity}</p>\n     *\n     * @param first the first BitMapProducer.\n     * @param second the second BitMapProducer.\n     * @return the Jaccard distance."
        },
        "jaccardSimilarity": {
          "Javadoc": "* Calculates the Jaccard similarity between two BitMapProducer.\n     *\n     * <p>Also known as Jaccard index, Intersection over Union, and Jaccard similarity coefficient</p>\n     *\n     * @param first the first BitMapProducer.\n     * @param second the second BitMapProducer.\n     * @return the Jaccard similarity."
        },
        "orCardinality": {
          "Javadoc": "* Calculates the cardinality of the logical {@code OR} of the bit maps for the two filters.\n     * @param first the first BitMapProducer.\n     * @param second the second BitMapProducer\n     * @return the cardinality of the {@code OR} of the filters."
        },
        "xorCardinality": {
          "Javadoc": "* Calculates the cardinality of the logical {@code XOR} of the bit maps for the two filters.\n     * @param first the first BitMapProducer.\n     * @param second the second BitMapProducer\n     * @return the cardinality of the {@code XOR} of the filters."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.Shape": {
      "Javadoc": "\n * The definition of a Bloom filter shape.\n *\n * <p> This class contains the values for the filter configuration and is used to\n * convert a Hasher into a BloomFilter as well as verify that two Bloom filters are\n * compatible. (i.e. can be compared or merged)</p>\n *\n * <h2>Interrelatedness of values</h2>\n *\n * <dl>\n * <dt>Number of Items ({@code n})</dt>\n * <dd>{@code n = ceil(m / (-k / ln(1 - exp(ln(p) / k))))}</dd>\n * <dt>Probability of False Positives ({@code p})</dt>\n * <dd>{@code p = pow(1 - exp(-k / (m / n)), k)}</dd>\n * <dt>Number of Bits ({@code m})</dt>\n * <dd>{@code m = ceil((n * ln(p)) / ln(1 / pow(2, ln(2))))}</dd>\n * <dt>Number of Functions ({@code k})</dt>\n * <dd>{@code k = round((m / n) * ln(2))}</dd>\n * </dl>\n *\n * <h2>Estimations from cardinality based on shape</h2>\n *\n * <p>Several estimates can be calculated from the Shape and the cardinality of a Bloom filter.</p>\n *\n * <p>In the calculation below the following values are used:</p>\n * <ul>\n * <li>double c = the cardinality of the Bloom filter.</li>\n * <li>double m = numberOfBits as specified in the shape.</li>\n * <li>double k = numberOfHashFunctions as specified in the shape.</li>\n * </ul>\n *\n * <h3>Estimate N - n()</h3>\n *\n * <p>The calculation for the estimate of N is: {@code -(m/k) * ln(1 - (c/m))}.  This is the calculation\n * performed by the {@code Shape.estimateN(cardinality)} method below.  This estimate is roughly equivalent to the\n * number of hashers that have been merged into a filter to create the cardinality specified.</p>\n *\n * <p><em>Note:</em></p>\n * <ul>\n * <li>if cardinality == numberOfBits, then result is infinity.</li>\n * <li>if cardinality &gt; numberOfBits, then result is NaN.</li>\n * </ul>\n *\n * <h3>Estimate N of Union - n(A &cup; B)</h3>\n *\n * <p>To estimate the number of items in the union of two Bloom filters with the same shape, merge them together and\n * calculate the estimated N from the result.</p>\n *\n * <h3>Estimate N of the Intersection - n(A &cap; B)</h3>\n *\n * <p>To estimate the number of items in the intersection of two Bloom filters A and B with the same shape the calculation is:\n * n(A) + n(b) - n(A &cup; B).</p>\n *\n * <p>Care must be taken when any of the n(x) returns infinity.  In general the following assumptions are true:\n *\n * <ul>\n * <li>If n(A) = &infin; and n(B) &lt; &infin; then n(A &cap; B) = n(B)</li>\n * <li>If n(A) &lt; &infin; and n(B) = &infin; then n(A &cap; B) = n(A)</li>\n * <li>If n(A) = &infin; and n(B) = &infin; then n(A &cap; B) = &infin;</li>\n * <li>If n(A) &lt; &infin; and n(B) &lt; &infin; and n(A &cup; B) = &infin; then n(A &cap; B) is undefined.</li>\n * </ul>\n *\n * @see <a href=\"https://hur.st/bloomfilter\">Bloom Filter calculator</a>\n * @see <a href=\"https://en.wikipedia.org/wiki/Bloom_filter\">Bloom filter\n * [Wikipedia]</a>\n * @since 4.5\n ",
      "methods": {
        "calculateNumberOfHashFunctions": {
          "Javadoc": "* Calculates the number of hash functions given numberOfItems and numberOfBits.\n     * This is a method so that the calculation is consistent across all constructors.\n     *\n     * @param numberOfItems the number of items in the filter.\n     * @param numberOfBits the number of bits in the filter.\n     * @return the optimal number of hash functions.\n     * @throws IllegalArgumentException if the calculated number of hash function is {@code < 1}"
        },
        "checkCalculatedProbability": {
          "Javadoc": "* Check the calculated probability is {@code < 1.0}.\n     *\n     * <p>This function is used to verify that the dynamically calculated probability for the\n     * Shape is in the valid range 0 to 1 exclusive. This need only be performed once upon\n     * construction.\n     *\n     * @param probability the probability\n     * @throws IllegalArgumentException if the probability is {@code >= 1.0}."
        },
        "checkNumberOfBits": {
          "Javadoc": "* Check number of bits is strictly positive.\n     *\n     * @param numberOfBits the number of bits\n     * @return the number of bits\n     * @throws IllegalArgumentException if the number of bits is {@code < 1}."
        },
        "checkNumberOfHashFunctions": {
          "Javadoc": "* Check number of hash functions is strictly positive.\n     *\n     * @param numberOfHashFunctions the number of hash functions\n     * @return the number of hash functions\n     * @throws IllegalArgumentException if the number of hash functions is {@code < 1}."
        },
        "checkNumberOfItems": {
          "Javadoc": "* Check number of items is strictly positive.\n     *\n     * @param numberOfItems the number of items\n     * @return the number of items\n     * @throws IllegalArgumentException if the number of items is {@code < 1}."
        },
        "checkProbability": {
          "Javadoc": "* Check the probability is in the range 0.0, exclusive, to 1.0, exclusive.\n     *\n     * @param probability the probability\n     * @throws IllegalArgumentException if the probability is not in the range {@code (0, 1)}"
        },
        "fromKM": {
          "Javadoc": "* Constructs a filter configuration with the specified number of hashFunctions ({@code k}) and\n     * bits ({@code m}).\n     *\n     * @param numberOfHashFunctions Number of hash functions to use for each item placed in the filter.\n     * @param numberOfBits The number of bits in the filter\n     * @return a valid Shape.\n     * @throws IllegalArgumentException if {@code numberOfHashFunctions < 1} or {@code numberOfBits < 1}"
        },
        "fromNM": {
          "Javadoc": "* Constructs a filter configuration with the specified number of items ({@code n}) and\n     * bits ({@code m}).\n     *\n     * <p>The optimal number of hash functions ({@code k}) is computed.\n     * <pre>k = round((m / n) * ln(2))</pre>\n     *\n     * <p>The false-positive probability is computed using the number of items, bits and hash\n     * functions. An exception is raised if this is greater than or equal to 1 (i.e. the\n     * shape is invalid for use as a Bloom filter).\n     *\n     * @param numberOfItems Number of items to be placed in the filter\n     * @param numberOfBits The number of bits in the filter\n     * @return a valid Shape.\n     * @throws IllegalArgumentException if {@code numberOfItems < 1}, {@code numberOfBits < 1},\n     * the calculated number of hash function is {@code < 1}, or if the actual probability is {@code >= 1.0}"
        },
        "fromNMK": {
          "Javadoc": "* Constructs a filter configuration with the specified number of items, bits\n     * and hash functions.\n     *\n     * <p>The false-positive probability is computed using the number of items, bits and hash\n     * functions. An exception is raised if this is greater than or equal to 1 (i.e. the\n     * shape is invalid for use as a Bloom filter).\n     *\n     * @param numberOfItems Number of items to be placed in the filter\n     * @param numberOfBits The number of bits in the filter.\n     * @param numberOfHashFunctions The number of hash functions in the filter\n     * @return a valid Shape.\n     * @throws IllegalArgumentException if {@code numberOfItems < 1}, {@code numberOfBits < 1},\n     * {@code numberOfHashFunctions < 1}, or if the actual probability is {@code >= 1.0}."
        },
        "fromNP": {
          "Javadoc": "* Constructs a filter configuration with the specified number of items ({@code n}) and\n     * desired false-positive probability ({@code p}).\n     *\n     * <p>The number of bits ({@code m}) for the filter is computed.\n     * <pre>m = ceil(n * ln(p) / ln(1 / 2^ln(2)))</pre>\n     *\n     * <p>The optimal number of hash functions ({@code k}) is computed.\n     * <pre>k = round((m / n) * ln(2))</pre>\n     *\n     * <p>The actual probability will be approximately equal to the\n     * desired probability but will be dependent upon the calculated number of bits and hash\n     * functions. An exception is raised if this is greater than or equal to 1 (i.e. the\n     * shape is invalid for use as a Bloom filter).\n     *\n     * @param numberOfItems Number of items to be placed in the filter\n     * @param probability The desired false-positive probability in the range {@code (0, 1)}\n     * @return a valid Shape\n     * @throws IllegalArgumentException if {@code numberOfItems < 1}, if the desired probability\n     * is not in the range {@code (0, 1)} or if the actual probability is {@code >= 1.0}."
        },
        "fromPMK": {
          "Javadoc": "* Constructs a filter configuration with a desired false-positive probability ({@code p}) and the\n     * specified number of bits ({@code m}) and hash functions ({@code k}).\n     *\n     * <p>The number of items ({@code n}) to be stored in the filter is computed.\n     * <pre>n = ceil(m / (-k / ln(1 - exp(ln(p) / k))))</pre>\n     *\n     * <p>The actual probability will be approximately equal to the\n     * desired probability but will be dependent upon the calculated Bloom filter capacity\n     * (number of items). An exception is raised if this is greater than or equal to 1 (i.e. the\n     * shape is invalid for use as a Bloom filter).\n     *\n     * @param probability The desired false-positive probability in the range {@code (0, 1)}\n     * @param numberOfBits The number of bits in the filter\n     * @param numberOfHashFunctions The number of hash functions in the filter\n     * @return a valid Shape.\n     * @throws IllegalArgumentException if the desired probability is not in the range {@code (0, 1)},\n     * {@code numberOfBits < 1}, {@code numberOfHashFunctions < 1}, or the actual\n     * probability is {@code >= 1.0}"
        },
        "estimateMaxN": {
          "Javadoc": "* Estimates the maximum number of elements that can be merged into a filter of\n     * this shape before the false positive rate exceeds the desired rate. <p> The\n     * formula for deriving {@code k} when {@code m} and {@code n} are known is:\n     *\n     * <p>{@code k = ln2 * m / n}</p>\n     *\n     * <p>Solving for {@code n} yields:</p>\n     *\n     * <p>{@code n = ln2 * m / k}</p>\n     *\n     * @return An estimate of max N."
        },
        "estimateN": {
          "Javadoc": "* Estimate the number of items in a Bloom filter with this shape and the specified number of bits enabled.\n     *\n     * <p><em>Note:</em></p>\n     * <ul>\n     * <li> if cardinality == numberOfBits, then result is infinity.</li>\n     * <li> if cardinality &gt; numberOfBits, then result is NaN.</li>\n     * </ul>\n     *\n     * @param cardinality the number of enabled  bits also known as the hamming value.\n     * @return An estimate of the number of items in the Bloom filter."
        },
        "getNumberOfBits": {
          "Javadoc": "* Gets the number of bits in the Bloom filter.\n     * This is also known as {@code m}.\n     *\n     * @return the number of bits in the Bloom filter ({@code m})."
        },
        "getNumberOfHashFunctions": {
          "Javadoc": "* Gets the number of hash functions used to construct the filter.\n     * This is also known as {@code k}.\n     *\n     * @return the number of hash functions used to construct the filter ({@code k})."
        },
        "getProbability": {
          "Javadoc": "* Calculates the probability of false positives ({@code p}) given\n     * numberOfItems ({@code n}), numberOfBits ({@code m}) and numberOfHashFunctions ({@code k}).\n     * <pre>p = pow(1 - exp(-k / (m / n)), k)</pre>\n     *\n     * <p>This is the probability that a Bloom filter will return true for the presence of an item\n     * when it does not contain the item.</p>\n     *\n     * <p>The probability assumes that the Bloom filter is filled with the expected number of\n     * items. If the filter contains fewer items then the actual probability will be lower.\n     * Thus, this returns the worst-case false positive probability for a filter that has not\n     * exceeded its expected number of items.</p>\n     *\n     * @param numberOfItems the number of items hashed into the Bloom filter.\n     * @return the probability of false positives."
        },
        "isSparse": {
          "Javadoc": "* Determines if a cardinality is sparse based on the shape.\n     * <p>This method assumes that bit maps are 64bits and indexes are 32bits. If the memory\n     * necessary to store the cardinality as indexes is less than the estimated memory for bit maps,\n     * the cardinality is determined to be {@code sparse}.</p>\n     * @param cardinality the cardinality to check.\n     * @return true if the cardinality is sparse within the shape."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.SimpleBloomFilter": {
      "Javadoc": "\n * A bloom filter using an array of bit maps to track enabled bits. This is a standard\n * implementation and should work well for most Bloom filters.\n * @since 4.5\n "
    },
    "org.apache.commons.collections4.bloomfilter.SparseBloomFilter": {
      "Javadoc": "\n * A bloom filter using a TreeSet of integers to track enabled bits. This is a standard\n * implementation and should work well for most low cardinality Bloom filters.\n * @since 4.5\n ",
      "methods": {
        "add": {
          "Javadoc": "* Adds the index to the indices.\n     * @param idx the index to add.\n     * @return {@code true} always"
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.WrappedBloomFilter": {
      "Javadoc": "\n * An abstract class to assist in implementing Bloom filter decorators.\n *\n * @since 4.5\n "
    },
    "org.apache.commons.collections4.BoundedCollection": {
      "Javadoc": "\n * Defines a collection that is bounded in size.\n * <p>\n * The size of the collection can vary, but it can never exceed a preset\n * maximum number of elements. This interface allows the querying of details\n * associated with the maximum number of elements.\n * </p>\n *\n * @see CollectionUtils#isFull\n * @see CollectionUtils#maxSize\n *\n * @param <E> the type of elements in this collection\n * @since 3.0\n ",
      "methods": {
        "isFull": {
          "Javadoc": "* Returns true if this collection is full and no new elements can be added.\n     *\n     * @return {@code true} if the collection is full."
        },
        "maxSize": {
          "Javadoc": "* Gets the maximum size of the collection (the bound).\n     *\n     * @return the maximum number of elements the collection can hold."
        }
      }
    },
    "org.apache.commons.collections4.BoundedMap": {
      "Javadoc": "\n * Defines a map that is bounded in size.\n * <p>\n * The size of the map can vary, but it can never exceed a preset\n * maximum number of elements. This interface allows the querying of details\n * associated with the maximum number of elements.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "isFull": {
          "Javadoc": "* Returns true if this map is full and no new elements can be added.\n     *\n     * @return {@code true} if the map is full"
        },
        "maxSize": {
          "Javadoc": "* Gets the maximum size of the map (the bound).\n     *\n     * @return the maximum number of elements the map can hold"
        }
      }
    },
    "org.apache.commons.collections4.Closure": {
      "Javadoc": "\n * Defines a functor interface implemented by classes that do something.\n * <p>\n * A {@code Closure} represents a block of code which is executed from\n * inside some block, function or iteration. It operates an input object.\n * </p>\n * <p>\n * Standard implementations of common closures are provided by\n * {@link ClosureUtils}. These include method invocation and for/while loops.\n * </p>\n *\n * @param <T> the type that the closure acts on\n * @since 1.0\n ",
      "methods": {
        "execute": {
          "Javadoc": "* Performs an action on the specified input object.\n     *\n     * @param input  the input to execute on\n     * @throws ClassCastException (runtime) if the input is the wrong class\n     * @throws IllegalArgumentException (runtime) if the input is invalid\n     * @throws FunctorException (runtime) if any other error occurs"
        }
      }
    },
    "org.apache.commons.collections4.ClosureUtils": {
      "Javadoc": "\n * {@code ClosureUtils} provides reference implementations and utilities\n * for the Closure functor interface. The supplied closures are:\n * <ul>\n * <li>Invoker - invokes a method on the input object\n * <li>For - repeatedly calls a closure for a fixed number of times\n * <li>While - repeatedly calls a closure while a predicate is true\n * <li>Chained - chains two or more closures together\n * <li>If - calls one closure or another based on a predicate\n * <li>Switch - calls one closure based on one or more predicates\n * <li>SwitchMap - calls one closure looked up from a Map\n * <li>Transformer - wraps a Transformer as a Closure\n * <li>NOP - does nothing\n * <li>Exception - always throws an exception\n * </ul>\n * <p>\n * Since v4.1 only closures which are considered to be safe are\n * Serializable. Closures considered to be unsafe for serialization are:\n * </p>\n * <ul>\n * <li>Invoker\n * <li>For\n * <li>While\n * </ul>\n *\n * @since 3.0\n ",
      "methods": {
        "asClosure": {
          "Javadoc": "* Creates a Closure that calls a Transformer each time it is called.\n     * The transformer will be called using the closure's input object.\n     * The transformer's result will be ignored.\n     *\n     * @see org.apache.commons.collections4.functors.TransformerClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param transformer  the transformer to run each time in the closure, null means nop\n     * @return the closure"
        },
        "chainedClosure": {
          "Javadoc": "* Create a new Closure that calls each closure in turn, passing the\n     * result into the next closure. The ordering is that of the iterator()\n     * method on the collection.\n     *\n     * @see org.apache.commons.collections4.functors.ChainedClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param closures  a collection of closures to chain\n     * @return the {@code chained} closure\n     * @throws NullPointerException if the closures collection is null\n     * @throws NullPointerException if any closure in the collection is null\n     * @throws IllegalArgumentException if the closures collection is empty"
        },
        "doWhileClosure": {
          "Javadoc": "* Creates a Closure that will call the closure once and then repeatedly\n     * until the predicate returns false.\n     *\n     * @see org.apache.commons.collections4.functors.WhileClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param closure  the closure to call repeatedly, not null\n     * @param predicate  the predicate to use as an end of loop test, not null\n     * @return the {@code do-while} closure\n     * @throws NullPointerException if either argument is null"
        },
        "exceptionClosure": {
          "Javadoc": "* Gets a Closure that always throws an exception.\n     * This could be useful during testing as a placeholder.\n     *\n     * @see org.apache.commons.collections4.functors.ExceptionClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @return the closure"
        },
        "forClosure": {
          "Javadoc": "* Creates a Closure that will call the closure {@code count} times.\n     * <p>\n     * A null closure or zero count returns the {@code NOPClosure}.\n     *\n     * @see org.apache.commons.collections4.functors.ForClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param count  the number of times to loop\n     * @param closure  the closure to call repeatedly\n     * @return the {@code for} closure"
        },
        "ifClosure": {
          "Javadoc": "* Create a new Closure that calls one of two closures depending\n     * on the specified predicate.\n     *\n     * @see org.apache.commons.collections4.functors.IfClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param predicate  the predicate to switch on\n     * @param trueClosure  the closure called if the predicate is true\n     * @param falseClosure  the closure called if the predicate is false\n     * @return the {@code switch} closure\n     * @throws NullPointerException if the predicate or either closure is null"
        },
        "invokerClosure": {
          "Javadoc": "* Creates a Closure that will invoke a specific method on the closure's\n     * input object by reflection.\n     *\n     * @see org.apache.commons.collections4.functors.InvokerTransformer\n     * @see org.apache.commons.collections4.functors.TransformerClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param methodName  the name of the method\n     * @param paramTypes  the parameter types\n     * @param args  the arguments\n     * @return the {@code invoker} closure\n     * @throws NullPointerException if the method name is null\n     * @throws IllegalArgumentException if the paramTypes and args don't match"
        },
        "nopClosure": {
          "Javadoc": "* Gets a Closure that will do nothing.\n     * This could be useful during testing as a placeholder.\n     *\n     * @see org.apache.commons.collections4.functors.NOPClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @return the closure"
        },
        "switchClosure": {
          "Javadoc": "* Create a new Closure that calls one of the closures depending\n     * on the predicates.\n     * <p>\n     * The closure at array location 0 is called if the predicate at array\n     * location 0 returned true. Each predicate is evaluated\n     * until one returns true. If no predicates evaluate to true, the default\n     * closure is called.\n     *\n     * @see org.apache.commons.collections4.functors.SwitchClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param predicates  an array of predicates to check, not null\n     * @param closures  an array of closures to call, not null\n     * @param defaultClosure  the default to call if no predicate matches\n     * @return the {@code switch} closure\n     * @throws NullPointerException if either array is null\n     * @throws NullPointerException if any element in the arrays is null\n     * @throws IllegalArgumentException if the arrays are different sizes"
        },
        "switchMapClosure": {
          "Javadoc": "* Create a new Closure that uses the input object as a key to find the\n     * closure to call.\n     * <p>\n     * The Map consists of object keys and Closure values. A closure\n     * is called if the input object equals the key. If there is no match, the\n     * default closure is called. The default closure is set in the map\n     * using a null key.\n     *\n     * @see org.apache.commons.collections4.functors.SwitchClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param objectsAndClosures  a map of objects to closures\n     * @return the closure\n     * @throws NullPointerException if the map is null\n     * @throws NullPointerException if any closure in the map is null\n     * @throws IllegalArgumentException if the map is empty"
        },
        "whileClosure": {
          "Javadoc": "* Creates a Closure that will call the closure repeatedly until the\n     * predicate returns false.\n     *\n     * @see org.apache.commons.collections4.functors.WhileClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param predicate  the predicate to use as an end of loop test, not null\n     * @param closure  the closure to call repeatedly, not null\n     * @return the {@code while} closure\n     * @throws NullPointerException if either argument is null"
        }
      }
    },
    "org.apache.commons.collections4.collection.AbstractCollectionDecorator": {
      "Javadoc": "\n * Decorates another {@code Collection} to provide additional behavior.\n * <p>\n * Each method call made on this {@code Collection} is forwarded to the\n * decorated {@code Collection}. This class is used as a framework on which\n * to build to extensions such as synchronized and unmodifiable behavior. The\n * main advantage of decoration is that one decorator can wrap any implementation\n * of {@code Collection}, whereas sub-classing requires a new class to be\n * written for each implementation.\n * </p>\n * <p>\n * This implementation does not perform any special processing with\n * {@link #iterator()}. Instead it simply returns the value from the\n * wrapped collection. This may be undesirable, for example if you are trying\n * to write an unmodifiable implementation it might provide a loophole.\n * </p>\n * <p>\n * This implementation does not forward the hashCode and equals methods through\n * to the backing object, but relies on Object's implementation. This is necessary\n * to preserve the symmetry of equals. Custom definitions of equality are usually\n * based on an interface, such as Set or List, so that the implementation of equals\n * can cast the object being tested for equality to the custom interface.\n * AbstractCollectionDecorator does not implement such custom interfaces directly;\n * they are implemented only in subclasses. Therefore, forwarding equals would break\n * symmetry, as the forwarding object might consider itself equal to the object being\n * tested, but the reverse could not be true. This behavior is consistent with the\n * JDK's collection wrappers, such as {@link java.util.Collections#unmodifiableCollection(Collection)}.\n * Use an interface-specific subclass of AbstractCollectionDecorator, such as\n * AbstractListDecorator, to preserve equality behavior, or override equals directly.\n * </p>\n *\n * @param <E> the type of the elements in the collection\n * @since 3.0\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the collection being decorated.\n     * All access to the decorated collection goes via this method.\n     *\n     * @return the decorated collection"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        },
        "setCollection": {
          "Javadoc": "* Sets the collection being decorated.\n     * <p>\n     * <b>NOTE:</b> this method should only be used during deserialization\n     *\n     * @param coll  the decorated collection"
        }
      }
    },
    "org.apache.commons.collections4.collection.CompositeCollection": {
      "Javadoc": "\n * Decorates a collection of other collections to provide a single unified view.\n * <p>\n * Changes made to this collection will actually be made on the decorated collection.\n * Add and remove operations require the use of a pluggable strategy. If no\n * strategy is provided then add and remove are unsupported.\n * </p>\n * @param <E> the type of the elements in the collection\n * @since 3.0\n ",
      "methods": {
        "add": {
          "Javadoc": "* Adds an object to the collection, throwing UnsupportedOperationException\n     * unless a CollectionMutator strategy is specified.\n     *\n     * @param obj  the object to add\n     * @return {@code true} if the collection was modified\n     * @throws UnsupportedOperationException if CollectionMutator hasn't been set\n     * @throws UnsupportedOperationException if add is unsupported\n     * @throws ClassCastException if the object cannot be added due to its type\n     * @throws NullPointerException if the object cannot be added because its null\n     * @throws IllegalArgumentException if the object cannot be added"
        },
        "addAll": {
          "Javadoc": "* Adds a collection of elements to this collection, throwing\n     * UnsupportedOperationException unless a CollectionMutator strategy is specified.\n     *\n     * @param coll  the collection to add\n     * @return true if the collection was modified\n     * @throws UnsupportedOperationException if CollectionMutator hasn't been set\n     * @throws UnsupportedOperationException if add is unsupported\n     * @throws ClassCastException if the object cannot be added due to its type\n     * @throws NullPointerException if the object cannot be added because its null\n     * @throws IllegalArgumentException if the object cannot be added"
        },
        "addComposited": {
          "Javadoc": "* Add these Collections to the list of collections in this composite\n     *\n     * @param compositeCollection1  the Collection to be appended to the composite\n     * @param compositeCollection2  the Collection to be appended to the composite"
        },
        "clear": {
          "Javadoc": "* Removes all of the elements from this collection .\n     * <p>\n     * This implementation calls {@code clear()} on each collection.\n     * </p>\n     * @throws UnsupportedOperationException if clear is unsupported"
        },
        "contains": {
          "Javadoc": "* Checks whether this composite collection contains the object.\n     * <p>\n     * This implementation calls {@code contains()} on each collection.\n     * </p>\n     * @param obj  the object to search for\n     * @return true if obj is contained in any of the contained collections"
        },
        "containsAll": {
          "Javadoc": "* Checks whether this composite contains all the elements in the specified collection.\n     * <p>\n     * This implementation calls {@code contains()} for each element in the\n     * specified collection.\n     * </p>\n     * @param coll  the collection to check for\n     * @return true if all elements contained"
        },
        "getCollections": {
          "Javadoc": "* Gets the collections being decorated.\n     *\n     * @return Unmodifiable list of all collections in this composite."
        },
        "getMutator": {
          "Javadoc": "* Gets the collection mutator to be used for this CompositeCollection.\n     * @return CollectionMutator&lt;E&gt;"
        },
        "isEmpty": {
          "Javadoc": "* Checks whether this composite collection is empty.\n     * <p>\n     * This implementation calls {@code isEmpty()} on each collection.\n     * </p>\n     * @return true if all of the contained collections are empty"
        },
        "iterator": {
          "Javadoc": "* Gets an iterator over all the collections in this composite.\n     * <p>\n     * This implementation uses an {@code IteratorChain}.\n     * </p>\n     * @return an {@code IteratorChain} instance which supports\n     *  {@code remove()}. Iteration occurs over contained collections in\n     *  the order they were added, but this behavior should not be relied upon.\n     * @see IteratorChain"
        },
        "remove": {
          "Javadoc": "* Removes an object from the collection, throwing UnsupportedOperationException\n     * unless a CollectionMutator strategy is specified.\n     *\n     * @param obj  the object being removed\n     * @return true if the collection is changed\n     * @throws UnsupportedOperationException if removed is unsupported\n     * @throws ClassCastException if the object cannot be removed due to its type\n     * @throws NullPointerException if the object cannot be removed because its null\n     * @throws IllegalArgumentException if the object cannot be removed"
        },
        "removeAll": {
          "Javadoc": "* Removes the elements in the specified collection from this composite collection.\n     * <p>\n     * This implementation calls {@code removeAll} on each collection.\n     * </p>\n     * @param coll  the collection to remove\n     * @return true if the collection was modified\n     * @throws UnsupportedOperationException if removeAll is unsupported"
        },
        "removeComposited": {
          "Javadoc": "* Removes a collection from the those being decorated in this composite.\n     *\n     * @param coll  collection to be removed"
        },
        "removeIf": {
          "Javadoc": "* Removes all of the elements of this collection that satisfy the given predicate from this composite collection.\n     * <p>\n     * This implementation calls {@code removeIf} on each collection.\n     * </p>\n     * @param filter  a predicate which returns true for elements to be removed\n     * @return true if the collection was modified\n     * @throws UnsupportedOperationException if removeIf is unsupported\n     * @since 4.4"
        },
        "retainAll": {
          "Javadoc": "* Retains all the elements in the specified collection in this composite collection,\n     * removing all others.\n     * <p>\n     * This implementation calls {@code retainAll()} on each collection.\n     * </p>\n     * @param coll  the collection to remove\n     * @return true if the collection was modified\n     * @throws UnsupportedOperationException if retainAll is unsupported"
        },
        "setMutator": {
          "Javadoc": "* Specify a CollectionMutator strategy instance to handle changes.\n     *\n     * @param mutator  the mutator to use"
        },
        "size": {
          "Javadoc": "* Gets the size of this composite collection.\n     * <p>\n     * This implementation calls {@code size()} on each collection.\n     * </p>\n     * @return total number of elements in all contained containers"
        },
        "toArray": {
          "Javadoc": "* Returns an object array, populating the supplied array if possible.\n     * See {@code Collection} interface for full details.\n     *\n     * @param <T>  the type of the elements in the collection\n     * @param array  the array to use, populating if possible\n     * @return an array of all the elements in the collection"
        },
        "toCollection": {
          "Javadoc": "* Returns a new collection containing all of the elements\n     *\n     * @return A new ArrayList containing all of the elements in this composite.\n     *         The new collection is <i>not</i> backed by this composite."
        }
      }
    },
    "org.apache.commons.collections4.collection.CollectionMutator": {
      "Javadoc": "\n     * Pluggable strategy to handle changes to the composite.\n     *\n     * @param <E> the element being held in the collection\n     ",
      "methods": {
        "add": {
          "Javadoc": "* Called when an object is to be added to the composite.\n         *\n         * @param composite  the CompositeCollection being changed\n         * @param collections  all of the Collection instances in this CompositeCollection\n         * @param obj  the object being added\n         * @return true if the collection is changed\n         * @throws UnsupportedOperationException if add is unsupported\n         * @throws ClassCastException if the object cannot be added due to its type\n         * @throws NullPointerException if the object cannot be added because its null\n         * @throws IllegalArgumentException if the object cannot be added"
        },
        "addAll": {
          "Javadoc": "* Called when a collection is to be added to the composite.\n         *\n         * @param composite  the CompositeCollection being changed\n         * @param collections  all of the Collection instances in this CompositeCollection\n         * @param coll  the collection being added\n         * @return true if the collection is changed\n         * @throws UnsupportedOperationException if add is unsupported\n         * @throws ClassCastException if the object cannot be added due to its type\n         * @throws NullPointerException if the object cannot be added because its null\n         * @throws IllegalArgumentException if the object cannot be added"
        },
        "remove": {
          "Javadoc": "* Called when an object is to be removed to the composite.\n         *\n         * @param composite  the CompositeCollection being changed\n         * @param collections  all of the Collection instances in this CompositeCollection\n         * @param obj  the object being removed\n         * @return true if the collection is changed\n         * @throws UnsupportedOperationException if removed is unsupported\n         * @throws ClassCastException if the object cannot be removed due to its type\n         * @throws NullPointerException if the object cannot be removed because its null\n         * @throws IllegalArgumentException if the object cannot be removed"
        }
      }
    },
    "org.apache.commons.collections4.collection.IndexedCollection": {
      "Javadoc": "\n * An IndexedCollection is a Map-like view onto a Collection. It accepts a\n * keyTransformer to define how the keys are converted from the values.\n * <p>\n * Modifications made to this decorator modify the index as well as the\n * decorated {@link Collection}. However, modifications to the underlying\n * {@link Collection} will not update the index and it will get out of sync.\n * </p>\n * <p>\n * If modification of the decorated {@link Collection} is unavoidable, then a\n * call to {@link #reindex()} will update the index to the current contents of\n * the {@link Collection}.\n * </p>\n *\n * @param <K> the type of object in the index.\n * @param <C> the type of object in the collection.\n *\n * @since 4.0\n ",
      "methods": {
        "nonUniqueIndexedCollection": {
          "Javadoc": "* Create an {@link IndexedCollection} for a non-unique index.\n     *\n     * @param <K> the index object type.\n     * @param <C> the collection type.\n     * @param coll the decorated {@link Collection}.\n     * @param keyTransformer the {@link Transformer} for generating index keys.\n     * @return the created {@link IndexedCollection}."
        },
        "uniqueIndexedCollection": {
          "Javadoc": "* Create an {@link IndexedCollection} for a unique index.\n     * <p>\n     * If an element is added, which maps to an existing key, an {@link IllegalArgumentException}\n     * will be thrown.\n     *\n     * @param <K> the index object type.\n     * @param <C> the collection type.\n     * @param coll the decorated {@link Collection}.\n     * @param keyTransformer the {@link Transformer} for generating index keys.\n     * @return the created {@link IndexedCollection}."
        },
        "add": {
          "Javadoc": "* {@inheritDoc}\n     *\n     * @throws IllegalArgumentException if the object maps to an existing key and the index\n     *   enforces a uniqueness constraint"
        },
        "addToIndex": {
          "Javadoc": "* Provides checking for adding the index.\n     *\n     * @param object the object to index\n     * @throws IllegalArgumentException if the object maps to an existing key and the index\n     *   enforces a uniqueness constraint"
        },
        "contains": {
          "Javadoc": "* {@inheritDoc}\n     * <p>\n     * Note: uses the index for fast lookup"
        },
        "containsAll": {
          "Javadoc": "* {@inheritDoc}\n     * <p>\n     * Note: uses the index for fast lookup"
        },
        "get": {
          "Javadoc": "* Gets the element associated with the given key.\n     * <p>\n     * In case of a non-unique index, this method will return the first\n     * value associated with the given key. To retrieve all elements associated\n     * with a key, use {@link #values(Object)}.\n     *\n     * @param key  key to look up\n     * @return element found\n     * @see #values(Object)"
        },
        "reindex": {
          "Javadoc": "* Clears the index and re-indexes the entire decorated {@link Collection}."
        },
        "removeFromIndex": {
          "Javadoc": "* Removes an object from the index.\n     *\n     * @param object the object to remove"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        },
        "values": {
          "Javadoc": "* Gets all elements associated with the given key.\n     *\n     * @param key  key to look up\n     * @return a collection of elements found, or null if {@code contains(key) == false}"
        }
      }
    },
    "org.apache.commons.collections4.collection.PredicatedCollection": {
      "Javadoc": "\n * Decorates another {@link Collection} to validate that additions\n * match a specified predicate.\n * <p>\n * This collection exists to provide validation for the decorated collection.\n * It is normally created to decorate an empty collection.\n * If an object cannot be added to the collection, an IllegalArgumentException is thrown.\n * </p>\n * <p>\n * One usage would be to ensure that no null entries are added to the collection:\n * </p>\n * <pre>\n * Collection coll = PredicatedCollection.predicatedCollection(new ArrayList(), NotNullPredicate.INSTANCE);\n * </pre>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <E> the type of the elements in the collection\n * @since 3.0\n ",
      "methods": {
        "builder": {
          "Javadoc": "* Returns a Builder with the given predicate.\n     *\n     * @param <E>  the element type\n     * @param predicate  the predicate to use\n     * @return a new Builder for predicated collections\n     * @since 4.1"
        },
        "notNullBuilder": {
          "Javadoc": "* Returns a Builder with a NotNullPredicate.\n     *\n     * @param <E>  the element type\n     * @return a new Builder for predicated collections that ignores null values.\n     * @since 4.1"
        },
        "predicatedCollection": {
          "Javadoc": "* Factory method to create a predicated (validating) collection.\n     * <p>\n     * If there are any elements already in the collection being decorated, they\n     * are validated.\n     *\n     * @param <T> the type of the elements in the collection\n     * @param coll  the collection to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated collection\n     * @throws NullPointerException if collection or predicate is null\n     * @throws IllegalArgumentException if the collection contains invalid elements\n     * @since 4.0"
        },
        "add": {
          "Javadoc": "* Override to validate the object being added to ensure it matches\n     * the predicate.\n     *\n     * @param object  the object being added\n     * @return the result of adding to the underlying collection\n     * @throws IllegalArgumentException if the add is invalid"
        },
        "addAll": {
          "Javadoc": "* Override to validate the objects being added to ensure they match\n     * the predicate. If anyone fails, no update is made to the underlying\n     * collection.\n     *\n     * @param coll  the collection being added\n     * @return the result of adding to the underlying collection\n     * @throws IllegalArgumentException if the add is invalid"
        },
        "validate": {
          "Javadoc": "* Validates the object being added to ensure it matches the predicate.\n     * <p>\n     * The predicate itself should not throw an exception, but return false to\n     * indicate that the object cannot be added.\n     *\n     * @param object  the object being added\n     * @throws IllegalArgumentException if the add is invalid"
        }
      }
    },
    "org.apache.commons.collections4.collection.Builder": {
      "Javadoc": "\n     * Builder for creating predicated collections.\n     * <p>\n     * Create a Builder with a predicate to validate elements against, then add any elements\n     * to the builder. Elements that fail the predicate will be added to a rejected list.\n     * Finally, create or decorate a collection using the createPredicated[List,Set,Bag,Queue] methods.\n     * <p>\n     * An example:\n     * <pre>\n     *   Predicate&lt;String&gt; predicate = NotNullPredicate.notNullPredicate();\n     *   PredicatedCollectionBuilder&lt;String&gt; builder = PredicatedCollection.builder(predicate);\n     *   builder.add(\"item1\");\n     *   builder.add(null);\n     *   builder.add(\"item2\");\n     *   List&lt;String&gt; predicatedList = builder.createPredicatedList();\n     * </pre>\n     * <p>\n     * At the end of the code fragment above predicatedList is protected by the predicate supplied\n     * to the builder, and it contains item1 and item2.\n     * <p>\n     * More elements can be added to the builder once a predicated collection has been created,\n     * but these elements will not be reflected in already created collections.\n     *\n     * @param <E>  the element type\n     * @since 4.1\n     ",
      "methods": {
        "add": {
          "Javadoc": "* Adds the item to the builder.\n         * <p>\n         * If the predicate is true, it is added to the list of accepted elements,\n         * otherwise it is added to the rejected list.\n         *\n         * @param item  the element to add\n         * @return the PredicatedCollectionBuilder."
        },
        "addAll": {
          "Javadoc": "* Adds all elements from the given collection to the builder.\n         * <p>\n         * All elements for which the predicate evaluates to true will be added to the\n         * list of accepted elements, otherwise they are added to the rejected list.\n         *\n         * @param items  the elements to add to the builder\n         * @return the PredicatedCollectionBuilder."
        },
        "createPredicatedBag": {
          "Javadoc": "* Decorates the given bag with validating behavior using the predicate. All accepted elements\n         * are appended to the bag. If the bag already contains elements, they are validated.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned bag.\n         *\n         * @param bag  the bag to decorate, must not be null\n         * @return the decorated bag.\n         * @throws NullPointerException if bag is null\n         * @throws IllegalArgumentException if bag contains invalid elements"
        },
        "createPredicatedList": {
          "Javadoc": "* Decorates the given list with validating behavior using the predicate. All accepted elements\n         * are appended to the list. If the list already contains elements, they are validated.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned list.\n         *\n         * @param list  the List to decorate, must not be null\n         * @return the decorated list.\n         * @throws NullPointerException if list is null\n         * @throws IllegalArgumentException if list contains invalid elements"
        },
        "createPredicatedMultiSet": {
          "Javadoc": "* Decorates the given multiset with validating behavior using the predicate. All accepted elements\n         * are appended to the multiset. If the multiset already contains elements, they are validated.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned multiset.\n         *\n         * @param multiset  the multiset to decorate, must not be null\n         * @return the decorated multiset.\n         * @throws NullPointerException if multiset is null\n         * @throws IllegalArgumentException if multiset contains invalid elements"
        },
        "createPredicatedQueue": {
          "Javadoc": "* Decorates the given queue with validating behavior using the predicate. All accepted elements\n         * are appended to the queue. If the queue already contains elements, they are validated.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned queue.\n         *\n         * @param queue  the queue to decorate, must not be null\n         * @return the decorated queue.\n         * @throws NullPointerException if queue is null\n         * @throws IllegalArgumentException if queue contains invalid elements"
        },
        "createPredicatedSet": {
          "Javadoc": "* Decorates the given list with validating behavior using the predicate. All accepted elements\n         * are appended to the set. If the set already contains elements, they are validated.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned set.\n         *\n         * @param set  the set to decorate, must not be null\n         * @return the decorated set.\n         * @throws NullPointerException if set is null\n         * @throws IllegalArgumentException if set contains invalid elements"
        },
        "rejectedElements": {
          "Javadoc": "* Returns an unmodifiable collection containing all rejected elements.\n         *\n         * @return an unmodifiable collection"
        }
      }
    },
    "org.apache.commons.collections4.collection.SynchronizedCollection": {
      "Javadoc": "\n * Decorates another {@link Collection} to synchronize its behavior\n * for a multithreaded environment.\n * <p>\n * Iterators must be manually synchronized:\n * </p>\n * <pre>\n * synchronized (coll) {\n *   Iterator it = coll.iterator();\n *   // do stuff with iterator\n * }\n * </pre>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <E> the type of the elements in the collection\n * @since 3.0\n ",
      "methods": {
        "synchronizedCollection": {
          "Javadoc": "* Factory method to create a synchronized collection.\n     *\n     * @param <T> the type of the elements in the collection\n     * @param coll  the collection to decorate, must not be null\n     * @return a new synchronized collection\n     * @throws NullPointerException if collection is null\n     * @since 4.0"
        },
        "decorated": {
          "Javadoc": "* Gets the collection being decorated.\n     *\n     * @return the decorated collection"
        },
        "iterator": {
          "Javadoc": "* Iterators must be manually synchronized.\n     * <pre>\n     * synchronized (coll) {\n     *   Iterator it = coll.iterator();\n     *   // do stuff with iterator\n     * }\n     * </pre>\n     *\n     * @return an iterator that must be manually synchronized on the collection"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        }
      }
    },
    "org.apache.commons.collections4.collection.TransformedCollection": {
      "Javadoc": "\n * Decorates another {@link Collection} to transform objects that are added.\n * <p>\n * The add methods are affected by this class.\n * Thus objects must be removed or searched for using their transformed form.\n * For example, if the transformation converts Strings to Integers, you must\n * use the Integer form to remove objects.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <E> the type of the elements in the collection\n * @since 3.0\n ",
      "methods": {
        "transformedCollection": {
          "Javadoc": "* Factory method to create a transforming collection that will transform\n     * existing contents of the specified collection.\n     * <p>\n     * If there are any elements already in the collection being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingCollection(Collection, Transformer)}.\n     *\n     * @param <E> the type of the elements in the collection\n     * @param collection  the collection to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed Collection\n     * @throws NullPointerException if collection or transformer is null\n     * @since 4.0"
        },
        "transformingCollection": {
          "Javadoc": "* Factory method to create a transforming collection.\n     * <p>\n     * If there are any elements already in the collection being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedCollection(Collection, Transformer)}.\n     *\n     * @param <E> the type of the elements in the collection\n     * @param coll  the collection to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed collection\n     * @throws NullPointerException if collection or transformer is null\n     * @since 4.0"
        },
        "transform": {
          "Javadoc": "* Transforms an object.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object  the object to transform\n     * @return a transformed object"
        }
      }
    },
    "org.apache.commons.collections4.collection.UnmodifiableBoundedCollection": {
      "Javadoc": "\n * {@link UnmodifiableBoundedCollection} decorates another\n * {@link BoundedCollection} to ensure it can't be altered.\n * <p>\n * If a BoundedCollection is first wrapped in some other collection decorator,\n * such as synchronized or predicated, the BoundedCollection methods are no\n * longer accessible.\n * The factory on this class will attempt to retrieve the bounded nature by\n * examining the package scope variables.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <E> the type of elements in this collection\n * @since 3.0\n ",
      "methods": {
        "unmodifiableBoundedCollection": {
          "Javadoc": "* Factory method to create an unmodifiable bounded collection.\n     * <p>\n     * This method is capable of drilling down through up to 1000 other decorators\n     * to find a suitable BoundedCollection.\n     *\n     * @param <E> the type of the elements in the collection\n     * @param collection  the {@code BoundedCollection} to decorate, must not be null\n     * @return a new unmodifiable bounded collection\n     * @throws NullPointerException if coll is null\n     * @throws IllegalArgumentException if coll is not a {@code BoundedCollection}\n     * @since 4.0"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        }
      }
    },
    "org.apache.commons.collections4.collection.UnmodifiableCollection": {
      "Javadoc": "\n * Decorates another {@link Collection} to ensure it can't be altered.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <E> the type of the elements in the collection\n * @since 3.0\n ",
      "methods": {
        "unmodifiableCollection": {
          "Javadoc": "* Factory method to create an unmodifiable collection.\n     * <p>\n     * If the collection passed in is already unmodifiable, it is returned.\n     *\n     * @param <T> the type of the elements in the collection\n     * @param coll  the collection to decorate, must not be null\n     * @return an unmodifiable collection\n     * @throws NullPointerException if collection is null\n     * @since 4.0"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        }
      }
    },
    "org.apache.commons.collections4.CollectionUtils": {
      "Javadoc": "\n * Provides utility methods and decorators for {@link Collection} instances.\n * <p>\n * Various utility methods might put the input objects into a Set/Map/Bag. In case\n * the input objects override {@link Object#equals(Object)}, it is mandatory that\n * the general contract of the {@link Object#hashCode()} method is maintained.\n * </p>\n * <p>\n * NOTE: From 4.0, method parameters will take {@link Iterable} objects when possible.\n * </p>\n *\n * @since 1.0\n ",
      "methods": {
        "addAll": {
          "Javadoc": "* Adds all elements in the iteration to the given collection.\n     *\n     * @param <C>  the type of object the {@link Collection} contains\n     * @param collection  the collection to add to, must not be null\n     * @param iterator  the iterator of elements to add, must not be null\n     * @return a boolean indicating whether the collection has changed or not.\n     * @throws NullPointerException if the collection or iterator is null"
        },
        "addIgnoreNull": {
          "Javadoc": "* Adds an element to the collection unless the element is null.\n     *\n     * @param <T>  the type of object the {@link Collection} contains\n     * @param collection  the collection to add to, must not be null\n     * @param object  the object to add, if null it will not be added\n     * @return true if the collection changed\n     * @throws NullPointerException if the collection is null\n     * @since 3.2"
        },
        "cardinality": {
          "Javadoc": "* Returns the number of occurrences of <i>obj</i> in <i>coll</i>.\n     *\n     * @param obj the object to find the cardinality of\n     * @param collection the {@link Iterable} to search\n     * @param <O> the type of object that the {@link Iterable} may contain.\n     * @return the number of occurrences of obj in coll\n     * @throws NullPointerException if collection is null\n     * @deprecated since 4.1, use {@link IterableUtils#frequency(Iterable, Object)} instead.\n     *   Be aware that the order of parameters has changed."
        },
        "checkIndexBounds": {
          "Javadoc": "* Ensures an index is not negative.\n     * @param index the index to check.\n     * @throws IndexOutOfBoundsException if the index is negative."
        },
        "collate": {
          "Javadoc": "* Merges two sorted Collections, a and b, into a single, sorted List\n     * such that the ordering of the elements according to Comparator c is retained.\n     * <p>\n     * Uses the standard O(n) merge algorithm for combining two sorted lists.\n     * </p>\n     *\n     * @param <O>  the element type\n     * @param iterableA  the first collection, must not be null\n     * @param iterableB  the second collection, must not be null\n     * @param comparator  the comparator to use for the merge.\n     * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n     *   they will be removed in the output collection\n     * @return a new sorted List, containing the elements of Collection a and b\n     * @throws NullPointerException if either collection or the comparator is null\n     * @since 4.0"
        },
        "collect": {
          "Javadoc": "* Transforms all elements from the input iterator with the given transformer\n     * and adds them to the output collection.\n     * <p>\n     * If the input iterator or transformer is null, the result is an empty list.\n     * </p>\n     *\n     * @param <I>  the type of object in the input collection\n     * @param <O>  the type of object in the output collection\n     * @param inputIterator  the iterator to get the input from, may be null\n     * @param transformer  the transformer to use, may be null\n     * @return the transformed result (new list)"
        },
        "containsAll": {
          "Javadoc": "* Returns {@code true} iff all elements of {@code coll2} are also contained\n     * in {@code coll1}. The cardinality of values in {@code coll2} is not taken into account,\n     * which is the same behavior as {@link Collection#containsAll(Collection)}.\n     * <p>\n     * In other words, this method returns {@code true} iff the\n     * {@link #intersection} of <i>coll1</i> and <i>coll2</i> has the same cardinality as\n     * the set of unique values from {@code coll2}. In case {@code coll2} is empty, {@code true}\n     * will be returned.\n     * </p>\n     * <p>\n     * This method is intended as a replacement for {@link Collection#containsAll(Collection)}\n     * with a guaranteed runtime complexity of {@code O(n + m)}. Depending on the type of\n     * {@link Collection} provided, this method will be much faster than calling\n     * {@link Collection#containsAll(Collection)} instead, though this will come at the\n     * cost of an additional space complexity O(n).\n     * </p>\n     *\n     * @param coll1  the first collection, must not be null\n     * @param coll2  the second collection, must not be null\n     * @return {@code true} iff the intersection of the collections has the same cardinality\n     *   as the set of unique elements from the second collection\n     * @throws NullPointerException if coll1 or coll2 is null\n     * @since 4.0"
        },
        "containsAny": {
          "Javadoc": "* Returns {@code true} iff at least one element is in both collections.\n     * <p>\n     * In other words, this method returns {@code true} iff the\n     * {@link #intersection} of <i>coll1</i> and <i>coll2</i> is not empty.\n     * </p>\n     *\n     * @param <T> the type of object to lookup in {@code coll1}.\n     * @param coll1  the first collection, must not be null\n     * @param coll2  the second collection, must not be null\n     * @return {@code true} iff the intersection of the collections is non-empty\n     * @throws NullPointerException if coll1 or coll2 is null\n     * @since 4.2\n     * @see #intersection"
        },
        "countMatches": {
          "Javadoc": "* Counts the number of elements in the input collection that match the\n     * predicate.\n     * <p>\n     * A {@code null} collection or predicate matches no elements.\n     * </p>\n     *\n     * @param <C>  the type of object the {@link Iterable} contains\n     * @param input  the {@link Iterable} to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @return the number of matches for the predicate in the collection\n     * @deprecated since 4.1, use {@link IterableUtils#countMatches(Iterable, Predicate)} instead"
        },
        "disjunction": {
          "Javadoc": "* Returns a {@link Collection} containing the exclusive disjunction\n     * (symmetric difference) of the given {@link Iterable}s.\n     * <p>\n     * The cardinality of each element <i>e</i> in the returned\n     * {@link Collection} will be equal to\n     * <code>max(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>)) - min(cardinality(<i>e</i>,<i>a</i>),\n     * cardinality(<i>e</i>,<i>b</i>))</code>.\n     * </p>\n     * <p>\n     * This is equivalent to\n     * {@code {@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})}\n     * or\n     * {@code {@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})}.\n     * </p>\n     *\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the symmetric difference of the two collections\n     * @throws NullPointerException if either collection is null"
        },
        "emptyCollection": {
          "Javadoc": "* Returns the immutable EMPTY_COLLECTION with generic type safety.\n     *\n     * @see #EMPTY_COLLECTION\n     * @since 4.0\n     * @param <T> the element type\n     * @return immutable empty collection"
        },
        "emptyIfNull": {
          "Javadoc": "* Returns an immutable empty collection if the argument is {@code null},\n     * or the argument itself otherwise.\n     *\n     * @param <T> the element type\n     * @param collection the collection, possibly {@code null}\n     * @return an empty collection if the argument is {@code null}"
        },
        "exists": {
          "Javadoc": "* Answers true if a predicate is true for at least one element of a\n     * collection.\n     * <p>\n     * A {@code null} collection or predicate returns false.\n     * </p>\n     *\n     * @param <C>  the type of object the {@link Iterable} contains\n     * @param input  the {@link Iterable} to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @return true if at least one element of the collection matches the predicate\n     * @deprecated since 4.1, use {@link IterableUtils#matchesAny(Iterable, Predicate)} instead"
        },
        "extractSingleton": {
          "Javadoc": "* Extract the lone element of the specified Collection.\n     *\n     * @param <E> collection type\n     * @param collection to read\n     * @return sole member of collection\n     * @throws NullPointerException if collection is null\n     * @throws IllegalArgumentException if collection is empty or contains more than one element\n     * @since 4.0"
        },
        "filter": {
          "Javadoc": "* Filter the collection by applying a Predicate to each element. If the\n     * predicate returns false, remove the element.\n     * <p>\n     * If the input collection or predicate is null, there is no change made.\n     * </p>\n     *\n     * @param <T>  the type of object the {@link Iterable} contains\n     * @param collection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use as a filter, may be null\n     * @return true if the collection is modified by this call, false otherwise."
        },
        "filterInverse": {
          "Javadoc": "* Filter the collection by applying a Predicate to each element. If the\n     * predicate returns true, remove the element.\n     * <p>\n     * This is equivalent to {@code filter(collection, PredicateUtils.notPredicate(predicate))}\n     * if predicate is != null.\n     * </p>\n     * <p>\n     * If the input collection or predicate is null, there is no change made.\n     * </p>\n     *\n     * @param <T>  the type of object the {@link Iterable} contains\n     * @param collection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use as a filter, may be null\n     * @return true if the collection is modified by this call, false otherwise."
        },
        "find": {
          "Javadoc": "* Finds the first element in the given collection which matches the given predicate.\n     * <p>\n     * If the input collection or predicate is null, or no element of the collection\n     * matches the predicate, null is returned.\n     * </p>\n     *\n     * @param <T>  the type of object the {@link Iterable} contains\n     * @param collection  the collection to search, may be null\n     * @param predicate  the predicate to use, may be null\n     * @return the first element of the collection which matches the predicate or null if none could be found\n     * @deprecated since 4.1, use {@link IterableUtils#find(Iterable, Predicate)} instead"
        },
        "forAllButLastDo": {
          "Javadoc": "* Executes the given closure on each but the last element in the collection.\n     * <p>\n     * If the input collection or closure is null, there is no change made.\n     * </p>\n     *\n     * @param <T>  the type of object the {@link Collection} contains\n     * @param <C>  the closure type\n     * @param iterator  the iterator to get the input from, may be null\n     * @param closure  the closure to perform, may be null\n     * @return the last element in the collection, or null if either iterator or closure is null\n     * @since 4.0\n     * @deprecated since 4.1, use {@link IteratorUtils#forEachButLast(Iterator, Closure)} instead"
        },
        "forAllDo": {
          "Javadoc": "* Executes the given closure on each element in the collection.\n     * <p>\n     * If the input collection or closure is null, there is no change made.\n     * </p>\n     *\n     * @param <T>  the type of object the {@link Iterator} contains\n     * @param <C>  the closure type\n     * @param iterator  the iterator to get the input from, may be null\n     * @param closure  the closure to perform, may be null\n     * @return closure\n     * @since 4.0\n     * @deprecated since 4.1, use {@link IteratorUtils#forEach(Iterator, Closure)} instead"
        },
        "get": {
          "Javadoc": "* Returns the {@code index}-th value in {@code object}, throwing\n     * {@code IndexOutOfBoundsException} if there is no such element or\n     * {@code IllegalArgumentException} if {@code object} is not an\n     * instance of one of the supported types.\n     * <p>\n     * The supported types, and associated semantics are:\n     * </p>\n     * <ul>\n     * <li> Map -- the value returned is the {@code Map.Entry} in position\n     *      {@code index} in the map's {@code entrySet} iterator,\n     *      if there is such an entry.</li>\n     * <li> List -- this method is equivalent to the list's get method.</li>\n     * <li> Array -- the {@code index}-th array entry is returned,\n     *      if there is such an entry; otherwise an {@code IndexOutOfBoundsException}\n     *      is thrown.</li>\n     * <li> Collection -- the value returned is the {@code index}-th object\n     *      returned by the collection's default iterator, if there is such an element.</li>\n     * <li> Iterator or Enumeration -- the value returned is the\n     *      {@code index}-th object in the Iterator/Enumeration, if there\n     *      is such an element.  The Iterator/Enumeration is advanced to\n     *      {@code index} (or to the end, if {@code index} exceeds the\n     *      number of entries) as a side effect of this method.</li>\n     * </ul>\n     *\n     * @param object  the object to get a value from\n     * @param index  the index to get\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @throws IllegalArgumentException if the object type is invalid"
        },
        "getCardinalityMap": {
          "Javadoc": "* Returns a {@link Map} mapping each unique element in the given\n     * {@link Collection} to an {@link Integer} representing the number\n     * of occurrences of that element in the {@link Collection}.\n     * <p>\n     * Only those elements present in the collection will appear as\n     * keys in the map.\n     * </p>\n     *\n     * @param <O>  the type of object in the returned {@link Map}. This is a super type of &lt;I&gt;.\n     * @param coll  the collection to get the cardinality map for, must not be null\n     * @return the populated cardinality map\n     * @throws NullPointerException if coll is null"
        },
        "hashCode": {
          "Javadoc": "* Returns the hash code of the input collection using the hash method of an equator.\n     *\n     * <p>\n     * Returns 0 if the input collection is {@code null}.\n     * </p>\n     *\n     * @param <E>  the element type\n     * @param collection  the input collection\n     * @param equator  the equator used for generate hashCode\n     * @return the hash code of the input collection using the hash method of an equator\n     * @throws NullPointerException if the equator is {@code null}\n     * @since 4.5"
        },
        "intersection": {
          "Javadoc": "* Returns a {@link Collection} containing the intersection of the given\n     * {@link Iterable}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection} will\n     * be equal to the minimum of the cardinality of that element in the two\n     * given {@link Iterable}s.\n     * </p>\n     *\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the intersection of the two collections\n     * @throws NullPointerException if either collection is null\n     * @see Collection#retainAll\n     * @see #containsAny"
        },
        "isEmpty": {
          "Javadoc": "* Null-safe check if the specified collection is empty.\n     * <p>\n     * Null returns true.\n     * </p>\n     *\n     * @param coll  the collection to check, may be null\n     * @return true if empty or null\n     * @since 3.2"
        },
        "isEqualCollection": {
          "Javadoc": "* Returns {@code true} iff the given {@link Collection}s contain\n     * exactly the same elements with exactly the same cardinalities.\n     * <p>\n     * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n     * equal to the cardinality of <i>e</i> in <i>b</i>,\n     * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n     * </p>\n     * <p>\n     * <b>Note:</b> from version 4.1 onwards this method requires the input\n     * collections and equator to be of compatible type (using bounded wildcards).\n     * Providing incompatible arguments (e.g. by casting to their rawtypes)\n     * will result in a {@code ClassCastException} thrown at runtime.\n     * </p>\n     *\n     * @param <E>  the element type\n     * @param a  the first collection, must not be null\n     * @param b  the second collection, must not be null\n     * @param equator  the Equator used for testing equality\n     * @return {@code true} iff the collections contain the same elements with the same cardinalities.\n     * @throws NullPointerException if either collection or equator is null\n     * @since 4.0"
        },
        "isFull": {
          "Javadoc": "* Returns true if no more elements can be added to the Collection.\n     * <p>\n     * This method uses the {@link BoundedCollection} interface to determine the\n     * full status. If the collection does not implement this interface then\n     * false is returned.\n     * </p>\n     * <p>\n     * The collection does not have to implement this interface directly.\n     * If the collection has been decorated using the decorators subpackage\n     * then these will be removed to access the BoundedCollection.\n     * </p>\n     *\n     * @param collection  the collection to check\n     * @return true if the BoundedCollection is full\n     * @throws NullPointerException if the collection is null"
        },
        "isNotEmpty": {
          "Javadoc": "* Null-safe check if the specified collection is not empty.\n     * <p>\n     * Null returns false.\n     * </p>\n     *\n     * @param coll  the collection to check, may be null\n     * @return true if non-null and non-empty\n     * @since 3.2"
        },
        "isProperSubCollection": {
          "Javadoc": "* Returns {@code true} iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>,\n     * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n     * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n     * for each element <i>e</i> in <i>a</i>, and there is at least one\n     * element <i>f</i> such that the cardinality of <i>f</i> in <i>b</i>\n     * is strictly greater than the cardinality of <i>f</i> in <i>a</i>.\n     * <p>\n     * The implementation assumes\n     * </p>\n     * <ul>\n     *    <li>{@code a.size()} and {@code b.size()} represent the\n     *    total cardinality of <i>a</i> and <i>b</i>, resp. </li>\n     *    <li>{@code a.size() &lt; Integer.MAXVALUE}</li>\n     * </ul>\n     *\n     * @param a  the first (sub?) collection, must not be null\n     * @param b  the second (super?) collection, must not be null\n     * @return {@code true} iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>\n     * @throws NullPointerException if either collection is null\n     * @see #isSubCollection\n     * @see Collection#containsAll"
        },
        "isSubCollection": {
          "Javadoc": "* Returns {@code true} iff <i>a</i> is a sub-collection of <i>b</i>,\n     * that is, iff the cardinality of <i>e</i> in <i>a</i> is less than or\n     * equal to the cardinality of <i>e</i> in <i>b</i>, for each element <i>e</i>\n     * in <i>a</i>.\n     *\n     * @param a the first (sub?) collection, must not be null\n     * @param b the second (super?) collection, must not be null\n     * @return {@code true} iff <i>a</i> is a sub-collection of <i>b</i>\n     * @throws NullPointerException if either collection is null\n     * @see #isProperSubCollection\n     * @see Collection#containsAll"
        },
        "matchesAll": {
          "Javadoc": "* Answers true if a predicate is true for every element of a\n     * collection.\n     *\n     * <p>\n     * A {@code null} predicate returns false.\n     * </p>\n     * <p>\n     * A {@code null} or empty collection returns true.\n     * </p>\n     *\n     * @param <C>  the type of object the {@link Iterable} contains\n     * @param input  the {@link Iterable} to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @return true if every element of the collection matches the predicate or if the\n     * collection is empty, false otherwise\n     * @since 4.0\n     * @deprecated since 4.1, use {@link IterableUtils#matchesAll(Iterable, Predicate)} instead"
        },
        "maxSize": {
          "Javadoc": "* Gets the maximum number of elements that the Collection can contain.\n     * <p>\n     * This method uses the {@link BoundedCollection} interface to determine the\n     * maximum size. If the collection does not implement this interface then\n     * -1 is returned.\n     * </p>\n     * <p>\n     * The collection does not have to implement this interface directly.\n     * If the collection has been decorated using the decorators subpackage\n     * then these will be removed to access the BoundedCollection.\n     * </p>\n     *\n     * @param collection  the collection to check\n     * @return the maximum size of the BoundedCollection, -1 if no maximum size\n     * @throws NullPointerException if the collection is null"
        },
        "permutations": {
          "Javadoc": "* Returns a {@link Collection} of all the permutations of the input collection.\n     * <p>\n     * NOTE: the number of permutations of a given collection is equal to n!, where\n     * n is the size of the collection. Thus, the resulting collection will become\n     * <b>very</b> large for collections &gt; 10 (e.g. 10! = 3628800, 15! = 1307674368000).\n     * </p>\n     * <p>\n     * For larger collections it is advised to use a {@link PermutationIterator} to\n     * iterate over all permutations.\n     * </p>\n     *\n     * @see PermutationIterator\n     *\n     * @param <E>  the element type\n     * @param collection  the collection to create permutations for, must not be null\n     * @return an unordered collection of all permutations of the input collection\n     * @throws NullPointerException if collection is null\n     * @since 4.0"
        },
        "predicatedCollection": {
          "Javadoc": "* Returns a predicated (validating) collection backed by the given collection.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to the collection.\n     * Trying to add an invalid object results in an IllegalArgumentException.\n     * It is important not to use the original collection after invoking this method,\n     * as it is a backdoor for adding invalid objects.\n     * </p>\n     *\n     * @param <C> the type of objects in the Collection.\n     * @param collection  the collection to predicate, must not be null\n     * @param predicate  the predicate for the collection, must not be null\n     * @return a predicated collection backed by the given collection\n     * @throws NullPointerException if the collection or predicate is null"
        },
        "removeAll": {
          "Javadoc": "* Removes all elements in {@code remove} from {@code collection}.\n     * That is, this method returns a collection containing all the elements in\n     * {@code collection} that are not in {@code remove}. The\n     * cardinality of an element {@code e} in the returned collection is\n     * the same as the cardinality of {@code e} in {@code collection}\n     * unless {@code remove} contains {@code e}, in which case the\n     * cardinality is zero. This method is useful if you do not wish to modify\n     * the collection {@code c} and thus cannot call\n     * {@code collection.removeAll(remove)}.\n     * <p>\n     * Moreover this method uses an {@link Equator} instead of\n     * {@link Object#equals(Object)} to determine the equality of the elements\n     * in {@code collection} and {@code remove}. Hence this method is\n     * useful in cases where the equals behavior of an object needs to be\n     * modified without changing the object itself.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Collection} contains\n     * @param collection the collection from which items are removed (in the returned collection)\n     * @param remove the items to be removed from the returned collection\n     * @param equator the Equator used for testing equality\n     * @return a {@code Collection} containing all the elements of {@code collection}\n     * except any element that if equal according to the {@code equator}\n     * @throws NullPointerException if any of the parameters is null\n     * @since 4.1"
        },
        "removeCount": {
          "Javadoc": "* Removes the specified number of elements from the start index in the collection and returns them.\n     * This method modifies the input collections.\n     *\n     * @param <E>  the type of object the {@link Collection} contains\n     * @param input  the collection will be operated, can't be null\n     * @param startIndex  the start index (inclusive) to remove element, can't be less than 0\n     * @param count  the specified number to remove, can't be less than 1\n     * @return collection of elements that removed from the input collection\n     * @throws NullPointerException if input is null\n     * @since 4.5"
        },
        "removeRange": {
          "Javadoc": "* Removes elements whose index are between startIndex, inclusive and endIndex,\n     * exclusive in the collection and returns them.\n     * This method modifies the input collections.\n     *\n     * @param <E>  the type of object the {@link Collection} contains\n     * @param input  the collection will be operated, must not be null\n     * @param startIndex  the start index (inclusive) to remove element, must not be less than 0\n     * @param endIndex  the end index (exclusive) to remove, must not be less than startIndex\n     * @return collection of elements that removed from the input collection\n     * @throws NullPointerException if input is null\n     * @since 4.5"
        },
        "retainAll": {
          "Javadoc": "* Returns a collection containing all the elements in\n     * {@code collection} that are also in {@code retain}. The\n     * cardinality of an element {@code e} in the returned collection is\n     * the same as the cardinality of {@code e} in {@code collection}\n     * unless {@code retain} does not contain {@code e}, in which case\n     * the cardinality is zero. This method is useful if you do not wish to\n     * modify the collection {@code c} and thus cannot call\n     * {@code c.retainAll(retain);}.\n     * <p>\n     * Moreover this method uses an {@link Equator} instead of\n     * {@link Object#equals(Object)} to determine the equality of the elements\n     * in {@code collection} and {@code retain}. Hence this method is\n     * useful in cases where the equals behavior of an object needs to be\n     * modified without changing the object itself.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Collection} contains\n     * @param collection the collection whose contents are the target of the {@code retainAll} operation\n     * @param retain the collection containing the elements to be retained in the returned collection\n     * @param equator the Equator used for testing equality\n     * @return a {@code Collection} containing all the elements of {@code collection}\n     * that occur at least once in {@code retain} according to the {@code equator}\n     * @throws NullPointerException if any of the parameters is null\n     * @since 4.1"
        },
        "reverseArray": {
          "Javadoc": "* Reverses the order of the given array.\n     *\n     * @param array  the array to reverse"
        },
        "select": {
          "Javadoc": "* Selects all elements from inputCollection into an output and rejected collection,\n     * based on the evaluation of the given predicate.\n     * <p>\n     * Elements matching the predicate are added to the {@code outputCollection},\n     * all other elements are added to the {@code rejectedCollection}.\n     * </p>\n     * <p>\n     * If the input predicate is {@code null}, no elements are added to\n     * {@code outputCollection} or {@code rejectedCollection}.\n     * </p>\n     * <p>\n     * Note: calling the method is equivalent to the following code snippet:\n     * </p>\n     * <pre>\n     *   select(inputCollection, predicate, outputCollection);\n     *   selectRejected(inputCollection, predicate, rejectedCollection);\n     * </pre>\n     *\n     * @param <O>  the type of object the {@link Iterable} contains\n     * @param <R>  the type of the output {@link Collection}\n     * @param inputCollection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @param outputCollection  the collection to output selected elements into, may not be null if the\n     *   inputCollection and predicate are not null\n     * @param rejectedCollection  the collection to output rejected elements into, may not be null if the\n     *   inputCollection or predicate are not null\n     * @return the outputCollection\n     * @since 4.1"
        },
        "selectRejected": {
          "Javadoc": "* Selects all elements from inputCollection which don't match the given\n     * predicate and adds them to outputCollection.\n     * <p>\n     * If the input predicate is {@code null}, no elements are added to\n     * {@code outputCollection}.\n     * </p>\n     *\n     * @param <O>  the type of object the {@link Iterable} contains\n     * @param <R>  the type of the output {@link Collection}\n     * @param inputCollection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @param outputCollection  the collection to output into, may not be null if the inputCollection\n     *   and predicate or not null\n     * @return outputCollection"
        },
        "size": {
          "Javadoc": "* Gets the size of the collection/iterator specified.\n     * <p>\n     * This method can handles objects as follows\n     * </p>\n     * <ul>\n     * <li>Collection - the collection size\n     * <li>Map - the map size\n     * <li>Array - the array size\n     * <li>Iterator - the number of elements remaining in the iterator\n     * <li>Enumeration - the number of elements remaining in the enumeration\n     * </ul>\n     *\n     * @param object  the object to get the size of, may be null\n     * @return the size of the specified collection or 0 if the object was null\n     * @throws IllegalArgumentException thrown if object is not recognized\n     * @since 3.1"
        },
        "sizeIsEmpty": {
          "Javadoc": "* Checks if the specified collection/array/iterator is empty.\n     * <p>\n     * This method can handles objects as follows\n     * </p>\n     * <ul>\n     * <li>Collection - via collection isEmpty\n     * <li>Map - via map isEmpty\n     * <li>Array - using array size\n     * <li>Iterator - via hasNext\n     * <li>Enumeration - via hasMoreElements\n     * </ul>\n     * <p>\n     * Note: This method is named to avoid clashing with\n     * {@link #isEmpty(Collection)}.\n     * </p>\n     *\n     * @param object  the object to get the size of, may be null\n     * @return true if empty or null\n     * @throws IllegalArgumentException thrown if object is not recognized\n     * @since 3.2"
        },
        "subtract": {
          "Javadoc": "* Returns a new {@link Collection} containing <i>a</i> minus a subset of\n     * <i>b</i>.  Only the elements of <i>b</i> that satisfy the predicate\n     * condition, <i>p</i> are subtracted from <i>a</i>.\n     *\n     * <p>\n     * The cardinality of each element <i>e</i> in the returned {@link Collection}\n     * that satisfies the predicate condition will be the cardinality of <i>e</i> in <i>a</i>\n     * minus the cardinality of <i>e</i> in <i>b</i>, or zero, whichever is greater.\n     * </p>\n     * <p>\n     * The cardinality of each element <i>e</i> in the returned {@link Collection} that does <b>not</b>\n     * satisfy the predicate condition will be equal to the cardinality of <i>e</i> in <i>a</i>.\n     * </p>\n     *\n     * @param a  the collection to subtract from, must not be null\n     * @param b  the collection to subtract, must not be null\n     * @param p  the condition used to determine which elements of <i>b</i> are\n     *        subtracted.\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return a new collection with the results\n     * @throws NullPointerException if either collection or p is null\n     * @since 4.0\n     * @see Collection#removeAll"
        },
        "synchronizedCollection": {
          "Javadoc": "* Returns a synchronized collection backed by the given collection.\n     * <p>\n     * You must manually synchronize on the returned buffer's iterator to\n     * avoid non-deterministic behavior:\n     * </p>\n     * <pre>\n     * Collection c = CollectionUtils.synchronizedCollection(myCollection);\n     * synchronized (c) {\n     *     Iterator i = c.iterator();\n     *     while (i.hasNext()) {\n     *         process (i.next());\n     *     }\n     * }\n     * </pre>\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     * </p>\n     *\n     * @param <C>  the type of object the {@link Collection} contains\n     * @param collection  the collection to synchronize, must not be null\n     * @return a synchronized collection backed by the given collection\n     * @throws NullPointerException if the collection is null\n     * @deprecated since 4.1, use {@link java.util.Collections#synchronizedCollection(Collection)} instead"
        },
        "transform": {
          "Javadoc": "* Transform the collection by applying a Transformer to each element.\n     * <p>\n     * If the input collection or transformer is null, there is no change made.\n     * </p>\n     * <p>\n     * This routine is best for Lists, for which set() is used to do the\n     * transformations \"in place.\" For other Collections, clear() and addAll()\n     * are used to replace elements.\n     * </p>\n     * <p>\n     * If the input collection controls its input, such as a Set, and the\n     * Transformer creates duplicates (or are otherwise invalid), the collection\n     * may reduce in size due to calling this method.\n     * </p>\n     *\n     * @param <C>  the type of object the {@link Collection} contains\n     * @param collection  the {@link Collection} to get the input from, may be null\n     * @param transformer  the transformer to perform, may be null"
        },
        "transformingCollection": {
          "Javadoc": "* Returns a transformed bag backed by the given collection.\n     * <p>\n     * Each object is passed through the transformer as it is added to the\n     * Collection. It is important not to use the original collection after invoking this\n     * method, as it is a backdoor for adding untransformed objects.\n     * </p>\n     * <p>\n     * Existing entries in the specified collection will not be transformed.\n     * If you want that behavior, see {@link TransformedCollection#transformedCollection}.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Collection} contains\n     * @param collection  the collection to predicate, must not be null\n     * @param transformer  the transformer for the collection, must not be null\n     * @return a transformed collection backed by the given collection\n     * @throws NullPointerException if the collection or transformer is null"
        },
        "union": {
          "Javadoc": "* Returns a {@link Collection} containing the union of the given\n     * {@link Iterable}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection} will\n     * be equal to the maximum of the cardinality of that element in the two\n     * given {@link Iterable}s.\n     * </p>\n     *\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the union of the two collections\n     * @throws NullPointerException if either collection is null\n     * @see Collection#addAll"
        },
        "unmodifiableCollection": {
          "Javadoc": "* Returns an unmodifiable collection backed by the given collection.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     * </p>\n     *\n     * @param <C>  the type of object the {@link Collection} contains\n     * @param collection  the collection to make unmodifiable, must not be null\n     * @return an unmodifiable collection backed by the given collection\n     * @throws NullPointerException if the collection is null\n     * @deprecated since 4.1, use {@link java.util.Collections#unmodifiableCollection(Collection)} instead"
        }
      }
    },
    "org.apache.commons.collections4.CardinalityHelper": {
      "Javadoc": "\n     * Helper class to easily access cardinality properties of two collections.\n     * @param <O>  the element type\n     ",
      "methods": {
        "freqA": {
          "Javadoc": "* Returns the frequency of this object in collection A.\n         * @param obj  the object\n         * @return the frequency of the object in collection A"
        },
        "freqB": {
          "Javadoc": "* Returns the frequency of this object in collection B.\n         * @param obj  the object\n         * @return the frequency of the object in collection B"
        },
        "max": {
          "Javadoc": "* Returns the maximum frequency of an object.\n         * @param obj  the object\n         * @return the maximum frequency of the object"
        },
        "min": {
          "Javadoc": "* Returns the minimum frequency of an object.\n         * @param obj  the object\n         * @return the minimum frequency of the object"
        }
      }
    },
    "org.apache.commons.collections4.EquatorWrapper": {
      "Javadoc": "\n     * Wraps another object and uses the provided Equator to implement\n     * {@link #equals(Object)} and {@link #hashCode()}.\n     * <p>\n     * This class can be used to store objects into a Map.\n     * </p>\n     *\n     * @param <O>  the element type\n     * @since 4.0\n     "
    },
    "org.apache.commons.collections4.SetOperationCardinalityHelper": {
      "Javadoc": "\n     * Helper class for set-related operations, e.g. union, subtract, intersection.\n     * @param <O>  the element type\n     ",
      "methods": {
        "list": {
          "Javadoc": "* Returns the resulting collection.\n         * @return the result"
        },
        "setCardinality": {
          "Javadoc": "* Add the object {@code count} times to the result collection.\n         * @param obj  the object to add\n         * @param count  the count"
        }
      }
    },
    "org.apache.commons.collections4.comparators.BooleanComparator": {
      "Javadoc": "\n * A {@link Comparator} for {@link Boolean} objects that can sort either\n * true or false first.\n *\n * @see #getTrueFirstComparator()\n * @see #getFalseFirstComparator()\n * @see #booleanComparator(boolean)\n *\n * @since 3.0\n ",
      "methods": {
        "booleanComparator": {
          "Javadoc": "* Returns a BooleanComparator instance that sorts\n     * {@code <i>trueFirst</i>} values before\n     * {@code &#x21;<i>trueFirst</i>} values.\n     * <p>\n     * Clients are encouraged to use the value returned from\n     * this method instead of constructing a new instance\n     * to reduce allocation and garbage collection overhead when\n     * multiple BooleanComparators may be used in the same\n     * virtual machine.\n     * </p>\n     *\n     * @param trueFirst when {@code true}, sort\n     * {@code true} {@code Boolean}s before {@code false}\n     * @return a singleton BooleanComparator instance\n     * @since 4.0"
        },
        "getFalseFirstComparator": {
          "Javadoc": "* Returns a BooleanComparator instance that sorts\n     * {@code false} values before {@code true} values.\n     * <p>\n     * Clients are encouraged to use the value returned from\n     * this method instead of constructing a new instance\n     * to reduce allocation and garbage collection overhead when\n     * multiple BooleanComparators may be used in the same\n     * virtual machine.\n     * </p>\n     *\n     * @return the false first singleton BooleanComparator"
        },
        "getTrueFirstComparator": {
          "Javadoc": "* Returns a BooleanComparator instance that sorts\n     * {@code true} values before {@code false} values.\n     * <p>\n     * Clients are encouraged to use the value returned from\n     * this method instead of constructing a new instance\n     * to reduce allocation and garbage collection overhead when\n     * multiple BooleanComparators may be used in the same\n     * virtual machine.\n     * </p>\n     *\n     * @return the true first singleton BooleanComparator"
        },
        "compare": {
          "Javadoc": "* Compares two non-{@code null} {@code Boolean} objects\n     * according to the value of {@link #sortsTrueFirst()}.\n     *\n     * @param b1  the first boolean to compare\n     * @param b2  the second boolean to compare\n     * @return negative if obj1 is less, positive if greater, zero if equal\n     * @throws NullPointerException when either argument {@code null}"
        },
        "equals": {
          "Javadoc": "* Returns {@code true} iff <i>that</i> Object is\n     * a {@link Comparator} whose ordering is known to be\n     * equivalent to mine.\n     * <p>\n     * This implementation returns {@code true}\n     * iff {@code <i>that</i>} is a {@link BooleanComparator}\n     * whose value of {@link #sortsTrueFirst()} is equal to mine.\n     *\n     * @param object  the object to compare to\n     * @return true if equal"
        },
        "hashCode": {
          "Javadoc": "* Implement a hash code for this comparator that is consistent with\n     * {@link #equals(Object) equals}.\n     *\n     * @return a hash code for this comparator."
        },
        "sortsTrueFirst": {
          "Javadoc": "* Returns {@code true} iff\n     * I sort {@code true} values before\n     * {@code false} values.  In other words,\n     * returns {@code true} iff\n     * {@link #compare(Boolean,Boolean) compare(Boolean.FALSE,Boolean.TRUE)}\n     * returns a positive value.\n     *\n     * @return the trueFirst flag"
        }
      }
    },
    "org.apache.commons.collections4.comparators.ComparableComparator": {
      "Javadoc": "\n * A {@link Comparator Comparator} that compares {@link Comparable Comparable}\n * objects.\n * <p>\n * This Comparator is useful, for example, for enforcing the natural order in\n * custom implementations of {@link java.util.SortedSet SortedSet} and\n * {@link java.util.SortedMap SortedMap}.\n * </p>\n * <p>\n * Note: In the 2.0 and 2.1 releases of Commons Collections, this class would\n * throw a {@link ClassCastException} if either of the arguments to\n * {@link #compare(Comparable, Comparable)} compare} were {@code null}, not\n * {@link Comparable Comparable}, or for which\n * {@link Comparable#compareTo(Object) compareTo} gave inconsistent results.\n * This is no longer the case. See {@link #compare(Comparable, Comparable)} compare} for\n * details.\n * </p>\n *\n * @param <E> the type of objects compared by this comparator\n *\n * @since 2.0\n * @see java.util.Collections#reverseOrder()\n ",
      "methods": {
        "comparableComparator": {
          "Javadoc": "* Gets the singleton instance of a ComparableComparator.\n     * <p>\n     * Developers are encouraged to use the comparator returned from this method\n     * instead of constructing a new instance to reduce allocation and GC overhead\n     * when multiple comparable comparators may be used in the same VM.\n     *\n     * @param <E>  the element type\n     * @return the singleton ComparableComparator\n     * @since 4.0"
        },
        "compare": {
          "Javadoc": "* Compare the two {@link Comparable Comparable} arguments.\n     * This method is equivalent to:\n     * <pre>((Comparable)obj1).compareTo(obj2)</pre>\n     *\n     * @param obj1  the first object to compare\n     * @param obj2  the second object to compare\n     * @return negative if obj1 is less, positive if greater, zero if equal\n     * @throws NullPointerException if <i>obj1</i> is {@code null},\n     *         or when {@code ((Comparable)obj1).compareTo(obj2)} does\n     * @throws ClassCastException if <i>obj1</i> is not a {@code Comparable},\n     *         or when {@code ((Comparable)obj1).compareTo(obj2)} does"
        },
        "equals": {
          "Javadoc": "* Returns {@code true} iff <i>that</i> Object is a {@link Comparator Comparator}\n     * whose ordering is known to be equivalent to mine.\n     * <p>\n     * This implementation returns {@code true} iff\n     * {@code <i>object</i>.{@link Object#getClass() getClass()}} equals\n     * {@code this.getClass()}. Subclasses may want to override this behavior to remain\n     * consistent with the {@link Comparator#equals(Object)} contract.\n     *\n     * @param object  the object to compare with\n     * @return {@code true} if equal\n     * @since 3.0"
        },
        "hashCode": {
          "Javadoc": "* Implement a hash code for this comparator that is consistent with\n     * {@link #equals(Object) equals}.\n     *\n     * @return a hash code for this comparator.\n     * @since 3.0"
        }
      }
    },
    "org.apache.commons.collections4.comparators.ComparatorChain": {
      "Javadoc": "\n * A ComparatorChain is a Comparator that wraps one or more Comparators in\n * sequence. The ComparatorChain calls each Comparator in sequence until either\n * 1) any single Comparator returns a non-zero result (and that result is then\n * returned), or 2) the ComparatorChain is exhausted (and zero is returned).\n * This type of sorting is very similar to multi-column sorting in SQL, and this\n * class allows Java classes to emulate that kind of behavior when sorting a\n * List.\n * <p>\n * To further facilitate SQL-like sorting, the order of any single Comparator in\n * the list can be reversed.\n * </p>\n * <p>\n * Calling a method that adds new Comparators or changes the ascend/descend sort\n * <i>after compare(Object, Object) has been called</i> will result in an\n * UnsupportedOperationException. However, <i>take care</i> to not alter the\n * underlying List of Comparators or the BitSet that defines the sort order.\n * </p>\n * <p>\n * Instances of ComparatorChain are not synchronized. The class is not\n * thread-safe at construction time, but it <i>is</i> thread-safe to perform\n * multiple comparisons after all the setup operations are complete.\n * </p>\n *\n * @param <E> the type of objects compared by this comparator\n * @since 2.0\n ",
      "methods": {
        "addComparator": {
          "Javadoc": "* Add a Comparator to the end of the chain using the\n     * given sort order\n     *\n     * @param comparator Comparator to add to the end of the chain\n     * @param reverse    false = forward sort order; true = reverse sort order"
        },
        "checkChainIntegrity": {
          "Javadoc": "* Throws an exception if the {@link ComparatorChain} is empty.\n     *\n     * @throws UnsupportedOperationException if the {@link ComparatorChain} is empty"
        },
        "checkLocked": {
          "Javadoc": "* Throws an exception if the {@link ComparatorChain} is locked.\n     *\n     * @throws UnsupportedOperationException if the {@link ComparatorChain} is locked"
        },
        "compare": {
          "Javadoc": "* Perform comparisons on the Objects as per\n     * Comparator.compare(o1,o2).\n     *\n     * @param o1  the first object to compare\n     * @param o2  the second object to compare\n     * @return -1, 0, or 1\n     * @throws UnsupportedOperationException if the ComparatorChain does not contain at least one Comparator"
        },
        "equals": {
          "Javadoc": "* Returns {@code true} iff <i>that</i> Object is\n     * a {@link Comparator} whose ordering is known to be\n     * equivalent to mine.\n     * <p>\n     * This implementation returns {@code true}\n     * iff {@code <i>object</i>.{@link Object#getClass() getClass()}}\n     * equals {@code this.getClass()}, and the underlying\n     * comparators and order bits are equal.\n     * Subclasses may want to override this behavior to remain consistent\n     * with the {@link Comparator#equals(Object)} contract.\n     *\n     * @param object  the object to compare with\n     * @return true if equal\n     * @since 3.0"
        },
        "hashCode": {
          "Javadoc": "* Implement a hash code for this comparator that is consistent with\n     * {@link #equals(Object) equals}.\n     *\n     * @return a suitable hash code\n     * @since 3.0"
        },
        "isLocked": {
          "Javadoc": "* Determine if modifications can still be made to the\n     * ComparatorChain.  ComparatorChains cannot be modified\n     * once they have performed a comparison.\n     *\n     * @return true = ComparatorChain cannot be modified; false =\n     *         ComparatorChain can still be modified."
        },
        "setComparator": {
          "Javadoc": "* Replace the Comparator at the given index in the\n     * ComparatorChain, using the given sort order\n     *\n     * @param index      index of the Comparator to replace\n     * @param comparator Comparator to set\n     * @param reverse    false = forward sort order; true = reverse sort order"
        },
        "setForwardSort": {
          "Javadoc": "* Change the sort order at the given index in the\n     * ComparatorChain to a forward sort.\n     *\n     * @param index  Index of the ComparatorChain"
        },
        "setReverseSort": {
          "Javadoc": "* Change the sort order at the given index in the\n     * ComparatorChain to a reverse sort.\n     *\n     * @param index  Index of the ComparatorChain"
        },
        "size": {
          "Javadoc": "* Number of Comparators in the current ComparatorChain.\n     *\n     * @return Comparator count"
        }
      }
    },
    "org.apache.commons.collections4.comparators.FixedOrderComparator": {
      "Javadoc": "\n * A Comparator which imposes a specific order on a specific set of Objects.\n * Objects are presented to the FixedOrderComparator in a specified order and\n * subsequent calls to {@link #compare(Object, Object) compare} yield that order.\n * For example:\n * <pre>\n * String[] planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"};\n * FixedOrderComparator distanceFromSun = new FixedOrderComparator(planets);\n * Arrays.sort(planets);                     // Sort to alphabetical order\n * Arrays.sort(planets, distanceFromSun);    // Back to original order\n * </pre>\n * <p>\n * Once {@code compare} has been called, the FixedOrderComparator is locked\n * and attempts to modify it yield an UnsupportedOperationException.\n * </p>\n * <p>\n * Instances of FixedOrderComparator are not synchronized.  The class is not\n * thread-safe at construction time, but it is thread-safe to perform\n * multiple comparisons  after all the setup operations are complete.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 4.0.\n * </p>\n *\n * @param <T> the type of objects compared by this comparator\n * @since 3.0\n ",
      "methods": {
        "add": {
          "Javadoc": "* Adds an item, which compares as after all items known to the Comparator.\n     * If the item is already known to the Comparator, its old position is\n     * replaced with the new position.\n     *\n     * @param obj  the item to be added to the Comparator.\n     * @return true if obj has been added for the first time, false if\n     *  it was already known to the Comparator.\n     * @throws UnsupportedOperationException if a comparison has already been made"
        },
        "addAsEqual": {
          "Javadoc": "* Adds a new item, which compares as equal to the given existing item.\n     *\n     * @param existingObj  an item already in the Comparator's set of\n     *  known objects\n     * @param newObj  an item to be added to the Comparator's set of\n     *  known objects\n     * @return true if newObj has been added for the first time, false if\n     *  it was already known to the Comparator.\n     * @throws IllegalArgumentException if existingObject is not in the\n     *  Comparator's set of known objects.\n     * @throws UnsupportedOperationException if a comparison has already been made"
        },
        "checkLocked": {
          "Javadoc": "* Checks to see whether the comparator is now locked against further changes.\n     *\n     * @throws UnsupportedOperationException if the comparator is locked"
        },
        "compare": {
          "Javadoc": "* Compares two objects according to the order of this Comparator.\n     * <p>\n     * It is important to note that this class will throw an IllegalArgumentException\n     * in the case of an unrecognized object. This is not specified in the\n     * Comparator interface, but is the most appropriate exception.\n     *\n     * @param obj1  the first object to compare\n     * @param obj2  the second object to compare\n     * @return negative if obj1 is less, positive if greater, zero if equal\n     * @throws IllegalArgumentException if obj1 or obj2 are not known\n     *  to this Comparator and an alternative behavior has not been set\n     *  via {@link #setUnknownObjectBehavior(UnknownObjectBehavior)}."
        },
        "getUnknownObjectBehavior": {
          "Javadoc": "* Gets the behavior for comparing unknown objects.\n     *\n     * @return {@link UnknownObjectBehavior}"
        },
        "isLocked": {
          "Javadoc": "* Returns true if modifications cannot be made to the FixedOrderComparator.\n     * FixedOrderComparators cannot be modified once they have performed a comparison.\n     *\n     * @return true if attempts to change the FixedOrderComparator yield an\n     *  UnsupportedOperationException, false if it can be changed."
        },
        "setUnknownObjectBehavior": {
          "Javadoc": "* Sets the behavior for comparing unknown objects.\n     *\n     * @param unknownObjectBehavior  the flag for unknown behavior -\n     * UNKNOWN_AFTER, UNKNOWN_BEFORE or UNKNOWN_THROW_EXCEPTION\n     * @throws UnsupportedOperationException if a comparison has been performed\n     * @throws NullPointerException if unknownObjectBehavior is null"
        }
      }
    },
    "org.apache.commons.collections4.comparators.NullComparator": {
      "Javadoc": "\n * A Comparator that will compare nulls to be either lower or higher than\n * other objects.\n *\n * @param <E> the type of objects compared by this comparator\n * @since 2.0\n ",
      "methods": {
        "compare": {
          "Javadoc": "*  Perform a comparison between two objects.  If both objects are\n     *  {@code null}, a {@code 0} value is returned.  If one object\n     *  is {@code null} and the other is not, the result is determined on\n     *  whether the Comparator was constructed to have nulls as higher or lower\n     *  than other objects.  If neither object is {@code null}, an\n     *  underlying comparator specified in the constructor (or the default) is\n     *  used to compare the non-{@code null} objects.\n     *\n     *  @param o1  the first object to compare\n     *  @param o2  the object to compare it to.\n     *  @return {@code -1} if {@code o1} is \"lower\" than (less than,\n     *  before, etc.) {@code o2}; {@code 1} if {@code o1} is\n     *  \"higher\" than (greater than, after, etc.) {@code o2}; or\n     *  {@code 0} if {@code o1} and {@code o2} are equal.\n     *"
        },
        "equals": {
          "Javadoc": "*  Determines whether the specified object represents a comparator that is\n     *  equal to this comparator.\n     *\n     *  @param obj  the object to compare this comparator with.\n     *\n     *  @return {@code true} if the specified object is a NullComparator\n     *  with equivalent {@code null} comparison behavior\n     *  (i.e. {@code null} high or low) and with equivalent underlying\n     *  non-{@code null} object comparators.\n     *"
        },
        "hashCode": {
          "Javadoc": "*  Implement a hash code for this comparator that is consistent with\n     *  {@link #equals(Object)}.\n     *\n     *  @return a hash code for this comparator.\n     *"
        }
      }
    },
    "org.apache.commons.collections4.comparators.ReverseComparator": {
      "Javadoc": "\n * Reverses the order of another comparator by reversing the arguments\n * to its {@link #compare(Object, Object) compare} method.\n *\n * @param <E> the type of objects compared by this comparator\n *\n * @since 2.0\n * @see java.util.Collections#reverseOrder()\n ",
      "methods": {
        "compare": {
          "Javadoc": "* Compares two objects in reverse order.\n     *\n     * @param obj1  the first object to compare\n     * @param obj2  the second object to compare\n     * @return negative if obj1 is less, positive if greater, zero if equal"
        },
        "equals": {
          "Javadoc": "* Returns {@code true} iff <i>that</i> Object is\n     * a {@link Comparator} whose ordering is known to be\n     * equivalent to mine.\n     * <p>\n     * This implementation returns {@code true}\n     * iff {@code <i>object</i>.{@link Object#getClass() getClass()}}\n     * equals {@code this.getClass()}, and the underlying\n     * comparators are equal.\n     * Subclasses may want to override this behavior to remain consistent\n     * with the {@link Comparator#equals(Object) equals} contract.\n     *\n     * @param object  the object to compare to\n     * @return true if equal\n     * @since 3.0"
        },
        "hashCode": {
          "Javadoc": "* Implement a hash code for this comparator that is consistent with\n     * {@link #equals(Object) equals}.\n     *\n     * @return a suitable hash code\n     * @since 3.0"
        }
      }
    },
    "org.apache.commons.collections4.comparators.TransformingComparator": {
      "Javadoc": "\n * Decorates another Comparator with transformation behavior. That is, the\n * return value from the transform operation will be passed to the decorated\n * {@link Comparator#compare(Object,Object) compare} method.\n * <p>\n * This class is Serializable from Commons Collections 4.0.\n * </p>\n *\n * @param <I> the input type to the transformer\n * @param <O> the output type from the transformer\n *\n * @since 2.1\n *\n * @see org.apache.commons.collections4.Transformer\n * @see org.apache.commons.collections4.comparators.ComparableComparator\n ",
      "methods": {
        "compare": {
          "Javadoc": "* Returns the result of comparing the values from the transform operation.\n     *\n     * @param obj1  the first object to transform then compare\n     * @param obj2  the second object to transform then compare\n     * @return negative if obj1 is less, positive if greater, zero if equal"
        },
        "equals": {
          "Javadoc": "* Returns {@code true} iff <i>that</i> Object is\n     * a {@link Comparator} whose ordering is known to be\n     * equivalent to mine.\n     * <p>\n     * This implementation returns {@code true}\n     * iff {@code <i>that</i>} is a {@link TransformingComparator}\n     * whose attributes are equal to mine.\n     *\n     * @param object  the object to compare to\n     * @return true if equal"
        },
        "hashCode": {
          "Javadoc": "* Implement a hash code for this comparator that is consistent with\n     * {@link #equals(Object) equals}.\n     *\n     * @return a hash code for this comparator."
        }
      }
    },
    "org.apache.commons.collections4.ComparatorUtils": {
      "Javadoc": "\n * Provides convenient static utility methods for <Code>Comparator</Code>\n * objects.\n * <p>\n * Most of the functionality in this class can also be found in the\n * {@code comparators} package. This class merely provides a\n * convenient central place if you have use for more than one class\n * in the {@code comparators} subpackage.\n * </p>\n *\n * @since 2.1\n ",
      "methods": {
        "booleanComparator": {
          "Javadoc": "* Gets a Comparator that can sort Boolean objects.\n     * <p>\n     * The parameter specifies whether true or false is sorted first.\n     * </p>\n     * <p>\n     * The comparator throws NullPointerException if a null value is compared.\n     * </p>\n     *\n     * @param trueFirst  when {@code true}, sort\n     *        {@code true} {@link Boolean}s before\n     *        {@code false} {@link Boolean}s.\n     * @return  a comparator that sorts booleans"
        },
        "chainedComparator": {
          "Javadoc": "* Gets a comparator that compares using an array of {@link Comparator}s, applied\n     * in sequence until one returns not equal or the array is exhausted.\n     *\n     * @param <E>  the object type to compare\n     * @param comparators  the comparators to use, not null or empty or containing nulls\n     * @return a {@link ComparatorChain} formed from the input comparators\n     * @throws NullPointerException if comparators array is null or contains a null\n     * @see ComparatorChain"
        },
        "max": {
          "Javadoc": "* Returns the largest of the given objects according to the given\n     * comparator, returning the second object if the comparator\n     * returns equal.\n     *\n     * @param <E>  the object type to compare\n     * @param o1  the first object to compare\n     * @param o2  the second object to compare\n     * @param comparator  the sort order to use\n     * @return  the larger of the two objects"
        },
        "min": {
          "Javadoc": "* Returns the smallest of the given objects according to the given\n     * comparator, returning the second object if the comparator\n     * returns equal.\n     *\n     * @param <E>  the object type to compare\n     * @param o1  the first object to compare\n     * @param o2  the second object to compare\n     * @param comparator  the sort order to use\n     * @return  the smaller of the two objects"
        },
        "naturalComparator": {
          "Javadoc": "* Gets a comparator that uses the natural order of the objects.\n     *\n     * @param <E>  the object type to compare\n     * @return  a comparator which uses natural order"
        },
        "nullHighComparator": {
          "Javadoc": "* Gets a Comparator that controls the comparison of {@code null} values.\n     * <p>\n     * The returned comparator will consider a null value to be greater than\n     * any nonnull value, and equal to any other null value.  Two nonnull\n     * values will be evaluated with the given comparator.\n     * </p>\n     *\n     * @param <E>  the object type to compare\n     * @param comparator the comparator that wants to allow nulls\n     * @return  a version of that comparator that allows nulls\n     * @see NullComparator"
        },
        "nullLowComparator": {
          "Javadoc": "* Gets a Comparator that controls the comparison of {@code null} values.\n     * <p>\n     * The returned comparator will consider a null value to be less than\n     * any nonnull value, and equal to any other null value.  Two nonnull\n     * values will be evaluated with the given comparator.\n     * </p>\n     *\n     * @param <E>  the object type to compare\n     * @param comparator the comparator that wants to allow nulls\n     * @return  a version of that comparator that allows nulls\n     * @see NullComparator"
        },
        "reversedComparator": {
          "Javadoc": "* Gets a comparator that reverses the order of the given comparator.\n     *\n     * @param <E>  the object type to compare\n     * @param comparator  the comparator to reverse\n     * @return  a comparator that reverses the order of the input comparator\n     * @see ReverseComparator"
        },
        "transformedComparator": {
          "Javadoc": "* Gets a Comparator that passes transformed objects to the given comparator.\n     * <p>\n     * Objects passed to the returned comparator will first be transformed\n     * by the given transformer before they are compared by the given\n     * comparator.\n     * </p>\n     *\n     * @param <I>  the input object type of the transformed comparator\n     * @param <O>  the object type of the decorated comparator\n     * @param comparator  the sort order to use\n     * @param transformer  the transformer to use\n     * @return  a comparator that transforms its input objects before comparing them\n     * @see  TransformingComparator"
        }
      }
    },
    "org.apache.commons.collections4.EnumerationUtils": {
      "Javadoc": "\n * Provides utility methods for {@link Enumeration} instances.\n *\n * @since 3.0\n ",
      "methods": {
        "asIterable": {
          "Javadoc": "* Creates an {@link Iterable} that wraps an {@link Enumeration}. The returned {@link Iterable} can be used for a\n     * single iteration.\n     *\n     * @param <T> the element type\n     * @param enumeration the enumeration to use, may not be null\n     * @return a new, single use {@link Iterable}\n     * @since 4.5"
        },
        "get": {
          "Javadoc": "* Returns the {@code index}-th value in the {@link Enumeration}, throwing\n     * {@code IndexOutOfBoundsException} if there is no such element.\n     * <p>\n     * The Enumeration is advanced to {@code index} (or to the end, if\n     * {@code index} exceeds the number of entries) as a side effect of this method.\n     *\n     * @param e  the enumeration to get a value from\n     * @param index  the index to get\n     * @param <T> the type of object in the {@link Enumeration}\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @throws IllegalArgumentException if the object type is invalid\n     * @since 4.1"
        },
        "toList": {
          "Javadoc": "* Override toList(Enumeration) for StringTokenizer as it implements Enumeration&lt;Object&gt;\n     * for the sake of backward compatibility.\n     *\n     * @param stringTokenizer  the tokenizer to convert to a {@link List}&lt;{@link String}&gt;\n     * @return a list containing all tokens of the given StringTokenizer"
        }
      }
    },
    "org.apache.commons.collections4.Equator": {
      "Javadoc": "\n * An equation function, which determines equality between objects of type T.\n * <p>\n * It is the functional sibling of {@link java.util.Comparator}; {@link Equator} is to\n * {@link Object} as {@link java.util.Comparator} is to {@link Comparable}.\n * </p>\n *\n * @param <T> the types of object this {@link Equator} can evaluate.\n * @since 4.0\n ",
      "methods": {
        "equate": {
          "Javadoc": "* Evaluates the two arguments for their equality.\n     *\n     * @param o1 the first object to be equated.\n     * @param o2 the second object to be equated.\n     * @return whether the two objects are equal."
        },
        "hash": {
          "Javadoc": "* Calculates the hash for the object, based on the method of equality used in the equate\n     * method. This is used for classes that delegate their {@link Object#equals(Object) equals(Object)} method to an\n     * Equator (and so must also delegate their {@link Object#hashCode() hashCode()} method), or for implementations\n     * of {@link org.apache.commons.collections4.map.HashedMap} that use an Equator for the key objects.\n     *\n     * @param o the object to calculate the hash for.\n     * @return the hash of the object."
        }
      }
    },
    "org.apache.commons.collections4.Factory": {
      "Javadoc": "\n * Defines a functor interface implemented by classes that create objects.\n * <p>\n * A {@code Factory} creates an object without using an input parameter.\n * If an input parameter is required, then {@link Transformer} is more appropriate.\n * </p>\n * <p>\n * Standard implementations of common factories are provided by\n * {@link FactoryUtils}. These include factories that return a constant,\n * a copy of a prototype or a new instance.\n * </p>\n *\n * @param <T> the type that the factory creates\n *\n * @since 2.1\n ",
      "methods": {
        "create": {
          "Javadoc": "* Create a new object.\n     *\n     * @return a new object\n     * @throws FunctorException (runtime) if the factory cannot create an object"
        }
      }
    },
    "org.apache.commons.collections4.FactoryUtils": {
      "Javadoc": "\n * {@code FactoryUtils} provides reference implementations and utilities\n * for the Factory functor interface. The supplied factories are:\n * <ul>\n * <li>Prototype - clones a specified object\n * <li>Instantiate - creates objects using reflection\n * <li>Constant - always returns the same object\n * <li>Null - always returns null\n * <li>Exception - always throws an exception\n * </ul>\n * <p>\n * Since v4.1 only factories which are considered to be safe are\n * Serializable. Factories considered to be unsafe for serialization are:\n * <ul>\n * <li>Prototype\n * <li>Instantiate\n * </ul>\n *\n * @since 3.0\n ",
      "methods": {
        "constantFactory": {
          "Javadoc": "* Creates a Factory that will return the same object each time the factory\n     * is used. No check is made that the object is immutable. In general, only\n     * immutable objects should use the constant factory. Mutable objects should\n     * use the prototype factory.\n     *\n     * @see org.apache.commons.collections4.functors.ConstantFactory\n     *\n     * @param <T> the type that the factory creates\n     * @param constantToReturn  the constant object to return each time in the factory\n     * @return the {@code constant} factory."
        },
        "exceptionFactory": {
          "Javadoc": "* Gets a Factory that always throws an exception.\n     * This could be useful during testing as a placeholder.\n     *\n     * @see org.apache.commons.collections4.functors.ExceptionFactory\n     *\n     * @param <T> the type that the factory creates\n     * @return the factory"
        },
        "instantiateFactory": {
          "Javadoc": "* Creates a Factory that can create objects of a specific type using\n     * the arguments specified to this method.\n     *\n     * @see org.apache.commons.collections4.functors.InstantiateFactory\n     *\n     * @param <T> the type that the factory creates\n     * @param classToInstantiate  the Class to instantiate each time in the factory\n     * @param paramTypes  parameter types for the constructor, can be null\n     * @param args  the arguments to pass to the constructor, can be null\n     * @return the {@code reflection} factory\n     * @throws NullPointerException if the classToInstantiate is null\n     * @throws IllegalArgumentException if the paramTypes and args don't match\n     * @throws IllegalArgumentException if the constructor doesn't exist"
        },
        "nullFactory": {
          "Javadoc": "* Gets a Factory that will return null each time the factory is used.\n     * This could be useful during testing as a placeholder.\n     *\n     * @see org.apache.commons.collections4.functors.ConstantFactory\n     * @param <T> the \"type\" of null object the factory should return.\n     * @return the factory"
        },
        "prototypeFactory": {
          "Javadoc": "* Creates a Factory that will return a clone of the same prototype object\n     * each time the factory is used. The prototype will be cloned using one of these\n     * techniques (in order):\n     *\n     * <ul>\n     * <li>public clone method</li>\n     * <li>public copy constructor</li>\n     * <li>serialization clone</li>\n     * </ul>\n     *\n     * @see org.apache.commons.collections4.functors.PrototypeFactory\n     *\n     * @param <T> the type that the factory creates\n     * @param prototype  the object to clone each time in the factory\n     * @return the {@code prototype} factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n     * the {@code prototype} is {@code null}\n     * @throws IllegalArgumentException if the prototype cannot be cloned"
        }
      }
    },
    "org.apache.commons.collections4.FluentIterable": {
      "Javadoc": "\n * A FluentIterable provides a powerful yet simple API for manipulating\n * Iterable instances in a fluent manner.\n * <p>\n * A FluentIterable can be created either from an Iterable or from a set\n * of elements. The following types of methods are provided:\n * </p>\n * <ul>\n *   <li>fluent methods which return a new {@code FluentIterable} instance,\n *       providing a view of the original iterable (e.g. filter(Predicate));\n *   <li>conversion methods which copy the FluentIterable's contents into a\n *       new collection or array (e.g. toList());\n *   <li>utility methods which answer questions about the FluentIterable's\n *       contents (e.g. size(), anyMatch(Predicate)).\n *   <li>\n * </ul>\n * <p>\n * The following example outputs the first 3 even numbers in the range [1, 10]\n * into a list:\n * </p>\n * <pre>\n * List&lt;String&gt; result =\n *   FluentIterable\n *       .of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n *       .filter(new Predicate&lt;Integer&gt;() {\n *                   public boolean evaluate(Integer number) {\n *                        return number % 2 == 0;\n *                   }\n *              )\n *       .transform(TransformerUtils.stringValueTransformer())\n *       .limit(3)\n *       .toList();\n * </pre>\n * The resulting list will contain the following elements:\n * <pre>[2, 4, 6]</pre>\n *\n * @param <E>  the element type\n * @since 4.1\n ",
      "methods": {
        "empty": {
          "Javadoc": "* Creates a new empty FluentIterable.\n     *\n     * @param <T>  the element type\n     * @return a new empty FluentIterable"
        },
        "of": {
          "Javadoc": "* Creates a new FluentIterable from the provided elements.\n     * <p>\n     * The returned iterable's iterator does not support {@code remove()}.\n     *\n     * @param <T>  the element type\n     * @param elements  the elements to be contained in the FluentIterable\n     * @return a new FluentIterable containing the provided elements"
        },
        "allMatch": {
          "Javadoc": "* Checks if all elements contained in this iterable are matching the\n     * provided predicate.\n     * <p>\n     * A {@code null} or empty iterable returns true.\n     *\n     * @param predicate  the predicate to use, may not be null\n     * @return true if all elements contained in this iterable match the predicate,\n     *   false otherwise\n     * @throws NullPointerException if predicate is null"
        },
        "anyMatch": {
          "Javadoc": "* Checks if this iterable contains any element matching the provided predicate.\n     * <p>\n     * A {@code null} or empty iterable returns false.\n     *\n     * @param predicate  the predicate to use, may not be null\n     * @return true if at least one element contained in this iterable matches the predicate,\n     *   false otherwise\n     * @throws NullPointerException if predicate is null"
        },
        "append": {
          "Javadoc": "* Returns a new FluentIterable whose iterator will first traverse\n     * the elements of the current iterable, followed by the elements\n     * of the provided iterable.\n     *\n     * @param other  the other iterable to combine, may not be null\n     * @return a new iterable, combining this iterable with other\n     * @throws NullPointerException if other is null"
        },
        "asEnumeration": {
          "Javadoc": "* Returns an Enumeration that will enumerate all elements contained\n     * in this iterable.\n     *\n     * @return an Enumeration over the elements of this iterable"
        },
        "collate": {
          "Javadoc": "* Returns a new FluentIterable whose iterator will traverse the\n     * elements of the current and provided iterable according to the\n     * ordering defined by a comparator.\n     * <p>\n     * Example: descending order\n     * <ul>\n     *   <li>this contains elements [7, 5, 3, 1]\n     *   <li>other contains elements [8, 6, 4, 2]\n     * </ul>\n     * <p>\n     * The returned iterable will traverse the elements in the following\n     * order: [8, 7, 6, 5, 4, 3, 2, 1]\n     *\n     * @param comparator  the comparator to define an ordering, may be null,\n     *   in which case natural ordering will be used\n     * @param other  the other iterable to collate, may not be null\n     * @return a new iterable, collating this iterable with the other in natural order\n     * @throws NullPointerException if other is null\n     * @see org.apache.commons.collections4.iterators.CollatingIterator"
        },
        "contains": {
          "Javadoc": "* Checks if the object is contained in this iterable.\n     *\n     * @param object  the object to check\n     * @return true if the object is contained in this iterable, false otherwise"
        },
        "copyInto": {
          "Javadoc": "* Traverses an iterator of this iterable and adds all elements\n     * to the provided collection.\n     *\n     * @param collection  the collection to add the elements\n     * @throws NullPointerException if collection is null"
        },
        "eval": {
          "Javadoc": "* This method fully traverses an iterator of this iterable and returns\n     * a new iterable with the same contents, but without any reference\n     * to the originating iterables and/or iterators.\n     * <p>\n     * Calling this method is equivalent to:\n     * <pre>\n     *   FluentIterable&lt;E&gt; someIterable = ...;\n     *   FluentIterable.of(someIterable.toList());\n     * </pre>\n     *\n     * @return a new iterable with the same contents as this iterable"
        },
        "filter": {
          "Javadoc": "* Returns a new FluentIterable whose iterator will only return\n     * elements from this iterable matching the provided predicate.\n     *\n     * @param predicate  the predicate used to filter elements\n     * @return a new iterable, providing a filtered view of this iterable\n     * @throws NullPointerException if predicate is null"
        },
        "forEach": {
          "Javadoc": "* Applies the closure to all elements contained in this iterable.\n     *\n     * @param closure  the closure to apply to each element, may not be null\n     * @throws NullPointerException if closure is null"
        },
        "get": {
          "Javadoc": "* Returns the element at the provided position in this iterable.\n     * In order to return the element, an iterator needs to be traversed\n     * up to the requested position.\n     *\n     * @param position  the position of the element to return\n     * @return the element\n     * @throws IndexOutOfBoundsException if the provided position is outside the\n     *   valid range of this iterable: [0, size)"
        },
        "isEmpty": {
          "Javadoc": "* Checks if this iterable is empty.\n     *\n     * @return true if this iterable does not contain any elements, false otherwise"
        },
        "iterator": {
          "Javadoc": "{@inheritDoc}"
        },
        "limit": {
          "Javadoc": "* Returns a new FluentIterable whose iterator will return at most\n     * the provided maximum number of elements from this iterable.\n     *\n     * @param maxSize  the maximum number of elements\n     * @return a new iterable, providing a bounded view of this iterable\n     * @throws IllegalArgumentException if maxSize is negative"
        },
        "loop": {
          "Javadoc": "* Returns a new FluentIterable whose iterator will loop infinitely\n     * over the elements from this iterable.\n     *\n     * @return a new iterable, providing a looping view of this iterable"
        },
        "reverse": {
          "Javadoc": "* Returns a new FluentIterable whose iterator will traverse the\n     * elements from this iterable in reverse order.\n     *\n     * @return a new iterable, providing a reversed view of this iterable"
        },
        "size": {
          "Javadoc": "* Returns the number of elements that are contained in this iterable.\n     * In order to determine the size, an iterator needs to be traversed.\n     *\n     * @return the size of this iterable"
        },
        "skip": {
          "Javadoc": "* Returns a new FluentIterable whose iterator will skip the first\n     * N elements from this iterable.\n     *\n     * @param elementsToSkip  the number of elements to skip\n     * @return a new iterable, providing a view of this iterable by skipping\n     *   the first N elements\n     * @throws IllegalArgumentException if elementsToSkip is negative"
        },
        "toArray": {
          "Javadoc": "* Returns an array containing all elements of this iterable by traversing\n     * its iterator.\n     *\n     * @param arrayClass  the class of array to create\n     * @return an array of the iterable contents\n     * @throws ArrayStoreException if arrayClass is invalid"
        },
        "toList": {
          "Javadoc": "* Returns a mutable list containing all elements of this iterable\n     * by traversing its iterator.\n     * <p>\n     * The returned list is guaranteed to be mutable.\n     *\n     * @return a list of the iterable contents"
        },
        "toString": {
          "Javadoc": "{@inheritDoc}"
        },
        "transform": {
          "Javadoc": "* Returns a new FluentIterable whose iterator will return all elements\n     * of this iterable transformed by the provided transformer.\n     *\n     * @param <O>  the output element type\n     * @param transformer  the transformer applied to each element\n     * @return a new iterable, providing a transformed view of this iterable\n     * @throws NullPointerException if transformer is null"
        },
        "unique": {
          "Javadoc": "* Returns a new FluentIterable whose iterator will return a unique view\n     * of this iterable.\n     *\n     * @return a new iterable, providing a unique view of this iterable"
        },
        "unmodifiable": {
          "Javadoc": "* Returns a new FluentIterable whose iterator will return an unmodifiable\n     * view of this iterable.\n     *\n     * @return a new iterable, providing an unmodifiable view of this iterable"
        },
        "zip": {
          "Javadoc": "* Returns a new FluentIterable whose iterator will traverse\n     * the elements of this iterable and the other iterables in\n     * alternating order.\n     *\n     * @param others  the iterables to interleave, may not be null\n     * @return a new iterable, interleaving this iterable with others\n     * @throws NullPointerException if either of the provided iterables is null"
        }
      }
    },
    "org.apache.commons.collections4.FunctorException": {
      "Javadoc": "\n * Runtime exception thrown from functors.\n * If required, a root cause error can be wrapped within this one.\n *\n * @since 3.0\n "
    },
    "org.apache.commons.collections4.functors.AbstractQuantifierPredicate": {
      "Javadoc": "\n * Abstract base class for quantification predicates, e.g. All, Any, None.\n *\n * @since 4.0\n ",
      "methods": {
        "getPredicates": {
          "Javadoc": "* Gets the predicates.\n     *\n     * @return a copy of the predicates\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.AllPredicate": {
      "Javadoc": "\n * Predicate implementation that returns true if all the\n * predicates return true.\n * If the array of predicates is empty, then this predicate returns true.\n * <p>\n * NOTE: In versions prior to 3.2 an array size of zero or one\n * threw an exception.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "allPredicate": {
          "Javadoc": "* Factory to create the predicate.\n     * <p>\n     * If the array is size zero, the predicate always returns true.\n     * If the array is size one, then that predicate is returned.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicates  the predicates to check, cloned, not null\n     * @return the {@code all} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning true if all predicates return true.\n     *\n     * @param object  the input object\n     * @return true if all decorated predicates return true"
        }
      }
    },
    "org.apache.commons.collections4.functors.AndPredicate": {
      "Javadoc": "\n * Predicate implementation that returns true if both the predicates return true.\n *\n * @since 3.0\n ",
      "methods": {
        "andPredicate": {
          "Javadoc": "* Factory to create the predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicate1  the first predicate to check, not null\n     * @param predicate2  the second predicate to check, not null\n     * @return the {@code and} predicate\n     * @throws NullPointerException if either predicate is null"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning true if both predicates return true.\n     *\n     * @param object  the input object\n     * @return true if both decorated predicates return true"
        },
        "getPredicates": {
          "Javadoc": "* Gets the two predicates being decorated as an array.\n     *\n     * @return the predicates\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.AnyPredicate": {
      "Javadoc": "\n * Predicate implementation that returns true if any of the\n * predicates return true.\n * If the array of predicates is empty, then this predicate returns false.\n * <p>\n * NOTE: In versions prior to 3.2 an array size of zero or one\n * threw an exception.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "anyPredicate": {
          "Javadoc": "* Factory to create the predicate.\n     * <p>\n     * If the array is size zero, the predicate always returns false.\n     * If the array is size one, then that predicate is returned.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicates  the predicates to check, cloned, not null\n     * @return the {@code any} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning true if any predicate returns true.\n     *\n     * @param object  the input object\n     * @return true if any decorated predicate return true"
        }
      }
    },
    "org.apache.commons.collections4.functors.CatchAndRethrowClosure": {
      "Javadoc": "\n * {@link Closure} that catches any checked exception and re-throws it as a\n * {@link FunctorException} runtime exception. Example usage:\n *\n * <pre>\n * // Create a catch and re-throw closure via anonymous subclass\n * CatchAndRethrowClosure&lt;String&gt; writer = new ThrowingClosure() {\n *     private java.io.Writer out = // some writer\n *\n *     protected void executeAndThrow(String input) throws IOException {\n *         out.write(input); // throwing of IOException allowed\n *     }\n * };\n *\n * // use catch and re-throw closure\n * java.util.List&lt;String&gt; strList = // some list\n * try {\n *     CollectionUtils.forAllDo(strList, writer);\n * } catch (FunctorException ex) {\n *     Throwable originalError = ex.getCause();\n *     // handle error\n * }\n * </pre>\n *\n * @since 4.0\n ",
      "methods": {
        "execute": {
          "Javadoc": "* Execute this closure on the specified input object.\n     *\n     * @param input the input to execute on\n     * @throws FunctorException (runtime) if the closure execution resulted in a\n     *             checked exception."
        },
        "executeAndThrow": {
          "Javadoc": "* Execute this closure on the specified input object.\n     *\n     * @param input the input to execute on\n     * @throws Throwable if the closure execution resulted in a checked\n     *             exception."
        }
      }
    },
    "org.apache.commons.collections4.functors.ChainedClosure": {
      "Javadoc": "\n * Closure implementation that chains the specified closures together.\n *\n * @since 3.0\n ",
      "methods": {
        "chainedClosure": {
          "Javadoc": "* Create a new Closure that calls each closure in turn, passing the\n     * result into the next closure. The ordering is that of the iterator()\n     * method on the collection.\n     *\n     * @param <E> the type that the closure acts on\n     * @param closures  a collection of closures to chain\n     * @return the {@code chained} closure\n     * @throws NullPointerException if the closures collection is null\n     * @throws NullPointerException if any closure in the collection is null"
        },
        "execute": {
          "Javadoc": "* Execute a list of closures.\n     *\n     * @param input  the input object passed to each closure"
        },
        "getClosures": {
          "Javadoc": "* Gets the closures.\n     *\n     * @return a copy of the closures\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.ChainedTransformer": {
      "Javadoc": "\n * Transformer implementation that chains the specified transformers together.\n * <p>\n * The input object is passed to the first transformer. The transformed result\n * is passed to the second transformer and so on.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "chainedTransformer": {
          "Javadoc": "* Factory method that performs validation and copies the parameter array.\n     *\n     * @param <T>  the object type\n     * @param transformers  the transformers to chain, copied, no nulls\n     * @return the {@code chained} transformer\n     * @throws NullPointerException if the transformers array is null\n     * @throws NullPointerException if any transformer in the array is null"
        },
        "getTransformers": {
          "Javadoc": "* Gets the transformers.\n     *\n     * @return a copy of the transformers\n     * @since 3.1"
        },
        "transform": {
          "Javadoc": "* Transforms the input to result via each decorated transformer\n     *\n     * @param object  the input object passed to the first transformer\n     * @return the transformed result"
        }
      }
    },
    "org.apache.commons.collections4.functors.CloneTransformer": {
      "Javadoc": "\n * Transformer implementation that returns a clone of the input object.\n * <p>\n * Clone is performed using {@code PrototypeFactory.prototypeFactory(input).create()}.\n * </p>\n * <p>\n * <b>WARNING:</b> from v4.1 onwards this class will <b>not</b> be serializable anymore\n * in order to prevent potential remote code execution exploits. Please refer to\n * <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-580\">COLLECTIONS-580</a>\n * for more details.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "cloneTransformer": {
          "Javadoc": "* Factory returning the singleton instance.\n     *\n     * @param <T>  the type of the objects to be cloned\n     * @return the singleton instance\n     * @since 3.1"
        },
        "transform": {
          "Javadoc": "* Transforms the input to result by cloning it.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result"
        }
      }
    },
    "org.apache.commons.collections4.functors.ClosureTransformer": {
      "Javadoc": "\n * Transformer implementation that calls a Closure using the input object\n * and then returns the input.\n *\n * @since 3.0\n ",
      "methods": {
        "closureTransformer": {
          "Javadoc": "* Factory method that performs validation.\n     *\n     * @param <T>  the type of the object to transform\n     * @param closure  the closure to call, not null\n     * @return the {@code closure} transformer\n     * @throws NullPointerException if the closure is null"
        },
        "getClosure": {
          "Javadoc": "* Gets the closure.\n     *\n     * @return the closure\n     * @since 3.1"
        },
        "transform": {
          "Javadoc": "* Transforms the input to result by executing a closure.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result"
        }
      }
    },
    "org.apache.commons.collections4.functors.ComparatorPredicate": {
      "Javadoc": "\n * Predicate that compares the input object with the one stored in the predicate using a comparator.\n * In addition, the comparator result can be evaluated in accordance to a supplied criterion value.\n *\n * <p>In order to demonstrate the use of the predicate, the following variables are declared:</p>\n *\n * <pre>\n * Integer ONE = Integer.valueOf(1);\n * Integer TWO = Integer.valueOf(2);\n *\n * Comparator comparator = new Comparator() {\n *\n *     public int compare(Object first, Object second) {\n *         return ((Integer) second) - ((Integer) first);\n *     }\n *\n * };\n * </pre>\n *\n * <p>Using the declared variables, the {@code ComparatorPredicate} can be used in the\n * following way:</p>\n *\n * <pre>\n * ComparatorPredicate.comparatorPredicate(ONE, comparator).evaluate(TWO);\n * </pre>\n *\n * <p>The input variable {@code TWO} in compared to the stored variable {@code ONE} using\n * the supplied {@code comparator}. This is the default usage of the predicate and will return\n * {@code true} if the underlying comparator returns {@code 0}. In addition to the default\n * usage of the predicate, it is possible to evaluate the comparator's result in several ways. The\n * following {@link Criterion} enumeration values are provided by the predicate:\n * </p>\n *\n * <ul>\n *     <li>EQUAL</li>\n *     <li>GREATER</li>\n *     <li>GREATER_OR_EQUAL</li>\n *     <li>LESS</li>\n *     <li>LESS_OR_EQUAL</li>\n * </ul>\n *\n * <p>The following examples demonstrates how these constants can be used in order to manipulate the\n * evaluation of a comparator result.</p>\n *\n * <pre>\n * ComparatorPredicate.comparatorPredicate(ONE, comparator,<b>ComparatorPredicate.Criterion.GREATER</b>).evaluate(TWO);\n * </pre>\n *\n * <p>The input variable TWO is compared to the stored variable ONE using the supplied {@code comparator}\n * using the {@code GREATER} evaluation criterion constant. This instructs the predicate to\n * return {@code true} if the comparator returns a value greater than {@code 0}.</p>\n *\n * @since 4.0\n ",
      "methods": {
        "comparatorPredicate": {
          "Javadoc": "* Factory to create the comparator predicate\n     *\n     * @param <T> the type that the predicate queries\n     * @param object  the object to compare to\n     * @param comparator  the comparator to use for comparison\n     * @param criterion  the criterion to use to evaluate comparison\n     * @return the predicate\n     * @throws NullPointerException if comparator or criterion is null"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate. The predicate evaluates to {@code true} in the following cases:\n     *\n     * <ul>\n     * <li>{@code comparator.compare(object, input) == 0 &amp;&amp; criterion == EQUAL}</li>\n     * <li>{@code comparator.compare(object, input) &lt; 0 &amp;&amp; criterion == LESS}</li>\n     * <li>{@code comparator.compare(object, input) &gt; 0 &amp;&amp; criterion == GREATER}</li>\n     * <li>{@code comparator.compare(object, input) &gt;= 0 &amp;&amp; criterion == GREATER_OR_EQUAL}</li>\n     * <li>{@code comparator.compare(object, input) &lt;= 0 &amp;&amp; criterion == LESS_OR_EQUAL}</li>\n     * </ul>\n     *\n     * @see org.apache.commons.collections4.Predicate#evaluate(Object)\n     * @see java.util.Comparator#compare(Object first, Object second)\n     *\n     * @param target  the target object to compare to\n     * @return {@code true} if the comparison succeeds according to the selected criterion\n     * @throws IllegalStateException if the criterion is invalid (really not possible)"
        }
      }
    },
    "org.apache.commons.collections4.functors.ConstantFactory": {
      "Javadoc": "\n * Factory implementation that returns the same constant each time.\n * <p>\n * No check is made that the object is immutable. In general, only immutable\n * objects should use the constant factory. Mutable objects should\n * use the prototype factory.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "constantFactory": {
          "Javadoc": "* Factory method that performs validation.\n     *\n     * @param <T>  the type of the constant\n     * @param constantToReturn  the constant object to return each time in the factory\n     * @return the {@code constant} factory."
        },
        "create": {
          "Javadoc": "* Always return constant.\n     *\n     * @return the stored constant value"
        },
        "getConstant": {
          "Javadoc": "* Gets the constant.\n     *\n     * @return the constant\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.ConstantTransformer": {
      "Javadoc": "\n * Transformer implementation that returns the same constant each time.\n * <p>\n * No check is made that the object is immutable. In general, only immutable\n * objects should use the constant factory. Mutable objects should\n * use the prototype factory.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "constantTransformer": {
          "Javadoc": "* Transformer method that performs validation.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param constantToReturn  the constant object to return each time in the factory\n     * @return the {@code constant} factory."
        },
        "nullTransformer": {
          "Javadoc": "* Gets a typed null instance.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @return Transformer&lt;I, O&gt; that always returns null."
        },
        "equals": {
          "Javadoc": "* {@inheritDoc}"
        },
        "getConstant": {
          "Javadoc": "* Gets the constant.\n     *\n     * @return the constant\n     * @since 3.1"
        },
        "hashCode": {
          "Javadoc": "* {@inheritDoc}"
        },
        "transform": {
          "Javadoc": "* Transforms the input by ignoring it and returning the stored constant instead.\n     *\n     * @param input  the input object which is ignored\n     * @return the stored constant"
        }
      }
    },
    "org.apache.commons.collections4.functors.DefaultEquator": {
      "Javadoc": "\n * Default {@link Equator} implementation.\n *\n * @param <T>  the types of object this {@link Equator} can evaluate.\n * @since 4.0\n ",
      "methods": {
        "defaultEquator": {
          "Javadoc": "* Factory returning the typed singleton instance.\n     *\n     * @param <T>  the object type\n     * @return the singleton instance"
        },
        "equate": {
          "Javadoc": "* {@inheritDoc} Delegates to {@link Objects#equals(Object, Object)}."
        },
        "hash": {
          "Javadoc": "* {@inheritDoc}\n     *\n     * @return {@code o.hashCode()} if {@code o} is non-\n     *         {@code null}, else {@link #HASHCODE_NULL}."
        }
      }
    },
    "org.apache.commons.collections4.functors.EqualPredicate": {
      "Javadoc": "\n * Predicate implementation that returns true if the input is the same object\n * as the one stored in this predicate by equals.\n *\n * @since 3.0\n ",
      "methods": {
        "equalPredicate": {
          "Javadoc": "* Factory to create the identity predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param object  the object to compare to\n     * @param equator  the equator to use for comparison\n     * @return the predicate\n     * @since 4.0"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning true if the input equals the stored value.\n     *\n     * @param object  the input object\n     * @return true if input object equals stored value"
        },
        "getValue": {
          "Javadoc": "* Gets the value.\n     *\n     * @return the value\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.ExceptionClosure": {
      "Javadoc": "\n * Closure implementation that always throws an exception.\n *\n * @since 3.0\n ",
      "methods": {
        "exceptionClosure": {
          "Javadoc": "* Factory returning the singleton instance.\n     *\n     * @param <E> the type that the closure acts on\n     * @return the singleton instance\n     * @since 3.1"
        },
        "execute": {
          "Javadoc": "* Always throw an exception.\n     *\n     * @param input  the input object\n     * @throws FunctorException always"
        }
      }
    },
    "org.apache.commons.collections4.functors.ExceptionFactory": {
      "Javadoc": "\n * Factory implementation that always throws an exception.\n *\n * @since 3.0\n ",
      "methods": {
        "exceptionFactory": {
          "Javadoc": "* Factory returning the singleton instance.\n     *\n     * @param <T>  the type the factory creates\n     * @return the singleton instance\n     * @since 3.1"
        },
        "create": {
          "Javadoc": "* Always throws an exception.\n     *\n     * @return never\n     * @throws FunctorException always"
        }
      }
    },
    "org.apache.commons.collections4.functors.ExceptionPredicate": {
      "Javadoc": "\n * Predicate implementation that always throws an exception.\n *\n * @since 3.0\n ",
      "methods": {
        "exceptionPredicate": {
          "Javadoc": "* Factory returning the singleton instance.\n     *\n     * @param <T>  the object type\n     * @return the singleton instance\n     * @since 3.1"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate always throwing an exception.\n     *\n     * @param object  the input object\n     * @return never\n     * @throws FunctorException always"
        }
      }
    },
    "org.apache.commons.collections4.functors.ExceptionTransformer": {
      "Javadoc": "\n * Transformer implementation that always throws an exception.\n *\n * @since 3.0\n ",
      "methods": {
        "exceptionTransformer": {
          "Javadoc": "* Factory returning the singleton instance.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @return the singleton instance\n     * @since 3.1"
        },
        "transform": {
          "Javadoc": "* Transforms the input to result by cloning it.\n     *\n     * @param input  the input object to transform\n     * @return never\n     * @throws FunctorException always"
        }
      }
    },
    "org.apache.commons.collections4.functors.FactoryTransformer": {
      "Javadoc": "\n * Transformer implementation that calls a Factory and returns the result.\n *\n * @since 3.0\n ",
      "methods": {
        "factoryTransformer": {
          "Javadoc": "* Factory method that performs validation.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param factory  the factory to call, not null\n     * @return the {@code factory} transformer\n     * @throws NullPointerException if the factory is null"
        },
        "getFactory": {
          "Javadoc": "* Gets the factory.\n     *\n     * @return the factory\n     * @since 3.1"
        },
        "transform": {
          "Javadoc": "* Transforms the input by ignoring the input and returning the result of\n     * calling the decorated factory.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result"
        }
      }
    },
    "org.apache.commons.collections4.functors.FalsePredicate": {
      "Javadoc": "\n * Predicate implementation that always returns false.\n *\n * @since 3.0\n ",
      "methods": {
        "falsePredicate": {
          "Javadoc": "* Gets a typed instance.\n     *\n     * @param <T> the type that the predicate queries\n     * @return the singleton instance\n     * @since 4.0"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning false always.\n     *\n     * @param object  the input object\n     * @return false always"
        }
      }
    },
    "org.apache.commons.collections4.functors.ForClosure": {
      "Javadoc": "\n * Closure implementation that calls another closure n times, like a for loop.\n * <p>\n * <b>WARNING:</b> from v4.1 onwards this class will <b>not</b> be serializable anymore\n * in order to prevent potential remote code execution exploits. Please refer to\n * <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-580\">COLLECTIONS-580</a>\n * for more details.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "forClosure": {
          "Javadoc": "* Factory method that performs validation.\n     * <p>\n     * A null closure or zero count returns the {@code NOPClosure}.\n     * A count of one returns the specified closure.\n     *\n     * @param <E> the type that the closure acts on\n     * @param count  the number of times to execute the closure\n     * @param closure  the closure to execute, not null\n     * @return the {@code for} closure"
        },
        "execute": {
          "Javadoc": "* Executes the closure {@code count} times.\n     *\n     * @param input  the input object"
        },
        "getClosure": {
          "Javadoc": "* Gets the closure.\n     *\n     * @return the closure\n     * @since 3.1"
        },
        "getCount": {
          "Javadoc": "* Gets the count.\n     *\n     * @return the count\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.FunctorUtils": {
      "Javadoc": "\n * Internal utilities for functors.\n *\n * @since 3.0\n ",
      "methods": {
        "coerce": {
          "Javadoc": "* A very simple method that coerces Transformer<? super I, ? extends O> to Transformer<I, O>.\n     * <p>This method exists\n     * simply as centralised documentation and atomic unchecked warning\n     * suppression.\n     *\n     * @param <I> the type of object the returned transformer should \"accept\"\n     * @param <O> the type of object the returned transformer should \"produce\"\n     * @param transformer the transformer to coerce.\n     * @return the coerced transformer."
        },
        "copy": {
          "Javadoc": "* Copy method\n     *\n     * @param transformers  the transformers to copy\n     * @return a clone of the transformers"
        },
        "validate": {
          "Javadoc": "* Validate method\n     *\n     * @param transformers  the transformers to validate"
        }
      }
    },
    "org.apache.commons.collections4.functors.IdentityPredicate": {
      "Javadoc": "\n * Predicate implementation that returns true if the input is the same object\n * as the one stored in this predicate.\n *\n * @since 3.0\n ",
      "methods": {
        "identityPredicate": {
          "Javadoc": "* Factory to create the identity predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param object  the object to compare to\n     * @return the predicate"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning true if the input object is identical to\n     * the stored object.\n     *\n     * @param object  the input object\n     * @return true if input is the same object as the stored value"
        },
        "getValue": {
          "Javadoc": "* Gets the value.\n     *\n     * @return the value\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.IfClosure": {
      "Javadoc": "\n * Closure implementation acts as an if statement calling one or other closure\n * based on a predicate.\n *\n * @since 3.0\n ",
      "methods": {
        "ifClosure": {
          "Javadoc": "* Factory method that performs validation.\n     *\n     * @param <E> the type that the closure acts on\n     * @param predicate  predicate to switch on\n     * @param trueClosure  closure used if true\n     * @param falseClosure  closure used if false\n     * @return the {@code if} closure\n     * @throws NullPointerException if any argument is null"
        },
        "execute": {
          "Javadoc": "* Executes the true or false closure according to the result of the predicate.\n     *\n     * @param input  the input object"
        },
        "getFalseClosure": {
          "Javadoc": "* Gets the closure called when false.\n     *\n     * @return the closure\n     * @since 3.1"
        },
        "getPredicate": {
          "Javadoc": "* Gets the predicate.\n     *\n     * @return the predicate\n     * @since 3.1"
        },
        "getTrueClosure": {
          "Javadoc": "* Gets the closure called when true.\n     *\n     * @return the closure\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.IfTransformer": {
      "Javadoc": "\n * Transformer implementation that will call one of two closures based on whether a predicate evaluates\n * as true or false.\n *\n * @param <I> The input type for the transformer\n * @param <O> The output type for the transformer\n *\n * @since 4.1\n ",
      "methods": {
        "ifTransformer": {
          "Javadoc": "* Factory method that performs validation.\n     * <p>\n     * This factory creates a transformer that just returns the input object when\n     * the predicate is false.\n     *\n     * @param <T>  input and output type for the transformer\n     * @param predicate  predicate to switch on\n     * @param trueTransformer  transformer used if true\n     * @return the {@code if} transformer\n     * @throws NullPointerException if either argument is null"
        },
        "getFalseTransformer": {
          "Javadoc": "* Gets the transformer used when false.\n     *\n     * @return the transformer"
        },
        "getPredicate": {
          "Javadoc": "* Gets the predicate.\n     *\n     * @return the predicate"
        },
        "getTrueTransformer": {
          "Javadoc": "* Gets the transformer used when true.\n     *\n     * @return the transformer"
        },
        "transform": {
          "Javadoc": "* Transforms the input using the true or false transformer based to the result of the predicate.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result"
        }
      }
    },
    "org.apache.commons.collections4.functors.InstanceofPredicate": {
      "Javadoc": "\n * Predicate implementation that returns true if the input is an instanceof\n * the type stored in this predicate.\n *\n * @since 3.0\n ",
      "methods": {
        "instanceOfPredicate": {
          "Javadoc": "* Factory to create the identity predicate.\n     *\n     * @param type  the type to check for, may not be null\n     * @return the predicate\n     * @throws NullPointerException if the class is null"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning true if the input object is of the correct type.\n     *\n     * @param object  the input object\n     * @return true if input is of stored type"
        },
        "getType": {
          "Javadoc": "* Gets the type to compare to.\n     *\n     * @return the type\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.InstantiateFactory": {
      "Javadoc": "\n * Factory implementation that creates a new object instance by reflection.\n * <p>\n * <b>WARNING:</b> from v4.1 onwards this class will <b>not</b> be serializable anymore\n * in order to prevent potential remote code execution exploits. Please refer to\n * <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-580\">COLLECTIONS-580</a>\n * for more details.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "instantiateFactory": {
          "Javadoc": "* Factory method that performs validation.\n     *\n     * @param <T>  the type the factory creates\n     * @param classToInstantiate  the class to instantiate, not null\n     * @param paramTypes  the constructor parameter types, cloned\n     * @param args  the constructor arguments, cloned\n     * @return a new instantiate factory\n     * @throws NullPointerException if classToInstantiate is null\n     * @throws IllegalArgumentException if paramTypes does not match args"
        },
        "create": {
          "Javadoc": "* Creates an object using the stored constructor.\n     *\n     * @return the new object"
        },
        "findConstructor": {
          "Javadoc": "* Find the Constructor for the class specified."
        }
      }
    },
    "org.apache.commons.collections4.functors.InstantiateTransformer": {
      "Javadoc": "\n * Transformer implementation that creates a new object instance by reflection.\n * <p>\n * <b>WARNING:</b> from v4.1 onwards this class will <b>not</b> be serializable anymore\n * in order to prevent potential remote code execution exploits. Please refer to\n * <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-580\">COLLECTIONS-580</a>\n * for more details.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "instantiateTransformer": {
          "Javadoc": "* Transformer method that performs validation.\n     *\n     * @param <T>  the type of the objects to be created\n     * @param paramTypes  the constructor parameter types\n     * @param args  the constructor arguments\n     * @return an instantiate transformer\n     * @throws IllegalArgumentException if paramTypes does not match args"
        },
        "transform": {
          "Javadoc": "* Transforms the input Class object to a result by instantiation.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result"
        }
      }
    },
    "org.apache.commons.collections4.functors.InvokerTransformer": {
      "Javadoc": "\n * Transformer implementation that creates a new object instance by reflection.\n * <p>\n * <b>WARNING:</b> from v4.1 onwards this class will <b>not</b> be serializable anymore\n * in order to prevent potential remote code execution exploits. Please refer to\n * <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-580\">COLLECTIONS-580</a>\n * for more details.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "invokerTransformer": {
          "Javadoc": "* Gets an instance of this transformer calling a specific method with specific values.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param methodName  the method name to call\n     * @param paramTypes  the parameter types of the method\n     * @param args  the arguments to pass to the method\n     * @return an invoker transformer\n     * @throws NullPointerException if methodName is null\n     * @throws IllegalArgumentException if paramTypes does not match args"
        },
        "transform": {
          "Javadoc": "* Transforms the input to result by invoking a method on the input.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result, null if null input"
        }
      }
    },
    "org.apache.commons.collections4.functors.MapTransformer": {
      "Javadoc": "\n * Transformer implementation that returns the value held in a specified map\n * using the input parameter as a key.\n *\n * @since 3.0\n ",
      "methods": {
        "mapTransformer": {
          "Javadoc": "* Factory to create the transformer.\n     * <p>\n     * If the map is null, a transformer that always returns null is returned.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param map the map, not cloned\n     * @return the transformer"
        },
        "getMap": {
          "Javadoc": "* Gets the map to lookup in.\n     *\n     * @return the map\n     * @since 3.1"
        },
        "transform": {
          "Javadoc": "* Transforms the input to result by looking it up in a {@code Map}.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result"
        }
      }
    },
    "org.apache.commons.collections4.functors.NonePredicate": {
      "Javadoc": "\n * Predicate implementation that returns true if none of the\n * predicates return true.\n * If the array of predicates is empty, then this predicate returns true.\n * <p>\n * NOTE: In versions prior to 3.2 an array size of zero or one\n * threw an exception.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "nonePredicate": {
          "Javadoc": "* Factory to create the predicate.\n     * <p>\n     * If the array is size zero, the predicate always returns true.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicates  the predicates to check, cloned, not null\n     * @return the {@code any} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning false if any stored predicate returns false.\n     *\n     * @param object  the input object\n     * @return true if none of decorated predicates return true"
        }
      }
    },
    "org.apache.commons.collections4.functors.NOPClosure": {
      "Javadoc": "\n * Closure implementation that does nothing.\n *\n * @since 3.0\n ",
      "methods": {
        "nopClosure": {
          "Javadoc": "* Factory returning the singleton instance.\n     *\n     * @param <E> the type that the closure acts on\n     * @return the singleton instance\n     * @since 3.1"
        },
        "execute": {
          "Javadoc": "* Do nothing.\n     *\n     * @param input  the input object"
        }
      }
    },
    "org.apache.commons.collections4.functors.NOPTransformer": {
      "Javadoc": "\n * Transformer implementation that does nothing.\n *\n * @since 3.0\n ",
      "methods": {
        "nopTransformer": {
          "Javadoc": "* Factory returning the singleton instance.\n     *\n     * @param <T>  the input/output type\n     * @return the singleton instance\n     * @since 3.1"
        },
        "transform": {
          "Javadoc": "* Transforms the input to result by doing nothing.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result which is the input"
        }
      }
    },
    "org.apache.commons.collections4.functors.NotNullPredicate": {
      "Javadoc": "\n * Predicate implementation that returns true if the input is not null.\n *\n * @since 3.0\n ",
      "methods": {
        "notNullPredicate": {
          "Javadoc": "* Factory returning the singleton instance.\n     *\n     * @param <T> the type that the predicate queries\n     * @return the singleton instance\n     * @since 3.1"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning true if the object does not equal null.\n     *\n     * @param object  the object to evaluate\n     * @return true if not null"
        }
      }
    },
    "org.apache.commons.collections4.functors.NotPredicate": {
      "Javadoc": "\n * Predicate implementation that returns the opposite of the decorated predicate.\n *\n * @since 3.0\n ",
      "methods": {
        "notPredicate": {
          "Javadoc": "* Factory to create the not predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicate  the predicate to decorate, not null\n     * @return the predicate\n     * @throws NullPointerException if the predicate is null"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning the opposite to the stored predicate.\n     *\n     * @param object  the input object\n     * @return true if predicate returns false"
        },
        "getPredicates": {
          "Javadoc": "* Gets the predicate being decorated.\n     *\n     * @return the predicate as the only element in an array\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.NullIsExceptionPredicate": {
      "Javadoc": "\n * Predicate implementation that throws an exception if the input is null.\n *\n * @since 3.0\n ",
      "methods": {
        "nullIsExceptionPredicate": {
          "Javadoc": "* Factory to create the null exception predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicate  the predicate to decorate, not null\n     * @return the predicate\n     * @throws NullPointerException if the predicate is null"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning the result of the decorated predicate\n     * once a null check is performed.\n     *\n     * @param object  the input object\n     * @return true if decorated predicate returns true\n     * @throws FunctorException if input is null"
        },
        "getPredicates": {
          "Javadoc": "* Gets the predicate being decorated.\n     *\n     * @return the predicate as the only element in an array\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.NullIsFalsePredicate": {
      "Javadoc": "\n * Predicate implementation that returns false if the input is null.\n *\n * @since 3.0\n ",
      "methods": {
        "nullIsFalsePredicate": {
          "Javadoc": "* Factory to create the null false predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicate  the predicate to decorate, not null\n     * @return the predicate\n     * @throws NullPointerException if the predicate is null"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning the result of the decorated predicate\n     * once a null check is performed.\n     *\n     * @param object  the input object\n     * @return true if decorated predicate returns true, false if input is null"
        },
        "getPredicates": {
          "Javadoc": "* Gets the predicate being decorated.\n     *\n     * @return the predicate as the only element in an array\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.NullIsTruePredicate": {
      "Javadoc": "\n * Predicate implementation that returns true if the input is null.\n *\n * @since 3.0\n ",
      "methods": {
        "nullIsTruePredicate": {
          "Javadoc": "* Factory to create the null true predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicate  the predicate to decorate, not null\n     * @return the predicate\n     * @throws NullPointerException if the predicate is null"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning the result of the decorated predicate\n     * once a null check is performed.\n     *\n     * @param object  the input object\n     * @return true if decorated predicate returns true or input is null"
        },
        "getPredicates": {
          "Javadoc": "* Gets the predicate being decorated.\n     *\n     * @return the predicate as the only element in an array\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.NullPredicate": {
      "Javadoc": "\n * Predicate implementation that returns true if the input is null.\n *\n * @since 3.0\n ",
      "methods": {
        "nullPredicate": {
          "Javadoc": "* Factory returning the singleton instance.\n     *\n     * @param <T> the type that the predicate queries\n     * @return the singleton instance\n     * @since 3.1"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning true if the input is null.\n     *\n     * @param object  the input object\n     * @return true if input is null"
        }
      }
    },
    "org.apache.commons.collections4.functors.OnePredicate": {
      "Javadoc": "\n * Predicate implementation that returns true if only one of the\n * predicates return true.\n * If the array of predicates is empty, then this predicate returns false.\n * <p>\n * NOTE: In versions prior to 3.2 an array size of zero or one\n * threw an exception.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "onePredicate": {
          "Javadoc": "* Factory to create the predicate.\n     * <p>\n     * If the array is size zero, the predicate always returns false.\n     * If the array is size one, then that predicate is returned.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicates  the predicates to check, cloned, not null\n     * @return the {@code any} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning true if only one decorated predicate\n     * returns true.\n     *\n     * @param object  the input object\n     * @return true if only one decorated predicate returns true"
        }
      }
    },
    "org.apache.commons.collections4.functors.OrPredicate": {
      "Javadoc": "\n * Predicate implementation that returns true if either of the predicates return true.\n *\n * @since 3.0\n ",
      "methods": {
        "orPredicate": {
          "Javadoc": "* Factory to create the predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicate1  the first predicate to check, not null\n     * @param predicate2  the second predicate to check, not null\n     * @return the {@code and} predicate\n     * @throws NullPointerException if either predicate is null"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning true if either predicate returns true.\n     *\n     * @param object  the input object\n     * @return true if either decorated predicate returns true"
        },
        "getPredicates": {
          "Javadoc": "* Gets the two predicates being decorated as an array.\n     *\n     * @return the predicates\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.PredicateDecorator": {
      "Javadoc": "\n * Defines a predicate that decorates one or more other predicates.\n * <p>\n * This interface enables tools to access the decorated predicates.\n * </p>\n *\n * @since 3.1\n ",
      "methods": {
        "getPredicates": {
          "Javadoc": "* Gets the predicates being decorated as an array.\n     * <p>\n     * The array may be the internal data structure of the predicate and thus\n     * should not be altered.\n     *\n     * @return the predicates being decorated"
        }
      }
    },
    "org.apache.commons.collections4.functors.PredicateTransformer": {
      "Javadoc": "\n * Transformer implementation that calls a Predicate using the input object\n * and then returns the result.\n *\n * @since 3.0\n ",
      "methods": {
        "predicateTransformer": {
          "Javadoc": "* Factory method that performs validation.\n     *\n     * @param <T>  the input type\n     * @param predicate  the predicate to call, not null\n     * @return the {@code predicate} transformer\n     * @throws IllegalArgumentException if the predicate is null"
        },
        "getPredicate": {
          "Javadoc": "* Gets the predicate.\n     *\n     * @return the predicate\n     * @since 3.1"
        },
        "transform": {
          "Javadoc": "* Transforms the input to result by calling a predicate.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result"
        }
      }
    },
    "org.apache.commons.collections4.functors.PrototypeFactory": {
      "Javadoc": "\n * Factory implementation that creates a new instance each time based on a prototype.\n * <p>\n * <b>WARNING:</b> from v4.1 onwards {@link Factory} instances returned by\n * {@link #prototypeFactory(Object)} will <b>not</b> be serializable anymore in order\n * to prevent potential remote code execution exploits. Please refer to\n * <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-580\">COLLECTIONS-580</a>\n * for more details.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "prototypeFactory": {
          "Javadoc": "* Factory method that performs validation.\n     * <p>\n     * Creates a Factory that will return a clone of the same prototype object\n     * each time the factory is used. The prototype will be cloned using one of these\n     * techniques (in order):\n     * </p>\n     *\n     * <ul>\n     * <li>public clone method</li>\n     * <li>public copy constructor</li>\n     * <li>serialization clone</li>\n     * </ul>\n     *\n     * @param <T>  the type the factory creates\n     * @param prototype  the object to clone each time in the factory\n     * @return the {@code prototype} factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n     * the {@code prototype} is {@code null}\n     * @throws IllegalArgumentException if the prototype cannot be cloned"
        }
      }
    },
    "org.apache.commons.collections4.functors.PrototypeCloneFactory": {
      "Javadoc": "\n     * PrototypeCloneFactory creates objects by copying a prototype using the clone method.\n     ",
      "methods": {
        "create": {
          "Javadoc": "* Creates an object by calling the clone method.\n         *\n         * @return the new object"
        },
        "findCloneMethod": {
          "Javadoc": "* Find the Clone method for the class specified."
        }
      }
    },
    "org.apache.commons.collections4.functors.PrototypeSerializationFactory": {
      "Javadoc": "\n     * PrototypeSerializationFactory creates objects by cloning a prototype using serialization.\n     ",
      "methods": {
        "create": {
          "Javadoc": "* Creates an object using serialization.\n         *\n         * @return the new object"
        }
      }
    },
    "org.apache.commons.collections4.functors.StringValueTransformer": {
      "Javadoc": "\n * Transformer implementation that returns the result of calling\n * {@code String.valueOf} on the input object.\n *\n * @since 3.0\n ",
      "methods": {
        "stringValueTransformer": {
          "Javadoc": "* Factory returning the singleton instance.\n     *\n     * @param <T>  the input type\n     * @return the singleton instance\n     * @since 3.1"
        },
        "transform": {
          "Javadoc": "* Transforms the input to result by calling {@code String.valueOf}.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result"
        }
      }
    },
    "org.apache.commons.collections4.functors.SwitchClosure": {
      "Javadoc": "\n * Closure implementation calls the closure whose predicate returns true,\n * like a switch statement.\n *\n * @since 3.0\n ",
      "methods": {
        "switchClosure": {
          "Javadoc": "* Factory method that performs validation and copies the parameter arrays.\n     *\n     * @param <E> the type that the closure acts on\n     * @param predicates  array of predicates, cloned, no nulls\n     * @param closures  matching array of closures, cloned, no nulls\n     * @param defaultClosure  the closure to use if no match, null means nop\n     * @return the {@code chained} closure\n     * @throws NullPointerException if array is null\n     * @throws NullPointerException if any element in the array is null\n     * @throws IllegalArgumentException if the array lengths of predicates and closures do not match"
        },
        "execute": {
          "Javadoc": "* Executes the closure whose matching predicate returns true\n     *\n     * @param input  the input object"
        },
        "getClosures": {
          "Javadoc": "* Gets the closures.\n     *\n     * @return a copy of the closures\n     * @since 3.1"
        },
        "getDefaultClosure": {
          "Javadoc": "* Gets the default closure.\n     *\n     * @return the default closure\n     * @since 3.1"
        },
        "getPredicates": {
          "Javadoc": "* Gets the predicates.\n     *\n     * @return a copy of the predicates\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.SwitchTransformer": {
      "Javadoc": "\n * Transformer implementation calls the transformer whose predicate returns true,\n * like a switch statement.\n *\n * @since 3.0\n ",
      "methods": {
        "switchTransformer": {
          "Javadoc": "* Factory method that performs validation and copies the parameter arrays.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param predicates  array of predicates, cloned, no nulls\n     * @param transformers  matching array of transformers, cloned, no nulls\n     * @param defaultTransformer  the transformer to use if no match, null means return null\n     * @return the {@code chained} transformer\n     * @throws NullPointerException if either array is null\n     * @throws NullPointerException if any element in the arrays is null\n     * @throws IllegalArgumentException if the arrays have different sizes"
        },
        "getDefaultTransformer": {
          "Javadoc": "* Gets the default transformer.\n     *\n     * @return the default transformer\n     * @since 3.1"
        },
        "getPredicates": {
          "Javadoc": "* Gets the predicates.\n     *\n     * @return a copy of the predicates\n     * @since 3.1"
        },
        "getTransformers": {
          "Javadoc": "* Gets the transformers.\n     *\n     * @return a copy of the transformers\n     * @since 3.1"
        },
        "transform": {
          "Javadoc": "* Transforms the input to result by calling the transformer whose matching\n     * predicate returns true.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result"
        }
      }
    },
    "org.apache.commons.collections4.functors.TransformedPredicate": {
      "Javadoc": "\n * Predicate implementation that transforms the given object before invoking\n * another {@code Predicate}.\n *\n * @since 3.1\n ",
      "methods": {
        "transformedPredicate": {
          "Javadoc": "* Factory to create the predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param transformer  the transformer to call\n     * @param predicate  the predicate to call with the result of the transform\n     * @return the predicate\n     * @throws NullPointerException if the transformer or the predicate is null"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning the result of the decorated predicate\n     * once the input has been transformed\n     *\n     * @param object  the input object which will be transformed\n     * @return true if decorated predicate returns true"
        },
        "getPredicates": {
          "Javadoc": "* Gets the predicate being decorated.\n     *\n     * @return the predicate as the only element in an array\n     * @since 3.1"
        },
        "getTransformer": {
          "Javadoc": "* Gets the transformer in use.\n     *\n     * @return the transformer"
        }
      }
    },
    "org.apache.commons.collections4.functors.TransformerClosure": {
      "Javadoc": "\n * Closure implementation that calls a Transformer using the input object\n * and ignore the result.\n *\n * @since 3.0\n ",
      "methods": {
        "transformerClosure": {
          "Javadoc": "* Factory method that performs validation.\n     * <p>\n     * A null transformer will return the {@code NOPClosure}.\n     *\n     * @param <E> the type that the closure acts on\n     * @param transformer  the transformer to call, null means nop\n     * @return the {@code transformer} closure"
        },
        "execute": {
          "Javadoc": "* Executes the closure by calling the decorated transformer.\n     *\n     * @param input  the input object"
        },
        "getTransformer": {
          "Javadoc": "* Gets the transformer.\n     *\n     * @return the transformer\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.TransformerPredicate": {
      "Javadoc": "\n * Predicate implementation that returns the result of a transformer.\n *\n * @since 3.0\n ",
      "methods": {
        "transformerPredicate": {
          "Javadoc": "* Factory to create the predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param transformer  the transformer to decorate\n     * @return the predicate\n     * @throws NullPointerException if the transformer is null"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning the result of the decorated transformer.\n     *\n     * @param object  the input object\n     * @return true if decorated transformer returns Boolean.TRUE\n     * @throws FunctorException if the transformer returns an invalid type"
        },
        "getTransformer": {
          "Javadoc": "* Gets the transformer.\n     *\n     * @return the transformer\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.functors.TruePredicate": {
      "Javadoc": "\n * Predicate implementation that always returns true.\n *\n * @since 3.0\n ",
      "methods": {
        "truePredicate": {
          "Javadoc": "* Factory returning the singleton instance.\n     *\n     * @param <T> the type that the predicate queries\n     * @return the singleton instance\n     * @since 3.1"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning true always.\n     *\n     * @param object  the input object\n     * @return true always"
        }
      }
    },
    "org.apache.commons.collections4.functors.UniquePredicate": {
      "Javadoc": "\n * Predicate implementation that returns true the first time an object is\n * passed into the predicate.\n *\n * @since 3.0\n ",
      "methods": {
        "uniquePredicate": {
          "Javadoc": "* Factory to create the predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @return the predicate\n     * @throws IllegalArgumentException if the predicate is null"
        },
        "evaluate": {
          "Javadoc": "* Evaluates the predicate returning true if the input object hasn't been\n     * received yet.\n     *\n     * @param object  the input object\n     * @return true if this is the first time the object is seen"
        }
      }
    },
    "org.apache.commons.collections4.functors.WhileClosure": {
      "Javadoc": "\n * Closure implementation that executes a closure repeatedly until a condition is met,\n * like a do-while or while loop.\n * <p>\n * <b>WARNING:</b> from v4.1 onwards this class will <b>not</b> be serializable anymore\n * in order to prevent potential remote code execution exploits. Please refer to\n * <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-580\">COLLECTIONS-580</a>\n * for more details.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "whileClosure": {
          "Javadoc": "* Factory method that performs validation.\n     *\n     * @param <E> the type that the closure acts on\n     * @param predicate  the predicate used to evaluate when the loop terminates, not null\n     * @param closure  the closure to execute, not null\n     * @param doLoop  true to act as a do-while loop, always executing the closure once\n     * @return the {@code while} closure\n     * @throws NullPointerException if the predicate or closure is null"
        },
        "execute": {
          "Javadoc": "* Executes the closure until the predicate is false.\n     *\n     * @param input  the input object"
        },
        "getClosure": {
          "Javadoc": "* Gets the closure.\n     *\n     * @return the closure\n     * @since 3.1"
        },
        "getPredicate": {
          "Javadoc": "* Gets the predicate in use.\n     *\n     * @return the predicate\n     * @since 3.1"
        },
        "isDoLoop": {
          "Javadoc": "* Is the loop a do-while loop.\n     *\n     * @return true is do-while, false if while\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.Get": {
      "Javadoc": "\n * The \"read\" subset of the {@link java.util.Map} interface.\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n *\n * @since 4.0\n * @see Put\n ",
      "methods": {
        "containsKey": {
          "Javadoc": "* @param key key whose presence in this map is to be tested\n     * @return {@code true} if this map contains a mapping for the specified\n     *         key\n     * @see java.util.Map#containsKey(Object)"
        },
        "containsValue": {
          "Javadoc": "* @param value value whose presence in this map is to be tested\n     * @return {@code true} if this map maps one or more keys to the\n     *         specified value\n     * @see java.util.Map#containsValue(Object)"
        },
        "entrySet": {
          "Javadoc": "* @return a set view of the mappings contained in this map\n     * @see java.util.Map#entrySet()"
        },
        "get": {
          "Javadoc": "* @param key the key whose associated value is to be returned\n     * @return the value to which the specified key is mapped, or\n     *         {@code null} if this map contains no mapping for the key\n     * @see java.util.Map#get(Object)"
        },
        "isEmpty": {
          "Javadoc": "* @return {@code true} if this map contains no key-value mappings\n     * @see java.util.Map#isEmpty()"
        },
        "keySet": {
          "Javadoc": "* @return a set view of the keys contained in this map\n     * @see java.util.Map#keySet()"
        },
        "remove": {
          "Javadoc": "* @param key key whose mapping is to be removed from the map\n     * @return the previous value associated with {@code key}, or\n     *         {@code null} if there was no mapping for {@code key}.\n     * @see java.util.Map#remove(Object)"
        },
        "size": {
          "Javadoc": "* @return the number of key-value mappings in this map\n     * @see java.util.Map#size()"
        },
        "values": {
          "Javadoc": "* @return a collection view of the values contained in this map\n     * @see java.util.Map#values()"
        }
      }
    },
    "org.apache.commons.collections4.IterableGet": {
      "Javadoc": "\n * The \"read\" subset of the {@link java.util.Map} interface.\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n *\n * @since 4.0\n * @see Put\n ",
      "methods": {
        "mapIterator": {
          "Javadoc": "* Obtains a {@code MapIterator} over the map.\n     * <p>\n     * A map iterator is an efficient way of iterating over maps.\n     * There is no need to access the entry set or use Map Entry objects.\n     * <pre>\n     * IterableMap&lt;String,Integer&gt; map = new HashedMap&lt;String,Integer&gt;();\n     * MapIterator&lt;String,Integer&gt; it = map.mapIterator();\n     * while (it.hasNext()) {\n     *   String key = it.next();\n     *   Integer value = it.getValue();\n     *   it.setValue(value + 1);\n     * }\n     * </pre>\n     *\n     * @return a map iterator"
        }
      }
    },
    "org.apache.commons.collections4.IterableMap": {
      "Javadoc": "\n * Defines a map that can be iterated directly without needing to create an entry set.\n * <p>\n * A map iterator is an efficient way of iterating over maps.\n * There is no need to access the entry set or use Map Entry objects.\n * </p>\n * <pre>\n * IterableMap&lt;String,Integer&gt; map = new HashedMap&lt;String,Integer&gt;();\n * MapIterator&lt;String,Integer&gt; it = map.mapIterator();\n * while (it.hasNext()) {\n *   String key = it.next();\n *   Integer value = it.getValue();\n *   it.setValue(value + 1);\n * }\n * </pre>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n *\n * @since 3.0\n "
    },
    "org.apache.commons.collections4.IterableSortedMap": {
      "Javadoc": "\n * {@link SortedMap} + {@link OrderedMap}.\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n *\n * @since 4.0\n "
    },
    "org.apache.commons.collections4.IterableUtils": {
      "Javadoc": "\n * Provides utility methods and decorators for {@link Iterable} instances.\n * <p>\n * <b>Note</b>: this util class has been designed for fail-fast argument checking.\n * </p>\n * <ul>\n * <li>\n * all decorator methods are <b>NOT</b> null-safe wrt the provided Iterable argument, i.e.\n * they will throw a {@link NullPointerException} if a null Iterable is passed as argument.\n * <li>\n * all other utility methods are null-safe wrt the provided Iterable argument, i.e. they will\n * treat a null Iterable the same way as an empty one. Other arguments which are null,\n * e.g. a {@link Predicate}, will result in a {@link NullPointerException}. Exception: passing\n * a null {@link Comparator} is equivalent to a Comparator with natural ordering.\n * </ul>\n *\n * @since 4.1\n ",
      "methods": {
        "boundedIterable": {
          "Javadoc": "* Returns a view of the given iterable that contains at most the given number\n     * of elements.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the corresponding\n     * input iterator supports it.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to limit, may not be null\n     * @param maxSize  the maximum number of elements, must not be negative\n     * @return a bounded view on the specified iterable\n     * @throws IllegalArgumentException if maxSize is negative\n     * @throws NullPointerException if iterable is null"
        },
        "chainedIterable": {
          "Javadoc": "* Combines four iterables into a single iterable.\n     * <p>\n     * The returned iterable has an iterator that traverses the elements in {@code a},\n     * followed by the elements in {@code b}, {@code c} and {@code d}. The source\n     * iterators are not polled until necessary.\n     * </p>\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the corresponding\n     * input iterator supports it.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param a  the first iterable, may not be null\n     * @param b  the second iterable, may not be null\n     * @param c  the third iterable, may not be null\n     * @param d  the fourth iterable, may not be null\n     * @return a new iterable, combining the provided iterables\n     * @throws NullPointerException if either of the provided iterables is null"
        },
        "checkNotNull": {
          "Javadoc": "* Fail-fast check for null arguments.\n     *\n     * @param iterables  the iterables to check\n     * @throws NullPointerException if the argument or any of its contents is null"
        },
        "collatedIterable": {
          "Javadoc": "* Combines the two provided iterables into an ordered iterable using\n     * natural ordering.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the\n     * corresponding input iterator supports it.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param a  the first iterable, must not be null\n     * @param b  the second iterable, must not be null\n     * @return a filtered view on the specified iterable\n     * @throws NullPointerException if either of the provided iterables is null"
        },
        "contains": {
          "Javadoc": "* Checks if the object is contained in the given iterable.\n     * <p>\n     * A {@code null} or empty iterable returns false.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Iterable} contains\n     * @param iterable  the iterable to check, may be null\n     * @param object  the object to check\n     * @return true if the object is contained in the iterable, false otherwise"
        },
        "countMatches": {
          "Javadoc": "* Counts the number of elements in the input iterable that match the predicate.\n     * <p>\n     * A {@code null} iterable matches no elements.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Iterable} contains\n     * @param input  the {@link Iterable} to get the input from, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return the number of matches for the predicate in the collection\n     * @throws NullPointerException if predicate is null"
        },
        "emptyIfNull": {
          "Javadoc": "* Returns an immutable empty iterable if the argument is null,\n     * or the argument itself otherwise.\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable, may be null\n     * @return an empty iterable if the argument is null"
        },
        "emptyIterable": {
          "Javadoc": "* Gets an empty iterable.\n     * <p>\n     * This iterable does not contain any elements.\n     * </p>\n     *\n     * @param <E> the element type\n     * @return an empty iterable"
        },
        "emptyIteratorIfNull": {
          "Javadoc": "* Returns an empty iterator if the argument is {@code null},\n     * or {@code iterable.iterator()} otherwise.\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable, possibly {@code null}\n     * @return an empty iterator if the argument is {@code null}"
        },
        "filteredIterable": {
          "Javadoc": "* Returns a view of the given iterable that only contains elements matching\n     * the provided predicate.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the\n     * corresponding input iterator supports it.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to filter, may not be null\n     * @param predicate  the predicate used to filter elements, may not be null\n     * @return a filtered view on the specified iterable\n     * @throws NullPointerException if either iterable or predicate is null"
        },
        "find": {
          "Javadoc": "* Finds the first element in the given iterable which matches the given predicate.\n     * <p>\n     * A {@code null} or empty iterator returns null.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to search, may be null\n     * @param predicate  the predicate to use, must not be null\n     * @return the first element of the iterable which matches the predicate or null if none could be found\n     * @throws NullPointerException if predicate is null"
        },
        "first": {
          "Javadoc": "* Shortcut for {@code get(iterator, 0)}.\n     * <p>\n     * Returns the {@code first} value in the {@code iterable}'s {@link Iterator}, throwing\n     * {@code IndexOutOfBoundsException} if there is no such element.\n     * </p>\n     * <p>\n     * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n     * </p>\n     *\n     * @param <T> the type of object in the {@link Iterable}.\n     * @param iterable  the {@link Iterable} to get a value from, may be null\n     * @return the first object\n     * @throws IndexOutOfBoundsException if the request  is invalid\n     * @since 4.2"
        },
        "forEach": {
          "Javadoc": "* Applies the closure to each element of the provided iterable.\n     *\n     * @param <E> the element type\n     * @param iterable  the iterator to use, may be null\n     * @param closure  the closure to apply to each element, may not be null\n     * @throws NullPointerException if closure is null"
        },
        "forEachButLast": {
          "Javadoc": "* Executes the given closure on each but the last element in the iterable.\n     * <p>\n     * If the input iterable is null no change is made.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Iterable} contains\n     * @param iterable  the iterable to get the input from, may be null\n     * @param closure  the closure to perform, may not be null\n     * @return the last element in the iterable, or null if iterable is null or empty"
        },
        "frequency": {
          "Javadoc": "* Returns the number of occurrences of the provided object in the iterable.\n     *\n     * @param <E> the element type that the {@link Iterable} may contain\n     * @param <T> the element type of the object to find\n     * @param iterable  the {@link Iterable} to search\n     * @param obj  the object to find the cardinality of\n     * @return the number of occurrences of obj in iterable"
        },
        "get": {
          "Javadoc": "* Returns the {@code index}-th value in the {@code iterable}'s {@link Iterator}, throwing\n     * {@code IndexOutOfBoundsException} if there is no such element.\n     * <p>\n     * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n     * </p>\n     *\n     * @param <T> the type of object in the {@link Iterable}.\n     * @param iterable  the {@link Iterable} to get a value from, may be null\n     * @param index  the index to get\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid"
        },
        "indexOf": {
          "Javadoc": "* Returns the index of the first element in the specified iterable that\n     * matches the given predicate.\n     * <p>\n     * A {@code null} or empty iterable returns -1.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to search, may be null\n     * @param predicate  the predicate to use, must not be null\n     * @return the index of the first element which matches the predicate or -1 if none matches\n     * @throws NullPointerException if predicate is null"
        },
        "isEmpty": {
          "Javadoc": "* Answers true if the provided iterable is empty.\n     * <p>\n     * A {@code null} iterable returns true.\n     * </p>\n     *\n     * @param iterable  the {@link Iterable to use}, may be null\n     * @return true if the iterable is null or empty, false otherwise"
        },
        "loopingIterable": {
          "Javadoc": "* Returns a view of the given iterable which will cycle infinitely over\n     * its elements.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} if\n     * {@code iterable.iterator()} does. After {@code remove()} is called, subsequent\n     * cycles omit the removed element, which is no longer in {@code iterable}. The\n     * iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n     * is empty.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to loop, may not be null\n     * @return a view of the iterable, providing an infinite loop over its elements\n     * @throws NullPointerException if iterable is null"
        },
        "matchesAll": {
          "Javadoc": "* Answers true if a predicate is true for every element of an iterable.\n     * <p>\n     * A {@code null} or empty iterable returns true.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Iterable} contains\n     * @param iterable  the {@link Iterable} to use, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return true if every element of the collection matches the predicate or if the\n     *   collection is empty, false otherwise\n     * @throws NullPointerException if predicate is null"
        },
        "matchesAny": {
          "Javadoc": "* Answers true if a predicate is true for any element of the iterable.\n     * <p>\n     * A {@code null} or empty iterable returns false.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Iterable} contains\n     * @param iterable  the {@link Iterable} to use, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return true if any element of the collection matches the predicate, false otherwise\n     * @throws NullPointerException if predicate is null"
        },
        "partition": {
          "Javadoc": "* Partitions all elements from iterable into separate output collections,\n     * based on the evaluation of the given predicates.\n     * <p>\n     * For each predicate, the result will contain a list holding all elements of the\n     * input iterable matching the predicate. The last list will hold all elements\n     * which didn't match any predicate:\n     * </p>\n     * <pre>\n     *  [C1, C2, R] = partition(I, P1, P2) with\n     *  I = input\n     *  P1 = first predicate\n     *  P2 = second predicate\n     *  C1 = collection of elements matching P1\n     *  C2 = collection of elements matching P2\n     *  R = collection of elements rejected by all predicates\n     * </pre>\n     * <p>\n     * <b>Note</b>: elements are only added to the output collection of the first matching\n     * predicate, determined by the order of arguments.\n     * </p>\n     * <p>\n     * If the input iterable is {@code null}, the same is returned as for an\n     * empty iterable.\n     * </p>\n     * <p>\n     * Example: for an input list [1, 2, 3, 4, 5] calling partition with predicates [x &lt; 3]\n     * and [x &lt; 5] will result in the following output: [[1, 2], [3, 4], [5]].\n     * </p>\n     *\n     * @param <O>  the type of object the {@link Iterable} contains\n     * @param iterable  the collection to get the input from, may be null\n     * @param predicates  the predicates to use, may not be null\n     * @return a list containing the output collections\n     * @throws NullPointerException if any predicate is null"
        },
        "reversedIterable": {
          "Javadoc": "* Returns a reversed view of the given iterable.\n     * <p>\n     * In case the provided iterable is a {@link List} instance, a\n     * {@link ReverseListIterator} will be used to reverse the traversal\n     * order, otherwise an intermediate {@link List} needs to be created.\n     * </p>\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} if the\n     * provided iterable is a {@link List} instance.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to use, may not be null\n     * @return a reversed view of the specified iterable\n     * @throws NullPointerException if iterable is null\n     * @see ReverseListIterator"
        },
        "size": {
          "Javadoc": "* Returns the number of elements contained in the given iterator.\n     * <p>\n     * A {@code null} or empty iterator returns {@code 0}.\n     * </p>\n     *\n     * @param iterable  the iterable to check, may be null\n     * @return the number of elements contained in the iterable"
        },
        "skippingIterable": {
          "Javadoc": "* Returns a view of the given iterable that skips the first N elements.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the corresponding\n     * input iterator supports it.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to use, may not be null\n     * @param elementsToSkip  the number of elements to skip from the start, must not be negative\n     * @return a view of the specified iterable, skipping the first N elements\n     * @throws IllegalArgumentException if elementsToSkip is negative\n     * @throws NullPointerException if iterable is null"
        },
        "toList": {
          "Javadoc": "* Gets a new list with the contents of the provided iterable.\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to use, may be null\n     * @return a list of the iterator contents"
        },
        "toString": {
          "Javadoc": "* Returns a string representation of the elements of the specified iterable.\n     * <p>\n     * The string representation consists of a list of the iterable's elements,\n     * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n     * are separated by the provided {@code delimiter}. Elements are converted to\n     * strings as by using the provided {@code transformer}.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to convert to a string, may be null\n     * @param transformer  the transformer used to get a string representation of an element\n     * @param delimiter  the string to delimit elements\n     * @param prefix  the prefix, prepended to the string representation\n     * @param suffix  the suffix, appended to the string representation\n     * @return a string representation of {@code iterable}\n     * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null"
        },
        "transformedIterable": {
          "Javadoc": "* Returns a transformed view of the given iterable where all of its elements\n     * have been transformed by the provided transformer.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the corresponding\n     * input iterator supports it.\n     * </p>\n     *\n     * @param <I>  the input element type\n     * @param <O>  the output element type\n     * @param iterable  the iterable to transform, may not be null\n     * @param transformer  the transformer, must not be null\n     * @return a transformed view of the specified iterable\n     * @throws NullPointerException if either iterable or transformer is null"
        },
        "uniqueIterable": {
          "Javadoc": "* Returns a unique view of the given iterable.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the\n     * corresponding input iterator supports it. Calling {@code remove()}\n     * will only remove a single element from the underlying iterator.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to use, may not be null\n     * @return a unique view of the specified iterable\n     * @throws NullPointerException if iterable is null"
        },
        "unmodifiableIterable": {
          "Javadoc": "* Returns an unmodifiable view of the given iterable.\n     * <p>\n     * The returned iterable's iterator does not support {@code remove()}.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to use, may not be null\n     * @return an unmodifiable view of the specified iterable\n     * @throws NullPointerException if iterable is null"
        },
        "zippingIterable": {
          "Javadoc": "* Interleaves two iterables into a single iterable.\n     * <p>\n     * The returned iterable has an iterator that traverses the elements in {@code a} and {@code b} in alternating order. The source iterators are not polled\n     * until necessary.\n     * </p>\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the corresponding input iterator supports it.\n     * </p>\n     *\n     * @param <E>    the element type\n     * @param first  the first iterable, may not be null\n     * @param others the array of iterables to interleave, may not be null\n     * @return a new iterable, interleaving the provided iterables\n     * @throws NullPointerException if either of the provided iterables is null"
        }
      }
    },
    "org.apache.commons.collections4.UnmodifiableIterable": {
      "Javadoc": "\n     * Inner class to distinguish unmodifiable instances.\n     "
    },
    "org.apache.commons.collections4.iterators.AbstractEmptyIterator": {
      "Javadoc": "\n * Provides an implementation of an empty iterator.\n *\n * @since 3.1\n "
    },
    "org.apache.commons.collections4.iterators.AbstractEmptyMapIterator": {
      "Javadoc": "\n * Provides an implementation of an empty map iterator.\n *\n * @param <K> the type of keys\n * @param <V> the type of mapped values\n * @since 4.0\n "
    },
    "org.apache.commons.collections4.iterators.AbstractIteratorDecorator": {
      "Javadoc": "\n * Provides basic behavior for decorating an iterator with extra functionality.\n * <p>\n * All methods are forwarded to the decorated iterator.\n * </p>\n *\n * @param <E> the type of the iterator being decorated.\n * @since 3.0\n ",
      "methods": {
        "next": {
          "Javadoc": "{@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.iterators.AbstractListIteratorDecorator": {
      "Javadoc": "\n * Provides basic behavior for decorating a list iterator with extra functionality.\n * <p>\n * All methods are forwarded to the decorated list iterator.\n * </p>\n *\n * @param <E> the type of elements in this iterator.\n * @since 3.0\n ",
      "methods": {
        "add": {
          "Javadoc": "{@inheritDoc}"
        },
        "getListIterator": {
          "Javadoc": "* Gets the iterator being decorated.\n     *\n     * @return the decorated iterator"
        },
        "hasNext": {
          "Javadoc": "{@inheritDoc}"
        },
        "hasPrevious": {
          "Javadoc": "{@inheritDoc}"
        },
        "next": {
          "Javadoc": "{@inheritDoc}"
        },
        "nextIndex": {
          "Javadoc": "{@inheritDoc}"
        },
        "previous": {
          "Javadoc": "{@inheritDoc}"
        },
        "previousIndex": {
          "Javadoc": "{@inheritDoc}"
        },
        "remove": {
          "Javadoc": "{@inheritDoc}"
        },
        "set": {
          "Javadoc": "{@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.iterators.AbstractMapIteratorDecorator": {
      "Javadoc": "\n * Provides basic behavior for decorating a map iterator with extra functionality.\n * <p>\n * All methods are forwarded to the decorated map iterator.\n *\n * @param <K> the type of keys\n * @param <V> the type of mapped values\n * @since 3.0\n ",
      "methods": {
        "getKey": {
          "Javadoc": "{@inheritDoc}"
        },
        "getMapIterator": {
          "Javadoc": "* Gets the iterator being decorated.\n     *\n     * @return the decorated iterator"
        },
        "getValue": {
          "Javadoc": "{@inheritDoc}"
        },
        "hasNext": {
          "Javadoc": "{@inheritDoc}"
        },
        "next": {
          "Javadoc": "{@inheritDoc}"
        },
        "remove": {
          "Javadoc": "{@inheritDoc}"
        },
        "setValue": {
          "Javadoc": "{@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.iterators.AbstractOrderedMapIteratorDecorator": {
      "Javadoc": "\n * Provides basic behavior for decorating an ordered map iterator with extra functionality.\n * <p>\n * All methods are forwarded to the decorated map iterator.\n *\n * @param <K> the type of keys\n * @param <V> the type of mapped values\n * @since 3.0\n ",
      "methods": {
        "getKey": {
          "Javadoc": "{@inheritDoc}"
        },
        "getOrderedMapIterator": {
          "Javadoc": "* Gets the iterator being decorated.\n     *\n     * @return the decorated iterator"
        },
        "getValue": {
          "Javadoc": "{@inheritDoc}"
        },
        "hasNext": {
          "Javadoc": "{@inheritDoc}"
        },
        "hasPrevious": {
          "Javadoc": "{@inheritDoc}"
        },
        "next": {
          "Javadoc": "{@inheritDoc}"
        },
        "previous": {
          "Javadoc": "{@inheritDoc}"
        },
        "remove": {
          "Javadoc": "{@inheritDoc}"
        },
        "setValue": {
          "Javadoc": "{@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.iterators.AbstractUntypedIteratorDecorator": {
      "Javadoc": "\n * Provides basic behavior for decorating an iterator with extra functionality without committing the generic type of the Iterator implementation.\n * <p>\n * All methods are forwarded to the decorated iterator.\n * </p>\n *\n * @param <I> the type of the iterator being decorated.\n * @param <O> the type of elements returned by this iterator.\n *\n * @since 4.0\n ",
      "methods": {
        "getIterator": {
          "Javadoc": "* Gets the iterator being decorated.\n     *\n     * @return the decorated iterator"
        }
      }
    },
    "org.apache.commons.collections4.iterators.ArrayIterator": {
      "Javadoc": "\n * Implements an {@link java.util.Iterator Iterator} over any array.\n * <p>\n * The array can be either an array of object or of primitives. If you know\n * that you have an object array, the\n * {@link org.apache.commons.collections4.iterators.ObjectArrayIterator ObjectArrayIterator}\n * class is a better choice, as it will perform better.\n * <p>\n * The iterator implements a {@link #reset} method, allowing the reset of\n * the iterator back to the start if required.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 1.0\n ",
      "methods": {
        "checkBound": {
          "Javadoc": "* Checks whether the index is valid or not.\n     *\n     * @param bound  the index to check\n     * @param len  the length of the array\n     * @param type  the index type (for error messages)\n     * @throws IndexOutOfBoundsException if the index is invalid"
        },
        "getArray": {
          "Javadoc": "* Gets the array that this iterator is iterating over.\n     *\n     * @return the array this iterator iterates over."
        },
        "getEndIndex": {
          "Javadoc": "* Gets the end index to loop to.\n     *\n     * @return the end index\n     * @since 4.0"
        },
        "getStartIndex": {
          "Javadoc": "* Gets the start index to loop from.\n     *\n     * @return the start index\n     * @since 4.0"
        },
        "hasNext": {
          "Javadoc": "* Returns true if there are more elements to return from the array.\n     *\n     * @return true if there is a next element to return"
        },
        "next": {
          "Javadoc": "* Returns the next element in the array.\n     *\n     * @return the next element in the array\n     * @throws NoSuchElementException if all the elements in the array\n     *  have already been returned"
        },
        "remove": {
          "Javadoc": "* Throws {@link UnsupportedOperationException}.\n     *\n     * @throws UnsupportedOperationException always"
        },
        "reset": {
          "Javadoc": "* Resets the iterator back to the start index."
        }
      }
    },
    "org.apache.commons.collections4.iterators.ArrayListIterator": {
      "Javadoc": "\n * Implements a {@link java.util.ListIterator} over an array.\n * <p>\n * The array can be either an array of object or of primitives. If you know\n * that you have an object array, the {@link ObjectArrayListIterator}\n * class is a better choice, as it will perform better.\n *\n * <p>\n * This iterator does not support {@link #add(Object)} or {@link #remove()}, as the array\n * cannot be changed in size. The {@link #set(Object)} method is supported however.\n *\n * @param <E> the type of elements returned by this iterator.\n * @see org.apache.commons.collections4.iterators.ArrayIterator\n * @see java.util.Iterator\n * @see java.util.ListIterator\n *\n * @since 3.0\n ",
      "methods": {
        "add": {
          "Javadoc": "* This iterator does not support modification of its backing collection, and so will\n     * always throw an {@link UnsupportedOperationException} when this method is invoked.\n     *\n     * @param o  the element to add\n     * @throws UnsupportedOperationException always thrown.\n     * @see java.util.ListIterator#set"
        },
        "hasPrevious": {
          "Javadoc": "* Returns true if there are previous elements to return from the array.\n     *\n     * @return true if there is a previous element to return"
        },
        "next": {
          "Javadoc": "* Gets the next element from the array.\n     *\n     * @return the next element\n     * @throws NoSuchElementException if there is no next element"
        },
        "nextIndex": {
          "Javadoc": "* Gets the next index to be retrieved.\n     *\n     * @return the index of the item to be retrieved next"
        },
        "previous": {
          "Javadoc": "* Gets the previous element from the array.\n     *\n     * @return the previous element\n     * @throws NoSuchElementException if there is no previous element"
        },
        "previousIndex": {
          "Javadoc": "* Gets the index of the item to be retrieved if {@link #previous()} is called.\n     *\n     * @return the index of the item to be retrieved next"
        },
        "reset": {
          "Javadoc": "* Resets the iterator back to the start index."
        },
        "set": {
          "Javadoc": "* Sets the element under the cursor.\n     * <p>\n     * This method sets the element that was returned by the last call\n     * to {@link #next()} of {@link #previous()}.\n     * <p>\n     * <b>Note:</b> {@link java.util.ListIterator} implementations that support\n     * {@code add()} and {@code remove()} only allow {@code set()} to be called\n     * once per call to {@code next()} or {@code previous} (see the {@link java.util.ListIterator}\n     * Javadoc for more details). Since this implementation does\n     * not support {@code add()} or {@code remove()}, {@code set()} may be\n     * called as often as desired.\n     *\n     * @param o  the element to set\n     * @throws IllegalStateException if {@link #next()} or {@link #previous()} has not been called\n     * before {@link #set(Object)}\n     * @see java.util.ListIterator#set"
        }
      }
    },
    "org.apache.commons.collections4.iterators.BoundedIterator": {
      "Javadoc": "\n * Decorates another iterator to return elements in a specific range.\n * <p>\n * The decorated iterator is bounded in the range [offset, offset+max).\n * The {@code offset} corresponds to the position of the first element to\n * be returned from the decorated iterator, and {@code max} is the maximum\n * number of elements to be returned at most.\n * <p>\n * In case an offset parameter other than 0 is provided, the decorated\n * iterator is immediately advanced to this position, skipping all elements\n * before that position.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 4.1\n ",
      "methods": {
        "checkBounds": {
          "Javadoc": "* Checks whether the iterator is still within its bounded range.\n     * @return {@code true} if the iterator is within its bounds, {@code false} otherwise"
        },
        "init": {
          "Javadoc": "* Advances the underlying iterator to the beginning of the bounded range."
        },
        "remove": {
          "Javadoc": "* {@inheritDoc}\n     * <p>\n     * In case an offset other than 0 was specified, the underlying iterator will be advanced\n     * to this position upon creation. A call to {@link #remove()} will still result in an\n     * {@link IllegalStateException} if no explicit call to {@link #next()} has been made prior\n     * to calling {@link #remove()}."
        }
      }
    },
    "org.apache.commons.collections4.iterators.CollatingIterator": {
      "Javadoc": "\n * Provides an ordered iteration over the elements contained in a collection of\n * ordered Iterators.\n * <p>\n * Given two ordered {@link Iterator} instances {@code A} and\n * {@code B}, the {@link #next} method on this iterator will return the\n * lesser of {@code A.next()} and {@code B.next()}.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 2.1\n ",
      "methods": {
        "addIterator": {
          "Javadoc": "* Adds the given {@link Iterator} to the iterators being collated.\n     *\n     * @param iterator the iterator to add to the collation, must not be null\n     * @throws IllegalStateException if iteration has started\n     * @throws NullPointerException if the iterator is null"
        },
        "anyHasNext": {
          "Javadoc": "* Returns {@code true} iff any {@link Iterator} in the given list has\n     * a next value."
        },
        "anyValueSet": {
          "Javadoc": "* Returns {@code true} iff any bit in the given set is\n     * {@code true}."
        },
        "checkNotStarted": {
          "Javadoc": "* Throws {@link IllegalStateException} if iteration has started via\n     * {@link #start}.\n     *\n     * @throws IllegalStateException if iteration started"
        },
        "clear": {
          "Javadoc": "* Clears the {@link #values} and {@link #valueSet} attributes at position\n     * <i>i</i>."
        },
        "getComparator": {
          "Javadoc": "* Gets the {@link Comparator} by which collation occurs.\n     *\n     * @return the {@link Comparator}"
        },
        "getIteratorIndex": {
          "Javadoc": "* Returns the index of the iterator that returned the last element.\n     *\n     * @return the index of the iterator that returned the last element\n     * @throws IllegalStateException if there is no last returned element"
        },
        "getIterators": {
          "Javadoc": "* Gets the list of Iterators (unmodifiable).\n     *\n     * @return the unmodifiable list of iterators added"
        },
        "hasNext": {
          "Javadoc": "* Returns {@code true} if any child iterator has remaining elements.\n     *\n     * @return true if this iterator has remaining elements"
        },
        "least": {
          "Javadoc": "* Returns the index of the least element in {@link #values},\n     * {@link #set(int) setting} any uninitialized values.\n     *\n     * @throws NullPointerException if no comparator is set"
        },
        "next": {
          "Javadoc": "* Returns the next ordered element from a child iterator.\n     *\n     * @return the next ordered element\n     * @throws NoSuchElementException if no child iterator has any more elements"
        },
        "remove": {
          "Javadoc": "* Removes the last returned element from the child iterator that produced it.\n     *\n     * @throws IllegalStateException if there is no last returned element, or if\n     * the last returned element has already been removed"
        },
        "set": {
          "Javadoc": "* Sets the {@link #values} and {@link #valueSet} attributes at position\n     * <i>i</i> to the next value of the {@link #iterators iterator} at position\n     * <i>i</i>, or clear them if the <i>i</i><sup>th</sup> iterator has no next\n     * value.\n     *\n     * @return {@code false} iff there was no value to set"
        },
        "setComparator": {
          "Javadoc": "* Sets the {@link Comparator} by which collation occurs. If you\n     * would like to use the natural sort order (or, in other words,\n     * if the elements in the iterators are implementing the\n     * {@link Comparable} interface), then use the\n     * {@link org.apache.commons.collections4.comparators.ComparableComparator}.\n     *\n     * @param comp the {@link Comparator} to set\n     * @throws IllegalStateException if iteration has started"
        },
        "setIterator": {
          "Javadoc": "* Sets the iterator at the given index.\n     *\n     * @param index index of the Iterator to replace\n     * @param iterator Iterator to place at the given index\n     * @throws IndexOutOfBoundsException if index &lt; 0 or index &gt;= size()\n     * @throws IllegalStateException if iteration has started\n     * @throws NullPointerException if the iterator is null"
        },
        "start": {
          "Javadoc": "* Initializes the collating state if it hasn't been already."
        }
      }
    },
    "org.apache.commons.collections4.iterators.EmptyIterator": {
      "Javadoc": "\n * Provides an implementation of an empty iterator.\n * <p>\n * This class provides an implementation of an empty iterator.\n * This class provides for binary compatibility between Commons Collections\n * 2.1.1 and 3.1 due to issues with {@code IteratorUtils}.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 2.1.1 and 3.1\n ",
      "methods": {
        "emptyIterator": {
          "Javadoc": "* Gets a typed empty iterator instance.\n     * @param <E> the element type\n     * @return Iterator&lt;E&gt;"
        },
        "resettableEmptyIterator": {
          "Javadoc": "* Gets a typed resettable empty iterator instance.\n     * @param <E> the element type\n     * @return ResettableIterator&lt;E&gt;"
        }
      }
    },
    "org.apache.commons.collections4.iterators.EmptyListIterator": {
      "Javadoc": "\n * Provides an implementation of an empty list iterator.\n * <p>\n * This class provides an implementation of an empty list iterator. This class\n * provides for binary compatibility between Commons Collections 2.1.1 and 3.1\n * due to issues with {@code IteratorUtils}.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 2.1.1 and 3.1\n ",
      "methods": {
        "emptyListIterator": {
          "Javadoc": "* Gets a typed instance of the iterator.\n     * @param <E> the element type\n     * @return {@link ListIterator}&lt;E&gt;"
        },
        "resettableEmptyListIterator": {
          "Javadoc": "* Gets a typed instance of the iterator.\n     * @param <E> the element type\n     * @return {@link ResettableListIterator}&lt;E&gt;"
        }
      }
    },
    "org.apache.commons.collections4.iterators.EmptyMapIterator": {
      "Javadoc": "\n * Provides an implementation of an empty map iterator.\n *\n * @param <K> the type of keys\n * @param <V> the type of mapped values\n * @since 3.1\n ",
      "methods": {
        "emptyMapIterator": {
          "Javadoc": "* Gets a typed instance of the iterator.\n     * @param <K> the key type\n     * @param <V> the value type\n     * @return {@link MapIterator}&lt;K, V&gt;"
        }
      }
    },
    "org.apache.commons.collections4.iterators.EmptyOrderedIterator": {
      "Javadoc": "\n * Provides an implementation of an empty ordered iterator.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 3.1\n ",
      "methods": {
        "emptyOrderedIterator": {
          "Javadoc": "* Typed instance of the iterator.\n     * @param <E> the element type\n     * @return OrderedIterator&lt;E&gt;"
        }
      }
    },
    "org.apache.commons.collections4.iterators.EmptyOrderedMapIterator": {
      "Javadoc": "\n * Provides an implementation of an empty ordered map iterator.\n *\n * @param <K> the type of keys\n * @param <V> the type of mapped values\n * @since 3.1\n ",
      "methods": {
        "emptyOrderedMapIterator": {
          "Javadoc": "* Gets a typed instance of the iterator.\n     * @param <K> the key type\n     * @param <V> the value type\n     * @return {@link OrderedMapIterator}&lt;K, V&gt;"
        }
      }
    },
    "org.apache.commons.collections4.iterators.EntrySetMapIterator": {
      "Javadoc": "\n * Implements a {@code MapIterator} using a Map entrySet.\n * Reverse iteration is not supported.\n * <pre>\n * MapIterator it = map.mapIterator();\n * while (it.hasNext()) {\n *   Object key = it.next();\n *   Object value = it.getValue();\n *   it.setValue(newValue);\n * }\n * </pre>\n *\n * @param <K> the type of keys\n * @param <V> the type of mapped values\n * @since 3.0\n ",
      "methods": {
        "getKey": {
          "Javadoc": "* Gets the current key, which is the key returned by the last call\n     * to {@code next()}.\n     *\n     * @return the current key\n     * @throws IllegalStateException if {@code next()} has not yet been called"
        },
        "getValue": {
          "Javadoc": "* Gets the current value, which is the value associated with the last key\n     * returned by {@code next()}.\n     *\n     * @return the current value\n     * @throws IllegalStateException if {@code next()} has not yet been called"
        },
        "hasNext": {
          "Javadoc": "* Checks to see if there are more entries still to be iterated.\n     *\n     * @return {@code true} if the iterator has more elements"
        },
        "next": {
          "Javadoc": "* Gets the next <em>key</em> from the {@code Map}.\n     *\n     * @return the next key in the iteration\n     * @throws java.util.NoSuchElementException if the iteration is finished"
        },
        "remove": {
          "Javadoc": "* Removes the last returned key from the underlying {@code Map}.\n     * <p>\n     * This method can be called once per call to {@code next()}.\n     *\n     * @throws UnsupportedOperationException if remove is not supported by the map\n     * @throws IllegalStateException if {@code next()} has not yet been called\n     * @throws IllegalStateException if {@code remove()} has already been called\n     *  since the last call to {@code next()}"
        },
        "reset": {
          "Javadoc": "* Resets the state of the iterator."
        },
        "setValue": {
          "Javadoc": "* Sets the value associated with the current key.\n     *\n     * @param value  the new value\n     * @return the previous value\n     * @throws UnsupportedOperationException if setValue is not supported by the map\n     * @throws IllegalStateException if {@code next()} has not yet been called\n     * @throws IllegalStateException if {@code remove()} has been called since the\n     *  last call to {@code next()}"
        },
        "toString": {
          "Javadoc": "* Gets the iterator as a String.\n     *\n     * @return a string version of the iterator"
        }
      }
    },
    "org.apache.commons.collections4.iterators.EnumerationIterator": {
      "Javadoc": "\n * Adapter to make {@link Enumeration Enumeration} instances appear\n * to be {@link Iterator Iterator} instances.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 1.0\n ",
      "methods": {
        "getEnumeration": {
          "Javadoc": "* Returns the underlying enumeration.\n     *\n     * @return the underlying enumeration"
        },
        "hasNext": {
          "Javadoc": "* Returns true if the underlying enumeration has more elements.\n     *\n     * @return true if the underlying enumeration has more elements\n     * @throws NullPointerException  if the underlying enumeration is null"
        },
        "next": {
          "Javadoc": "* Returns the next object from the enumeration.\n     *\n     * @return the next object from the enumeration\n     * @throws NullPointerException if the enumeration is null"
        },
        "remove": {
          "Javadoc": "* Removes the last retrieved element if a collection is attached.\n     * <p>\n     * Functions if an associated {@code Collection} is known.\n     * If so, the first occurrence of the last returned object from this\n     * iterator will be removed from the collection.\n     *\n     * @throws IllegalStateException {@code next()} not called.\n     * @throws UnsupportedOperationException if no associated collection"
        },
        "setEnumeration": {
          "Javadoc": "* Sets the underlying enumeration.\n     *\n     * @param enumeration  the new underlying enumeration"
        }
      }
    },
    "org.apache.commons.collections4.iterators.FilterIterator": {
      "Javadoc": "\n * Decorates another {@link Iterator} using a predicate to filter elements.\n * <p>\n * This iterator decorates the underlying iterator, only allowing through\n * those elements that match the specified {@link Predicate Predicate}.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 1.0\n ",
      "methods": {
        "getIterator": {
          "Javadoc": "* Gets the iterator this iterator is using.\n     *\n     * @return the iterator"
        },
        "getPredicate": {
          "Javadoc": "* Gets the predicate this iterator is using.\n     *\n     * @return the predicate"
        },
        "hasNext": {
          "Javadoc": "* Returns true if the underlying iterator contains an object that\n     * matches the predicate.\n     *\n     * @return true if there is another object that matches the predicate\n     * @throws NullPointerException if either the iterator or predicate are null"
        },
        "next": {
          "Javadoc": "* Returns the next object that matches the predicate.\n     *\n     * @return the next object which matches the given predicate\n     * @throws NullPointerException if either the iterator or predicate are null\n     * @throws NoSuchElementException if there are no more elements that\n     *  match the predicate"
        },
        "remove": {
          "Javadoc": "* Removes from the underlying collection of the base iterator the last\n     * element returned by this iterator.\n     * This method can only be called\n     * if {@code next()} was called, but not after\n     * {@code hasNext()}, because the {@code hasNext()} call\n     * changes the base iterator.\n     *\n     * @throws IllegalStateException if {@code hasNext()} has already\n     *  been called."
        },
        "setIterator": {
          "Javadoc": "* Sets the iterator for this iterator to use.\n     * If iteration has started, this effectively resets the iterator.\n     *\n     * @param iterator  the iterator to use"
        },
        "setNextObject": {
          "Javadoc": "* Sets nextObject to the next object. If there are no more\n     * objects, then return false. Otherwise, return true."
        },
        "setPredicate": {
          "Javadoc": "* Sets the predicate this the iterator to use.\n     *\n     * @param predicate  the predicate to use"
        }
      }
    },
    "org.apache.commons.collections4.iterators.FilterListIterator": {
      "Javadoc": "\n * Decorates another {@link ListIterator} using a predicate to filter elements.\n * <p>\n * This iterator decorates the underlying iterator, only allowing through\n * those elements that match the specified {@link Predicate Predicate}.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 2.0\n ",
      "methods": {
        "add": {
          "Javadoc": "* Not supported.\n     * @param o the element to insert"
        },
        "getListIterator": {
          "Javadoc": "* Gets the iterator this iterator is using.\n     *\n     * @return the iterator."
        },
        "getPredicate": {
          "Javadoc": "* Gets the predicate this iterator is using.\n     *\n     * @return the predicate."
        },
        "remove": {
          "Javadoc": "Not supported."
        },
        "set": {
          "Javadoc": "* Not supported.\n     * @param o the element with which to replace the last element returned by\n     *          {@code next} or {@code previous}"
        },
        "setListIterator": {
          "Javadoc": "* Sets the iterator for this iterator to use.\n     * If iteration has started, this effectively resets the iterator.\n     *\n     * @param iterator  the iterator to use"
        },
        "setPredicate": {
          "Javadoc": "* Sets the predicate this the iterator to use.\n     *\n     * @param predicate  the transformer to use"
        }
      }
    },
    "org.apache.commons.collections4.iterators.IteratorChain": {
      "Javadoc": "\n * An IteratorChain is an Iterator that wraps a number of Iterators.\n * <p>\n * This class makes multiple iterators look like one to the caller. When any\n * method from the Iterator interface is called, the IteratorChain will delegate\n * to a single underlying Iterator. The IteratorChain will invoke the Iterators\n * in sequence until all Iterators are exhausted.\n * <p>\n * Under many circumstances, linking Iterators together in this manner is more\n * efficient (and convenient) than reading out the contents of each Iterator\n * into a List and creating a new Iterator.\n * <p>\n * Calling a method that adds new Iterator <i>after a method in the Iterator\n * interface has been called</i> will result in an UnsupportedOperationException.\n * <p>\n * NOTE: As from version 3.0, the IteratorChain may contain no iterators. In\n * this case the class will function as an empty iterator.\n * <p>\n * NOTE: As from version 4.0, the IteratorChain stores the iterators in a queue\n * and removes any reference to them as soon as they are not used anymore. Thus,\n * the methods {@code setIterator(Iterator)} and {@code getIterators()} have been\n * removed and {@link #size()} will return the number of remaining iterators in\n * the queue.\n *\n * @param <E> the type of elements in this iterator.\n * @since 2.1\n ",
      "methods": {
        "addIterator": {
          "Javadoc": "* Add an Iterator to the end of the chain\n     *\n     * @param iterator Iterator to add\n     * @throws IllegalStateException if I've already started iterating\n     * @throws NullPointerException if the iterator is null"
        },
        "checkLocked": {
          "Javadoc": "* Checks whether the iterator chain is now locked and in use."
        },
        "hasNext": {
          "Javadoc": "* Return true if any Iterator in the IteratorChain has a remaining element.\n     *\n     * @return true if elements remain"
        },
        "isLocked": {
          "Javadoc": "* Determine if modifications can still be made to the IteratorChain.\n     * IteratorChains cannot be modified once they have executed a method from\n     * the Iterator interface.\n     *\n     * @return true if IteratorChain cannot be modified, false if it can"
        },
        "lockChain": {
          "Javadoc": "* Lock the chain so no more iterators can be added. This must be called\n     * from all Iterator interface methods."
        },
        "next": {
          "Javadoc": "* Returns the next Object of the current Iterator\n     *\n     * @return Object from the current Iterator\n     * @throws java.util.NoSuchElementException if all the Iterators are\n     * exhausted"
        },
        "remove": {
          "Javadoc": "* Removes from the underlying collection the last element returned by the\n     * Iterator. As with next() and hasNext(), this method calls remove() on the\n     * underlying Iterator. Therefore, this method may throw an\n     * UnsupportedOperationException if the underlying Iterator does not support\n     * this method.\n     *\n     * @throws UnsupportedOperationException if the remove operator is not\n     * supported by the underlying Iterator\n     * @throws IllegalStateException if the next method has not yet been called,\n     * or the remove method has already been called after the last call to the\n     * next method."
        },
        "size": {
          "Javadoc": "* Returns the remaining number of Iterators in the current IteratorChain.\n     *\n     * @return Iterator count"
        },
        "updateCurrentIterator": {
          "Javadoc": "* Updates the current iterator field to ensure that the current Iterator is\n     * not exhausted"
        }
      }
    },
    "org.apache.commons.collections4.iterators.IteratorEnumeration": {
      "Javadoc": "\n * Adapter to make an {@link Iterator Iterator} instance appear to be an\n * {@link Enumeration Enumeration} instance.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 1.0\n ",
      "methods": {
        "getIterator": {
          "Javadoc": "* Returns the underlying iterator.\n     *\n     * @return the underlying iterator"
        },
        "hasMoreElements": {
          "Javadoc": "* Returns true if the underlying iterator has more elements.\n     *\n     * @return true if the underlying iterator has more elements"
        },
        "nextElement": {
          "Javadoc": "* Returns the next element from the underlying iterator.\n     *\n     * @return the next element from the underlying iterator.\n     * @throws java.util.NoSuchElementException if the underlying iterator has\n     * no more elements"
        },
        "setIterator": {
          "Javadoc": "* Sets the underlying iterator.\n     *\n     * @param iterator the new underlying iterator"
        }
      }
    },
    "org.apache.commons.collections4.iterators.IteratorIterable": {
      "Javadoc": "\n * Adapter to make an {@link Iterator Iterator} instance appear to be an\n * {@link Iterable Iterable} instance.  The iterable can be constructed in one\n * of two variants:  single use, multiple use.\n *\n * <p>\n * In the single use iterable case, the iterable is only usable for one\n * iterative operation over the source iterator.  Subsequent iterative\n * operations use the same, exhausted source iterator.  To create a single use\n * iterable, construct a new {@link IteratorIterable} using a {@link Iterator}\n * that is NOT a {@link ResettableIterator} iterator:\n * </p>\n *\n * <pre>\n *   Iterator&lt;Integer&gt; iterator = // some non-resettable iterator\n *   Iterable&lt;Integer&gt; iterable = new IteratorIterable&lt;Integer&gt;(iterator);\n * </pre>\n *\n * <p>\n * In the multiple use iterable case, the iterable is usable for any number of\n * iterative operations over the source iterator.  Of special note, even though\n * the iterable supports multiple iterations, it does not support concurrent\n * iterations. To implicitly create a multiple use iterable, construct a new\n * {@link IteratorIterable} using a {@link ResettableIterator} iterator:\n * </p>\n *\n * <pre>\n *   Integer[] array = {Integer.valueOf(1),Integer.valueOf(2),Integer.valueOf(3)};\n *   Iterator&lt;Integer&gt; iterator = IteratorUtils.arrayIterator(array); // a resettable iterator\n *   Iterable&lt;Integer&gt; iterable = new IteratorIterable&lt;Integer&gt;(iterator);\n * </pre>\n *\n * <p>\n * A multiple use iterable can also be explicitly constructed using any\n * {@link Iterator} and specifying {@code true} for the\n * {@code multipleUse} flag:\n * </p>\n *\n * <pre>\n *   Iterator&lt;Integer&gt; iterator = // some non-resettable iterator\n *   Iterable&lt;Integer&gt; iterable = new IteratorIterable&lt;Integer&gt;(iterator, true);\n * </pre>\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 4.0\n ",
      "methods": {
        "createTypesafeIterator": {
          "Javadoc": "* Factory method to create an {@link Iterator Iterator} from another\n     * iterator over objects of a different subtype."
        },
        "iterator": {
          "Javadoc": "* Gets the iterator wrapped by this iterable.\n     *\n     * @return the iterator"
        }
      }
    },
    "org.apache.commons.collections4.iterators.LazyIteratorChain": {
      "Javadoc": "\n * An LazyIteratorChain is an Iterator that wraps a number of Iterators in a lazy manner.\n * <p>\n * This class makes multiple iterators look like one to the caller. When any\n * method from the Iterator interface is called, the LazyIteratorChain will delegate\n * to a single underlying Iterator. The LazyIteratorChain will invoke the Iterators\n * in sequence until all Iterators are exhausted.\n * <p>\n * The Iterators are provided by {@link #nextIterator(int)} which has to be overridden by\n * subclasses and allows to lazily create the Iterators as they are accessed:\n * <pre>\n * return new LazyIteratorChain&lt;String&gt;() {\n *     protected Iterator&lt;String&gt; nextIterator(int count) {\n *         return count == 1 ? Arrays.asList(\"foo\", \"bar\").iterator() : null;\n *     }\n * };\n * </pre>\n * <p>\n * Once the inner Iterator's {@link Iterator#hasNext()} method returns false,\n * {@link #nextIterator(int)} will be called to obtain another iterator, and so on\n * until {@link #nextIterator(int)} returns null, indicating that the chain is exhausted.\n * <p>\n * NOTE: The LazyIteratorChain may contain no iterators. In this case the class will\n * function as an empty iterator.\n *\n * @param <E> the type of elements in this iterator.\n * @since 4.0\n ",
      "methods": {
        "hasNext": {
          "Javadoc": "* Return true if any Iterator in the chain has a remaining element.\n     *\n     * @return true if elements remain"
        },
        "next": {
          "Javadoc": "* Returns the next element of the current Iterator\n     *\n     * @return element from the current Iterator\n     * @throws java.util.NoSuchElementException if all the Iterators are exhausted"
        },
        "nextIterator": {
          "Javadoc": "* Gets the next iterator after the previous one has been exhausted.\n     * <p>\n     * This method <b>MUST</b> return null when there are no more iterators.\n     *\n     * @param count the number of time this method has been called (starts with 1)\n     * @return the next iterator, or null if there are no more."
        },
        "remove": {
          "Javadoc": "* Removes from the underlying collection the last element returned by the Iterator.\n     * <p>\n     * As with next() and hasNext(), this method calls remove() on the underlying Iterator.\n     * Therefore, this method may throw an UnsupportedOperationException if the underlying\n     * Iterator does not support this method.\n     *\n     * @throws UnsupportedOperationException if the remove operator is not\n     *   supported by the underlying Iterator\n     * @throws IllegalStateException if the next method has not yet been called,\n     *   or the remove method has already been called after the last call to the next method."
        },
        "updateCurrentIterator": {
          "Javadoc": "* Updates the current iterator field to ensure that the current Iterator\n     * is not exhausted."
        }
      }
    },
    "org.apache.commons.collections4.iterators.ListIteratorWrapper": {
      "Javadoc": "\n * Converts an {@link Iterator} into a {@link ResettableListIterator}.\n * For plain {@code Iterator}s this is accomplished by caching the returned\n * elements.  This class can also be used to simply add\n * {@link org.apache.commons.collections4.ResettableIterator ResettableIterator}\n * functionality to a given {@link ListIterator}.\n * <p>\n * The {@code ListIterator} interface has additional useful methods\n * for navigation - {@code previous()} and the index methods.\n * This class allows a regular {@code Iterator} to behave as a\n * {@code ListIterator}. It achieves this by building a list internally\n * of as the underlying iterator is traversed.\n * <p>\n * The optional operations of {@code ListIterator} are not supported for plain {@code Iterator}s.\n * <p>\n * This class implements ResettableListIterator from Commons Collections 3.2.\n *\n * @param <E> the type of elements in this iterator.\n * @since 2.1\n ",
      "methods": {
        "add": {
          "Javadoc": "* Throws {@link UnsupportedOperationException}\n     * unless the underlying {@code Iterator} is a {@code ListIterator}.\n     *\n     * @param obj  the object to add\n     * @throws UnsupportedOperationException if the underlying iterator is not of\n     * type {@link ListIterator}"
        },
        "hasNext": {
          "Javadoc": "* Returns true if there are more elements in the iterator.\n     *\n     * @return true if there are more elements"
        },
        "hasPrevious": {
          "Javadoc": "* Returns true if there are previous elements in the iterator.\n     *\n     * @return true if there are previous elements"
        },
        "next": {
          "Javadoc": "* Returns the next element from the iterator.\n     *\n     * @return the next element from the iterator\n     * @throws NoSuchElementException if there are no more elements"
        },
        "nextIndex": {
          "Javadoc": "* Returns the index of the next element.\n     *\n     * @return the index of the next element"
        },
        "previous": {
          "Javadoc": "* Returns the previous element.\n     *\n     * @return the previous element\n     * @throws NoSuchElementException  if there are no previous elements"
        },
        "previousIndex": {
          "Javadoc": "* Returns the index of the previous element.\n     *\n     * @return  the index of the previous element"
        },
        "remove": {
          "Javadoc": "* Removes the last element that was returned by {@link #next()} or {@link #previous()} from the underlying collection.\n     * This call can only be made once per call to {@code next} or {@code previous} and only if {@link #add(Object)} was not called in between.\n     *\n     * @throws IllegalStateException if {@code next} or {@code previous} have not been called before, or if {@code remove} or {@code add} have been called after the last call to {@code next} or {@code previous}"
        },
        "reset": {
          "Javadoc": "* Resets this iterator back to the position at which the iterator\n     * was created.\n     *\n     * @since 3.2"
        },
        "set": {
          "Javadoc": "* Throws {@link UnsupportedOperationException}\n     * unless the underlying {@code Iterator} is a {@code ListIterator}.\n     *\n     * @param obj  the object to set\n     * @throws UnsupportedOperationException if the underlying iterator is not of\n     * type {@link ListIterator}"
        }
      }
    },
    "org.apache.commons.collections4.iterators.LoopingIterator": {
      "Javadoc": "\n * An Iterator that restarts when it reaches the end.\n * <p>\n * The iterator will loop continuously around the provided elements, unless\n * there are no elements in the collection to begin with, or all the elements\n * have been {@link #remove removed}.\n * <p>\n * Concurrent modifications are not directly supported, and for most collection\n * implementations will throw a ConcurrentModificationException.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 3.0\n ",
      "methods": {
        "hasNext": {
          "Javadoc": "* Has the iterator any more elements.\n     * <p>\n     * Returns false only if the collection originally had zero elements, or\n     * all the elements have been {@link #remove removed}.\n     *\n     * @return {@code true} if there are more elements"
        },
        "next": {
          "Javadoc": "* Returns the next object in the collection.\n     * <p>\n     * If at the end of the collection, return the first element.\n     *\n     * @return the next object\n     * @throws NoSuchElementException if there are no elements\n     *         at all.  Use {@link #hasNext} to avoid this error."
        },
        "remove": {
          "Javadoc": "* Removes the previously retrieved item from the underlying collection.\n     * <p>\n     * This feature is only supported if the underlying collection's\n     * {@link Collection#iterator iterator} method returns an implementation\n     * that supports it.\n     * <p>\n     * This method can only be called after at least one {@link #next} method call.\n     * After a removal, the remove method may not be called again until another\n     * next has been performed. If the {@link #reset} is called, then remove may\n     * not be called until {@link #next} is called again."
        },
        "reset": {
          "Javadoc": "* Resets the iterator back to the start of the collection."
        },
        "size": {
          "Javadoc": "* Gets the size of the collection underlying the iterator.\n     *\n     * @return the current collection size"
        }
      }
    },
    "org.apache.commons.collections4.iterators.LoopingListIterator": {
      "Javadoc": "\n * A ListIterator that restarts when it reaches the end or when it\n * reaches the beginning.\n * <p>\n * The iterator will loop continuously around the provided list,\n * unless there are no elements in the collection to begin with, or\n * all of the elements have been {@link #remove removed}.\n * <p>\n * Concurrent modifications are not directly supported, and for most\n * collection implementations will throw a\n * ConcurrentModificationException.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 3.2\n ",
      "methods": {
        "add": {
          "Javadoc": "* Inserts the specified element into the underlying list.\n     * <p>\n     * The element is inserted before the next element that would be\n     * returned by {@link #next}, if any, and after the next element\n     * that would be returned by {@link #previous}, if any.\n     * <p>\n     * This feature is only supported if the underlying list's\n     * {@link List#listIterator} method returns an implementation\n     * that supports it.\n     *\n     * @param obj  the element to insert\n     * @throws UnsupportedOperationException if the add method is not\n     *  supported by the iterator implementation of the underlying list"
        },
        "hasNext": {
          "Javadoc": "* Returns whether this iterator has any more elements.\n     * <p>\n     * Returns false only if the list originally had zero elements, or\n     * all elements have been {@link #remove removed}.\n     *\n     * @return {@code true} if there are more elements"
        },
        "hasPrevious": {
          "Javadoc": "* Returns whether this iterator has any more previous elements.\n     * <p>\n     * Returns false only if the list originally had zero elements, or\n     * all elements have been {@link #remove removed}.\n     *\n     * @return {@code true} if there are more elements"
        },
        "next": {
          "Javadoc": "* Returns the next object in the list.\n     * <p>\n     * If at the end of the list, returns the first element.\n     *\n     * @return the object after the last element returned\n     * @throws NoSuchElementException if there are no elements in the list"
        },
        "nextIndex": {
          "Javadoc": "* Returns the index of the element that would be returned by a\n     * subsequent call to {@link #next}.\n     * <p>\n     * As would be expected, if the iterator is at the physical end of\n     * the underlying list, 0 is returned, signifying the beginning of\n     * the list.\n     *\n     * @return the index of the element that would be returned if next() were called\n     * @throws NoSuchElementException if there are no elements in the list"
        },
        "previous": {
          "Javadoc": "* Returns the previous object in the list.\n     * <p>\n     * If at the beginning of the list, return the last element. Note\n     * that in this case, traversal to find that element takes linear time.\n     *\n     * @return the object before the last element returned\n     * @throws NoSuchElementException if there are no elements in the list"
        },
        "previousIndex": {
          "Javadoc": "* Returns the index of the element that would be returned by a\n     * subsequent call to {@link #previous}.\n     * <p>\n     * As would be expected, if at the iterator is at the physical\n     * beginning of the underlying list, the list's size minus one is\n     * returned, signifying the end of the list.\n     *\n     * @return the index of the element that would be returned if previous() were called\n     * @throws NoSuchElementException if there are no elements in the list"
        },
        "remove": {
          "Javadoc": "* Removes the previously retrieved item from the underlying list.\n     * <p>\n     * This feature is only supported if the underlying list's\n     * {@link List#iterator iterator} method returns an implementation\n     * that supports it.\n     * <p>\n     * This method can only be called after at least one {@link #next}\n     * or {@link #previous} method call. After a removal, the remove\n     * method may not be called again until another {@link #next} or\n     * {@link #previous} has been performed. If the {@link #reset} is\n     * called, then remove may not be called until {@link #next} or\n     * {@link #previous} is called again.\n     *\n     * @throws UnsupportedOperationException if the remove method is\n     * not supported by the iterator implementation of the underlying\n     * list"
        },
        "reset": {
          "Javadoc": "* Resets the iterator back to the start of the list."
        },
        "set": {
          "Javadoc": "* Replaces the last element that was returned by {@link #next} or\n     * {@link #previous}.\n     * <p>\n     * This feature is only supported if the underlying list's\n     * {@link List#listIterator} method returns an implementation\n     * that supports it.\n     *\n     * @param obj  the element with which to replace the last element returned\n     * @throws UnsupportedOperationException if the set method is not\n     *  supported by the iterator implementation of the underlying list"
        },
        "size": {
          "Javadoc": "* Gets the size of the list underlying the iterator.\n     *\n     * @return the current list size"
        }
      }
    },
    "org.apache.commons.collections4.iterators.NodeListIterator": {
      "Javadoc": "\n * An {@link Iterator} over a {@link NodeList}.\n * <p>\n * This iterator does not support {@link #remove()} as a {@link NodeList} does not support\n * removal of items.\n *\n * @since 4.0\n * @see NodeList\n ",
      "methods": {
        "remove": {
          "Javadoc": "* Throws {@link UnsupportedOperationException}.\n     *\n     * @throws UnsupportedOperationException always"
        }
      }
    },
    "org.apache.commons.collections4.iterators.ObjectArrayIterator": {
      "Javadoc": "\n * An {@link java.util.Iterator Iterator} over an array of objects.\n * <p>\n * This iterator does not support {@link #remove}, as the object array cannot be\n * structurally modified.\n * <p>\n * The iterator implements a {@link #reset} method, allowing the reset of the iterator\n * back to the start if required.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 3.0\n ",
      "methods": {
        "getArray": {
          "Javadoc": "* Gets the array that this iterator is iterating over.\n     *\n     * @return the array this iterator iterates over"
        },
        "getEndIndex": {
          "Javadoc": "* Gets the end index to loop to.\n     *\n     * @return the end index"
        },
        "getStartIndex": {
          "Javadoc": "* Gets the start index to loop from.\n     *\n     * @return the start index"
        },
        "hasNext": {
          "Javadoc": "* Returns true if there are more elements to return from the array.\n     *\n     * @return true if there is a next element to return"
        },
        "next": {
          "Javadoc": "* Returns the next element in the array.\n     *\n     * @return the next element in the array\n     * @throws NoSuchElementException if all the elements in the array\n     *    have already been returned"
        },
        "remove": {
          "Javadoc": "* Throws {@link UnsupportedOperationException}.\n     *\n     * @throws UnsupportedOperationException always"
        },
        "reset": {
          "Javadoc": "* Resets the iterator back to the start index."
        }
      }
    },
    "org.apache.commons.collections4.iterators.ObjectArrayListIterator": {
      "Javadoc": "\n * Implements a {@link java.util.ListIterator} over an array of objects.\n * <p>\n * This iterator does not support {@link #add} or {@link #remove}, as the object array\n * cannot be structurally modified. The {@link #set} method is supported however.\n * <p>\n * The iterator implements a {@link #reset} method, allowing the reset of the iterator\n * back to the start if required.\n *\n * @param <E> the type of elements returned by this iterator.\n * @see org.apache.commons.collections4.iterators.ObjectArrayIterator\n * @see java.util.Iterator\n * @see java.util.ListIterator\n *\n * @since 3.0\n ",
      "methods": {
        "add": {
          "Javadoc": "* This iterator does not support modification of its backing array's size, and so will\n     * always throw an {@link UnsupportedOperationException} when this method is invoked.\n     *\n     * @param obj  the object to add\n     * @throws UnsupportedOperationException always thrown."
        },
        "hasPrevious": {
          "Javadoc": "* Returns true if there are previous elements to return from the array.\n     *\n     * @return true if there is a previous element to return"
        },
        "next": {
          "Javadoc": "* Gets the next element from the array.\n     *\n     * @return the next element\n     * @throws NoSuchElementException if there is no next element"
        },
        "nextIndex": {
          "Javadoc": "* Gets the next index to be retrieved.\n     *\n     * @return the index of the item to be retrieved next"
        },
        "previous": {
          "Javadoc": "* Gets the previous element from the array.\n     *\n     * @return the previous element\n     * @throws NoSuchElementException if there is no previous element"
        },
        "previousIndex": {
          "Javadoc": "* Gets the index of the item to be retrieved if {@link #previous()} is called.\n     *\n     * @return the index of the item to be retrieved next"
        },
        "reset": {
          "Javadoc": "* Resets the iterator back to the start index."
        },
        "set": {
          "Javadoc": "* Sets the element under the cursor.\n     * <p>\n     * This method sets the element that was returned by the last call\n     * to {@link #next()} of {@link #previous()}.\n     *\n     * <b>Note:</b> {@link java.util.ListIterator} implementations that support {@code add()}\n     * and {@code remove()} only allow {@code set()} to be called once per call\n     * to {@code next()} or {@code previous} (see the {@link java.util.ListIterator}\n     * Javadoc for more details). Since this implementation does not support\n     * {@code add()} or {@code remove()}, {@code set()} may be\n     * called as often as desired.\n     *\n     * @param obj  the object to set into the array\n     * @throws IllegalStateException if next() has not yet been called.\n     * @throws ClassCastException if the object type is unsuitable for the array"
        }
      }
    },
    "org.apache.commons.collections4.iterators.ObjectGraphIterator": {
      "Javadoc": "\n * An Iterator that can traverse multiple iterators down an object graph.\n * <p>\n * This iterator can extract multiple objects from a complex tree-like object graph.\n * The iteration starts from a single root object.\n * It uses a {@code Transformer} to extract the iterators and elements.\n * Its main benefit is that no intermediate {@code List} is created.\n * <p>\n * For example, consider an object graph:\n * <pre>\n *                 |- Branch -- Leaf\n *                 |         \\- Leaf\n *         |- Tree |         /- Leaf\n *         |       |- Branch -- Leaf\n *  Forest |                 \\- Leaf\n *         |       |- Branch -- Leaf\n *         |       |         \\- Leaf\n *         |- Tree |         /- Leaf\n *                 |- Branch -- Leaf\n *                 |- Branch -- Leaf</pre>\n * The following {@code Transformer}, used in this class, will extract all\n * the Leaf objects without creating a combined intermediate list:\n * <pre>\n * public Object transform(Object input) {\n *   if (input instanceof Forest) {\n *     return ((Forest) input).treeIterator();\n *   }\n *   if (input instanceof Tree) {\n *     return ((Tree) input).branchIterator();\n *   }\n *   if (input instanceof Branch) {\n *     return ((Branch) input).leafIterator();\n *   }\n *   if (input instanceof Leaf) {\n *     return input;\n *   }\n *   throw new ClassCastException();\n * }</pre>\n * <p>\n * Internally, iteration starts from the root object. When next is called,\n * the transformer is called to examine the object. The transformer will return\n * either an iterator or an object. If the object is an Iterator, the next element\n * from that iterator is obtained and the process repeats. If the element is an object\n * it is returned.\n * <p>\n * Under many circumstances, linking Iterators together in this manner is\n * more efficient (and convenient) than using nested for loops to extract a list.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 3.1\n ",
      "methods": {
        "findNext": {
          "Javadoc": "* Finds the next object in the iteration given any start object.\n     *\n     * @param value  the value to start from"
        },
        "findNextByIterator": {
          "Javadoc": "* Finds the next object in the iteration given an iterator.\n     *\n     * @param iterator  the iterator to start from"
        },
        "hasNext": {
          "Javadoc": "* Checks whether there are any more elements in the iteration to obtain.\n     *\n     * @return true if elements remain in the iteration"
        },
        "next": {
          "Javadoc": "* Gets the next element of the iteration.\n     *\n     * @return the next element from the iteration\n     * @throws NoSuchElementException if all the Iterators are exhausted"
        },
        "remove": {
          "Javadoc": "* Removes from the underlying collection the last element returned.\n     * <p>\n     * This method calls remove() on the underlying Iterator, and it may\n     * throw an UnsupportedOperationException if the underlying Iterator\n     * does not support this method.\n     *\n     * @throws UnsupportedOperationException\n     *   if the remove operator is not supported by the underlying Iterator\n     * @throws IllegalStateException\n     *   if the next method has not yet been called, or the remove method has\n     *   already been called after the last call to the next method."
        },
        "updateCurrentIterator": {
          "Javadoc": "* Loops around the iterators to find the next value to return."
        }
      }
    },
    "org.apache.commons.collections4.iterators.PeekingIterator": {
      "Javadoc": "\n * Decorates an iterator to support one-element lookahead while iterating.\n * <p>\n * The decorator supports the removal operation, but an {@link IllegalStateException}\n * will be thrown if {@link #remove()} is called directly after a call to\n * {@link #peek()} or {@link #element()}.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 4.0\n ",
      "methods": {
        "peekingIterator": {
          "Javadoc": "* Decorates the specified iterator to support one-element lookahead.\n     * <p>\n     * If the iterator is already a {@link PeekingIterator} it is returned directly.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @return a new peeking iterator\n     * @throws NullPointerException if the iterator is null"
        },
        "element": {
          "Javadoc": "* Returns the next element in iteration without advancing the underlying iterator.\n     * If the iterator is already exhausted, null will be returned.\n     *\n     * @return the next element from the iterator\n     * @throws NoSuchElementException if the iterator is already exhausted according to {@link #hasNext()}"
        },
        "peek": {
          "Javadoc": "* Returns the next element in iteration without advancing the underlying iterator.\n     * If the iterator is already exhausted, null will be returned.\n     * <p>\n     * Note: this method does not throw a {@link NoSuchElementException} if the iterator\n     * is already exhausted. If you want such a behavior, use {@link #element()} instead.\n     * <p>\n     * The rationale behind this is to follow the {@link java.util.Queue} interface\n     * which uses the same terminology.\n     *\n     * @return the next element from the iterator"
        },
        "remove": {
          "Javadoc": "* {@inheritDoc}\n     *\n     * @throws IllegalStateException if {@link #peek()} or {@link #element()} has been called\n     *   prior to the call to {@link #remove()}"
        }
      }
    },
    "org.apache.commons.collections4.iterators.PermutationIterator": {
      "Javadoc": "\n * This iterator creates permutations of an input collection, using the\n * Steinhaus-Johnson-Trotter algorithm (also called plain changes).\n * <p>\n * The iterator will return exactly n! permutations of the input collection.\n * The {@code remove()} operation is not supported, and will throw an\n * {@code UnsupportedOperationException}.\n * <p>\n * NOTE: in case an empty collection is provided, the iterator will\n * return exactly one empty list as result, as 0! = 1.\n *\n * @param <E>  the type of the objects being permuted\n *\n * @since 4.0\n ",
      "methods": {
        "hasNext": {
          "Javadoc": "* Indicates if there are more permutation available.\n     * @return true if there are more permutations, otherwise false"
        },
        "next": {
          "Javadoc": "* Returns the next permutation of the input collection.\n     * @return a list of the permutator's elements representing a permutation\n     * @throws NoSuchElementException if there are no more permutations"
        }
      }
    },
    "org.apache.commons.collections4.iterators.PushbackIterator": {
      "Javadoc": "\n * Decorates an iterator to support pushback of elements.\n * <p>\n * The decorator stores the pushed back elements in a LIFO manner: the last element\n * that has been pushed back, will be returned as the next element in a call to {@link #next()}.\n * <p>\n * The decorator does not support the removal operation. Any call to {@link #remove()} will\n * result in an {@link UnsupportedOperationException}.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 4.0\n ",
      "methods": {
        "pushbackIterator": {
          "Javadoc": "* Decorates the specified iterator to support one-element lookahead.\n     * <p>\n     * If the iterator is already a {@link PushbackIterator} it is returned directly.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @return a new peeking iterator\n     * @throws NullPointerException if the iterator is null"
        },
        "pushback": {
          "Javadoc": "* Push back the given element to the iterator.\n     * <p>\n     * Calling {@link #next()} immediately afterwards will return exactly this element.\n     *\n     * @param item  the element to push back to the iterator"
        },
        "remove": {
          "Javadoc": "* This iterator will always throw an {@link UnsupportedOperationException}.\n     *\n     * @throws UnsupportedOperationException always"
        }
      }
    },
    "org.apache.commons.collections4.iterators.ReverseListIterator": {
      "Javadoc": "\n * Iterates backwards through a List, starting with the last element\n * and continuing to the first. This is useful for looping around\n * a list in reverse order without needing to actually reverse the list.\n * <p>\n * The first call to {@code next()} will return the last element\n * from the list, and so on. The {@code hasNext()} method works\n * in concert with the {@code next()} method as expected.\n * However, the {@code nextIndex()} method returns the correct\n * index in the list, thus it starts high and reduces as the iteration\n * continues. The previous methods work similarly.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 3.2\n ",
      "methods": {
        "add": {
          "Javadoc": "* Adds a new element to the list between the next and previous elements.\n     *\n     * @param obj  the object to add\n     * @throws UnsupportedOperationException if the list is unmodifiable\n     * @throws IllegalStateException if the iterator is not in a valid state for set"
        },
        "hasNext": {
          "Javadoc": "* Checks whether there is another element.\n     *\n     * @return true if there is another element"
        },
        "hasPrevious": {
          "Javadoc": "* Checks whether there is a previous element.\n     *\n     * @return true if there is a previous element"
        },
        "next": {
          "Javadoc": "* Gets the next element.\n     * The next element is the previous in the list.\n     *\n     * @return the next element in the iterator"
        },
        "nextIndex": {
          "Javadoc": "* Gets the index of the next element.\n     *\n     * @return the index of the next element in the iterator"
        },
        "previous": {
          "Javadoc": "* Gets the previous element.\n     * The next element is the previous in the list.\n     *\n     * @return the previous element in the iterator"
        },
        "previousIndex": {
          "Javadoc": "* Gets the index of the previous element.\n     *\n     * @return the index of the previous element in the iterator"
        },
        "remove": {
          "Javadoc": "* Removes the last returned element.\n     *\n     * @throws UnsupportedOperationException if the list is unmodifiable\n     * @throws IllegalStateException if there is no element to remove"
        },
        "reset": {
          "Javadoc": "* Resets the iterator back to the start (which is the\n     * end of the list as this is a reversed iterator)"
        },
        "set": {
          "Javadoc": "* Replaces the last returned element.\n     *\n     * @param obj  the object to set\n     * @throws UnsupportedOperationException if the list is unmodifiable\n     * @throws IllegalStateException if the iterator is not in a valid state for set"
        }
      }
    },
    "org.apache.commons.collections4.iterators.SingletonIterator": {
      "Javadoc": "\n * {@code SingletonIterator} is an {@link java.util.Iterator} over a single\n * object instance.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 2.0\n ",
      "methods": {
        "hasNext": {
          "Javadoc": "* Is another object available from the iterator?\n     * <p>\n     * This returns true if the single object hasn't been returned yet.\n     *\n     * @return true if the single object hasn't been returned yet"
        },
        "next": {
          "Javadoc": "* Gets the next object from the iterator.\n     * <p>\n     * This returns the single object if it hasn't been returned yet.\n     *\n     * @return the single object\n     * @throws NoSuchElementException if the single object has already\n     *    been returned"
        },
        "remove": {
          "Javadoc": "* Remove the object from this iterator.\n     *\n     * @throws IllegalStateException if the {@code next} method has not\n     *        yet been called, or the {@code remove} method has already\n     *        been called after the last call to the {@code next}\n     *        method.\n     * @throws UnsupportedOperationException if remove is not supported"
        },
        "reset": {
          "Javadoc": "* Reset the iterator to the start."
        }
      }
    },
    "org.apache.commons.collections4.iterators.SingletonListIterator": {
      "Javadoc": "\n * {@code SingletonIterator} is an {@link java.util.ListIterator} over a single\n * object instance.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 2.1\n ",
      "methods": {
        "add": {
          "Javadoc": "* Add always throws {@link UnsupportedOperationException}.\n     *\n     * @param obj  the object to add\n     * @throws UnsupportedOperationException always"
        },
        "hasNext": {
          "Javadoc": "* Is another object available from the iterator?\n     * <p>\n     * This returns true if the single object hasn't been returned yet.\n     *\n     * @return true if the single object hasn't been returned yet"
        },
        "hasPrevious": {
          "Javadoc": "* Is a previous object available from the iterator?\n     * <p>\n     * This returns true if the single object has been returned.\n     *\n     * @return true if the single object has been returned"
        },
        "next": {
          "Javadoc": "* Gets the next object from the iterator.\n     * <p>\n     * This returns the single object if it hasn't been returned yet.\n     *\n     * @return the single object\n     * @throws NoSuchElementException if the single object has already\n     *    been returned"
        },
        "nextIndex": {
          "Javadoc": "* Returns the index of the element that would be returned by a subsequent\n     * call to {@code next}.\n     *\n     * @return 0 or 1 depending on current state."
        },
        "previous": {
          "Javadoc": "* Gets the previous object from the iterator.\n     * <p>\n     * This returns the single object if it has been returned.\n     *\n     * @return the single object\n     * @throws NoSuchElementException if the single object has not already\n     *    been returned"
        },
        "previousIndex": {
          "Javadoc": "* Returns the index of the element that would be returned by a subsequent\n     * call to {@code previous}. A return value of -1 indicates that the iterator is currently at\n     * the start.\n     *\n     * @return 0 or -1 depending on current state."
        },
        "remove": {
          "Javadoc": "* Remove the object from this iterator.\n     * @throws IllegalStateException if the {@code next} or {@code previous}\n     *        method has not yet been called, or the {@code remove} method\n     *        has already been called after the last call to {@code next}\n     *        or {@code previous}."
        },
        "reset": {
          "Javadoc": "* Reset the iterator back to the start."
        },
        "set": {
          "Javadoc": "* Sets sets the value of the singleton.\n     *\n     * @param obj  the object to set\n     * @throws IllegalStateException if {@code next} has not been called\n     *          or the object has been removed"
        }
      }
    },
    "org.apache.commons.collections4.iterators.SkippingIterator": {
      "Javadoc": "\n * Decorates another iterator to skip the first N elements.\n * <p>\n * In case an offset parameter other than 0 is provided, the decorated\n * iterator is immediately advanced to this position, skipping all elements\n * before that position.\n * </p>\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 4.1\n ",
      "methods": {
        "init": {
          "Javadoc": "* Skips the given number of elements."
        },
        "remove": {
          "Javadoc": "* {@inheritDoc}\n     * <p>\n     * In case an offset other than 0 was specified, the underlying iterator will be advanced\n     * to this position upon creation. A call to {@link #remove()} will still result in an\n     * {@link IllegalStateException} if no explicit call to {@link #next()} has been made prior\n     * to calling {@link #remove()}."
        }
      }
    },
    "org.apache.commons.collections4.iterators.TransformIterator": {
      "Javadoc": "\n * Decorates an iterator such that each element returned is transformed.\n *\n * @since 1.0\n ",
      "methods": {
        "getIterator": {
          "Javadoc": "* Gets the iterator this iterator is using.\n     *\n     * @return the iterator."
        },
        "getTransformer": {
          "Javadoc": "* Gets the transformer this iterator is using.\n     *\n     * @return the transformer."
        },
        "next": {
          "Javadoc": "* Gets the next object from the iteration, transforming it using the\n     * current transformer. If the transformer is null, no transformation\n     * occurs and the object from the iterator is returned directly.\n     *\n     * @return the next object\n     * @throws java.util.NoSuchElementException if there are no more elements"
        },
        "setIterator": {
          "Javadoc": "* Sets the iterator for this iterator to use.\n     * If iteration has started, this effectively resets the iterator.\n     *\n     * @param iterator  the iterator to use"
        },
        "setTransformer": {
          "Javadoc": "* Sets the transformer this the iterator to use.\n     * A null transformer is a no-op transformer.\n     *\n     * @param transformer  the transformer to use"
        },
        "transform": {
          "Javadoc": "* Transforms the given object using the transformer.\n     * If the transformer is null, the original object is returned as-is.\n     *\n     * @param source  the object to transform\n     * @return the transformed object"
        }
      }
    },
    "org.apache.commons.collections4.iterators.UniqueFilterIterator": {
      "Javadoc": "\n * A FilterIterator which only returns \"unique\" Objects.  Internally,\n * the Iterator maintains a Set of objects it has already encountered,\n * and duplicate Objects are skipped.\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 2.1\n "
    },
    "org.apache.commons.collections4.iterators.UnmodifiableIterator": {
      "Javadoc": "\n * Decorates an iterator such that it cannot be modified.\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 3.0\n ",
      "methods": {
        "unmodifiableIterator": {
          "Javadoc": "* Decorates the specified iterator such that it cannot be modified.\n     * <p>\n     * If the iterator is already unmodifiable it is returned directly.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @return a new unmodifiable iterator\n     * @throws NullPointerException if the iterator is null"
        }
      }
    },
    "org.apache.commons.collections4.iterators.UnmodifiableListIterator": {
      "Javadoc": "\n * Decorates a list iterator such that it cannot be modified.\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 3.0\n ",
      "methods": {
        "umodifiableListIterator": {
          "Javadoc": "* Decorates the specified iterator such that it cannot be modified.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @return a new unmodifiable list iterator\n     * @throws NullPointerException if the iterator is null\n     * @deprecated method name has typo in it. Use {@link org.apache.commons.collections4.iterators.UnmodifiableListIterator#unmodifiableListIterator(ListIterator)} instead."
        },
        "unmodifiableListIterator": {
          "Javadoc": "* Decorates the specified iterator such that it cannot be modified.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @return a new unmodifiable list iterator\n     * @throws NullPointerException if the iterator is null"
        }
      }
    },
    "org.apache.commons.collections4.iterators.UnmodifiableMapIterator": {
      "Javadoc": "\n * Decorates a map iterator such that it cannot be modified.\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <K> the type of keys\n * @param <V> the type of mapped values\n * @since 3.0\n ",
      "methods": {
        "unmodifiableMapIterator": {
          "Javadoc": "* Decorates the specified iterator such that it cannot be modified.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param iterator  the iterator to decorate\n     * @return a new unmodifiable map iterator\n     * @throws NullPointerException if the iterator is null"
        }
      }
    },
    "org.apache.commons.collections4.iterators.UnmodifiableOrderedMapIterator": {
      "Javadoc": "\n * Decorates an ordered map iterator such that it cannot be modified.\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <K> the type of keys\n * @param <V> the type of mapped values\n * @since 3.0\n ",
      "methods": {
        "unmodifiableOrderedMapIterator": {
          "Javadoc": "* Decorates the specified iterator such that it cannot be modified.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param iterator  the iterator to decorate\n     * @return a new unmodifiable ordered map iterator\n     * @throws NullPointerException if the iterator is null"
        }
      }
    },
    "org.apache.commons.collections4.iterators.ZippingIterator": {
      "Javadoc": "\n * Provides an interleaved iteration over the elements contained in a\n * collection of Iterators.\n * <p>\n * Given two {@link Iterator} instances {@code A} and {@code B}, the\n * {@link #next} method on this iterator will switch between {@code A.next()}\n * and {@code B.next()} until both iterators are exhausted.\n * </p>\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 4.1\n ",
      "methods": {
        "hasNext": {
          "Javadoc": "* Returns {@code true} if any child iterator has remaining elements.\n     *\n     * @return true if this iterator has remaining elements"
        },
        "next": {
          "Javadoc": "* Returns the next element from a child iterator.\n     *\n     * @return the next interleaved element\n     * @throws NoSuchElementException if no child iterator has any more elements"
        },
        "remove": {
          "Javadoc": "* Removes the last returned element from the child iterator that produced it.\n     *\n     * @throws IllegalStateException if there is no last returned element, or if\n     *   the last returned element has already been removed"
        }
      }
    },
    "org.apache.commons.collections4.IteratorUtils": {
      "Javadoc": "\n * Provides static utility methods and decorators for {@link Iterator}\n * instances. The implementations are provided in the iterators subpackage.\n *\n * @since 2.1\n ",
      "methods": {
        "arrayIterator": {
          "Javadoc": "* Gets an iterator over part of an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E> the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @param end  the index to finish iterating at\n     * @return an iterator over part of the array\n     * @throws IllegalArgumentException if the array is not an array or end is before start\n     * @throws IndexOutOfBoundsException if array bounds are invalid\n     * @throws NullPointerException if array is null"
        },
        "arrayListIterator": {
          "Javadoc": "* Gets a list iterator over part of an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E> the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @param end  the index to finish iterating at\n     * @return a list iterator over part of the array\n     * @throws IllegalArgumentException if the array is not an array or end is before start\n     * @throws IndexOutOfBoundsException if array bounds are invalid\n     * @throws NullPointerException if array is null"
        },
        "asEnumeration": {
          "Javadoc": "* Gets an enumeration that wraps an iterator.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, may not be null\n     * @return a new enumeration\n     * @throws NullPointerException if iterator is null"
        },
        "asIterable": {
          "Javadoc": "* Gets an {@link Iterable} that wraps an iterator.  The returned {@link Iterable} can be\n     * used for a single iteration.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, may not be null\n     * @return a new, single use {@link Iterable}\n     * @throws NullPointerException if iterator is null"
        },
        "asIterator": {
          "Javadoc": "* Gets an iterator that provides an iterator view of the given enumeration\n     * that will remove elements from the specified collection.\n     *\n     * @param <E> the element type\n     * @param enumeration  the enumeration to use, may not be null\n     * @param removeCollection  the collection to remove elements from, may not be null\n     * @return a new iterator\n     * @throws NullPointerException if enumeration or removeCollection is null"
        },
        "asMultipleUseIterable": {
          "Javadoc": "* Gets an iterable that wraps an iterator.  The returned iterable can be\n     * used for multiple iterations.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, may not be null\n     * @return a new, multiple use iterable\n     * @throws NullPointerException if iterator is null"
        },
        "boundedIterator": {
          "Javadoc": "* Decorates the specified iterator to return at most the given number\n     * of elements, skipping all elements until the iterator reaches the\n     * position at {@code offset}.\n     * <p>\n     * The iterator is immediately advanced until it reaches the position at\n     * {@code offset}, incurring O(n) time.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the index of the first element of the decorated iterator to return\n     * @param max  the maximum number of elements returned by this iterator\n     * @return a new bounded iterator\n     * @throws NullPointerException if the iterator is null\n     * @throws IllegalArgumentException if either offset or max is negative\n     * @since 4.1"
        },
        "chainedIterator": {
          "Javadoc": "* Gets an iterator that iterates through two {@link Iterator}s\n     * one after another.\n     *\n     * @param <E> the element type\n     * @param iterator1  the first iterator to use, not null\n     * @param iterator2  the second iterator to use, not null\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if either iterator is null"
        },
        "collatedIterator": {
          "Javadoc": "* Gets an iterator that provides an ordered iteration over the elements\n     * contained in a collection of ordered {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s {@code A} and {@code B},\n     * the {@link Iterator#next()} method will return the lesser of\n     * {@code A.next()} and {@code B.next()}.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E> the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterator1  the first iterators to use, not null\n     * @param iterator2  the first iterators to use, not null\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if either iterator is null"
        },
        "contains": {
          "Javadoc": "* Checks if the object is contained in the given iterator.\n     * <p>\n     * A {@code null} or empty iterator returns false.\n     *\n     * @param <E> the type of object the {@link Iterator} contains\n     * @param iterator  the iterator to check, may be null\n     * @param object  the object to check\n     * @return true if the object is contained in the iterator, false otherwise\n     * @since 4.1"
        },
        "emptyIterator": {
          "Javadoc": "* Gets an empty iterator.\n     * <p>\n     * This iterator is a valid iterator object that will iterate over nothing.\n     *\n     * @param <E> the element type\n     * @return an iterator over nothing"
        },
        "emptyListIterator": {
          "Javadoc": "* Gets an empty list iterator.\n     * <p>\n     * This iterator is a valid list iterator object that will iterate\n     * over nothing.\n     *\n     * @param <E> the element type\n     * @return a list iterator over nothing"
        },
        "emptyMapIterator": {
          "Javadoc": "* Gets an empty map iterator.\n     * <p>\n     * This iterator is a valid map iterator object that will iterate\n     * over nothing.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @return a map iterator over nothing"
        },
        "emptyOrderedIterator": {
          "Javadoc": "* Gets an empty ordered iterator.\n     * <p>\n     * This iterator is a valid iterator object that will iterate\n     * over nothing.\n     *\n     * @param <E> the element type\n     * @return an ordered iterator over nothing"
        },
        "emptyOrderedMapIterator": {
          "Javadoc": "* Gets an empty ordered map iterator.\n     * <p>\n     * This iterator is a valid map iterator object that will iterate\n     * over nothing.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @return a map iterator over nothing"
        },
        "filteredIterator": {
          "Javadoc": "* Gets an iterator that filters another iterator.\n     * <p>\n     * The returned iterator will only return objects that match the specified\n     * filtering predicate.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, not null\n     * @param predicate  the predicate to use as a filter, not null\n     * @return a new filtered iterator\n     * @throws NullPointerException if either parameter is null"
        },
        "filteredListIterator": {
          "Javadoc": "* Gets a list iterator that filters another list iterator.\n     * <p>\n     * The returned iterator will only return objects that match the specified\n     * filtering predicate.\n     *\n     * @param <E> the element type\n     * @param listIterator  the list iterator to use, not null\n     * @param predicate  the predicate to use as a filter, not null\n     * @return a new filtered iterator\n     * @throws NullPointerException if either parameter is null"
        },
        "find": {
          "Javadoc": "* Finds the first element in the given iterator which matches the given predicate.\n     * <p>\n     * A {@code null} or empty iterator returns null.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to search, may be null\n     * @param predicate  the predicate to use, must not be null\n     * @return the first element of the iterator which matches the predicate or null if none could be found\n     * @throws NullPointerException if predicate is null\n     * @since 4.1"
        },
        "first": {
          "Javadoc": "* Shortcut for {@code get(iterator, 0)}.\n     * <p>\n     * Returns the {@code first} value in {@link Iterator}, throwing\n     * {@code IndexOutOfBoundsException} if there is no such element.\n     * </p>\n     * <p>\n     * The Iterator is advanced to {@code 0} (or to the end, if\n     * {@code 0} exceeds the number of entries) as a side effect of this method.\n     * </p>\n     * @param <E> the type of object in the {@link Iterator}\n     * @param iterator the iterator to get a value from\n     * @return the first object\n     * @throws IndexOutOfBoundsException if the request is invalid\n     * @since 4.2"
        },
        "forEach": {
          "Javadoc": "* Applies the closure to each element of the provided iterator.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, may be null\n     * @param closure  the closure to apply to each element, may not be null\n     * @throws NullPointerException if closure is null\n     * @since 4.1"
        },
        "forEachButLast": {
          "Javadoc": "* Executes the given closure on each but the last element in the iterator.\n     * <p>\n     * If the input iterator is null no change is made.\n     *\n     * @param <E> the type of object the {@link Iterator} contains\n     * @param iterator  the iterator to get the input from, may be null\n     * @param closure  the closure to perform, may not be null\n     * @return the last element in the iterator, or null if iterator is null or empty\n     * @throws NullPointerException if closure is null\n     * @since 4.1"
        },
        "get": {
          "Javadoc": "* Returns the {@code index}-th value in {@link Iterator}, throwing\n     * {@code IndexOutOfBoundsException} if there is no such element.\n     * <p>\n     * The Iterator is advanced to {@code index} (or to the end, if\n     * {@code index} exceeds the number of entries) as a side effect of this method.\n     *\n     * @param <E> the type of object in the {@link Iterator}\n     * @param iterator  the iterator to get a value from\n     * @param index  the index to get\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 4.1"
        },
        "getIterator": {
          "Javadoc": "* Gets a suitable Iterator for the given object.\n     * <p>\n     * This method can handle objects as follows\n     * <ul>\n     * <li>null - empty iterator\n     * <li>Iterator - returned directly\n     * <li>Enumeration - wrapped\n     * <li>Collection - iterator from collection returned\n     * <li>Map - values iterator returned\n     * <li>Dictionary - values (elements) enumeration returned as iterator\n     * <li>array - iterator over array returned\n     * <li>object with iterator() public method accessed by reflection\n     * <li>object - singleton iterator\n     * <li>NodeList - iterator over the list\n     * <li>Node - iterator over the child nodes\n     * </ul>\n     *\n     * @param obj  the object to convert to an iterator\n     * @return a suitable iterator, never null"
        },
        "indexOf": {
          "Javadoc": "* Returns the index of the first element in the specified iterator that\n     * matches the given predicate.\n     * <p>\n     * A {@code null} or empty iterator returns -1.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to search, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return the index of the first element which matches the predicate or -1 if none matches\n     * @throws NullPointerException if predicate is null\n     * @since 4.1"
        },
        "isEmpty": {
          "Javadoc": "* Checks if the given iterator is empty.\n     * <p>\n     * A {@code null} or empty iterator returns true.\n     *\n     * @param iterator  the {@link Iterator} to use, may be null\n     * @return true if the iterator is exhausted or null, false otherwise\n     * @since 4.1"
        },
        "loopingIterator": {
          "Javadoc": "* Gets an iterator that loops continuously over the supplied collection.\n     * <p>\n     * The iterator will only stop looping if the remove method is called\n     * enough times to empty the collection, or if the collection is empty\n     * to start with.\n     *\n     * @param <E> the element type\n     * @param collection  the collection to iterate over, not null\n     * @return a new looping iterator\n     * @throws NullPointerException if the collection is null"
        },
        "loopingListIterator": {
          "Javadoc": "* Gets an iterator that loops continuously over the supplied list.\n     * <p>\n     * The iterator will only stop looping if the remove method is called\n     * enough times to empty the list, or if the list is empty to start with.\n     *\n     * @param <E> the element type\n     * @param list  the list to iterate over, not null\n     * @return a new looping iterator\n     * @throws NullPointerException if the list is null\n     * @since 3.2"
        },
        "matchesAll": {
          "Javadoc": "* Answers true if a predicate is true for every element of an iterator.\n     * <p>\n     * A {@code null} or empty iterator returns true.\n     *\n     * @param <E> the type of object the {@link Iterator} contains\n     * @param iterator  the {@link Iterator} to use, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return true if every element of the collection matches the predicate or if the\n     *   collection is empty, false otherwise\n     * @throws NullPointerException if predicate is null\n     * @since 4.1"
        },
        "matchesAny": {
          "Javadoc": "* Answers true if a predicate is true for any element of the iterator.\n     * <p>\n     * A {@code null} or empty iterator returns false.\n     *\n     * @param <E> the type of object the {@link Iterator} contains\n     * @param iterator  the {@link Iterator} to use, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return true if any element of the collection matches the predicate, false otherwise\n     * @throws NullPointerException if predicate is null\n     * @since 4.1"
        },
        "nodeListIterator": {
          "Javadoc": "* Gets an {@link Iterator} that wraps the specified {@link NodeList}.\n     * The returned {@link Iterator} can be used for a single iteration.\n     *\n     * @param nodeList  the node list to use, may not be null\n     * @return a new, single use {@link Iterator}\n     * @throws NullPointerException if nodeList is null\n     * @since 4.0"
        },
        "objectGraphIterator": {
          "Javadoc": "* Gets an iterator that operates over an object graph.\n     * <p>\n     * This iterator can extract multiple objects from a complex tree-like object graph.\n     * The iteration starts from a single root object.\n     * It uses a {@code Transformer} to extract the iterators and elements.\n     * Its main benefit is that no intermediate {@code List} is created.\n     * <p>\n     * For example, consider an object graph:\n     * <pre>\n     *                 |- Branch -- Leaf\n     *                 |         \\- Leaf\n     *         |- Tree |         /- Leaf\n     *         |       |- Branch -- Leaf\n     *  Forest |                 \\- Leaf\n     *         |       |- Branch -- Leaf\n     *         |       |         \\- Leaf\n     *         |- Tree |         /- Leaf\n     *                 |- Branch -- Leaf\n     *                 |- Branch -- Leaf</pre>\n     * The following {@code Transformer}, used in this class, will extract all\n     * the Leaf objects without creating a combined intermediate list:\n     * <pre>\n     * public Object transform(Object input) {\n     *   if (input instanceof Forest) {\n     *     return ((Forest) input).treeIterator();\n     *   }\n     *   if (input instanceof Tree) {\n     *     return ((Tree) input).branchIterator();\n     *   }\n     *   if (input instanceof Branch) {\n     *     return ((Branch) input).leafIterator();\n     *   }\n     *   if (input instanceof Leaf) {\n     *     return input;\n     *   }\n     *   throw new ClassCastException();\n     * }</pre>\n     * <p>\n     * Internally, iteration starts from the root object. When next is called,\n     * the transformer is called to examine the object. The transformer will return\n     * either an iterator or an object. If the object is an Iterator, the next element\n     * from that iterator is obtained and the process repeats. If the element is an object\n     * it is returned.\n     * <p>\n     * Under many circumstances, linking Iterators together in this manner is\n     * more efficient (and convenient) than using nested for loops to extract a list.\n     *\n     * @param <E> the element type\n     * @param root  the root object to start iterating from, null results in an empty iterator\n     * @param transformer  the transformer to use, see above, null uses no effect transformer\n     * @return a new object graph iterator\n     * @since 3.1"
        },
        "peekingIterator": {
          "Javadoc": "* Gets an iterator that supports one-element lookahead.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate, not null\n     * @return a peeking iterator\n     * @throws NullPointerException if the iterator is null\n     * @since 4.0"
        },
        "pushbackIterator": {
          "Javadoc": "* Gets an iterator that supports pushback of elements.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate, not null\n     * @return a pushback iterator\n     * @throws NullPointerException if the iterator is null\n     * @since 4.0"
        },
        "singletonIterator": {
          "Javadoc": "* Gets a singleton iterator.\n     * <p>\n     * This iterator is a valid iterator object that will iterate over\n     * the specified object.\n     *\n     * @param <E> the element type\n     * @param object  the single object over which to iterate\n     * @return a singleton iterator over the object"
        },
        "singletonListIterator": {
          "Javadoc": "* Gets a singleton list iterator.\n     * <p>\n     * This iterator is a valid list iterator object that will iterate over\n     * the specified object.\n     *\n     * @param <E> the element type\n     * @param object  the single object over which to iterate\n     * @return a singleton list iterator over the object"
        },
        "size": {
          "Javadoc": "* Returns the number of elements contained in the given iterator.\n     * <p>\n     * A {@code null} or empty iterator returns {@code 0}.\n     *\n     * @param iterator  the iterator to check, may be null\n     * @return the number of elements contained in the iterator\n     * @since 4.1"
        },
        "skippingIterator": {
          "Javadoc": "* Decorates the specified iterator to skip the first N elements.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the first number of elements to skip\n     * @return a new skipping iterator\n     * @throws NullPointerException if the iterator is null\n     * @throws IllegalArgumentException if offset is negative\n     * @since 4.1"
        },
        "toArray": {
          "Javadoc": "* Gets an array based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, this is converted to an array.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, not null\n     * @param arrayClass  the class of array to create\n     * @return an array of the iterator contents\n     * @throws NullPointerException if iterator parameter or arrayClass is null\n     * @throws ArrayStoreException if the arrayClass is invalid"
        },
        "toList": {
          "Javadoc": "* Gets a list based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, the list is returned.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, not null\n     * @param estimatedSize  the initial size of the ArrayList\n     * @return a list of the iterator contents\n     * @throws NullPointerException if iterator parameter is null\n     * @throws IllegalArgumentException if the size is less than 1"
        },
        "toListIterator": {
          "Javadoc": "* Gets a list iterator based on a simple iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, a LinkedList of its values is\n     * cached, permitting all required operations of ListIterator.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, may not be null\n     * @return a new iterator\n     * @throws NullPointerException if iterator parameter is null"
        },
        "toString": {
          "Javadoc": "* Returns a string representation of the elements of the specified iterator.\n     * <p>\n     * The string representation consists of a list of the iterator's elements,\n     * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n     * are separated by the provided {@code delimiter}. Elements are converted to\n     * strings as by using the provided {@code transformer}.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to convert to a string, may be null\n     * @param transformer  the transformer used to get a string representation of an element\n     * @param delimiter  the string to delimit elements\n     * @param prefix  the prefix, prepended to the string representation\n     * @param suffix  the suffix, appended to the string representation\n     * @return a string representation of {@code iterator}\n     * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n     * @since 4.1"
        },
        "transformedIterator": {
          "Javadoc": "* Gets an iterator that transforms the elements of another iterator.\n     * <p>\n     * The transformation occurs during the next() method and the underlying\n     * iterator is unaffected by the transformation.\n     *\n     * @param <I> the input type\n     * @param <O> the output type\n     * @param iterator  the iterator to use, not null\n     * @param transformer  the transform to use, not null\n     * @return a new transforming iterator\n     * @throws NullPointerException if either parameter is null"
        },
        "unmodifiableIterator": {
          "Javadoc": "* Gets an immutable version of an {@link Iterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove} method.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to make immutable\n     * @return an immutable version of the iterator"
        },
        "unmodifiableListIterator": {
          "Javadoc": "* Gets an immutable version of a {@link ListIterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove}, {@link ListIterator#add} and\n     * {@link ListIterator#set} methods.\n     *\n     * @param <E> the element type\n     * @param listIterator  the iterator to make immutable\n     * @return an immutable version of the iterator"
        },
        "unmodifiableMapIterator": {
          "Javadoc": "* Gets an immutable version of a {@link MapIterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove}, {@link MapIterator#setValue(Object)} methods.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param mapIterator  the iterator to make immutable\n     * @return an immutable version of the iterator"
        },
        "zippingIterator": {
          "Javadoc": "* Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E> the element type\n     * @param a  the first iterator to interleave\n     * @param b  the second iterator to interleave\n     * @param c  the third iterator to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws NullPointerException if any iterator is null\n     * @since 4.1"
        }
      }
    },
    "org.apache.commons.collections4.keyvalue.AbstractKeyValue": {
      "Javadoc": "\n * Abstract pair class to assist with creating {@code KeyValue}\n * and {@link java.util.Map.Entry Map.Entry} implementations.\n *\n * @param <K> the type of keys\n * @param <V> the type of values\n * @since 3.0\n ",
      "methods": {
        "getKey": {
          "Javadoc": "* Gets the key from the pair.\n     *\n     * @return the key"
        },
        "getValue": {
          "Javadoc": "* Gets the value from the pair.\n     *\n     * @return the value"
        },
        "toString": {
          "Javadoc": "* Gets a debugging String view of the pair.\n     *\n     * @return a String view of the entry"
        }
      }
    },
    "org.apache.commons.collections4.keyvalue.AbstractMapEntry": {
      "Javadoc": "\n * Abstract Pair class to assist with creating correct\n * {@link java.util.Map.Entry Map.Entry} implementations.\n *\n * @param <K> the type of keys\n * @param <V> the type of mapped values\n * @since 3.0\n ",
      "methods": {
        "equals": {
          "Javadoc": "* Compares this {@code Map.Entry} with another {@code Map.Entry}.\n     * <p>\n     * Implemented per API documentation of {@link java.util.Map.Entry#equals(Object)}\n     *\n     * @param obj  the object to compare to\n     * @return true if equal key and value"
        },
        "hashCode": {
          "Javadoc": "* Gets a hashCode compatible with the equals method.\n     * <p>\n     * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()}\n     *\n     * @return a suitable hash code"
        },
        "setValue": {
          "Javadoc": "* Sets the value stored in this {@code Map.Entry}.\n     * <p>\n     * This {@code Map.Entry} is not connected to a Map, so only the\n     * local data is changed.\n     *\n     * @param value  the new value\n     * @return the previous value"
        }
      }
    },
    "org.apache.commons.collections4.keyvalue.AbstractMapEntryDecorator": {
      "Javadoc": "\n * Provides a base decorator that allows additional functionality to be\n * added to a {@link java.util.Map.Entry Map.Entry}.\n *\n * @param <K> the type of keys\n * @param <V> the type of mapped values\n * @since 3.0\n ",
      "methods": {
        "getMapEntry": {
          "Javadoc": "* Gets the map being decorated.\n     *\n     * @return the decorated map"
        }
      }
    },
    "org.apache.commons.collections4.keyvalue.DefaultKeyValue": {
      "Javadoc": "\n * A mutable {@code KeyValue} pair that does not implement\n * {@link java.util.Map.Entry Map.Entry}.\n * <p>\n * Note that a {@code DefaultKeyValue} instance may not contain\n * itself as a key or value.\n * </p>\n *\n * @param <K> the type of keys\n * @param <V> the type of values\n * @since 3.0\n ",
      "methods": {
        "equals": {
          "Javadoc": "* Compares this {@code Map.Entry} with another {@code Map.Entry}.\n     * <p>\n     * Returns true if the compared object is also a {@code DefaultKeyValue},\n     * and its key and value are equal to this object's key and value.\n     *\n     * @param obj  the object to compare to\n     * @return true if equal key and value"
        },
        "hashCode": {
          "Javadoc": "* Gets a hashCode compatible with the equals method.\n     * <p>\n     * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()},\n     * however subclasses may override this.\n     *\n     * @return a suitable hash code"
        },
        "setKey": {
          "Javadoc": "* Sets the key.\n     *\n     * @param key  the new key\n     * @return the old key\n     * @throws IllegalArgumentException if key is this object"
        },
        "setValue": {
          "Javadoc": "* Sets the value.\n     *\n     * @return the old value of the value\n     * @param value the new value\n     * @throws IllegalArgumentException if value is this object"
        },
        "toMapEntry": {
          "Javadoc": "* Returns a new {@code Map.Entry} object with key and value from this pair.\n     *\n     * @return a MapEntry instance"
        }
      }
    },
    "org.apache.commons.collections4.keyvalue.DefaultMapEntry": {
      "Javadoc": "\n * A restricted implementation of {@link java.util.Map.Entry Map.Entry} that prevents\n * the {@link java.util.Map.Entry Map.Entry} contract from being broken.\n *\n * @param <K> the type of keys\n * @param <V> the type of mapped values\n * @since 3.0\n "
    },
    "org.apache.commons.collections4.keyvalue.MultiKey": {
      "Javadoc": "\n * A {@code MultiKey} allows multiple map keys to be merged together.\n * <p>\n * The purpose of this class is to avoid the need to write code to handle\n * maps of maps. An example might be the need to look up a file name by\n * key and locale. The typical solution might be nested maps. This class\n * can be used instead by creating an instance passing in the key and locale.\n * </p>\n * <p>\n * Example usage:\n * </p>\n * <pre>\n * // populate map with data mapping key+locale to localizedText\n * Map map = new HashMap();\n * MultiKey multiKey = new MultiKey(key, locale);\n * map.put(multiKey, localizedText);\n *\n * // later retrieve the localized text\n * MultiKey multiKey = new MultiKey(key, locale);\n * String localizedText = (String) map.get(multiKey);\n * </pre>\n *\n * @param <K> the type of keys\n * @since 3.0\n ",
      "methods": {
        "calculateHashCode": {
          "Javadoc": "* Calculate the hash code of the instance using the provided keys.\n     * @param keys the keys to calculate the hash code for"
        },
        "equals": {
          "Javadoc": "* Compares this object to another.\n     * <p>\n     * To be equal, the other object must be a {@code MultiKey} with the\n     * same number of keys which are also equal.\n     *\n     * @param other  the other object to compare to\n     * @return true if equal"
        },
        "getKey": {
          "Javadoc": "* Gets the key at the specified index.\n     * <p>\n     * The key should be immutable.\n     * If it is not then it must not be changed.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 3.1"
        },
        "getKeys": {
          "Javadoc": "* Gets a clone of the array of keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed.\n     *\n     * @return the individual keys"
        },
        "hashCode": {
          "Javadoc": "* Gets the combined hash code that is computed from all the keys.\n     * <p>\n     * This value is computed once and then cached, so elements should not\n     * change their hash codes once created (note that this is the same\n     * constraint that would be used if the individual keys elements were\n     * themselves {@link java.util.Map Map} keys).\n     *\n     * @return the hash code"
        },
        "readResolve": {
          "Javadoc": "* Recalculate the hash code after deserialization. The hash code of some\n     * keys might have change (hash codes based on the system hash code are\n     * only stable for the same process).\n     * @return the instance with recalculated hash code"
        },
        "size": {
          "Javadoc": "* Gets the size of the list of keys.\n     *\n     * @return the size of the list of keys\n     * @since 3.1"
        },
        "toString": {
          "Javadoc": "* Gets a debugging string version of the key.\n     *\n     * @return a debugging string"
        }
      }
    },
    "org.apache.commons.collections4.keyvalue.TiedMapEntry": {
      "Javadoc": "\n * A {@link java.util.Map.Entry Map.Entry} tied to a map underneath.\n * <p>\n * This can be used to enable a map entry to make changes on the underlying\n * map, however this will probably mess up any iterators.\n * </p>\n *\n * @param <K> the type of keys\n * @param <V> the type of mapped values\n * @since 3.0\n ",
      "methods": {
        "equals": {
          "Javadoc": "* Compares this {@code Map.Entry} with another {@code Map.Entry}.\n     * <p>\n     * Implemented per API documentation of {@link java.util.Map.Entry#equals(Object)}\n     *\n     * @param obj  the object to compare to\n     * @return true if equal key and value"
        },
        "getKey": {
          "Javadoc": "* Gets the key of this entry\n     *\n     * @return the key"
        },
        "getValue": {
          "Javadoc": "* Gets the value of this entry direct from the map.\n     *\n     * @return the value"
        },
        "hashCode": {
          "Javadoc": "* Gets a hashCode compatible with the equals method.\n     * <p>\n     * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()}\n     *\n     * @return a suitable hash code"
        },
        "setValue": {
          "Javadoc": "* Sets the value associated with the key direct onto the map.\n     *\n     * @param value  the new value\n     * @return the old value\n     * @throws IllegalArgumentException if the value is set to this map entry"
        },
        "toString": {
          "Javadoc": "* Gets a string version of the entry.\n     *\n     * @return entry as a string"
        }
      }
    },
    "org.apache.commons.collections4.keyvalue.UnmodifiableMapEntry": {
      "Javadoc": "\n * A {@link java.util.Map.Entry Map.Entry} that throws\n * UnsupportedOperationException when {@code setValue} is called.\n *\n * @param <K> the type of keys\n * @param <V> the type of mapped values\n * @since 3.0\n ",
      "methods": {
        "setValue": {
          "Javadoc": "* Throws UnsupportedOperationException.\n     *\n     * @param value  the new value\n     * @return the previous value\n     * @throws UnsupportedOperationException always"
        }
      }
    },
    "org.apache.commons.collections4.KeyValue": {
      "Javadoc": "\n * Defines a simple key value pair.\n * <p>\n * A Map Entry has considerable additional semantics over and above a simple\n * key-value pair. This interface defines the minimum key value, with just the\n * two get methods.\n * </p>\n *\n * @param <K> the type of the key\n * @param <V> the type of the value\n * @since 3.0\n ",
      "methods": {
        "getKey": {
          "Javadoc": "* Gets the key from the pair.\n     *\n     * @return the key"
        },
        "getValue": {
          "Javadoc": "* Gets the value from the pair.\n     *\n     * @return the value"
        }
      }
    },
    "org.apache.commons.collections4.list.AbstractLinkedList": {
      "Javadoc": "\n * An abstract implementation of a linked list which provides numerous points for\n * subclasses to override.\n * <p>\n * Overridable methods are provided to change the storage node and to change how\n * nodes are added to and removed. Hopefully, all you need for unusual subclasses\n * is here.\n * </p>\n *\n * @param <E> the type of elements in this list\n * @since 3.0\n ",
      "methods": {
        "addNode": {
          "Javadoc": "* Inserts a new node into the list.\n     *\n     * @param nodeToInsert  new node to insert\n     * @param insertBeforeNode  node to insert before\n     * @throws NullPointerException if either node is null"
        },
        "addNodeAfter": {
          "Javadoc": "* Creates a new node with the specified object as its\n     * {@code value} and inserts it after {@code node}.\n     * <p>\n     * This implementation uses {@link #createNode(Object)} and\n     * {@link #addNode(AbstractLinkedList.Node,AbstractLinkedList.Node)}.\n     *\n     * @param node  node to insert after\n     * @param value  value of the newly added node\n     * @throws NullPointerException if {@code node} is null"
        },
        "addNodeBefore": {
          "Javadoc": "* Creates a new node with the specified object as its\n     * {@code value} and inserts it before {@code node}.\n     * <p>\n     * This implementation uses {@link #createNode(Object)} and\n     * {@link #addNode(AbstractLinkedList.Node,AbstractLinkedList.Node)}.\n     *\n     * @param node  node to insert before\n     * @param value  value of the newly added node\n     * @throws NullPointerException if {@code node} is null"
        },
        "createHeaderNode": {
          "Javadoc": "* Creates a new node with previous, next and element all set to null.\n     * This implementation creates a new empty Node.\n     * Subclasses can override this to create a different class.\n     *\n     * @return  newly created node"
        },
        "createNode": {
          "Javadoc": "* Creates a new node with the specified properties.\n     * This implementation creates a new Node with data.\n     * Subclasses can override this to create a different class.\n     *\n     * @param value  value of the new node\n     * @return a new node containing the value"
        },
        "createSubListIterator": {
          "Javadoc": "* Creates an iterator for the sublist.\n     *\n     * @param subList  the sublist to get an iterator for\n     * @return a new iterator on the given sublist"
        },
        "createSubListListIterator": {
          "Javadoc": "* Creates a list iterator for the sublist.\n     *\n     * @param subList  the sublist to get an iterator for\n     * @param fromIndex  the index to start from, relative to the sublist\n     * @return a new list iterator on the given sublist"
        },
        "doReadObject": {
          "Javadoc": "* Deserializes the data held in this object to the stream specified.\n     * <p>\n     * The first serializable subclass must call this method from\n     * {@code readObject}.\n     *\n     * @param inputStream  the stream to read the object from\n     * @throws IOException  if any error occurs while reading from the stream\n     * @throws ClassNotFoundException  if a class read from the stream can not be loaded"
        },
        "doWriteObject": {
          "Javadoc": "* Serializes the data held in this object to the stream specified.\n     * <p>\n     * The first serializable subclass must call this method from\n     * {@code writeObject}.\n     *\n     * @param outputStream  the stream to write the object to\n     * @throws IOException  if anything goes wrong"
        },
        "getNode": {
          "Javadoc": "* Gets the node at a particular index.\n     *\n     * @param index  the index, starting from 0\n     * @param endMarkerAllowed  whether or not the end marker can be returned if\n     * startIndex is set to the list's size\n     * @return the node at the given index\n     * @throws IndexOutOfBoundsException if the index is less than 0; equal to\n     * the size of the list and endMakerAllowed is false; or greater than the\n     * size of the list"
        },
        "init": {
          "Javadoc": "* The equivalent of a default constructor, broken out so it can be called\n     * by any constructor and by {@code readObject}.\n     * Subclasses which override this method should make sure they call super,\n     * so the list is initialized properly."
        },
        "isEqualValue": {
          "Javadoc": "* Compares two values for equals.\n     * This implementation uses the equals method.\n     * Subclasses can override this to match differently.\n     *\n     * @param value1  the first value to compare, may be null\n     * @param value2  the second value to compare, may be null\n     * @return true if equal"
        },
        "removeAll": {
          "Javadoc": "* {@inheritDoc}\n     * <p>\n     * This implementation iterates over the elements of this list, checking each element in\n     * turn to see if it's contained in {@code coll}. If it's contained, it's removed\n     * from this list. As a consequence, it is advised to use a collection type for\n     * {@code coll} that provides a fast (e.g. O(1)) implementation of\n     * {@link Collection#contains(Object)}."
        },
        "removeAllNodes": {
          "Javadoc": "* Removes all nodes by resetting the circular list marker."
        },
        "removeNode": {
          "Javadoc": "* Removes the specified node from the list.\n     *\n     * @param node  the node to remove\n     * @throws NullPointerException if {@code node} is null"
        },
        "retainAll": {
          "Javadoc": "* {@inheritDoc}\n     * <p>\n     * This implementation iterates over the elements of this list, checking each element in\n     * turn to see if it's contained in {@code coll}. If it's not contained, it's removed\n     * from this list. As a consequence, it is advised to use a collection type for\n     * {@code coll} that provides a fast (e.g. O(1)) implementation of\n     * {@link Collection#contains(Object)}."
        },
        "subList": {
          "Javadoc": "* Gets a sublist of the main list.\n     *\n     * @param fromIndexInclusive  the index to start from\n     * @param toIndexExclusive  the index to end at\n     * @return the new sublist"
        },
        "updateNode": {
          "Javadoc": "* Updates the node with a new value.\n     * This implementation sets the value on the node.\n     * Subclasses can override this to record the change.\n     *\n     * @param node  node to update\n     * @param value  new value of the node"
        }
      }
    },
    "org.apache.commons.collections4.list.LinkedListIterator": {
      "Javadoc": "\n     * A list iterator over the linked list.\n     *\n     * @param <E> the type of elements in this iterator.\n     ",
      "methods": {
        "checkModCount": {
          "Javadoc": "* Checks the modification count of the list is the value that this\n         * object expects.\n         *\n         * @throws ConcurrentModificationException If the list's modification\n         * count isn't the value that was expected."
        },
        "getLastNodeReturned": {
          "Javadoc": "* Gets the last node returned.\n         *\n         * @return the last node returned\n         * @throws IllegalStateException If {@link #next()} or {@link #previous()} haven't been called,\n         * or if the node has been removed with {@link #remove()} or a new node added with {@link #add(Object)}."
        }
      }
    },
    "org.apache.commons.collections4.list.LinkedSubList": {
      "Javadoc": "\n     * The sublist implementation for AbstractLinkedList.\n     *\n     * @param <E> the type of elements in this list.\n     "
    },
    "org.apache.commons.collections4.list.LinkedSubListIterator": {
      "Javadoc": "\n     * A list iterator over the linked sub list.\n     *\n     * @param <E> the type of elements in this iterator.\n     "
    },
    "org.apache.commons.collections4.list.Node": {
      "Javadoc": "\n     * A node within the linked list.\n     * <p>\n     * From Commons Collections 3.1, all access to the {@code value} property\n     * is via the methods on this class.\n     ",
      "methods": {
        "getNextNode": {
          "Javadoc": "* Gets the next node.\n         *\n         * @return the next node\n         * @since 3.1"
        },
        "getPreviousNode": {
          "Javadoc": "* Gets the previous node.\n         *\n         * @return the previous node\n         * @since 3.1"
        },
        "getValue": {
          "Javadoc": "* Gets the value of the node.\n         *\n         * @return the value\n         * @since 3.1"
        },
        "setNextNode": {
          "Javadoc": "* Sets the next node.\n         *\n         * @param next  the next node\n         * @since 3.1"
        },
        "setPreviousNode": {
          "Javadoc": "* Sets the previous node.\n         *\n         * @param previous  the previous node\n         * @since 3.1"
        },
        "setValue": {
          "Javadoc": "* Sets the value of the node.\n         *\n         * @param value  the value\n         * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.list.AbstractListDecorator": {
      "Javadoc": "\n * Decorates another {@link List} to provide additional behavior.\n * <p>\n * Methods are forwarded directly to the decorated list.\n * </p>\n *\n * @param <E> the type of the elements in the list\n * @since 3.0\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the list being decorated.\n     *\n     * @return the decorated list"
        }
      }
    },
    "org.apache.commons.collections4.list.AbstractSerializableListDecorator": {
      "Javadoc": "\n * Serializable subclass of AbstractListDecorator.\n *\n * @since 3.1\n ",
      "methods": {
        "readObject": {
          "Javadoc": "* Read the list in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "writeObject": {
          "Javadoc": "* Write the list out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.list.CursorableLinkedList": {
      "Javadoc": "\n * A {@code List} implementation with a {@code ListIterator} that\n * allows concurrent modifications to the underlying list.\n * <p>\n * This implementation supports all of the optional {@link List} operations.\n * It extends {@code AbstractLinkedList} and thus provides the\n * stack/queue/dequeue operations available in {@link java.util.LinkedList}.\n * </p>\n * <p>\n * The main feature of this class is the ability to modify the list and the\n * iterator at the same time. Both the {@link #listIterator()} and {@link #cursor()}\n * methods provides access to a {@code Cursor} instance which extends\n * {@code ListIterator}. The cursor allows changes to the list concurrent\n * with changes to the iterator. Note that the {@link #iterator()} method and\n * sublists do <b>not</b> provide this cursor behavior.\n * </p>\n * <p>\n * The {@code Cursor} class is provided partly for backwards compatibility\n * and partly because it allows the cursor to be directly closed. Closing the\n * cursor is optional because references are held via a {@code WeakReference}.\n * For most purposes, simply modify the iterator and list at will, and then let\n * the garbage collector to the rest.\n * </p>\n * <p>\n * <b>Note that this implementation is not synchronized.</b>\n * </p>\n *\n * @see java.util.LinkedList\n * @since 1.0\n ",
      "methods": {
        "addNode": {
          "Javadoc": "* Inserts a new node into the list.\n     *\n     * @param nodeToInsert  new node to insert\n     * @param insertBeforeNode  node to insert before\n     * @throws NullPointerException if either node is null"
        },
        "broadcastNodeChanged": {
          "Javadoc": "* Informs all of my registered cursors that the specified\n     * element was changed.\n     *\n     * @param node  the node that was changed"
        },
        "broadcastNodeInserted": {
          "Javadoc": "* Informs all of my registered cursors that the specified\n     * element was just added to my list.\n     *\n     * @param node  the node that was changed"
        },
        "broadcastNodeRemoved": {
          "Javadoc": "* Informs all of my registered cursors that the specified\n     * element was just removed from my list.\n     *\n     * @param node  the node that was changed"
        },
        "createSubListListIterator": {
          "Javadoc": "* Creates a list iterator for the sublist.\n     *\n     * @param subList  the sublist to get an iterator for\n     * @param fromIndex  the index to start from, relative to the sublist\n     * @return the list iterator for the sublist"
        },
        "cursor": {
          "Javadoc": "* Returns a {@link Cursor} for iterating through the elements of this list\n     * starting from a specified index.\n     * <p>\n     * A {@code Cursor} is a {@code ListIterator} with an additional\n     * {@code close()} method. Calling this method immediately discards the\n     * references to the cursor. If it is not called, then the garbage collector\n     * will still remove the reference as it is held via a {@code WeakReference}.\n     * <p>\n     * The cursor enables iteration and list changes to occur in any order without\n     * invalidating the iterator (from one thread). When elements are added to the\n     * list, an event is fired to all active cursors enabling them to adjust to the\n     * change in the list.\n     * <p>\n     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n     * or {@link ListIterator#previous}) element of the list is removed,\n     * the cursor automatically adjusts to the change (invalidating the\n     * last returned value such that it cannot be removed).\n     * <p>\n     * The {@link #listIterator(int)} method returns the same as this method, and can\n     * be cast to a {@code Cursor} if the {@code close} method is required.\n     *\n     * @param fromIndex  the index to start from\n     * @return a new cursor iterator\n     * @throws IndexOutOfBoundsException if the index is out of range\n     *      (index &lt; 0 || index &gt; size())."
        },
        "init": {
          "Javadoc": "* The equivalent of a default constructor called\n     * by any constructor and by {@code readObject}."
        },
        "iterator": {
          "Javadoc": "* Returns an iterator that does <b>not</b> support concurrent modification.\n     * <p>\n     * If the underlying list is modified while iterating using this iterator\n     * a ConcurrentModificationException will occur.\n     * The cursor behavior is available via {@link #listIterator()}.\n     *\n     * @return a new iterator that does <b>not</b> support concurrent modification"
        },
        "listIterator": {
          "Javadoc": "* Returns a cursor iterator that allows changes to the underlying list in parallel.\n     * <p>\n     * The cursor enables iteration and list changes to occur in any order without\n     * invalidating the iterator (from one thread). When elements are added to the\n     * list, an event is fired to all active cursors enabling them to adjust to the\n     * change in the list.\n     * <p>\n     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n     * or {@link ListIterator#previous}) element of the list is removed,\n     * the cursor automatically adjusts to the change (invalidating the\n     * last returned value such that it cannot be removed).\n     *\n     * @param fromIndex  the index to start from\n     * @return a new cursor iterator"
        },
        "readObject": {
          "Javadoc": "* Deserializes the data held in this object to the stream specified.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "registerCursor": {
          "Javadoc": "* Registers a cursor to be notified of changes to this list.\n     *\n     * @param cursor  the cursor to register"
        },
        "removeAllNodes": {
          "Javadoc": "* Removes all nodes by iteration."
        },
        "removeNode": {
          "Javadoc": "* Removes the specified node from the list.\n     *\n     * @param node  the node to remove\n     * @throws NullPointerException if {@code node} is null"
        },
        "unregisterCursor": {
          "Javadoc": "* Deregisters a cursor from the list to be notified of changes.\n     *\n     * @param cursor  the cursor to deregister"
        },
        "updateNode": {
          "Javadoc": "* Updates the node with a new value.\n     * This implementation sets the value on the node.\n     * Subclasses can override this to record the change.\n     *\n     * @param node  node to update\n     * @param value  new value of the node"
        },
        "writeObject": {
          "Javadoc": "* Serializes the data held in this object to the stream specified.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.list.Cursor": {
      "Javadoc": "\n     * An extended {@code ListIterator} that allows concurrent changes to\n     * the underlying list.\n     *\n     * @param <E> the type of elements in this cursor.\n     ",
      "methods": {
        "add": {
          "Javadoc": "* Adds an object to the list.\n         * The object added here will be the new 'previous' in the iterator.\n         *\n         * @param obj  the object to add"
        },
        "checkModCount": {
          "Javadoc": "* Override superclass modCount check, and replace it with our valid flag."
        },
        "close": {
          "Javadoc": "* Mark this cursor as no longer being needed. Any resources\n         * associated with this cursor are immediately released.\n         * In previous versions of this class, it was mandatory to close\n         * all cursor objects to avoid memory leaks. It is <i>no longer</i>\n         * necessary to call this close method; an instance of this class\n         * can now be treated exactly like a normal iterator."
        },
        "nextIndex": {
          "Javadoc": "* Gets the index of the next element to be returned.\n         *\n         * @return the next index"
        },
        "nodeChanged": {
          "Javadoc": "* Handle event from the list when a node has changed.\n         *\n         * @param node  the node that changed"
        },
        "nodeInserted": {
          "Javadoc": "* Handle event from the list when a node has been added.\n         *\n         * @param node  the node that was added"
        },
        "nodeRemoved": {
          "Javadoc": "* Handle event from the list when a node has been removed.\n         *\n         * @param node  the node that was removed"
        },
        "remove": {
          "Javadoc": "* Removes the item last returned by this iterator.\n         * <p>\n         * There may have been subsequent alterations to the list\n         * since you obtained this item, however you can still remove it.\n         * You can even remove it if the item is no longer in the main list.\n         * However, you can't call this method on the same iterator more\n         * than once without calling next() or previous().\n         *\n         * @throws IllegalStateException if there is no item to remove"
        }
      }
    },
    "org.apache.commons.collections4.list.SubCursor": {
      "Javadoc": "\n     * A cursor for the sublist based on LinkedSubListIterator.\n     *\n     * @param <E> the type of elements in this cursor.\n     * @since 3.2\n     "
    },
    "org.apache.commons.collections4.list.FixedSizeList": {
      "Javadoc": "\n * Decorates another {@code List} to fix the size preventing add/remove.\n * <p>\n * The add, remove, clear and retain operations are unsupported.\n * The set method is allowed (as it doesn't change the list size).\n * </p>\n * <p>\n * NOTE:\n * Modifying the decorated list directly would results in influencing the outcome\n * of method calls on this object. For example, the bounds of this list would reflect\n * a newly added object to the underlying list.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <E> the type of elements in this collection\n * @since 3.0\n ",
      "methods": {
        "fixedSizeList": {
          "Javadoc": "* Factory method to create a fixed size list.\n     *\n     * @param <E> the type of the elements in the list\n     * @param list  the list to decorate, must not be null\n     * @return a new fixed size list\n     * @throws NullPointerException if list is null\n     * @since 4.0"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        }
      }
    },
    "org.apache.commons.collections4.list.FixedSizeListIterator": {
      "Javadoc": "\n     * List iterator that only permits changes via set()\n     "
    },
    "org.apache.commons.collections4.list.GrowthList": {
      "Javadoc": "\n * Decorates another {@code List} to make it seamlessly grow when\n * indices larger than the list size are used on add and set,\n * avoiding most IndexOutOfBoundsExceptions.\n * <p>\n * This class avoids errors by growing when a set or add method would\n * normally throw an IndexOutOfBoundsException.\n * Note that IndexOutOfBoundsException IS returned for invalid negative indices.\n * </p>\n * <p>\n * Trying to set or add to an index larger than the size will cause the list\n * to grow (using {@code null} elements). Clearly, care must be taken\n * not to use excessively large indices, as the internal list will grow to\n * match.\n * </p>\n * <p>\n * Trying to use any method other than add or set with an invalid index will\n * call the underlying list and probably result in an IndexOutOfBoundsException.\n * </p>\n * <p>\n * Take care when using this list with {@code null} values, as\n * {@code null} is the value added when growing the list.\n * </p>\n * <p>\n * All sub-lists will access the underlying list directly, and will throw\n * IndexOutOfBoundsExceptions.\n * </p>\n * <p>\n * This class differs from {@link LazyList} because here growth occurs on\n * set and add, where {@code LazyList} grows on get. However, they\n * can be used together by decorating twice.\n * </p>\n *\n * @see LazyList\n * @since 3.2\n ",
      "methods": {
        "growthList": {
          "Javadoc": "* Factory method to create a growth list.\n     *\n     * @param <E> the type of the elements in the list\n     * @param list  the list to decorate, must not be null\n     * @return a new growth list\n     * @throws NullPointerException if list is null\n     * @since 4.0"
        },
        "add": {
          "Javadoc": "* Decorate the add method to perform the growth behavior.\n     * <p>\n     * If the requested index is greater than the current size, the list will\n     * grow to the new size. Indices between the old size and the requested\n     * size will be filled with {@code null}.\n     * <p>\n     * If the index is less than the current size, the value will be added to\n     * the underlying list directly.\n     * If the index is less than zero, the underlying list is called, which\n     * will probably throw an IndexOutOfBoundsException.\n     *\n     * @param index  the index to add at\n     * @param element  the object to add at the specified index\n     * @throws UnsupportedOperationException if the underlying list doesn't implement set\n     * @throws ClassCastException if the underlying list rejects the element\n     * @throws IllegalArgumentException if the underlying list rejects the element"
        },
        "addAll": {
          "Javadoc": "* Decorate the addAll method to perform the growth behavior.\n     * <p>\n     * If the requested index is greater than the current size, the list will\n     * grow to the new size. Indices between the old size and the requested\n     * size will be filled with {@code null}.\n     * <p>\n     * If the index is less than the current size, the values will be added to\n     * the underlying list directly.\n     * If the index is less than zero, the underlying list is called, which\n     * will probably throw an IndexOutOfBoundsException.\n     *\n     * @param index  the index to add at\n     * @param coll  the collection to add at the specified index\n     * @return true if the list changed\n     * @throws UnsupportedOperationException if the underlying list doesn't implement set\n     * @throws ClassCastException if the underlying list rejects the element\n     * @throws IllegalArgumentException if the underlying list rejects the element"
        },
        "set": {
          "Javadoc": "* Decorate the set method to perform the growth behavior.\n     * <p>\n     * If the requested index is greater than the current size, the list will\n     * grow to the new size. Indices between the old size and the requested\n     * size will be filled with {@code null}.\n     * <p>\n     * If the index is less than the current size, the value will be set onto\n     * the underlying list directly.\n     * If the index is less than zero, the underlying list is called, which\n     * will probably throw an IndexOutOfBoundsException.\n     *\n     * @param index  the index to set\n     * @param element  the object to set at the specified index\n     * @return the object previously at that index\n     * @throws UnsupportedOperationException if the underlying list doesn't implement set\n     * @throws ClassCastException if the underlying list rejects the element\n     * @throws IllegalArgumentException if the underlying list rejects the element"
        }
      }
    },
    "org.apache.commons.collections4.list.LazyList": {
      "Javadoc": "\n * Decorates another {@code List} to create objects in the list on demand.\n * <p>\n * When the {@link #get(int)} method is called with an index greater than\n * the size of the list, the list will automatically grow in size and return\n * a new object from the specified factory or transformer. The gaps will be\n * filled by null. If a get method call encounters a null, it will be replaced\n * with a new object from the factory. Thus this list is unsuitable for\n * storing null objects.\n * </p>\n * <p>\n * For instance:\n * </p>\n *\n * <pre>\n * Factory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n *     public Date create() {\n *         return new Date();\n *     }\n * }\n * List&lt;Date&gt; lazy = LazyList.decorate(new ArrayList&lt;Date&gt;(), factory);\n * Date date = lazy.get(3);\n * </pre>\n *\n * <p>\n * After the above code is executed, {@code date} will contain\n * a new {@code Date} instance.  Furthermore, that {@code Date}\n * instance is the fourth element in the list.  The first, second,\n * and third element are all set to {@code null}.\n * </p>\n * <p>\n * This class differs from {@link GrowthList} because here growth occurs on\n * get, where {@code GrowthList} grows on set and add. However, they\n * could easily be used together by decorating twice.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @see GrowthList\n * @since 3.0\n ",
      "methods": {
        "lazyList": {
          "Javadoc": "* Transformer method to create a lazily instantiating list.\n     *\n     * @param <E> the type of the elements in the list\n     * @param list  the list to decorate, must not be null\n     * @param transformer  the transformer to use for creation, must not be null\n     * @return a new lazy list\n     * @throws NullPointerException if list or transformer is null\n     * @since 4.4"
        },
        "get": {
          "Javadoc": "* Decorate the get method to perform the lazy behavior.\n     * <p>\n     * If the requested index is greater than the current size, the list will\n     * grow to the new size and a new object will be returned from the factory\n     * or transformer. Indexes in-between the old size and the requested size\n     * are left with a placeholder that is replaced with a factory or\n     * transformer object when requested.\n     *\n     * @param index  the index to retrieve\n     * @return the element at the given index"
        }
      }
    },
    "org.apache.commons.collections4.list.NodeCachingLinkedList": {
      "Javadoc": "\n * A {@code List} implementation that stores a cache of internal Node objects\n * in an effort to reduce wasteful object creation.\n * <p>\n * A linked list creates one Node for each item of data added. This can result in\n * a lot of object creation and garbage collection. This implementation seeks to\n * avoid that by maintaining a store of cached nodes.\n * </p>\n * <p>\n * This implementation is suitable for long-lived lists where both add and remove\n * are used. Short-lived lists, or lists which only grow will have worse performance\n * using this class.\n * </p>\n * <p>\n * <b>Note that this implementation is not synchronized.</b>\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "addNodeToCache": {
          "Javadoc": "* Adds a node to the cache, if the cache isn't full.\n     * The node's contents are cleared, so they can be garbage collected.\n     *\n     * @param node  the node to add to the cache"
        },
        "createNode": {
          "Javadoc": "* Creates a new node, either by reusing one from the cache or creating\n     * a new one.\n     *\n     * @param value  value of the new node\n     * @return the newly created node"
        },
        "getMaximumCacheSize": {
          "Javadoc": "* Gets the maximum size of the cache.\n     *\n     * @return the maximum cache size"
        },
        "getNodeFromCache": {
          "Javadoc": "* Gets a node from the cache. If a node is returned, then the value of\n     * {@link #cacheSize} is decreased accordingly. The node that is returned\n     * will have {@code null} values for next, previous and element.\n     *\n     * @return a node, or {@code null} if there are no nodes in the cache."
        },
        "isCacheFull": {
          "Javadoc": "* Checks whether the cache is full.\n     *\n     * @return true if the cache is full"
        },
        "readObject": {
          "Javadoc": "* Deserializes the data held in this object to the stream specified.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "removeAllNodes": {
          "Javadoc": "* Removes all the nodes from the list, storing as many as required in the\n     * cache for reuse."
        },
        "removeNode": {
          "Javadoc": "* Removes the node from the list, storing it in the cache for reuse\n     * if the cache is not yet full.\n     *\n     * @param node  the node to remove"
        },
        "setMaximumCacheSize": {
          "Javadoc": "* Sets the maximum size of the cache.\n     *\n     * @param maximumCacheSize  the new maximum cache size"
        },
        "shrinkCacheToMaximumSize": {
          "Javadoc": "* Reduce the size of the cache to the maximum, if necessary."
        },
        "writeObject": {
          "Javadoc": "* Serializes the data held in this object to the stream specified.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.list.PredicatedList": {
      "Javadoc": "\n * Decorates another {@code List} to validate that all additions\n * match a specified predicate.\n * <p>\n * This list exists to provide validation for the decorated list.\n * It is normally created to decorate an empty list.\n * If an object cannot be added to the list, an IllegalArgumentException is thrown.\n * </p>\n * <p>\n * One usage would be to ensure that no null entries are added to the list.\n * </p>\n * <pre>\n * {@code\n * List<String> list =\n *   PredicatedList.predicatedList(new ArrayList<String>(), PredicateUtils.notNullPredicate());\n * }\n * </pre>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "predicatedList": {
          "Javadoc": "* Factory method to create a predicated (validating) list.\n     * <p>\n     * If there are any elements already in the list being decorated, they\n     * are validated.\n     *\n     * @param <T> the type of the elements in the list\n     * @param list  the list to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated list\n     * @throws NullPointerException if list or predicate is null\n     * @throws IllegalArgumentException if the list contains invalid elements\n     * @since 4.0"
        },
        "decorated": {
          "Javadoc": "* Gets the list being decorated.\n     *\n     * @return the decorated list"
        }
      }
    },
    "org.apache.commons.collections4.list.PredicatedListIterator": {
      "Javadoc": "\n     * Inner class Iterator for the PredicatedList\n     "
    },
    "org.apache.commons.collections4.list.SetUniqueList": {
      "Javadoc": "\n * Decorates a {@code List} to ensure that no duplicates are present much\n * like a {@code Set}.\n * <p>\n * The {@code List} interface makes certain assumptions/requirements. This\n * implementation breaks these in certain ways, but this is merely the result of\n * rejecting duplicates. Each violation is explained in the method, but it\n * should not affect you. Bear in mind that Sets require immutable objects to\n * function correctly.\n * </p>\n * <p>\n * The {@link org.apache.commons.collections4.set.ListOrderedSet ListOrderedSet}\n * class provides an alternative approach, by wrapping an existing Set and\n * retaining insertion order in the iterator.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "setUniqueList": {
          "Javadoc": "* Factory method to create a SetList using the supplied list to retain order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one\n     * kept). A {@code HashSet} is used for the set behavior.\n     *\n     * @param <E>  the element type\n     * @param list  the list to decorate, must not be null\n     * @return a new {@link SetUniqueList}\n     * @throws NullPointerException if list is null\n     * @since 4.0"
        },
        "add": {
          "Javadoc": "* Adds an element to a specific index in the list if it is not already\n     * present.\n     * <p>\n     * <i>(Violation)</i> The {@code List} interface makes the assumption\n     * that the element is always inserted. This may not happen with this\n     * implementation.\n     *\n     * @param index  the index to insert at\n     * @param object  the object to add"
        },
        "addAll": {
          "Javadoc": "* Adds a collection of objects a specific index in the list avoiding\n     * duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <i>(Violation)</i> The {@code List} interface makes the assumption\n     * that the elements are always inserted. This may not happen with this\n     * implementation.\n     *\n     * @param index  the index to insert at\n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed"
        },
        "asSet": {
          "Javadoc": "* Gets an unmodifiable view as a Set.\n     *\n     * @return an unmodifiable set view"
        },
        "createSetBasedOnList": {
          "Javadoc": "* Create a new {@link Set} with the same type as the provided {@code set}\n     * and populate it with all elements of {@code list}.\n     *\n     * @param set  the {@link Set} to be used as return type, must not be null\n     * @param list  the {@link List} to populate the {@link Set}\n     * @return a new {@link Set} populated with all elements of the provided\n     *   {@link List}"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        },
        "retainAll": {
          "Javadoc": "* {@inheritDoc}\n     * <p>\n     * This implementation iterates over the elements of this list, checking\n     * each element in turn to see if it's contained in {@code coll}.\n     * If it's not contained, it's removed from this list. As a consequence,\n     * it is advised to use a collection type for {@code coll} that provides\n     * a fast (e.g. O(1)) implementation of {@link Collection#contains(Object)}."
        },
        "set": {
          "Javadoc": "* Sets the value at the specified index avoiding duplicates.\n     * <p>\n     * The object is set into the specified index. Afterwards, any previous\n     * duplicate is removed. If the object is not already in the list then a\n     * normal set occurs. If it is present, then the old version is removed.\n     *\n     * @param index  the index to insert at\n     * @param object  the object to set\n     * @return the previous object"
        },
        "subList": {
          "Javadoc": "* {@inheritDoc}\n     * <p>\n     * NOTE: from 4.0, an unmodifiable list will be returned, as changes to the\n     * subList can invalidate the parent list."
        }
      }
    },
    "org.apache.commons.collections4.list.SetListIterator": {
      "Javadoc": "\n     * Inner class iterator.\n     "
    },
    "org.apache.commons.collections4.list.SetListListIterator": {
      "Javadoc": "\n     * Inner class iterator.\n     "
    },
    "org.apache.commons.collections4.list.TransformedList": {
      "Javadoc": "\n * Decorates another {@code List} to transform objects that are added.\n * <p>\n * The add and set methods are affected by this class.\n * Thus objects must be removed or searched for using their transformed form.\n * For example, if the transformation converts Strings to Integers, you must\n * use the Integer form to remove objects.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "transformedList": {
          "Javadoc": "* Factory method to create a transforming list that will transform\n     * existing contents of the specified list.\n     * <p>\n     * If there are any elements already in the list being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingList(List, Transformer)}.\n     *\n     * @param <E> the type of the elements in the list\n     * @param list  the list to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed List\n     * @throws NullPointerException if list or transformer is null\n     * @since 4.0"
        },
        "transformingList": {
          "Javadoc": "* Factory method to create a transforming list.\n     * <p>\n     * If there are any elements already in the list being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedList(List, Transformer)}.\n     *\n     * @param <E> the type of the elements in the list\n     * @param list  the list to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed list\n     * @throws NullPointerException if list or transformer is null\n     * @since 4.0"
        },
        "getList": {
          "Javadoc": "* Gets the decorated list.\n     *\n     * @return the decorated list"
        }
      }
    },
    "org.apache.commons.collections4.list.TransformedListIterator": {
      "Javadoc": "\n     * Inner class Iterator for the TransformedList\n     "
    },
    "org.apache.commons.collections4.list.TreeList": {
      "Javadoc": "\n * A {@code List} implementation that is optimized for fast insertions and\n * removals at any index in the list.\n * <p>\n * This list implementation utilises a tree structure internally to ensure that\n * all insertions and removals are O(log n). This provides much faster performance\n * than both an {@code ArrayList} and a {@code LinkedList} where elements\n * are inserted and removed repeatedly from anywhere in the list.\n * </p>\n * <p>\n * The following relative performance statistics are indicative of this class:\n * </p>\n * <pre>\n *              get  add  insert  iterate  remove\n * TreeList       3    5       1       2       1\n * ArrayList      1    1      40       1      40\n * LinkedList  5800    1     350       2     325\n * </pre>\n * <p>\n * {@code ArrayList} is a good general purpose list implementation.\n * It is faster than {@code TreeList} for most operations except inserting\n * and removing in the middle of the list. {@code ArrayList} also uses less\n * memory as {@code TreeList} uses one object per entry.\n * </p>\n * <p>\n * {@code LinkedList} is rarely a good choice of implementation.\n * {@code TreeList} is almost always a good replacement for it, although it\n * does use slightly more memory.\n * </p>\n *\n * @since 3.1\n ",
      "methods": {
        "add": {
          "Javadoc": "* Adds a new element to the list.\n     *\n     * @param index  the index to add before\n     * @param obj  the element to add"
        },
        "addAll": {
          "Javadoc": "* Appends all the elements in the specified collection to the end of this list,\n     * in the order that they are returned by the specified collection's Iterator.\n     * <p>\n     * This method runs in O(n + log m) time, where m is\n     * the size of this list and n is the size of {@code c}.\n     *\n     * @param c  the collection to be added to this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws NullPointerException {@inheritDoc}"
        },
        "checkInterval": {
          "Javadoc": "* Checks whether the index is valid.\n     *\n     * @param index  the index to check\n     * @param startIndex  the first allowed index\n     * @param endIndex  the last allowed index\n     * @throws IndexOutOfBoundsException if the index is invalid"
        },
        "clear": {
          "Javadoc": "* Clears the list, removing all entries."
        },
        "contains": {
          "Javadoc": "* Searches for the presence of an object in the list.\n     *\n     * @param object  the object to check\n     * @return true if the object is found"
        },
        "get": {
          "Javadoc": "* Gets the element at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the element at the specified index"
        },
        "indexOf": {
          "Javadoc": "* Searches for the index of an object in the list.\n     *\n     * @param object  the object to search\n     * @return the index of the object, -1 if not found"
        },
        "iterator": {
          "Javadoc": "* Gets an iterator over the list.\n     *\n     * @return an iterator over the list"
        },
        "listIterator": {
          "Javadoc": "* Gets a ListIterator over the list.\n     *\n     * @param fromIndex  the index to start from\n     * @return the new iterator"
        },
        "remove": {
          "Javadoc": "* Removes the element at the specified index.\n     *\n     * @param index  the index to remove\n     * @return the previous object at that index"
        },
        "set": {
          "Javadoc": "* Sets the element at the specified index.\n     *\n     * @param index  the index to set\n     * @param obj  the object to store at the specified index\n     * @return the previous object at that index\n     * @throws IndexOutOfBoundsException if the index is invalid"
        },
        "size": {
          "Javadoc": "* Gets the current size of the list.\n     *\n     * @return the current size"
        },
        "toArray": {
          "Javadoc": "* Converts the list into an array.\n     *\n     * @return the list as an array"
        }
      }
    },
    "org.apache.commons.collections4.list.AVLNode": {
      "Javadoc": "\n     * Implements an AVLNode which keeps the offset updated.\n     * <p>\n     * This node contains the real work.\n     * TreeList is just there to implement {@link java.util.List}.\n     * The nodes don't know the index of the object they are holding.  They\n     * do know however their position relative to their parent node.\n     * This allows to calculate the index of a node while traversing the tree.\n     * <p>\n     * The Faedelung calculation stores a flag for both the left and right child\n     * to indicate if they are a child (false) or a link as in linked list (true).\n     ",
      "methods": {
        "addAll": {
          "Javadoc": "* Appends the elements of another tree list to this tree list by efficiently\n         * merging the two AVL trees. This operation is destructive to both trees and\n         * runs in O(log(m + n)) time.\n         *\n         * @param otherTree\n         *            the root of the AVL tree to merge with this one\n         * @param currentSize\n         *            the number of elements in this AVL tree\n         * @return the root of the new, merged AVL tree"
        },
        "balance": {
          "Javadoc": "* Balances according to the AVL algorithm."
        },
        "get": {
          "Javadoc": "* Locate the element with the given index relative to the\n         * offset of the parent of this node."
        },
        "getHeight": {
          "Javadoc": "* Returns the height of the node or -1 if the node is null."
        },
        "getLeftSubTree": {
          "Javadoc": "* Gets the left node, returning null if it's a faedelung."
        },
        "getOffset": {
          "Javadoc": "* Gets the relative position."
        },
        "getRightSubTree": {
          "Javadoc": "* Gets the right node, returning null if it's a faedelung."
        },
        "getValue": {
          "Javadoc": "* Gets the value.\n         *\n         * @return the value of this node"
        },
        "heightRightMinusLeft": {
          "Javadoc": "* Returns the height difference right - left"
        },
        "indexOf": {
          "Javadoc": "* Locate the index that contains the specified object."
        },
        "insert": {
          "Javadoc": "* Inserts a node at the position index.\n         *\n         * @param index is the index of the position relative to the position of\n         * the parent node.\n         * @param obj is the object to be stored in the position."
        },
        "max": {
          "Javadoc": "* Gets the rightmost child of this node.\n         *\n         * @return the rightmost child (greatest index)"
        },
        "min": {
          "Javadoc": "* Gets the leftmost child of this node.\n         *\n         * @return the leftmost child (smallest index)"
        },
        "next": {
          "Javadoc": "* Gets the next node in the list after this one.\n         *\n         * @return the next node"
        },
        "previous": {
          "Javadoc": "* Gets the node in the list before this one.\n         *\n         * @return the previous node"
        },
        "recalcHeight": {
          "Javadoc": "* Sets the height by calculation."
        },
        "remove": {
          "Javadoc": "* Removes the node at a given position.\n         *\n         * @param index is the index of the element to be removed relative to the position of\n         * the parent node of the current node."
        },
        "removeSelf": {
          "Javadoc": "* Removes this node from the tree.\n         *\n         * @return the node that replaces this one in the parent"
        },
        "setLeft": {
          "Javadoc": "* Sets the left field to the node, or the previous node if that is null\n         *\n         * @param node  the new left subtree node\n         * @param previous  the previous node in the linked list"
        },
        "setOffset": {
          "Javadoc": "* Sets the relative position."
        },
        "setRight": {
          "Javadoc": "* Sets the right field to the node, or the next node if that is null\n         *\n         * @param node  the new left subtree node\n         * @param next  the next node in the linked list"
        },
        "setValue": {
          "Javadoc": "* Sets the value.\n         *\n         * @param obj  the value to store"
        },
        "toArray": {
          "Javadoc": "* Stores the node and its children into the array specified.\n         *\n         * @param array the array to be filled\n         * @param index the index of this node"
        },
        "toString": {
          "Javadoc": "* Used for debugging."
        }
      }
    },
    "org.apache.commons.collections4.list.TreeListIterator": {
      "Javadoc": "\n     * A list iterator over the linked list.\n     ",
      "methods": {
        "checkModCount": {
          "Javadoc": "* Checks the modification count of the list is the value that this\n         * object expects.\n         *\n         * @throws ConcurrentModificationException If the list's modification\n         * count isn't the value that was expected."
        }
      }
    },
    "org.apache.commons.collections4.list.UnmodifiableList": {
      "Javadoc": "\n * Decorates another {@code List} to ensure it can't be altered.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @since 3.0\n ",
      "methods": {
        "unmodifiableList": {
          "Javadoc": "* Factory method to create an unmodifiable list.\n     *\n     * @param <E> the type of the elements in the list\n     * @param list  the list to decorate, must not be null\n     * @return a new unmodifiable list\n     * @throws NullPointerException if list is null\n     * @since 4.0"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        }
      }
    },
    "org.apache.commons.collections4.ListUtils": {
      "Javadoc": "\n * Provides utility methods and decorators for {@link List} instances.\n *\n * @since 1.0\n ",
      "methods": {
        "defaultIfNull": {
          "Javadoc": "* Returns either the passed in list, or if the list is {@code null},\n     * the value of {@code defaultList}.\n     *\n     * @param <T> the element type\n     * @param list  the list, possibly {@code null}\n     * @param defaultList  the returned values if list is {@code null}\n     * @return an empty list if the argument is {@code null}\n     * @since 4.0"
        },
        "emptyIfNull": {
          "Javadoc": "* Returns an immutable empty list if the argument is {@code null},\n     * or the argument itself otherwise.\n     *\n     * @param <T> the element type\n     * @param list the list, possibly {@code null}\n     * @return an empty list if the argument is {@code null}"
        },
        "fixedSizeList": {
          "Javadoc": "* Returns a fixed-sized list backed by the given list.\n     * Elements may not be added or removed from the returned list, but\n     * existing elements can be changed (for instance, via the\n     * {@link List#set(int, Object)} method).\n     *\n     * @param <E>  the element type\n     * @param list  the list whose size to fix, must not be null\n     * @return a fixed-size list backed by that list\n     * @throws NullPointerException  if the List is null"
        },
        "getFirst": {
          "Javadoc": "* Gets the first element of a list.\n     * <p>\n     * Shorthand for {@code list.get(0)}\n     * </p>\n     * @param <T> The list type.\n     * @param list The list.\n     * @return the first element of a list.\n     * @see List#get(int)\n     * @since 4.5"
        },
        "getLast": {
          "Javadoc": "* Gets the last element of a list.\n     * <p>\n     * Shorthand for {@code list.get(list.size() - 1)}\n     * </p>\n     * @param <T> The list type.\n     * @param list The list.\n     * @return the last element of a list.\n     * @see List#get(int)\n     * @since 4.5"
        },
        "hashCodeForList": {
          "Javadoc": "* Generates a hash code using the algorithm specified in\n     * {@link java.util.List#hashCode()}.\n     * <p>\n     * This method is useful for implementing {@code List} when you cannot\n     * extend AbstractList. The method takes Collection instances to enable other\n     * collection types to use the List implementation algorithm.\n     *\n     * @see java.util.List#hashCode()\n     * @param list  the list to generate the hashCode for, may be null\n     * @return the hash code"
        },
        "indexOf": {
          "Javadoc": "* Finds the first index in the given List which matches the given predicate.\n     * <p>\n     * If the input List or predicate is null, or no element of the List\n     * matches the predicate, -1 is returned.\n     *\n     * @param <E>  the element type\n     * @param list the List to search, may be null\n     * @param predicate  the predicate to use, may be null\n     * @return the first index of an Object in the List which matches the predicate or -1 if none could be found"
        },
        "intersection": {
          "Javadoc": "* Returns a new list containing all elements that are contained in\n     * both given lists.\n     *\n     * @param <E> the element type\n     * @param list1  the first list\n     * @param list2  the second list\n     * @return  the intersection of those two lists\n     * @throws NullPointerException if either list is null"
        },
        "isEqualList": {
          "Javadoc": "* Tests two lists for value-equality as per the equality contract in\n     * {@link java.util.List#equals(Object)}.\n     * <p>\n     * This method is useful for implementing {@code List} when you cannot\n     * extend AbstractList. The method takes Collection instances to enable other\n     * collection types to use the List implementation algorithm.\n     * <p>\n     * The relevant text (slightly paraphrased as this is a static method) is:\n     * <blockquote>\n     * Compares the two list objects for equality.  Returns\n     * {@code true} if and only if both\n     * lists have the same size, and all corresponding pairs of elements in\n     * the two lists are <i>equal</i>.  (Two elements {@code e1} and\n     * {@code e2} are <i>equal</i> if <code>(e1==null ? e2==null :\n     * e1.equals(e2))</code>.)  In other words, two lists are defined to be\n     * equal if they contain the same elements in the same order.  This\n     * definition ensures that the equals method works properly across\n     * different implementations of the {@code List} interface.\n     * </blockquote>\n     *\n     * <b>Note:</b> The behavior of this method is undefined if the lists are\n     * modified during the equals comparison.\n     *\n     * @see java.util.List\n     * @param list1  the first list, may be null\n     * @param list2  the second list, may be null\n     * @return whether the lists are equal by value comparison"
        },
        "lazyList": {
          "Javadoc": "* Returns a \"lazy\" list whose elements will be created on demand.\n     * <p>\n     * When the index passed to the returned list's {@link List#get(int) get}\n     * method is greater than the list's size, then the transformer will be used\n     * to create a new object and that object will be inserted at that index.\n     * <p>\n     * For instance:\n     *\n     * <pre>\n     * List&lt;Integer&gt; hours = Arrays.asList(7, 5, 8, 2);\n     * Transformer&lt;Integer,Date&gt; transformer = input -&gt; LocalDateTime.now().withHour(hours.get(input));\n     * List&lt;LocalDateTime&gt; lazy = ListUtils.lazyList(new ArrayList&lt;LocalDateTime&gt;(), transformer);\n     * Date date = lazy.get(3);\n     * </pre>\n     *\n     * After the above code is executed, {@code date} will refer to\n     * a new {@code Date} instance. Furthermore, that {@code Date}\n     * instance is the fourth element in the list.  The first, second,\n     * and third element are all set to {@code null}.\n     *\n     * @param <E> the element type\n     * @param list  the list to make lazy, must not be null\n     * @param transformer  the transformer for creating new objects, must not be null\n     * @return a lazy list backed by the given list\n     * @throws NullPointerException if the List or Transformer is null"
        },
        "longestCommonSubsequence": {
          "Javadoc": "* Returns the longest common subsequence (LCS) of two sequences (lists).\n     *\n     * @param <E>  the element type\n     * @param listA  the first list\n     * @param listB  the second list\n     * @param equator  the equator used to test object equality\n     * @return the longest common subsequence\n     * @throws NullPointerException if either list or the equator is {@code null}\n     * @since 4.0"
        },
        "partition": {
          "Javadoc": "* Returns consecutive {@link List#subList(int, int) sublists} of a\n     * list, each of the same size (the final list may be smaller). For example,\n     * partitioning a list containing {@code [a, b, c, d, e]} with a partition\n     * size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing\n     * two inner lists of three and two elements, all in the original order.\n     * <p>\n     * The outer list is unmodifiable, but reflects the latest state of the\n     * source list. The inner lists are sublist views of the original list,\n     * produced on demand using {@link List#subList(int, int)}, and are subject\n     * to all the usual caveats about modification as explained in that API.\n     * <p>\n     * Adapted from https://github.com/google/guava\n     *\n     * @param <T> the element type\n     * @param list  the list to return consecutive sublists of\n     * @param size  the desired size of each sublist (the last may be smaller)\n     * @return a list of consecutive sublists\n     * @throws NullPointerException if list is null\n     * @throws IllegalArgumentException if size is not strictly positive\n     * @since 4.0"
        },
        "predicatedList": {
          "Javadoc": "* Returns a predicated (validating) list backed by the given list.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to the list.\n     * Trying to add an invalid object results in an IllegalArgumentException.\n     * It is important not to use the original list after invoking this method,\n     * as it is a backdoor for adding invalid objects.\n     *\n     * @param <E> the element type\n     * @param list  the list to predicate, must not be null\n     * @param predicate  the predicate for the list, must not be null\n     * @return a predicated list backed by the given list\n     * @throws NullPointerException if the List or Predicate is null"
        },
        "removeAll": {
          "Javadoc": "* Removes the elements in {@code remove} from {@code collection}. That is, this\n     * method returns a list containing all the elements in {@code collection}\n     * that are not in {@code remove}. The cardinality of an element {@code e}\n     * in the returned collection is the same as the cardinality of {@code e}\n     * in {@code collection} unless {@code remove} contains {@code e}, in which\n     * case the cardinality is zero. This method is useful if you do not wish to modify\n     * {@code collection} and thus cannot call {@code collection.removeAll(remove);}.\n     * <p>\n     * This implementation iterates over {@code collection}, checking each element in\n     * turn to see if it's contained in {@code remove}. If it's not contained, it's added\n     * to the returned list. As a consequence, it is advised to use a collection type for\n     * {@code remove} that provides a fast (e.g. O(1)) implementation of\n     * {@link Collection#contains(Object)}.\n     *\n     * @param <E>  the element type\n     * @param collection  the collection from which items are removed (in the returned collection)\n     * @param remove  the items to be removed from the returned {@code collection}\n     * @return a {@code List} containing all the elements of {@code c} except\n     * any elements that also occur in {@code remove}.\n     * @throws NullPointerException if either parameter is null\n     * @since 3.2"
        },
        "retainAll": {
          "Javadoc": "* Returns a List containing all the elements in {@code collection}\n     * that are also in {@code retain}. The cardinality of an element {@code e}\n     * in the returned list is the same as the cardinality of {@code e}\n     * in {@code collection} unless {@code retain} does not contain {@code e}, in which\n     * case the cardinality is zero. This method is useful if you do not wish to modify\n     * the collection {@code c} and thus cannot call {@code collection.retainAll(retain);}.\n     * <p>\n     * This implementation iterates over {@code collection}, checking each element in\n     * turn to see if it's contained in {@code retain}. If it's contained, it's added\n     * to the returned list. As a consequence, it is advised to use a collection type for\n     * {@code retain} that provides a fast (e.g. O(1)) implementation of\n     * {@link Collection#contains(Object)}.\n     *\n     * @param <E>  the element type\n     * @param collection  the collection whose contents are the target of the #retailAll operation\n     * @param retain  the collection containing the elements to be retained in the returned collection\n     * @return a {@code List} containing all the elements of {@code c}\n     * that occur at least once in {@code retain}.\n     * @throws NullPointerException if either parameter is null\n     * @since 3.2"
        },
        "select": {
          "Javadoc": "* Selects all elements from input collection which match the given\n     * predicate into an output list.\n     * <p>\n     * A {@code null} predicate matches no elements.\n     *\n     * @param <E> the element type\n     * @param inputCollection  the collection to get the input from, may not be null\n     * @param predicate  the predicate to use, may be null\n     * @return the elements matching the predicate (new list)\n     * @throws NullPointerException if the input list is null\n     *\n     * @since 4.0\n     * @see CollectionUtils#select(Iterable, Predicate)"
        },
        "selectRejected": {
          "Javadoc": "* Selects all elements from inputCollection which don't match the given\n     * predicate into an output collection.\n     * <p>\n     * If the input predicate is {@code null}, the result is an empty list.\n     *\n     * @param <E> the element type\n     * @param inputCollection the collection to get the input from, may not be null\n     * @param predicate the predicate to use, may be null\n     * @return the elements <b>not</b> matching the predicate (new list)\n     * @throws NullPointerException if the input collection is null\n     *\n     * @since 4.0\n     * @see CollectionUtils#selectRejected(Iterable, Predicate)"
        },
        "subtract": {
          "Javadoc": "* Subtracts all elements in the second list from the first list,\n     * placing the results in a new list.\n     * <p>\n     * This differs from {@link List#removeAll(Collection)} in that\n     * cardinality is respected; if <Code>list1</Code> contains two\n     * occurrences of <Code>null</Code> and <Code>list2</Code> only\n     * contains one occurrence, then the returned list will still contain\n     * one occurrence.\n     *\n     * @param <E> the element type\n     * @param list1  the list to subtract from\n     * @param list2  the list to subtract\n     * @return a new list containing the results\n     * @throws NullPointerException if either list is null"
        },
        "sum": {
          "Javadoc": "* Returns the sum of the given lists.  This is their intersection\n     * subtracted from their union.\n     *\n     * @param <E> the element type\n     * @param list1  the first list\n     * @param list2  the second list\n     * @return  a new list containing the sum of those lists\n     * @throws NullPointerException if either list is null"
        },
        "synchronizedList": {
          "Javadoc": "* Returns a synchronized list backed by the given list.\n     * <p>\n     * You must manually synchronize on the returned list's iterator to\n     * avoid non-deterministic behavior:\n     *\n     * <pre>\n     * List list = ListUtils.synchronizedList(myList);\n     * synchronized (list) {\n     *     Iterator i = list.iterator();\n     *     while (i.hasNext()) {\n     *         process (i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * This method is just a wrapper for {@link Collections#synchronizedList(List)}.\n     *\n     * @param <E> the element type\n     * @param list  the list to synchronize, must not be null\n     * @return a synchronized list backed by the given list\n     * @throws NullPointerException if the list is null"
        },
        "transformedList": {
          "Javadoc": "* Returns a transformed list backed by the given list.\n     * <p>\n     * This method returns a new list (decorating the specified list) that\n     * will transform any new entries added to it.\n     * Existing entries in the specified list will not be transformed.\n     * <p>\n     * Each object is passed through the transformer as it is added to the\n     * List. It is important not to use the original list after invoking this\n     * method, as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified list will not be transformed.\n     * If you want that behavior, see {@link TransformedList#transformedList}.\n     *\n     * @param <E> the element type\n     * @param list  the list to predicate, must not be null\n     * @param transformer  the transformer for the list, must not be null\n     * @return a transformed list backed by the given list\n     * @throws NullPointerException if the List or Transformer is null"
        },
        "union": {
          "Javadoc": "* Returns a new list containing the second list appended to the\n     * first list.  The {@link List#addAll(Collection)} operation is\n     * used to append the two given lists into a new list.\n     *\n     * @param <E> the element type\n     * @param list1  the first list\n     * @param list2  the second list\n     * @return a new list containing the union of those lists\n     * @throws NullPointerException if either list is null"
        },
        "unmodifiableList": {
          "Javadoc": "* Returns an unmodifiable list backed by the given list.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     *\n     * @param <E>  the element type\n     * @param list  the list to make unmodifiable, must not be null\n     * @return an unmodifiable list backed by the given list\n     * @throws NullPointerException if the list is null"
        }
      }
    },
    "org.apache.commons.collections4.CharSequenceAsList": {
      "Javadoc": "\n     * A simple wrapper to use a CharSequence as List.\n     "
    },
    "org.apache.commons.collections4.LcsVisitor": {
      "Javadoc": "\n     * A helper class used to construct the longest common subsequence.\n     "
    },
    "org.apache.commons.collections4.Partition": {
      "Javadoc": "\n     * Provides a partition view on a {@link List}.\n     * @since 4.0\n     "
    },
    "org.apache.commons.collections4.ListValuedMap": {
      "Javadoc": "\n * Defines a map that holds a list of values against each key.\n * <p>\n * A {@code ListValuedMap} is a Map with slightly different semantics:\n * </p>\n * <ul>\n *   <li>Putting a value into the map will add the value to a {@link List} at that key.</li>\n *   <li>Getting a value will return a {@link List}, holding all the values put to that key.</li>\n * </ul>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.1\n ",
      "methods": {
        "get": {
          "Javadoc": "* Gets the list of values associated with the specified key.\n     * <p>\n     * This method will return an <b>empty</b> list if\n     * {@link #containsKey(Object)} returns {@code false}. Changes to the\n     * returned list will update the underlying {@code ListValuedMap} and\n     * vice-versa.\n     *\n     * @param key  the key to retrieve\n     * @return the {@code List} of values, implementations should return an\n     *   empty {@code List} for no mapping\n     * @throws NullPointerException if the key is null and null keys are invalid"
        },
        "remove": {
          "Javadoc": "* Removes all values associated with the specified key.\n     * <p>\n     * The returned list <i>may</i> be modifiable, but updates will not be\n     * propagated to this list-valued map. In case no mapping was stored for the\n     * specified key, an empty, unmodifiable list will be returned.\n     *\n     * @param key  the key to remove values from\n     * @return the {@code List} of values removed, implementations\n     *   typically return an empty, unmodifiable {@code List} for no mapping found\n     * @throws UnsupportedOperationException if the map is unmodifiable\n     * @throws NullPointerException if the key is null and null keys are invalid"
        }
      }
    },
    "org.apache.commons.collections4.map.AbstractHashedMap": {
      "Javadoc": "\n * An abstract implementation of a hash-based map which provides numerous points for\n * subclasses to override.\n * <p>\n * This class implements all the features necessary for a subclass hash-based map.\n * Key-value entries are stored in instances of the {@code HashEntry} class,\n * which can be overridden and replaced. The iterators can similarly be replaced,\n * without the need to replace the KeySet, EntrySet and Values view classes.\n * <p>\n * Overridable methods are provided to change the default hashing behavior, and\n * to change how entries are added to and removed from the map. Hopefully, all you\n * need for unusual subclasses is here.\n * <p>\n * NOTE: From Commons Collections 3.1 this class extends AbstractMap.\n * This is to provide backwards compatibility for ReferenceMap between v3.0 and v3.1.\n * This extends clause will be removed in v5.0.\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "_putAll": {
          "Javadoc": "* Puts all the values from the specified map into this map.\n     * <p>\n     * This implementation iterates around the specified map and\n     * uses {@link #put(Object, Object)}.\n     * <p>\n     * It is private to allow the constructor to still call it\n     * even when putAll is overridden.\n     *\n     * @param map  the map to add\n     * @throws NullPointerException if the map is null"
        },
        "addEntry": {
          "Javadoc": "* Adds an entry into this map.\n     * <p>\n     * This implementation adds the entry to the data storage table.\n     * Subclasses could override to handle changes to the map.\n     *\n     * @param entry  the entry to add\n     * @param hashIndex  the index into the data array to store at"
        },
        "addMapping": {
          "Javadoc": "* Adds a new key-value mapping into this map.\n     * <p>\n     * This implementation calls {@code createEntry()}, {@code addEntry()}\n     * and {@code checkCapacity()}.\n     * It also handles changes to {@code modCount} and {@code size}.\n     * Subclasses could override to fully control adds to the map.\n     *\n     * @param hashIndex  the index into the data array to store at\n     * @param hashCode  the hash code of the key to add\n     * @param key  the key to add\n     * @param value  the value to add"
        },
        "calculateNewCapacity": {
          "Javadoc": "* Calculates the new capacity of the map.\n     * This implementation normalizes the capacity to a power of two.\n     *\n     * @param proposedCapacity  the proposed capacity\n     * @return the normalized new capacity"
        },
        "calculateThreshold": {
          "Javadoc": "* Calculates the new threshold of the map, where it will be resized.\n     * This implementation uses the load factor.\n     *\n     * @param newCapacity  the new capacity\n     * @param factor  the load factor\n     * @return the new resize threshold"
        },
        "checkCapacity": {
          "Javadoc": "* Checks the capacity of the map and enlarges it if necessary.\n     * <p>\n     * This implementation uses the threshold to check if the map needs enlarging"
        },
        "clear": {
          "Javadoc": "* Clears the map, resetting the size to zero and nullifying references\n     * to avoid garbage collection issues."
        },
        "clone": {
          "Javadoc": "* Clones the map without cloning the keys or values.\n     * <p>\n     * To implement {@code clone()}, a subclass must implement the\n     * {@code Cloneable} interface and make this method public.\n     *\n     * @return a shallow clone\n     * @throws InternalError if {@link AbstractMap#clone()} failed"
        },
        "containsKey": {
          "Javadoc": "* Checks whether the map contains the specified key.\n     *\n     * @param key  the key to search for\n     * @return true if the map contains the key"
        },
        "containsValue": {
          "Javadoc": "* Checks whether the map contains the specified value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value"
        },
        "convertKey": {
          "Javadoc": "* Converts input keys to another object for storage in the map.\n     * This implementation masks nulls.\n     * Subclasses can override this to perform alternate key conversions.\n     * <p>\n     * The reverse conversion can be changed, if required, by overriding the\n     * getKey() method in the hash entry.\n     *\n     * @param key  the key convert\n     * @return the converted key"
        },
        "createEntry": {
          "Javadoc": "* Creates an entry to store the key-value data.\n     * <p>\n     * This implementation creates a new HashEntry instance.\n     * Subclasses can override this to return a different storage class,\n     * or implement caching.\n     *\n     * @param next  the next entry in sequence\n     * @param hashCode  the hash code to use\n     * @param key  the key to store\n     * @param value  the value to store\n     * @return the newly created entry"
        },
        "createEntrySetIterator": {
          "Javadoc": "* Creates an entry set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the entrySet iterator"
        },
        "createKeySetIterator": {
          "Javadoc": "* Creates a key set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the keySet iterator"
        },
        "createValuesIterator": {
          "Javadoc": "* Creates a values iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the values iterator"
        },
        "destroyEntry": {
          "Javadoc": "* Kills an entry ready for the garbage collector.\n     * <p>\n     * This implementation prepares the HashEntry for garbage collection.\n     * Subclasses can override this to implement caching (override clear as well).\n     *\n     * @param entry  the entry to destroy"
        },
        "doReadObject": {
          "Javadoc": "* Reads the map data from the stream. This method must be overridden if a\n     * subclass must be setup before {@code put()} is used.\n     * <p>\n     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n     * initialize the superclass before the subclass. Sometimes however, this isn't\n     * what you want, as in this case the {@code put()} method on read can be\n     * affected by subclass state.\n     * <p>\n     * The solution adopted here is to deserialize the state data of this class in\n     * this protected method. This method must be called by the\n     * {@code readObject()} of the first serializable subclass.\n     * <p>\n     * Subclasses may override if the subclass has a specific field that must be present\n     * before {@code put()} or {@code calculateThreshold()} will work correctly.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "doWriteObject": {
          "Javadoc": "* Writes the map data to the stream. This method must be overridden if a\n     * subclass must be setup before {@code put()} is used.\n     * <p>\n     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n     * initialize the superclass before the subclass. Sometimes however, this isn't\n     * what you want, as in this case the {@code put()} method on read can be\n     * affected by subclass state.\n     * <p>\n     * The solution adopted here is to serialize the state data of this class in\n     * this protected method. This method must be called by the\n     * {@code writeObject()} of the first serializable subclass.\n     * <p>\n     * Subclasses may override if they have a specific field that must be present\n     * on read before this implementation will work. Generally, the read determines\n     * what must be serialized here, if anything.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        },
        "ensureCapacity": {
          "Javadoc": "* Changes the size of the data structure to the capacity proposed.\n     *\n     * @param newCapacity  the new capacity of the array (a power of two, less or equal to max)"
        },
        "entryHashCode": {
          "Javadoc": "* Gets the {@code hashCode} field from a {@code HashEntry}.\n     * Used in subclasses that have no visibility of the field.\n     *\n     * @param entry  the entry to query, must not be null\n     * @return the {@code hashCode} field of the entry\n     * @throws NullPointerException if the entry is null\n     * @since 3.1"
        },
        "entryKey": {
          "Javadoc": "* Gets the {@code key} field from a {@code HashEntry}.\n     * Used in subclasses that have no visibility of the field.\n     *\n     * @param entry  the entry to query, must not be null\n     * @return the {@code key} field of the entry\n     * @throws NullPointerException if the entry is null\n     * @since 3.1"
        },
        "entryNext": {
          "Javadoc": "* Gets the {@code next} field from a {@code HashEntry}.\n     * Used in subclasses that have no visibility of the field.\n     *\n     * @param entry  the entry to query, must not be null\n     * @return the {@code next} field of the entry\n     * @throws NullPointerException if the entry is null\n     * @since 3.1"
        },
        "entrySet": {
          "Javadoc": "* Gets the entrySet view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the entries, use {@link #mapIterator()}.\n     *\n     * @return the entrySet view"
        },
        "entryValue": {
          "Javadoc": "* Gets the {@code value} field from a {@code HashEntry}.\n     * Used in subclasses that have no visibility of the field.\n     *\n     * @param entry  the entry to query, must not be null\n     * @return the {@code value} field of the entry\n     * @throws NullPointerException if the entry is null\n     * @since 3.1"
        },
        "equals": {
          "Javadoc": "* Compares this map with another.\n     *\n     * @param obj  the object to compare to\n     * @return true if equal"
        },
        "get": {
          "Javadoc": "* Gets the value mapped to the key specified.\n     *\n     * @param key  the key\n     * @return the mapped value, null if no match"
        },
        "getEntry": {
          "Javadoc": "* Gets the entry mapped to the key specified.\n     * <p>\n     * This method exists for subclasses that may need to perform a multi-step\n     * process accessing the entry. The public methods in this class don't use this\n     * method to gain a small performance boost.\n     *\n     * @param key  the key\n     * @return the entry, null if no match"
        },
        "hash": {
          "Javadoc": "* Gets the hash code for the key specified.\n     * This implementation uses the additional hashing routine from JDK1.4.\n     * Subclasses can override this to return alternate hash codes.\n     *\n     * @param key  the key to get a hash code for\n     * @return the hash code"
        },
        "hashCode": {
          "Javadoc": "* Gets the standard Map hashCode.\n     *\n     * @return the hash code defined in the Map interface"
        },
        "hashIndex": {
          "Javadoc": "* Gets the index into the data storage for the hashCode specified.\n     * This implementation uses the least significant bits of the hashCode.\n     * Subclasses can override this to return alternate bucketing.\n     *\n     * @param hashCode  the hash code to use\n     * @param dataSize  the size of the data to pick a bucket from\n     * @return the bucket index"
        },
        "init": {
          "Javadoc": "* Initialize subclasses during construction, cloning or deserialization."
        },
        "isEmpty": {
          "Javadoc": "* Checks whether the map is currently empty.\n     *\n     * @return true if the map is currently size zero"
        },
        "isEqualKey": {
          "Javadoc": "* Compares two keys, in internal converted form, to see if they are equal.\n     * This implementation uses the equals method and assumes neither key is null.\n     * Subclasses can override this to match differently.\n     *\n     * @param key1  the first key to compare passed in from outside\n     * @param key2  the second key extracted from the entry via {@code entry.key}\n     * @return true if equal"
        },
        "isEqualValue": {
          "Javadoc": "* Compares two values, in external form, to see if they are equal.\n     * This implementation uses the equals method and assumes neither value is null.\n     * Subclasses can override this to match differently.\n     *\n     * @param value1  the first value to compare passed in from outside\n     * @param value2  the second value extracted from the entry via {@code getValue()}\n     * @return true if equal"
        },
        "keySet": {
          "Javadoc": "* Gets the keySet view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the keys, use {@link #mapIterator()}.\n     *\n     * @return the keySet view"
        },
        "mapIterator": {
          "Javadoc": "* Gets an iterator over the map.\n     * Changes made to the iterator affect this map.\n     * <p>\n     * A MapIterator returns the keys in the map. It also provides convenient\n     * methods to get the key and value, and set the value.\n     * It avoids the need to create an entrySet/keySet/values object.\n     * It also avoids creating the Map.Entry object.\n     *\n     * @return the map iterator"
        },
        "put": {
          "Javadoc": "* Puts a key-value mapping into this map.\n     *\n     * @param key  the key to add\n     * @param value  the value to add\n     * @return the value previously mapped to this key, null if none"
        },
        "putAll": {
          "Javadoc": "* Puts all the values from the specified map into this map.\n     * <p>\n     * This implementation iterates around the specified map and\n     * uses {@link #put(Object, Object)}.\n     *\n     * @param map  the map to add\n     * @throws NullPointerException if the map is null"
        },
        "remove": {
          "Javadoc": "* Removes the specified mapping from this map.\n     *\n     * @param key  the mapping to remove\n     * @return the value mapped to the removed key, null if key not in map"
        },
        "removeEntry": {
          "Javadoc": "* Removes an entry from the chain stored in a particular index.\n     * <p>\n     * This implementation removes the entry from the data storage table.\n     * The size is not updated.\n     * Subclasses could override to handle changes to the map.\n     *\n     * @param entry  the entry to remove\n     * @param hashIndex  the index into the data structure\n     * @param previous  the previous entry in the chain"
        },
        "removeMapping": {
          "Javadoc": "* Removes a mapping from the map.\n     * <p>\n     * This implementation calls {@code removeEntry()} and {@code destroyEntry()}.\n     * It also handles changes to {@code modCount} and {@code size}.\n     * Subclasses could override to fully control removals from the map.\n     *\n     * @param entry  the entry to remove\n     * @param hashIndex  the index into the data structure\n     * @param previous  the previous entry in the chain"
        },
        "reuseEntry": {
          "Javadoc": "* Reuses an existing key-value mapping, storing completely new data.\n     * <p>\n     * This implementation sets all the data fields on the entry.\n     * Subclasses could populate additional entry fields.\n     *\n     * @param entry  the entry to update, not null\n     * @param hashIndex  the index in the data array\n     * @param hashCode  the hash code of the key to add\n     * @param key  the key to add\n     * @param value  the value to add"
        },
        "size": {
          "Javadoc": "* Gets the size of the map.\n     *\n     * @return the size"
        },
        "toString": {
          "Javadoc": "* Gets the map as a String.\n     *\n     * @return a string version of the map"
        },
        "updateEntry": {
          "Javadoc": "* Updates an existing key-value mapping to change the value.\n     * <p>\n     * This implementation calls {@code setValue()} on the entry.\n     * Subclasses could override to handle changes to the map.\n     *\n     * @param entry  the entry to update\n     * @param newValue  the new value to store"
        },
        "values": {
          "Javadoc": "* Gets the values view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the values, use {@link #mapIterator()}.\n     *\n     * @return the values view"
        }
      }
    },
    "org.apache.commons.collections4.map.EntrySet": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.EntrySetIterator": {
      "Javadoc": "\n     * EntrySetIterator and MapEntry\n     "
    },
    "org.apache.commons.collections4.map.HashEntry": {
      "Javadoc": "\n     * HashEntry used to store the data.\n     * <p>\n     * If you subclass {@code AbstractHashedMap} but not {@code HashEntry}\n     * then you will not be able to access the protected fields.\n     * The {@code entryXxx()} methods on {@code AbstractHashedMap} exist\n     * to provide the necessary access.\n     *\n     * @param <K> the type of the keys\n     * @param <V> the type of the values\n     "
    },
    "org.apache.commons.collections4.map.HashIterator": {
      "Javadoc": "\n     * Base Iterator\n     *\n     * @param <K> the type of the keys in the map\n     * @param <V> the type of the values in the map\n     "
    },
    "org.apache.commons.collections4.map.HashMapIterator": {
      "Javadoc": "\n     * MapIterator implementation.\n     *\n     * @param <K> the type of the keys in the map\n     * @param <V> the type of the values in the map\n     "
    },
    "org.apache.commons.collections4.map.KeySet": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.KeySetIterator": {
      "Javadoc": "\n     * KeySetIterator\n     "
    },
    "org.apache.commons.collections4.map.Values": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.ValuesIterator": {
      "Javadoc": "\n     * Inner class that provides the values iterator.\n     "
    },
    "org.apache.commons.collections4.map.AbstractInputCheckedMapDecorator": {
      "Javadoc": "\n * An abstract base class that simplifies the task of creating map decorators.\n * <p>\n * The Map API is very difficult to decorate correctly, and involves implementing\n * lots of different classes. This class exists to provide a simpler API.\n * </p>\n * <p>\n * Special hook methods are provided that are called when objects are added to\n * the map. By overriding these methods, the input can be validated or manipulated.\n * In addition to the main map methods, the entrySet is also affected, which is\n * the hardest part of writing map implementations.\n * </p>\n * <p>\n * This class is package-scoped, and may be withdrawn or replaced in future\n * versions of Commons Collections.\n * </p>\n *\n * @since 3.1\n ",
      "methods": {
        "checkSetValue": {
          "Javadoc": "* Hook method called when a value is being set using {@code setValue}.\n     * <p>\n     * An implementation may validate the value and throw an exception\n     * or it may transform the value into another object.\n     * </p>\n     * <p>\n     * This implementation returns the input value.\n     * </p>\n     *\n     * @param value  the value to check\n     * @return the input value\n     * @throws UnsupportedOperationException if the map may not be changed by setValue\n     * @throws IllegalArgumentException if the specified value is invalid\n     * @throws ClassCastException if the class of the specified value is invalid\n     * @throws NullPointerException if the specified value is null and nulls are invalid"
        },
        "isSetValueChecking": {
          "Javadoc": "* Hook method called to determine if {@code checkSetValue} has any effect.\n     * <p>\n     * An implementation should return false if the {@code checkSetValue} method\n     * has no effect as this optimizes the implementation.\n     * <p>\n     * This implementation returns {@code true}.\n     *\n     * @return true always"
        }
      }
    },
    "org.apache.commons.collections4.map.MapEntry": {
      "Javadoc": "\n     * Implementation of a map entry that checks additions via setValue.\n     "
    },
    "org.apache.commons.collections4.map.AbstractIterableMap": {
      "Javadoc": "\n * Provide a basic {@link IterableMap} implementation.\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.0\n ",
      "methods": {
        "mapIterator": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.map.AbstractLinkedMap": {
      "Javadoc": "\n * An abstract implementation of a hash-based map that links entries to create an\n * ordered map and which provides numerous points for subclasses to override.\n * <p>\n * This class implements all the features necessary for a subclass linked\n * hash-based map. Key-value entries are stored in instances of the\n * {@code LinkEntry} class which can be overridden and replaced.\n * The iterators can similarly be replaced, without the need to replace the KeySet,\n * EntrySet and Values view classes.\n * </p>\n * <p>\n * Overridable methods are provided to change the default hashing behavior, and\n * to change how entries are added to and removed from the map. Hopefully, all you\n * need for unusual subclasses is here.\n * </p>\n * <p>\n * This implementation maintains order by original insertion, but subclasses\n * may work differently. The {@code OrderedMap} interface is implemented\n * to provide access to bidirectional iteration and extra convenience methods.\n * </p>\n * <p>\n * The {@code orderedMapIterator()} method provides direct access to a\n * bidirectional iterator. The iterators from the other views can also be cast\n * to {@code OrderedIterator} if required.\n * </p>\n * <p>\n * All the available iterators can be reset back to the start by casting to\n * {@code ResettableIterator} and calling {@code reset()}.\n * </p>\n * <p>\n * The implementation is also designed to be subclassed, with lots of useful\n * methods exposed.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "addEntry": {
          "Javadoc": "* Adds an entry into this map, maintaining insertion order.\n     * <p>\n     * This implementation adds the entry to the data storage table and\n     * to the end of the linked list.\n     *\n     * @param entry  the entry to add\n     * @param hashIndex  the index into the data array to store at"
        },
        "clear": {
          "Javadoc": "* Clears the map, resetting the size to zero and nullifying references\n     * to avoid garbage collection issues."
        },
        "containsValue": {
          "Javadoc": "* Checks whether the map contains the specified value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value"
        },
        "createEntry": {
          "Javadoc": "* Creates an entry to store the data.\n     * <p>\n     * This implementation creates a new LinkEntry instance.\n     *\n     * @param next  the next entry in sequence\n     * @param hashCode  the hash code to use\n     * @param key  the key to store\n     * @param value  the value to store\n     * @return the newly created entry"
        },
        "createEntrySetIterator": {
          "Javadoc": "* Creates an entry set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the entrySet iterator"
        },
        "createKeySetIterator": {
          "Javadoc": "* Creates a key set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the keySet iterator"
        },
        "createValuesIterator": {
          "Javadoc": "* Creates a values iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the values iterator"
        },
        "entryAfter": {
          "Javadoc": "* Gets the {@code after} field from a {@code LinkEntry}.\n     * Used in subclasses that have no visibility of the field.\n     *\n     * @param entry  the entry to query, must not be null\n     * @return the {@code after} field of the entry\n     * @throws NullPointerException if the entry is null\n     * @since 3.1"
        },
        "entryBefore": {
          "Javadoc": "* Gets the {@code before} field from a {@code LinkEntry}.\n     * Used in subclasses that have no visibility of the field.\n     *\n     * @param entry  the entry to query, must not be null\n     * @return the {@code before} field of the entry\n     * @throws NullPointerException if the entry is null\n     * @since 3.1"
        },
        "firstKey": {
          "Javadoc": "* Gets the first key in the map, which is the first inserted.\n     *\n     * @return the eldest key"
        },
        "getEntry": {
          "Javadoc": "* Gets the key at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid"
        },
        "init": {
          "Javadoc": "* Initialize this subclass during construction.\n     * <p>\n     * NOTE: As from v3.2 this method calls\n     * {@link #createEntry(HashEntry, int, Object, Object)} to create\n     * the map entry object."
        },
        "lastKey": {
          "Javadoc": "* Gets the last key in the map, which is the most recently inserted.\n     *\n     * @return the most recently inserted key"
        },
        "mapIterator": {
          "Javadoc": "* {@inheritDoc}"
        },
        "nextKey": {
          "Javadoc": "* Gets the next key in sequence.\n     *\n     * @param key  the key to get after\n     * @return the next key"
        },
        "previousKey": {
          "Javadoc": "* Gets the previous key in sequence.\n     *\n     * @param key  the key to get before\n     * @return the previous key"
        },
        "removeEntry": {
          "Javadoc": "* Removes an entry from the map and the linked list.\n     * <p>\n     * This implementation removes the entry from the linked list chain, then\n     * calls the superclass implementation.\n     *\n     * @param entry  the entry to remove\n     * @param hashIndex  the index into the data structure\n     * @param previous  the previous entry in the chain"
        }
      }
    },
    "org.apache.commons.collections4.map.LinkEntry": {
      "Javadoc": "\n     * LinkEntry that stores the data.\n     * <p>\n     * If you subclass {@code AbstractLinkedMap} but not {@code LinkEntry}\n     * then you will not be able to access the protected fields.\n     * The {@code entryXxx()} methods on {@code AbstractLinkedMap} exist\n     * to provide the necessary access.\n     "
    },
    "org.apache.commons.collections4.map.LinkIterator": {
      "Javadoc": "\n     * Base Iterator that iterates in link order.\n     "
    },
    "org.apache.commons.collections4.map.LinkMapIterator": {
      "Javadoc": "\n     * MapIterator implementation.\n     "
    },
    "org.apache.commons.collections4.map.AbstractMapDecorator": {
      "Javadoc": "\n * Provides a base decorator that enables additional functionality to be added\n * to a Map via decoration.\n * <p>\n * Methods are forwarded directly to the decorated map.\n * </p>\n * <p>\n * This implementation does not perform any special processing with\n * {@link #entrySet()}, {@link #keySet()} or {@link #values()}. Instead\n * it simply returns the set/collection from the wrapped map. This may be\n * undesirable, for example if you are trying to write a validating\n * implementation it would provide a loophole around the validation.\n * But, you might want that loophole, so this class is kept simple.\n * </p>\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n * @since 3.0\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the map being decorated.\n     *\n     * @return the decorated map"
        }
      }
    },
    "org.apache.commons.collections4.map.AbstractOrderedMapDecorator": {
      "Javadoc": "\n * Provides a base decorator that enables additional functionality to be added\n * to an OrderedMap via decoration.\n * <p>\n * Methods are forwarded directly to the decorated map.\n * </p>\n * <p>\n * This implementation does not perform any special processing with the map views.\n * Instead it simply returns the set/collection from the wrapped map. This may be\n * undesirable, for example if you are trying to write a validating implementation\n * it would provide a loophole around the validation.\n * But, you might want that loophole, so this class is kept simple.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the map being decorated.\n     *\n     * @return the decorated map"
        }
      }
    },
    "org.apache.commons.collections4.map.AbstractReferenceMap": {
      "Javadoc": "\n * An abstract implementation of a hash-based map that allows the entries to\n * be removed by the garbage collector.\n * <p>\n * This class implements all the features necessary for a subclass reference\n * hash-based map. Key-value entries are stored in instances of the\n * {@code ReferenceEntry} class which can be overridden and replaced.\n * The iterators can similarly be replaced, without the need to replace the KeySet,\n * EntrySet and Values view classes.\n * </p>\n * <p>\n * Overridable methods are provided to change the default hashing behavior, and\n * to change how entries are added to and removed from the map. Hopefully, all you\n * need for unusual subclasses is here.\n * </p>\n * <p>\n * When you construct an {@code AbstractReferenceMap}, you can specify what\n * kind of references are used to store the map's keys and values.\n * If non-hard references are used, then the garbage collector can remove\n * mappings if a key or value becomes unreachable, or if the JVM's memory is\n * running low. For information on how the different reference types behave,\n * see {@link Reference}.\n * </p>\n * <p>\n * Different types of references can be specified for keys and values.\n * The keys can be configured to be weak but the values hard,\n * in which case this class will behave like a\n * <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/WeakHashMap.html\">\n * {@code WeakHashMap}</a>. However, you can also specify hard keys and\n * weak values, or any other combination. The default constructor uses\n * hard keys and soft values, providing a memory-sensitive cache.\n * </p>\n * <p>\n * This {@link Map} implementation does <i>not</i> allow null elements.\n * Attempting to add a null key or value to the map will raise a\n * {@code NullPointerException}.\n * </p>\n * <p>\n * All the available iterators can be reset back to the start by casting to\n * {@code ResettableIterator} and calling {@code reset()}.\n * </p>\n * <p>\n * This implementation is not synchronized.\n * You can use {@link java.util.Collections#synchronizedMap} to\n * provide synchronized access to a {@code ReferenceMap}.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n *\n * @see java.lang.ref.Reference\n * @since 3.1 (extracted from ReferenceMap in 3.0)\n ",
      "methods": {
        "clear": {
          "Javadoc": "* Clears this map."
        },
        "containsKey": {
          "Javadoc": "* Checks whether the map contains the specified key.\n     *\n     * @param key  the key to search for\n     * @return true if the map contains the key"
        },
        "containsValue": {
          "Javadoc": "* Checks whether the map contains the specified value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value"
        },
        "createEntry": {
          "Javadoc": "* Creates a ReferenceEntry instead of a HashEntry.\n     *\n     * @param next  the next entry in sequence\n     * @param hashCode  the hash code to use\n     * @param key  the key to store\n     * @param value  the value to store\n     * @return the newly created entry"
        },
        "createEntrySetIterator": {
          "Javadoc": "* Creates an entry set iterator.\n     *\n     * @return the entrySet iterator"
        },
        "createKeySetIterator": {
          "Javadoc": "* Creates a key set iterator.\n     *\n     * @return the keySet iterator"
        },
        "createValuesIterator": {
          "Javadoc": "* Creates a values iterator.\n     *\n     * @return the values iterator"
        },
        "doReadObject": {
          "Javadoc": "* Replaces the superclass method to read the state of this class.\n     * <p>\n     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n     * initialize the superclass before the subclass. Sometimes however, this isn't\n     * what you want, as in this case the {@code put()} method on read can be\n     * affected by subclass state.\n     * <p>\n     * The solution adopted here is to deserialize the state data of this class in\n     * this protected method. This method must be called by the\n     * {@code readObject()} of the first serializable subclass.\n     * <p>\n     * Subclasses may override if the subclass has a specific field that must be present\n     * before {@code put()} or {@code calculateThreshold()} will work correctly.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "doWriteObject": {
          "Javadoc": "* Replaces the superclass method to store the state of this class.\n     * <p>\n     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n     * initialize the superclass before the subclass. Sometimes however, this isn't\n     * what you want, as in this case the {@code put()} method on read can be\n     * affected by subclass state.\n     * <p>\n     * The solution adopted here is to serialize the state data of this class in\n     * this protected method. This method must be called by the\n     * {@code writeObject()} of the first serializable subclass.\n     * <p>\n     * Subclasses may override if they have a specific field that must be present\n     * on read before this implementation will work. Generally, the read determines\n     * what must be serialized here, if anything.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        },
        "entrySet": {
          "Javadoc": "* Returns a set view of this map's entries.\n     * An iterator returned entry is valid until {@code next()} is called again.\n     * The {@code setValue()} method on the {@code toArray} entries has no effect.\n     *\n     * @return a set view of this map's entries"
        },
        "get": {
          "Javadoc": "* Gets the value mapped to the key specified.\n     *\n     * @param key  the key\n     * @return the mapped value, null if no match"
        },
        "getEntry": {
          "Javadoc": "* Gets the entry mapped to the key specified.\n     *\n     * @param key  the key\n     * @return the entry, null if no match"
        },
        "hashEntry": {
          "Javadoc": "* Gets the hash code for a MapEntry.\n     * Subclasses can override this, for example to use the identityHashCode.\n     *\n     * @param key  the key to get a hash code for, may be null\n     * @param value  the value to get a hash code for, may be null\n     * @return the hash code, as per the MapEntry specification"
        },
        "init": {
          "Javadoc": "* Initialize this subclass during construction, cloning or deserialization."
        },
        "isEmpty": {
          "Javadoc": "* Checks whether the map is currently empty.\n     *\n     * @return true if the map is currently size zero"
        },
        "isEqualKey": {
          "Javadoc": "* Compares two keys, in internal converted form, to see if they are equal.\n     * <p>\n     * This implementation converts the key from the entry to a real reference\n     * before comparison.\n     *\n     * @param key1  the first key to compare passed in from outside\n     * @param key2  the second key extracted from the entry via {@code entry.key}\n     * @return true if equal"
        },
        "isKeyType": {
          "Javadoc": "* Provided protected read-only access to the key type.\n     * @param type the type to check against.\n     * @return true if keyType has the specified type"
        },
        "isValueType": {
          "Javadoc": "* Provided protected read-only access to the value type.\n     * @param type the type to check against.\n     * @return true if valueType has the specified type"
        },
        "keySet": {
          "Javadoc": "* Returns a set view of this map's keys.\n     *\n     * @return a set view of this map's keys"
        },
        "mapIterator": {
          "Javadoc": "* Gets a MapIterator over the reference map.\n     * The iterator only returns valid key/value pairs.\n     *\n     * @return a map iterator"
        },
        "purge": {
          "Javadoc": "* Purges the specified reference.\n     *\n     * @param ref  the reference to purge"
        },
        "purgeBeforeRead": {
          "Javadoc": "* Purges stale mappings from this map before read operations.\n     * <p>\n     * This implementation calls {@link #purge()} to maintain a consistent state."
        },
        "purgeBeforeWrite": {
          "Javadoc": "* Purges stale mappings from this map before write operations.\n     * <p>\n     * This implementation calls {@link #purge()} to maintain a consistent state."
        },
        "put": {
          "Javadoc": "* Puts a key-value mapping into this map.\n     * Neither the key nor the value may be null.\n     *\n     * @param key  the key to add, must not be null\n     * @param value  the value to add, must not be null\n     * @return the value previously mapped to this key, null if none\n     * @throws NullPointerException if either the key or value is null"
        },
        "remove": {
          "Javadoc": "* Removes the specified mapping from this map.\n     *\n     * @param key  the mapping to remove\n     * @return the value mapped to the removed key, null if key not in map"
        },
        "size": {
          "Javadoc": "* Gets the size of the map.\n     *\n     * @return the size"
        },
        "values": {
          "Javadoc": "* Returns a collection view of this map's values.\n     *\n     * @return a set view of this map's values"
        }
      }
    },
    "org.apache.commons.collections4.map.ReferenceBaseIterator": {
      "Javadoc": "\n     * Base iterator class.\n     "
    },
    "org.apache.commons.collections4.map.ReferenceEntry": {
      "Javadoc": "\n     * A MapEntry implementation for the map.\n     * <p>\n     * If getKey() or getValue() returns null, it means\n     * the mapping is stale and should be removed.\n     * </p>\n     *\n     * @param <K> the type of the keys\n     * @param <V> the type of the values\n     * @since 3.1\n     ",
      "methods": {
        "equals": {
          "Javadoc": "* Compares this map entry to another.\n         * <p>\n         * This implementation uses {@code isEqualKey} and\n         * {@code isEqualValue} on the main map for comparison.\n         *\n         * @param obj  the other map entry to compare to\n         * @return true if equal, false if not"
        },
        "getKey": {
          "Javadoc": "* Gets the key from the entry.\n         * This method dereferences weak and soft keys and thus may return null.\n         *\n         * @return the key, which may be null if it was garbage collected"
        },
        "getValue": {
          "Javadoc": "* Gets the value from the entry.\n         * This method dereferences weak and soft value and thus may return null.\n         *\n         * @return the value, which may be null if it was garbage collected"
        },
        "hashCode": {
          "Javadoc": "* Gets the hash code of the entry using temporary hard references.\n         * <p>\n         * This implementation uses {@code hashEntry} on the main map.\n         *\n         * @return the hash code of the entry"
        },
        "next": {
          "Javadoc": "* Gets the next entry in the bucket.\n         *\n         * @return the next entry in the bucket"
        },
        "nullValue": {
          "Javadoc": "* This method can be overridden to provide custom logic to purge value"
        },
        "onPurge": {
          "Javadoc": "* This is the callback for custom \"after purge\" logic"
        },
        "purge": {
          "Javadoc": "* Purges the specified reference\n         * @param ref  the reference to purge\n         * @return true or false"
        },
        "setValue": {
          "Javadoc": "* Sets the value of the entry.\n         *\n         * @param obj  the object to store\n         * @return the previous value"
        },
        "toReference": {
          "Javadoc": "* Constructs a reference of the given type to the given referent.\n         * The reference is registered with the queue for later purging.\n         *\n         * @param <T> the type of the referenced object\n         * @param type  HARD, SOFT or WEAK\n         * @param referent  the object to refer to\n         * @param hash  the hash code of the <i>key</i> of the mapping;\n         *    this number might be different from referent.hashCode() if\n         *    the referent represents a value and not a key\n         * @return the reference to the object"
        }
      }
    },
    "org.apache.commons.collections4.map.ReferenceEntrySet": {
      "Javadoc": "\n     * EntrySet implementation.\n     "
    },
    "org.apache.commons.collections4.map.ReferenceEntrySetIterator": {
      "Javadoc": "\n     * The EntrySet iterator.\n     "
    },
    "org.apache.commons.collections4.map.ReferenceKeySet": {
      "Javadoc": "\n     * KeySet implementation.\n     "
    },
    "org.apache.commons.collections4.map.ReferenceKeySetIterator": {
      "Javadoc": "\n     * The keySet iterator.\n     "
    },
    "org.apache.commons.collections4.map.ReferenceMapIterator": {
      "Javadoc": "\n     * The MapIterator implementation.\n     "
    },
    "org.apache.commons.collections4.map.ReferenceValues": {
      "Javadoc": "\n     * Values implementation.\n     "
    },
    "org.apache.commons.collections4.map.ReferenceValuesIterator": {
      "Javadoc": "\n     * The values iterator.\n     "
    },
    "org.apache.commons.collections4.map.SoftRef": {
      "Javadoc": "\n     * A soft reference holder.\n     "
    },
    "org.apache.commons.collections4.map.WeakRef": {
      "Javadoc": "\n     * A weak reference holder.\n     "
    },
    "org.apache.commons.collections4.map.AbstractSortedMapDecorator": {
      "Javadoc": "\n * Provides a base decorator that enables additional functionality to be added\n * to a Map via decoration.\n * <p>\n * Methods are forwarded directly to the decorated map.\n * </p>\n * <p>\n * This implementation does not perform any special processing with the map views.\n * Instead it simply returns the set/collection from the wrapped map. This may be\n * undesirable, for example if you are trying to write a validating implementation\n * it would provide a loophole around the validation.\n * But, you might want that loophole, so this class is kept simple.\n * </p>\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n * @since 3.0\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the map being decorated.\n     *\n     * @return the decorated map"
        },
        "mapIterator": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.map.SortedMapIterator": {
      "Javadoc": "\n     * OrderedMapIterator implementation.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     ",
      "methods": {
        "hasPrevious": {
          "Javadoc": "* {@inheritDoc}"
        },
        "previous": {
          "Javadoc": "* {@inheritDoc}"
        },
        "reset": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.map.CaseInsensitiveMap": {
      "Javadoc": "\n * A case-insensitive {@code Map}.\n * <p>\n * Before keys are added to the map or compared to other existing keys, they are converted\n * to all lowercase in a locale-independent fashion by using information from the Unicode\n * data file.\n * </p>\n * <p>\n * Null keys are supported.\n * </p>\n * <p>\n * The {@code keySet()} method returns all lowercase keys, or nulls.\n * </p>\n * <p>\n * Example:\n * </p>\n * <pre><code>\n *  Map&lt;String, String&gt; map = new CaseInsensitiveMap&lt;String, String&gt;();\n *  map.put(\"One\", \"One\");\n *  map.put(\"Two\", \"Two\");\n *  map.put(null, \"Three\");\n *  map.put(\"one\", \"Four\");\n * </code></pre>\n * <p>\n * The example above creates a {@code CaseInsensitiveMap} with three entries.\n * </p>\n * <p>\n * {@code map.get(null)} returns {@code \"Three\"} and {@code map.get(\"ONE\")}\n * returns {@code \"Four\".}  The {@code Set} returned by {@code keySet()}\n * equals {@code {\"one\", \"two\", null}.}\n * </p>\n * <p>\n * <strong>This map will violate the detail of various Map and map view contracts.</strong>\n * As a general rule, don't compare this map to other maps. In particular, you can't\n * use decorators like {@link ListOrderedMap} on it, which silently assume that these\n * contracts are fulfilled.\n * </p>\n * <p>\n * <strong>Note that CaseInsensitiveMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "clone": {
          "Javadoc": "* Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone"
        },
        "convertKey": {
          "Javadoc": "* Overrides convertKey() from {@link AbstractHashedMap} to convert keys to\n     * lower case.\n     * <p>\n     * Returns {@link AbstractHashedMap#NULL} if key is null.\n     *\n     * @param key  the key convert\n     * @return the converted key"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.map.CompositeMap": {
      "Javadoc": "\n * Decorates a map of other maps to provide a single unified view.\n * <p>\n * Changes made to this map will actually be made on the decorated map.\n * Add and remove operations require the use of a pluggable strategy. If no\n * strategy is provided then add and remove are unsupported.\n * </p>\n * <p>\n * <strong>Note that CompositeMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "addComposited": {
          "Javadoc": "* Add an additional Map to the composite.\n     *\n     * @param map  the Map to be added to the composite\n     * @throws IllegalArgumentException if there is a key collision and there is no\n     *         MapMutator set to handle it."
        },
        "clear": {
          "Javadoc": "* Calls {@code clear()} on all composited Maps.\n     *\n     * @throws UnsupportedOperationException if any of the composited Maps do not support clear()"
        },
        "containsKey": {
          "Javadoc": "* Returns {@code true} if this map contains a mapping for the specified\n     * key.  More formally, returns {@code true} if and only if\n     * this map contains at a mapping for a key {@code k} such that\n     * {@code (key==null ? k==null : key.equals(k))}.  (There can be\n     * at most one such mapping.)\n     *\n     * @param key  key whose presence in this map is to be tested.\n     * @return {@code true} if this map contains a mapping for the specified\n     *         key.\n     *\n     * @throws ClassCastException if the key is of an inappropriate type for\n     *         this map (optional).\n     * @throws NullPointerException if the key is {@code null} and this map\n     *            does not permit {@code null} keys (optional)."
        },
        "containsValue": {
          "Javadoc": "* Returns {@code true} if this map maps one or more keys to the\n     * specified value.  More formally, returns {@code true} if and only if\n     * this map contains at least one mapping to a value {@code v} such that\n     * {@code (value==null ? v==null : value.equals(v))}.  This operation\n     * will probably require time linear in the map size for most\n     * implementations of the {@code Map} interface.\n     *\n     * @param value value whose presence in this map is to be tested.\n     * @return {@code true} if this map maps one or more keys to the\n     *         specified value.\n     * @throws ClassCastException if the value is of an inappropriate type for\n     *         this map (optional).\n     * @throws NullPointerException if the value is {@code null} and this map\n     *            does not permit {@code null} values (optional)."
        },
        "entrySet": {
          "Javadoc": "* Returns a set view of the mappings contained in this map.  Each element\n     * in the returned set is a {@code Map.Entry}.  The set is backed by the\n     * map, so changes to the map are reflected in the set, and vice-versa.\n     * If the map is modified while an iteration over the set is in progress,\n     * the results of the iteration are undefined.  The set supports element\n     * removal, which removes the corresponding mapping from the map, via the\n     * {@code Iterator.remove}, {@code Set.remove}, {@code removeAll},\n     * {@code retainAll} and {@code clear} operations.  It does not support\n     * the {@code add} or {@code addAll} operations.\n     * <p>\n     * This implementation returns a {@code CompositeSet} which\n     * composites the entry sets from all of the composited maps.\n     *\n     * @see CompositeSet\n     * @return a set view of the mappings contained in this map."
        },
        "equals": {
          "Javadoc": "* Checks if this Map equals another as per the Map specification.\n     *\n     * @param obj  the object to compare to\n     * @return true if the maps are equal"
        },
        "get": {
          "Javadoc": "* Returns the value to which this map maps the specified key.  Returns\n     * {@code null} if the map contains no mapping for this key.  A return\n     * value of {@code null} does not <i>necessarily</i> indicate that the\n     * map contains no mapping for the key; it's also possible that the map\n     * explicitly maps the key to {@code null}.  The {@code containsKey}\n     * operation may be used to distinguish these two cases.\n     *\n     * <p>More formally, if this map contains a mapping from a key\n     * {@code k} to a value {@code v} such that <code>(key==null ? k==null :\n     * key.equals(k))</code>, then this method returns {@code v}; otherwise\n     * it returns {@code null}.  (There can be at most one such mapping.)\n     *\n     * @param key key whose associated value is to be returned.\n     * @return the value to which this map maps the specified key, or\n     *         {@code null} if the map contains no mapping for this key.\n     *\n     * @throws ClassCastException if the key is of an inappropriate type for\n     *         this map (optional).\n     * @throws NullPointerException key is {@code null} and this map does\n     *         not permit {@code null} keys (optional).\n     *\n     * @see #containsKey(Object)"
        },
        "hashCode": {
          "Javadoc": "* Gets a hash code for the Map as per the Map specification.\n     * {@inheritDoc}"
        },
        "isEmpty": {
          "Javadoc": "* Returns {@code true} if this map contains no key-value mappings.\n     *\n     * @return {@code true} if this map contains no key-value mappings."
        },
        "keySet": {
          "Javadoc": "* Returns a set view of the keys contained in this map.  The set is\n     * backed by the map, so changes to the map are reflected in the set, and\n     * vice-versa.  If the map is modified while an iteration over the set is\n     * in progress, the results of the iteration are undefined.  The set\n     * supports element removal, which removes the corresponding mapping from\n     * the map, via the {@code Iterator.remove}, {@code Set.remove},\n     * {@code removeAll} {@code retainAll}, and {@code clear} operations.\n     * It does not support the add or {@code addAll} operations.\n     * <p>\n     * This implementation returns a {@code CompositeSet} which\n     * composites the key sets from all of the composited maps.\n     *\n     * @return a set view of the keys contained in this map."
        },
        "put": {
          "Javadoc": "* Associates the specified value with the specified key in this map\n     * (optional operation).  If the map previously contained a mapping for\n     * this key, the old value is replaced by the specified value.  (A map\n     * {@code m} is said to contain a mapping for a key {@code k} if and only\n     * if {@link #containsKey(Object) m.containsKey(k)} would return\n     * {@code true}.))\n     *\n     * @param key key with which the specified value is to be associated.\n     * @param value value to be associated with the specified key.\n     * @return previous value associated with specified key, or {@code null}\n     *         if there was no mapping for key.  A {@code null} return can\n     *         also indicate that the map previously associated {@code null}\n     *         with the specified key, if the implementation supports\n     *         {@code null} values.\n     *\n     * @throws UnsupportedOperationException if no MapMutator has been specified\n     * @throws ClassCastException if the class of the specified key or value\n     *            prevents it from being stored in this map.\n     * @throws IllegalArgumentException if some aspect of this key or value\n     *            prevents it from being stored in this map.\n     * @throws NullPointerException this map does not permit {@code null}\n     *            keys or values, and the specified key or value is\n     *            {@code null}."
        },
        "putAll": {
          "Javadoc": "* Copies all of the mappings from the specified map to this map\n     * (optional operation).  The effect of this call is equivalent to that\n     * of calling {@link #put(Object,Object) put(k, v)} on this map once\n     * for each mapping from key {@code k} to value {@code v} in the\n     * specified map.  The behavior of this operation is unspecified if the\n     * specified map is modified while the operation is in progress.\n     *\n     * @param map Mappings to be stored in this map.\n     *\n     * @throws UnsupportedOperationException if the {@code putAll} method is\n     *         not supported by this map.\n     *\n     * @throws ClassCastException if the class of a key or value in the\n     *         specified map prevents it from being stored in this map.\n     *\n     * @throws IllegalArgumentException some aspect of a key or value in the\n     *         specified map prevents it from being stored in this map.\n     * @throws NullPointerException the specified map is {@code null}, or if\n     *         this map does not permit {@code null} keys or values, and the\n     *         specified map contains {@code null} keys or values."
        },
        "remove": {
          "Javadoc": "* Removes the mapping for this key from this map if it is present\n     * (optional operation).   More formally, if this map contains a mapping\n     * from key {@code k} to value {@code v} such that\n     * {@code (key==null ?  k==null : key.equals(k))}, that mapping\n     * is removed.  (The map can contain at most one such mapping.)\n     *\n     * <p>Returns the value to which the map previously associated the key, or\n     * {@code null} if the map contained no mapping for this key.  (A\n     * {@code null} return can also indicate that the map previously\n     * associated {@code null} with the specified key if the implementation\n     * supports {@code null} values.)  The map will not contain a mapping for\n     * the specified  key once the call returns.\n     *\n     * @param key key whose mapping is to be removed from the map.\n     * @return previous value associated with specified key, or {@code null}\n     *         if there was no mapping for key.\n     *\n     * @throws ClassCastException if the key is of an inappropriate type for\n     *         the composited map (optional).\n     * @throws NullPointerException if the key is {@code null} and the composited map\n     *            does not permit {@code null} keys (optional).\n     * @throws UnsupportedOperationException if the {@code remove} method is\n     *         not supported by the composited map containing the key"
        },
        "removeComposited": {
          "Javadoc": "* Remove a Map from the composite.\n     *\n     * @param map  the Map to be removed from the composite\n     * @return The removed Map or {@code null} if map is not in the composite"
        },
        "setMutator": {
          "Javadoc": "* Specify the MapMutator to be used by mutation operations.\n     *\n     * @param mutator  the MapMutator to be used for mutation delegation"
        },
        "size": {
          "Javadoc": "* Returns the number of key-value mappings in this map.  If the\n     * map contains more than {@code Integer.MAX_VALUE} elements, returns\n     * {@code Integer.MAX_VALUE}.\n     *\n     * @return the number of key-value mappings in this map."
        },
        "values": {
          "Javadoc": "* Returns a collection view of the values contained in this map.  The\n     * collection is backed by the map, so changes to the map are reflected in\n     * the collection, and vice-versa.  If the map is modified while an\n     * iteration over the collection is in progress, the results of the\n     * iteration are undefined.  The collection supports element removal,\n     * which removes the corresponding mapping from the map, via the\n     * {@code Iterator.remove}, {@code Collection.remove},\n     * {@code removeAll}, {@code retainAll} and {@code clear} operations.\n     * It does not support the add or {@code addAll} operations.\n     *\n     * @return a collection view of the values contained in this map."
        }
      }
    },
    "org.apache.commons.collections4.map.MapMutator": {
      "Javadoc": "\n     * This interface allows definition for all of the indeterminate\n     * mutators in a CompositeMap, as well as providing a hook for\n     * callbacks on key collisions.\n     *\n     * @param <K> the type of the keys in the map\n     * @param <V> the type of the values in the map\n     ",
      "methods": {
        "put": {
          "Javadoc": "* Called when the CompositeMap.put() method is invoked.\n         *\n         * @param map  the CompositeMap which is being modified\n         * @param composited  array of Maps in the CompositeMap being modified\n         * @param key  key with which the specified value is to be associated.\n         * @param value  value to be associated with the specified key.\n         * @return previous value associated with specified key, or {@code null}\n         *         if there was no mapping for key.  A {@code null} return can\n         *         also indicate that the map previously associated {@code null}\n         *         with the specified key, if the implementation supports\n         *         {@code null} values.\n         *\n         * @throws UnsupportedOperationException if not defined\n         * @throws ClassCastException if the class of the specified key or value\n         *            prevents it from being stored in this map.\n         * @throws IllegalArgumentException if some aspect of this key or value\n         *            prevents it from being stored in this map.\n         * @throws NullPointerException this map does not permit {@code null}\n         *            keys or values, and the specified key or value is\n         *            {@code null}."
        },
        "putAll": {
          "Javadoc": "* Called when the CompositeMap.putAll() method is invoked.\n         *\n         * @param map  the CompositeMap which is being modified\n         * @param composited  array of Maps in the CompositeMap being modified\n         * @param mapToAdd  Mappings to be stored in this CompositeMap\n         *\n         * @throws UnsupportedOperationException if not defined\n         * @throws ClassCastException if the class of the specified key or value\n         *            prevents it from being stored in this map.\n         * @throws IllegalArgumentException if some aspect of this key or value\n         *            prevents it from being stored in this map.\n         * @throws NullPointerException this map does not permit {@code null}\n         *            keys or values, and the specified key or value is\n         *            {@code null}."
        },
        "resolveCollision": {
          "Javadoc": "* Called when adding a new Composited Map results in a\n         * key collision.\n         *\n         * @param composite  the CompositeMap with the collision\n         * @param existing  the Map already in the composite which contains the\n         *        offending key\n         * @param added  the Map being added\n         * @param intersect  the intersection of the keysets of the existing and added maps"
        }
      }
    },
    "org.apache.commons.collections4.map.DefaultedMap": {
      "Javadoc": "\n * Decorates another {@code Map} returning a default value if the map\n * does not contain the requested key.\n * <p>\n * When the {@link #get(Object)} method is called with a key that does not\n * exist in the map, this map will return the default value specified in\n * the constructor/factory. Only the get method is altered, so the\n * {@link Map#containsKey(Object)} can be used to determine if a key really\n * is in the map or not.\n * </p>\n * <p>\n * The defaulted value is not added to the map.\n * Compare this behavior with {@link LazyMap}, which does add the value\n * to the map (via a Transformer).\n * </p>\n * <p>\n * For instance:\n * </p>\n * <pre>\n * Map map = new DefaultedMap(\"NULL\");\n * Object obj = map.get(\"Surname\");\n * // obj == \"NULL\"\n * </pre>\n * <p>\n * After the above code is executed the map is still empty.\n * </p>\n * <p>\n * <strong>Note that DefaultedMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n *\n * @since 3.2\n * @see LazyMap\n ",
      "methods": {
        "defaultedMap": {
          "Javadoc": "* Factory method to create a defaulting map.\n     * <p>\n     * The value specified is returned when a missing key is found.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param defaultValue  the default value to return when the key is not found\n     * @return a new defaulting map\n     * @throws NullPointerException if map is null\n     * @since 4.0"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.map.EntrySetToMapIteratorAdapter": {
      "Javadoc": "\n * Adapts a Map entrySet to the MapIterator interface.\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n *\n * @since 4.0\n ",
      "methods": {
        "current": {
          "Javadoc": "* Gets the currently active entry.\n     * @return Map.Entry&lt;K, V&gt;"
        },
        "getKey": {
          "Javadoc": "* {@inheritDoc}"
        },
        "getValue": {
          "Javadoc": "* {@inheritDoc}"
        },
        "hasNext": {
          "Javadoc": "* {@inheritDoc}"
        },
        "next": {
          "Javadoc": "* {@inheritDoc}"
        },
        "remove": {
          "Javadoc": "* {@inheritDoc}"
        },
        "reset": {
          "Javadoc": "* {@inheritDoc}"
        },
        "setValue": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.map.FixedSizeMap": {
      "Javadoc": "\n * Decorates another {@code Map} to fix the size, preventing add/remove.\n * <p>\n * Any action that would change the size of the map is disallowed.\n * The put method is allowed to change the value associated with an existing\n * key however.\n * </p>\n * <p>\n * If trying to remove or clear the map, an UnsupportedOperationException is\n * thrown. If trying to put a new mapping into the map, an\n * IllegalArgumentException is thrown. This is because the put method can\n * succeed if the mapping's key already exists in the map, so the put method\n * is not always unsupported.\n * </p>\n * <p>\n * <strong>Note that FixedSizeMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "fixedSizeMap": {
          "Javadoc": "* Factory method to create a fixed size map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @return a new fixed size map\n     * @throws NullPointerException if map is null\n     * @since 4.0"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.map.FixedSizeSortedMap": {
      "Javadoc": "\n * Decorates another {@code SortedMap} to fix the size blocking add/remove.\n * <p>\n * Any action that would change the size of the map is disallowed.\n * The put method is allowed to change the value associated with an existing\n * key however.\n * </p>\n * <p>\n * If trying to remove or clear the map, an UnsupportedOperationException is\n * thrown. If trying to put a new mapping into the map, an\n * IllegalArgumentException is thrown. This is because the put method can\n * succeed if the mapping's key already exists in the map, so the put method\n * is not always unsupported.\n * </p>\n * <p>\n * <strong>Note that FixedSizeSortedMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "fixedSizeSortedMap": {
          "Javadoc": "* Factory method to create a fixed size sorted map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @return a new fixed size sorted map\n     * @throws NullPointerException if map is null\n     * @since 4.0"
        },
        "getSortedMap": {
          "Javadoc": "* Gets the map being decorated.\n     *\n     * @return the decorated map"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.map.Flat3Map": {
      "Javadoc": "\n * A {@code Map} implementation that stores data in simple fields until\n * the size is greater than 3.\n * <p>\n * This map is designed for performance and can outstrip HashMap.\n * It also has good garbage collection characteristics.\n * </p>\n * <ul>\n * <li>Optimised for operation at size 3 or less.\n * <li>Still works well once size 3 exceeded.\n * <li>Gets at size 3 or less are about 0-10% faster than HashMap,\n * <li>Puts at size 3 or less are over 4 times faster than HashMap.\n * <li>Performance 5% slower than HashMap once size 3 exceeded once.\n * </ul>\n * <p>\n * The design uses two distinct modes of operation - flat and delegate.\n * While the map is size 3 or less, operations map straight onto fields using\n * switch statements. Once size 4 is reached, the map switches to delegate mode\n * and only switches back when cleared. In delegate mode, all operations are\n * forwarded straight to a HashMap resulting in the 5% performance loss.\n * </p>\n * <p>\n * The performance gains on puts are due to not needing to create a Map Entry\n * object. This is a large saving not only in performance but in garbage collection.\n * </p>\n * <p>\n * Whilst in flat mode this map is also easy for the garbage collector to dispatch.\n * This is because it contains no complex objects or arrays which slow the progress.\n * </p>\n * <p>\n * Do not use {@code Flat3Map} if the size is likely to grow beyond 3.\n * </p>\n * <p>\n * <strong>Note that Flat3Map is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "clear": {
          "Javadoc": "* Clears the map, resetting the size to zero and nullifying references\n     * to avoid garbage collection issues."
        },
        "clone": {
          "Javadoc": "* Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone\n     * @since 3.1"
        },
        "containsKey": {
          "Javadoc": "* Checks whether the map contains the specified key.\n     *\n     * @param key  the key to search for\n     * @return true if the map contains the key"
        },
        "containsValue": {
          "Javadoc": "* Checks whether the map contains the specified value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the key"
        },
        "convertToMap": {
          "Javadoc": "* Converts the flat map data to a map."
        },
        "createDelegateMap": {
          "Javadoc": "* Create an instance of the map used for storage when in delegation mode.\n     * <p>\n     * This can be overridden by subclasses to provide a different map implementation.\n     * Not every AbstractHashedMap is suitable, identity and reference based maps\n     * would be poor choices.\n     *\n     * @return a new AbstractHashedMap or subclass\n     * @since 3.1"
        },
        "entrySet": {
          "Javadoc": "* Gets the entrySet view of the map.\n     * Changes made to the view affect this map.\n     * <p>\n     * NOTE: from 4.0, the returned Map Entry will be an independent object and will\n     * not change anymore as the iterator progresses. To avoid this additional object\n     * creation and simply iterate through the entries, use {@link #mapIterator()}.\n     *\n     * @return the entrySet view"
        },
        "equals": {
          "Javadoc": "* Compares this map with another.\n     *\n     * @param obj  the object to compare to\n     * @return true if equal"
        },
        "get": {
          "Javadoc": "* Gets the value mapped to the key specified.\n     *\n     * @param key  the key\n     * @return the mapped value, null if no match"
        },
        "hashCode": {
          "Javadoc": "* Gets the standard Map hashCode.\n     *\n     * @return the hash code defined in the Map interface"
        },
        "isEmpty": {
          "Javadoc": "* Checks whether the map is currently empty.\n     *\n     * @return true if the map is currently size zero"
        },
        "keySet": {
          "Javadoc": "* Gets the keySet view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the keys, use {@link #mapIterator()}.\n     *\n     * @return the keySet view"
        },
        "mapIterator": {
          "Javadoc": "* Gets an iterator over the map.\n     * Changes made to the iterator affect this map.\n     * <p>\n     * A MapIterator returns the keys in the map. It also provides convenient\n     * methods to get the key and value, and set the value.\n     * It avoids the need to create an entrySet/keySet/values object.\n     * It also avoids creating the Map Entry object.\n     *\n     * @return the map iterator"
        },
        "put": {
          "Javadoc": "* Puts a key-value mapping into this map.\n     *\n     * @param key  the key to add\n     * @param value  the value to add\n     * @return the value previously mapped to this key, null if none"
        },
        "putAll": {
          "Javadoc": "* Puts all the values from the specified map into this map.\n     *\n     * @param map  the map to add\n     * @throws NullPointerException if the map is null"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "remove": {
          "Javadoc": "* Removes the specified mapping from this map.\n     *\n     * @param key  the mapping to remove\n     * @return the value mapped to the removed key, null if key not in map"
        },
        "size": {
          "Javadoc": "* Gets the size of the map.\n     *\n     * @return the size"
        },
        "toString": {
          "Javadoc": "* Gets the map as a String.\n     *\n     * @return a string version of the map"
        },
        "values": {
          "Javadoc": "* Gets the values view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the values, use {@link #mapIterator()}.\n     *\n     * @return the values view"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.map.EntryIterator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.FlatMapEntry": {
      "Javadoc": "",
      "methods": {
        "setRemoved": {
          "Javadoc": "* Used by the iterator that created this entry to indicate that\n         * {@link java.util.Iterator#remove()} has been called.\n         * <p>\n         * As a consequence, all subsequent call to {@link #getKey()},\n         * {@link #setValue(Object)} and {@link #getValue()} will fail.\n         *\n         * @param flag the new value of the removed flag"
        }
      }
    },
    "org.apache.commons.collections4.map.FlatMapIterator": {
      "Javadoc": "\n     * FlatMapIterator\n     "
    },
    "org.apache.commons.collections4.map.HashedMap": {
      "Javadoc": "\n * A {@code Map} implementation that is a general purpose alternative\n * to {@code HashMap}.\n * <p>\n * This implementation improves on the JDK1.4 HashMap by adding the\n * {@link org.apache.commons.collections4.MapIterator MapIterator}\n * functionality and many methods for subclassing.\n * </p>\n * <p>\n * <strong>Note that HashedMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "clone": {
          "Javadoc": "* Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.map.LazyMap": {
      "Javadoc": "\n * Decorates another {@code Map} to create objects in the map on demand.\n * <p>\n * When the {@link #get(Object)} method is called with a key that does not\n * exist in the map, the factory is used to create the object. The created\n * object will be added to the map using the requested key.\n * </p>\n * <p>\n * For instance:\n * </p>\n * <pre>\n * Factory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n *     public Date create() {\n *         return new Date();\n *     }\n * }\n * Map&lt;String, Date&gt; lazy = LazyMap.lazyMap(new HashMap&lt;String, Date&gt;(), factory);\n * Date date = lazy.get(\"NOW\");\n * </pre>\n *\n * <p>\n * After the above code is executed, {@code date} will refer to\n * a new {@code Date} instance. Furthermore, that {@code Date}\n * instance is mapped to the \"NOW\" key in the map.\n * </p>\n * <p>\n * <strong>Note that LazyMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "lazyMap": {
          "Javadoc": "* Factory method to create a lazily instantiated map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param factory  the factory to use, must not be null\n     * @return a new lazy map\n     * @throws NullPointerException if map or factory is null\n     * @since 4.0"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.map.LazySortedMap": {
      "Javadoc": "\n * Decorates another {@code SortedMap} to create objects in the map on demand.\n * <p>\n * When the {@link #get(Object)} method is called with a key that does not\n * exist in the map, the factory is used to create the object. The created\n * object will be added to the map using the requested key.\n * </p>\n * <p>\n * For instance:\n * </p>\n * <pre>\n * Factory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n *     public Date create() {\n *         return new Date();\n *     }\n * }\n * SortedMap&lt;String, Date&gt; lazy =\n *     LazySortedMap.lazySortedMap(new HashMap&lt;String, Date&gt;(), factory);\n * Date date = lazy.get(\"NOW\");\n * </pre>\n *\n * <p>\n * After the above code is executed, {@code date} will refer to\n * a new {@code Date} instance. Furthermore, that {@code Date}\n * instance is mapped to the \"NOW\" key in the map.\n * </p>\n * <p>\n * <strong>Note that LazySortedMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "lazySortedMap": {
          "Javadoc": "* Factory method to create a lazily instantiated sorted map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param factory  the factory to use, must not be null\n     * @return a new lazy sorted map\n     * @throws NullPointerException if map or factory is null\n     * @since 4.0"
        },
        "getSortedMap": {
          "Javadoc": "* Gets the map being decorated.\n     *\n     * @return the decorated map"
        }
      }
    },
    "org.apache.commons.collections4.map.LinkedMap": {
      "Javadoc": "\n * A {@code Map} implementation that maintains the order of the entries.\n * In this implementation order is maintained by original insertion.\n * <p>\n * This implementation improves on the JDK1.4 LinkedHashMap by adding the\n * {@link org.apache.commons.collections4.MapIterator MapIterator}\n * functionality, additional convenience methods and allowing\n * bidirectional iteration. It also implements {@code OrderedMap}.\n * In addition, non-interface methods are provided to access the map by index.\n * </p>\n * <p>\n * The {@code orderedMapIterator()} method provides direct access to a\n * bidirectional iterator. The iterators from the other views can also be cast\n * to {@code OrderedIterator} if required.\n * </p>\n * <p>\n * All the available iterators can be reset back to the start by casting to\n * {@code ResettableIterator} and calling {@code reset()}.\n * </p>\n * <p>\n * The implementation is also designed to be subclassed, with lots of useful\n * methods exposed.\n * </p>\n * <p>\n * <strong>Note that LinkedMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "asList": {
          "Javadoc": "* Gets an unmodifiable List view of the keys.\n     * <p>\n     * The returned list is unmodifiable because changes to the values of\n     * the list (using {@link java.util.ListIterator#set(Object)}) will\n     * effectively remove the value from the list and reinsert that value at\n     * the end of the list, which is an unexpected side effect of changing the\n     * value of a list.  This occurs because changing the key, changes when the\n     * mapping is added to the map and thus where it appears in the list.\n     * <p>\n     * An alternative to this method is to use {@link #keySet()}.\n     *\n     * @see #keySet()\n     * @return The ordered list of keys."
        },
        "clone": {
          "Javadoc": "* Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone"
        },
        "get": {
          "Javadoc": "* Gets the key at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid"
        },
        "getValue": {
          "Javadoc": "* Gets the value at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the value at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid"
        },
        "indexOf": {
          "Javadoc": "* Gets the index of the specified key.\n     *\n     * @param key  the key to find the index of\n     * @return the index, or -1 if not found"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "remove": {
          "Javadoc": "* Removes the element at the specified index.\n     *\n     * @param index  the index of the object to remove\n     * @return the previous value corresponding the {@code key},\n     *  or {@code null} if none existed\n     * @throws IndexOutOfBoundsException if the index is invalid"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.map.LinkedMapList": {
      "Javadoc": "\n     * List view of map.\n     ",
      "methods": {
        "removeIf": {
          "Javadoc": "* @since 4.4"
        }
      }
    },
    "org.apache.commons.collections4.map.ListOrderedMap": {
      "Javadoc": "\n * Decorates a {@code Map} to ensure that the order of addition is retained\n * using a {@code List} to maintain order.\n * <p>\n * The order will be used via the iterators and toArray methods on the views.\n * The order is also returned by the {@code MapIterator}.\n * The {@code orderedMapIterator()} method accesses an iterator that can\n * iterate both forwards and backwards through the map.\n * In addition, non-interface methods are provided to access the map by index.\n * </p>\n * <p>\n * If an object is added to the Map for a second time, it will remain in the\n * original position in the iteration.\n * </p>\n * <p>\n * <strong>Note that ListOrderedMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n * <p>\n * <strong>Note that ListOrderedMap doesn't work with\n * {@link java.util.IdentityHashMap IdentityHashMap}, {@link CaseInsensitiveMap},\n * or similar maps that violate the general contract of {@link java.util.Map}.</strong>\n * The {@code ListOrderedMap} (or, more precisely, the underlying {@code List})\n * is relying on {@link Object#equals(Object) equals()}. This is fine, as long as the\n * decorated {@code Map} is also based on {@link Object#equals(Object) equals()},\n * and {@link Object#hashCode() hashCode()}, which\n * {@link java.util.IdentityHashMap IdentityHashMap}, and\n * {@link CaseInsensitiveMap} don't: The former uses {@code ==}, and\n * the latter uses {@link Object#equals(Object) equals()} on a lower-cased\n * key.\n * </p>\n * <p>\n * This class is {@link Serializable} starting with Commons Collections 3.1.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "listOrderedMap": {
          "Javadoc": "* Factory method to create an ordered map.\n     * <p>\n     * An {@code ArrayList} is used to retain order.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @return a new list ordered map\n     * @throws NullPointerException if map is null\n     * @since 4.0"
        },
        "asList": {
          "Javadoc": "* Gets an unmodifiable List view of the keys which changes as the map changes.\n     * <p>\n     * The returned list is unmodifiable because changes to the values of\n     * the list (using {@link java.util.ListIterator#set(Object)}) will\n     * effectively remove the value from the list and reinsert that value at\n     * the end of the list, which is an unexpected side effect of changing the\n     * value of a list.  This occurs because changing the key, changes when the\n     * mapping is added to the map and thus where it appears in the list.\n     * <p>\n     * An alternative to this method is to use the better named\n     * {@link #keyList()} or {@link #keySet()}.\n     *\n     * @see #keyList()\n     * @see #keySet()\n     * @return The ordered list of keys."
        },
        "entrySet": {
          "Javadoc": "* Gets a view over the entries in the map.\n     * <p>\n     * The Set will be ordered by object insertion into the map.\n     *\n     * @return the fully modifiable set view over the entries"
        },
        "firstKey": {
          "Javadoc": "* Gets the first key in this map by insert order.\n     *\n     * @return the first key currently in this map\n     * @throws NoSuchElementException if this map is empty"
        },
        "get": {
          "Javadoc": "* Gets the key at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid"
        },
        "getValue": {
          "Javadoc": "* Gets the value at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid"
        },
        "indexOf": {
          "Javadoc": "* Gets the index of the specified key.\n     *\n     * @param key  the key to find the index of\n     * @return the index, or -1 if not found"
        },
        "keyList": {
          "Javadoc": "* Gets a view over the keys in the map as a List.\n     * <p>\n     * The List will be ordered by object insertion into the map.\n     * The List is unmodifiable.\n     *\n     * @see #keySet()\n     * @return the unmodifiable list view over the keys\n     * @since 3.2"
        },
        "keySet": {
          "Javadoc": "* Gets a view over the keys in the map.\n     * <p>\n     * The Collection will be ordered by object insertion into the map.\n     *\n     * @see #keyList()\n     * @return the fully modifiable collection view over the keys"
        },
        "lastKey": {
          "Javadoc": "* Gets the last key in this map by insert order.\n     *\n     * @return the last key currently in this map\n     * @throws NoSuchElementException if this map is empty"
        },
        "nextKey": {
          "Javadoc": "* Gets the next key to the one specified using insert order.\n     * This method performs a list search to find the key and is O(n).\n     *\n     * @param key  the key to find previous for\n     * @return the next key, null if no match or at start"
        },
        "previousKey": {
          "Javadoc": "* Gets the previous key to the one specified using insert order.\n     * This method performs a list search to find the key and is O(n).\n     *\n     * @param key  the key to find previous for\n     * @return the previous key, null if no match or at start"
        },
        "put": {
          "Javadoc": "* Puts a key-value mapping into the map at the specified index.\n     * <p>\n     * If the map already contains the key, then the original mapping\n     * is removed and the new mapping added at the specified index.\n     * The remove may change the effect of the index. The index is\n     * always calculated relative to the original state of the map.\n     * <p>\n     * Thus, the steps are: (1) remove the existing key-value mapping,\n     * then (2) insert the new key-value mapping at the position it\n     * would have been inserted had the remove not occurred.\n     *\n     * @param index  the index at which the mapping should be inserted\n     * @param key  the key\n     * @param value  the value\n     * @return the value previously mapped to the key\n     * @throws IndexOutOfBoundsException if the index is out of range [0, size]\n     * @since 3.2"
        },
        "putAll": {
          "Javadoc": "* Puts the values contained in a supplied Map into the Map starting at\n     * the specified index.\n     *\n     * @param index the index in the Map to start at.\n     * @param map the Map containing the entries to be added.\n     * @throws IndexOutOfBoundsException if the index is out of range [0, size]"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1"
        },
        "remove": {
          "Javadoc": "* Removes the element at the specified index.\n     *\n     * @param index  the index of the object to remove\n     * @return the removed value, or {@code null} if none existed\n     * @throws IndexOutOfBoundsException if the index is invalid"
        },
        "setValue": {
          "Javadoc": "* Sets the value at the specified index.\n     *\n     * @param index  the index of the value to set\n     * @param value  the new value to set\n     * @return the previous value at that index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 3.2"
        },
        "toString": {
          "Javadoc": "* Returns the Map as a string.\n     *\n     * @return the Map as a String"
        },
        "valueList": {
          "Javadoc": "* Gets a view over the values in the map as a List.\n     * <p>\n     * The List will be ordered by object insertion into the map.\n     * The List supports remove and set, but does not support add.\n     *\n     * @see #values()\n     * @return the partially modifiable list view over the values\n     * @since 3.2"
        },
        "values": {
          "Javadoc": "* Gets a view over the values in the map.\n     * <p>\n     * The Collection will be ordered by object insertion into the map.\n     * <p>\n     * From Commons Collections 3.2, this Collection can be cast\n     * to a list, see {@link #valueList()}\n     *\n     * @see #valueList()\n     * @return the fully modifiable collection view over the values"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.map.EntrySetView": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.KeySetView": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.ListOrderedIterator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.ListOrderedMapEntry": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.ListOrderedMapIterator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.ValuesView": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.LRUMap": {
      "Javadoc": "\n * A {@code Map} implementation with a fixed maximum size which removes\n * the least recently used entry if an entry is added when full.\n * <p>\n * The least recently used algorithm works on the get and put operations only.\n * Iteration of any kind, including setting the value by iteration, does not\n * change the order. Queries such as containsKey and containsValue or access\n * via views also do not change the order.\n * </p>\n * <p>\n * A somewhat subtle ramification of the least recently used\n * algorithm is that calls to {@link #get(Object)} stand a very good chance\n * of modifying the map's iteration order and thus invalidating any\n * iterators currently in use.  It is therefore suggested that iterations\n * over an {@link LRUMap} instance access entry values only through a\n * {@link org.apache.commons.collections4.MapIterator MapIterator} or {@link #entrySet()} iterator.\n * </p>\n * <p>\n * The map implements {@code OrderedMap} and entries may be queried using\n * the bidirectional {@code OrderedMapIterator}. The order returned is\n * least recently used to most recently used. Iterators from map views can\n * also be cast to {@code OrderedIterator} if required.\n * </p>\n * <p>\n * All the available iterators can be reset back to the start by casting to\n * {@code ResettableIterator} and calling {@code reset()}.\n * </p>\n * <p>\n * <strong>Note that LRUMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n * {@code NullPointerException}'s when accessed by concurrent threads.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0 (previously in main package v1.0)\n ",
      "methods": {
        "addMapping": {
          "Javadoc": "* Adds a new key-value mapping into this map.\n     * <p>\n     * This implementation checks the LRU size and determines whether to\n     * discard an entry or not using {@link #removeLRU(AbstractLinkedMap.LinkEntry)}.\n     * <p>\n     * From Commons Collections 3.1 this method uses {@link #isFull()} rather\n     * than accessing {@code size} and {@code maxSize} directly.\n     * It also handles the scanUntilRemovable functionality.\n     *\n     * @param hashIndex  the index into the data array to store at\n     * @param hashCode  the hash code of the key to add\n     * @param key  the key to add\n     * @param value  the value to add"
        },
        "clone": {
          "Javadoc": "* Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone"
        },
        "doReadObject": {
          "Javadoc": "* Reads the data necessary for {@code put()} to work in the superclass.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "doWriteObject": {
          "Javadoc": "* Writes the data necessary for {@code put()} to work in deserialization.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        },
        "get": {
          "Javadoc": "* Gets the value mapped to the key specified.\n     * <p>\n     * If {@code updateToMRU} is {@code true}, the position of the key in the map\n     * is changed to the most recently used position (last), otherwise the iteration\n     * order is not changed by this operation.\n     *\n     * @param key  the key\n     * @param updateToMRU  whether the key shall be updated to the\n     *   most recently used position\n     * @return the mapped value, null if no match\n     * @since 4.1"
        },
        "isFull": {
          "Javadoc": "* Returns true if this map is full and no new mappings can be added.\n     *\n     * @return {@code true} if the map is full"
        },
        "isScanUntilRemovable": {
          "Javadoc": "* Whether this LRUMap will scan until a removable entry is found when the\n     * map is full.\n     *\n     * @return true if this map scans\n     * @since 3.1"
        },
        "maxSize": {
          "Javadoc": "* Gets the maximum size of the map (the bound).\n     *\n     * @return the maximum number of elements the map can hold"
        },
        "moveToMRU": {
          "Javadoc": "* Moves an entry to the MRU position at the end of the list.\n     * <p>\n     * This implementation moves the updated entry to the end of the list.\n     *\n     * @param entry  the entry to update"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "removeLRU": {
          "Javadoc": "* Subclass method to control removal of the least recently used entry from the map.\n     * <p>\n     * This method exists for subclasses to override. A subclass may wish to\n     * provide cleanup of resources when an entry is removed. For example:\n     * <pre>\n     * protected boolean removeLRU(LinkEntry entry) {\n     *   releaseResources(entry.getValue());  // release resources held by entry\n     *   return true;  // actually delete entry\n     * }\n     * </pre>\n     * <p>\n     * Alternatively, a subclass may choose to not remove the entry or selectively\n     * keep certain LRU entries. For example:\n     * <pre>\n     * protected boolean removeLRU(LinkEntry entry) {\n     *   if (entry.getKey().toString().startsWith(\"System.\")) {\n     *     return false;  // entry not removed from LRUMap\n     *   } else {\n     *     return true;  // actually delete entry\n     *   }\n     * }\n     * </pre>\n     * The effect of returning false is dependent on the scanUntilRemovable flag.\n     * If the flag is true, the next LRU entry will be passed to this method and so on\n     * until one returns false and is removed, or every entry in the map has been passed.\n     * If the scanUntilRemovable flag is false, the map will exceed the maximum size.\n     * <p>\n     * NOTE: Commons Collections 3.0 passed the wrong entry to this method.\n     * This is fixed in version 3.1 onwards.\n     *\n     * @param entry  the entry to be removed\n     * @return {@code true}"
        },
        "reuseMapping": {
          "Javadoc": "* Reuses an entry by removing it and moving it to a new place in the map.\n     * <p>\n     * This method uses {@link #removeEntry}, {@link #reuseEntry} and {@link #addEntry}.\n     *\n     * @param entry  the entry to reuse\n     * @param hashIndex  the index into the data array to store at\n     * @param hashCode  the hash code of the key to add\n     * @param key  the key to add\n     * @param value  the value to add"
        },
        "updateEntry": {
          "Javadoc": "* Updates an existing key-value mapping.\n     * <p>\n     * This implementation moves the updated entry to the end of the list\n     * using {@link #moveToMRU(AbstractLinkedMap.LinkEntry)}.\n     *\n     * @param entry  the entry to update\n     * @param newValue  the new value to store"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.map.MultiKeyMap": {
      "Javadoc": "\n * A {@code Map} implementation that uses multiple keys to map the value.\n * <p>\n * This class is the most efficient way to uses multiple keys to map to a value.\n * The best way to use this class is via the additional map-style methods.\n * These provide {@code get}, {@code containsKey}, {@code put} and\n * {@code remove} for individual keys which operate without extra object creation.\n * </p>\n * <p>\n * The additional methods are the main interface of this map.\n * As such, you will not normally hold this map in a variable of type {@code Map}.\n * </p>\n * <p>\n * The normal map methods take in and return a {@link MultiKey}.\n * If you try to use {@code put()} with any other object type a\n * {@code ClassCastException} is thrown. If you try to use {@code null} as\n * the key in {@code put()} a {@code NullPointerException} is thrown.\n * </p>\n * <p>\n * This map is implemented as a decorator of a {@code AbstractHashedMap} which\n * enables extra behavior to be added easily.\n * </p>\n * <ul>\n * <li>{@code MultiKeyMap.decorate(new LinkedMap())} creates an ordered map.\n * <li>{@code MultiKeyMap.decorate(new LRUMap())} creates an least recently used map.\n * <li>{@code MultiKeyMap.decorate(new ReferenceMap())} creates a garbage collector sensitive map.\n * </ul>\n * <p>\n * Note that {@code IdentityMap} and {@code ReferenceIdentityMap} are unsuitable\n * for use as the key comparison would work on the whole MultiKey, not the elements within.\n * </p>\n * <p>\n * As an example, consider a least recently used cache that uses a String airline code\n * and a Locale to lookup the airline's name:\n * </p>\n * <pre>\n * private MultiKeyMap cache = MultiKeyMap.multiKeyMap(new LRUMap(50));\n *\n * public String getAirlineName(String code, String locale) {\n *   String name = (String) cache.get(code, locale);\n *   if (name == null) {\n *     name = getAirlineNameFromDB(code, locale);\n *     cache.put(code, locale, name);\n *   }\n *   return name;\n * }\n * </pre>\n * <p>\n * <strong>Note that MultiKeyMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. This class may throw exceptions when accessed\n * by concurrent threads without synchronization.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.1\n ",
      "methods": {
        "multiKeyMap": {
          "Javadoc": "* Decorates the specified map to add the MultiKeyMap API and fast query.\n     * The map must not be null and must be empty.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, not null\n     * @return a new multi key map\n     * @throws NullPointerException if map is null\n     * @throws IllegalArgumentException if the map is not empty\n     * @since 4.0"
        },
        "checkKey": {
          "Javadoc": "* Check to ensure that input keys are valid MultiKey objects.\n     *\n     * @param key  the key to check"
        },
        "clone": {
          "Javadoc": "* Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone"
        },
        "containsKey": {
          "Javadoc": "* Checks whether the map contains the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     * @return true if the map contains the key"
        },
        "decorated": {
          "Javadoc": "* {@inheritDoc}"
        },
        "get": {
          "Javadoc": "* Gets the value mapped to the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     * @return the mapped value, null if no match"
        },
        "hash": {
          "Javadoc": "* Gets the hash code for the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     * @return the hash code"
        },
        "isEqualKey": {
          "Javadoc": "* Is the key equal to the combined key.\n     *\n     * @param entry  the entry to compare to\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     * @return true if the key matches"
        },
        "put": {
          "Javadoc": "* Puts the key and value into the map, where the key must be a non-null\n     * MultiKey object.\n     *\n     * @param key  the non-null MultiKey object\n     * @param value  the value to store\n     * @return the previous value for the key\n     * @throws NullPointerException if the key is null\n     * @throws ClassCastException if the key is not a MultiKey"
        },
        "putAll": {
          "Javadoc": "* Copies all of the keys and values from the specified map to this map.\n     * Each key must be non-null and a MultiKey object.\n     *\n     * @param mapToCopy  to this map\n     * @throws NullPointerException if the mapToCopy or any key within is null\n     * @throws ClassCastException if any key in mapToCopy is not a MultiKey"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "removeAll": {
          "Javadoc": "* Removes all mappings where the first four keys are those specified.\n     * <p>\n     * This method removes all the mappings where the {@code MultiKey}\n     * has four or more keys, and the first four match those specified.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @return true if any elements were removed"
        },
        "removeMultiKey": {
          "Javadoc": "* Removes the specified multi-key from this map.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     * @return the value mapped to the removed key, null if key not in map\n     * @since 4.0 (previous name: remove(Object, Object, Object, Object, Object))"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.map.MultiValueMap": {
      "Javadoc": "\n * A MultiValueMap decorates another map, allowing it to have\n * more than one value for a key.\n * <p>\n * A {@code MultiMap} is a Map with slightly different semantics.\n * Putting a value into the map will add the value to a Collection at that key.\n * Getting a value will return a Collection, holding all the values put to that key.\n * </p>\n * <p>\n * This implementation is a decorator, allowing any Map implementation\n * to be used as the base.\n * </p>\n * <p>\n * In addition, this implementation allows the type of collection used\n * for the values to be controlled. By default, an {@code ArrayList}\n * is used, however a {@code Class} to instantiate may be specified,\n * or a factory that returns a {@code Collection} instance.\n * </p>\n * <p>\n * <strong>Note that MultiValueMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. This class may throw exceptions when accessed\n * by concurrent threads without synchronization.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.2\n * @deprecated since 4.1, use {@link org.apache.commons.collections4.MultiValuedMap MultiValuedMap} instead\n ",
      "methods": {
        "multiValueMap": {
          "Javadoc": "* Creates a map which wraps the given map and\n     * maps keys to ArrayLists.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to wrap\n     * @return a new multi-value map\n     * @since 4.0"
        },
        "clear": {
          "Javadoc": "* Clear the map."
        },
        "containsValue": {
          "Javadoc": "* Checks whether the collection at the specified key contains the value.\n     *\n     * @param key  the key to search for\n     * @param value  the value to search for\n     * @return true if the map contains the value"
        },
        "createCollection": {
          "Javadoc": "* Creates a new instance of the map value Collection container\n     * using the factory.\n     * <p>\n     * This method can be overridden to perform your own processing\n     * instead of using the factory.\n     *\n     * @param size  the collection size that is about to be added\n     * @return the new collection"
        },
        "entrySet": {
          "Javadoc": "* {@inheritDoc}\n     * <p>\n     * NOTE: the returned Entry objects will contain as value a {@link Collection}\n     * of all values that are mapped to the given key. To get a \"flattened\" version\n     * of all mappings contained in this map, use {@link #iterator()}.\n     *\n     * @see #iterator()"
        },
        "getCollection": {
          "Javadoc": "* Gets the collection mapped to the specified key.\n     * This method is a convenience method to typecast the result of {@code get(key)}.\n     *\n     * @param key  the key to retrieve\n     * @return the collection mapped to the key, null if no mapping"
        },
        "iterator": {
          "Javadoc": "* Gets an iterator for the collection mapped to the specified key.\n     *\n     * @param key  the key to get an iterator for\n     * @return the iterator of the collection at the key, empty iterator if key not in map"
        },
        "put": {
          "Javadoc": "* Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal {@code Map} the previous value is not replaced.\n     * Instead, the new value is added to the collection stored against the key.\n     *\n     * @param key  the key to store against\n     * @param value  the value to add to the collection at the key\n     * @return the value added if the map changed and null if the map did not change"
        },
        "putAll": {
          "Javadoc": "* Override superclass to ensure that MultiMap instances are\n     * correctly handled.\n     * <p>\n     * If you call this method with a normal map, each entry is\n     * added using {@code put(Object,Object)}.\n     * If you call this method with a multi map, each entry is\n     * added using {@code putAll(Object,Collection)}.\n     *\n     * @param map  the map to copy (either a normal or multi map)"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 4.0"
        },
        "removeMapping": {
          "Javadoc": "* Removes a specific value from map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, {@code null} will be returned\n     * from a subsequent {@code get(key)}.\n     *\n     * @param key  the key to remove from\n     * @param value the value to remove\n     * @return {@code true} if the mapping was removed, {@code false} otherwise"
        },
        "size": {
          "Javadoc": "* Gets the size of the collection mapped to the specified key.\n     *\n     * @param key  the key to get size for\n     * @return the size of the collection at the key, zero if key not in map"
        },
        "totalSize": {
          "Javadoc": "* Gets the total size of the map by counting all the values.\n     *\n     * @return the total size of the map counting all values"
        },
        "values": {
          "Javadoc": "* Gets a collection containing all the values in the map.\n     * <p>\n     * This returns a collection containing the combination of values from all keys.\n     *\n     * @return a collection view of the values contained in this map"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream\n     * @since 4.0"
        }
      }
    },
    "org.apache.commons.collections4.map.ReflectionFactory": {
      "Javadoc": "\n     * Inner class that provides a simple reflection factory.\n     "
    },
    "org.apache.commons.collections4.map.PassiveExpiringMap": {
      "Javadoc": "\n * Decorates a {@code Map} to evict expired entries once their expiration\n * time has been reached.\n * <p>\n * When putting a key-value pair in the map this decorator uses a\n * {@link ExpirationPolicy} to determine how long the entry should remain alive\n * as defined by an expiration time value.\n * </p>\n * <p>\n * When accessing the mapped value for a key, its expiration time is checked,\n * and if it is a negative value or if it is greater than the current time, the\n * mapped value is returned. Otherwise, the key is removed from the decorated\n * map, and {@code null} is returned.\n * </p>\n * <p>\n * When invoking methods that involve accessing the entire map contents (i.e\n * {@link #containsValue(Object)}, {@link #entrySet()}, etc.) this decorator\n * removes all expired entries prior to actually completing the invocation.\n * </p>\n * <p>\n * <strong>Note that {@link PassiveExpiringMap} is not synchronized and is not\n * thread-safe.</strong> If you wish to use this map from multiple threads\n * concurrently, you must use appropriate synchronization. The simplest approach\n * is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.\n * This class may throw exceptions when accessed by concurrent threads without\n * synchronization.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.0\n ",
      "methods": {
        "validateAndConvertToMillis": {
          "Javadoc": "* First validate the input parameters. If the parameters are valid, convert\n     * the given time measured in the given units to the same time measured in\n     * milliseconds.\n     *\n     * @param timeToLive the constant amount of time an entry is available\n     *        before it expires. A negative value results in entries that NEVER\n     *        expire. A zero value results in entries that ALWAYS expire.\n     * @param timeUnit the unit of time for the {@code timeToLive}\n     *        parameter, must not be null.\n     * @throws NullPointerException if the time unit is null."
        },
        "clear": {
          "Javadoc": "* Normal {@link Map#clear()} behavior with the addition of clearing all\n     * expiration entries as well."
        },
        "containsKey": {
          "Javadoc": "* All expired entries are removed from the map prior to determining the\n     * contains result.\n     * {@inheritDoc}"
        },
        "containsValue": {
          "Javadoc": "* All expired entries are removed from the map prior to determining the\n     * contains result.\n     * {@inheritDoc}"
        },
        "entrySet": {
          "Javadoc": "* All expired entries are removed from the map prior to returning the entry set.\n     * {@inheritDoc}"
        },
        "get": {
          "Javadoc": "* All expired entries are removed from the map prior to returning the entry value.\n     * {@inheritDoc}"
        },
        "isEmpty": {
          "Javadoc": "* All expired entries are removed from the map prior to determining if it is empty.\n     * {@inheritDoc}"
        },
        "isExpired": {
          "Javadoc": "* Determines if the given expiration time is less than {@code now}.\n     *\n     * @param now the time in milliseconds used to compare against the\n     *        expiration time.\n     * @param expirationTimeObject the expiration time value retrieved from\n     *        {@link #expirationMap}, can be null.\n     * @return {@code true} if {@code expirationTimeObject} is &ge; 0\n     *         and {@code expirationTimeObject} &lt; {@code now}.\n     *         {@code false} otherwise."
        },
        "keySet": {
          "Javadoc": "* All expired entries are removed from the map prior to returning the key set.\n     * {@inheritDoc}"
        },
        "now": {
          "Javadoc": "* The current time in milliseconds."
        },
        "put": {
          "Javadoc": "* Add the given key-value pair to this map as well as recording the entry's expiration time based on\n    * the current time in milliseconds and this map's {@link #expiringPolicy}.\n    * <p>\n    * {@inheritDoc}"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "remove": {
          "Javadoc": "* Normal {@link Map#remove(Object)} behavior with the addition of removing\n     * any expiration entry as well.\n     * {@inheritDoc}"
        },
        "removeAllExpired": {
          "Javadoc": "* Removes all entries in the map whose expiration time is less than\n     * {@code now}. The exceptions are entries with negative expiration\n     * times; those entries are never removed.\n     *\n     * @see #isExpired(long, Long)"
        },
        "removeIfExpired": {
          "Javadoc": "* Removes the entry with the given key if the entry's expiration time is\n     * less than {@code now}. If the entry has a negative expiration time,\n     * the entry is never removed."
        },
        "size": {
          "Javadoc": "* All expired entries are removed from the map prior to returning the size.\n     * {@inheritDoc}"
        },
        "values": {
          "Javadoc": "* All expired entries are removed from the map prior to returning the value collection.\n     * {@inheritDoc}"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.map.ConstantTimeToLiveExpirationPolicy": {
      "Javadoc": "\n     * A {@link org.apache.commons.collections4.map.PassiveExpiringMap.ExpirationPolicy ExpirationPolicy}\n     * that returns an expiration time that is a\n     * constant about of time in the future from the current time.\n     *\n     * @param <K> the type of the keys in the map\n     * @param <V> the type of the values in the map\n     * @since 4.0\n     ",
      "methods": {
        "expirationTime": {
          "Javadoc": "* Determine the expiration time for the given key-value entry.\n         *\n         * @param key the key for the entry (ignored).\n         * @param value the value for the entry (ignored).\n         * @return if {@link #timeToLiveMillis} &ge; 0, an expiration time of\n         *         {@link #timeToLiveMillis} +\n         *         {@link System#currentTimeMillis()} is returned. Otherwise, -1\n         *         is returned indicating the entry never expires."
        }
      }
    },
    "org.apache.commons.collections4.map.ExpirationPolicy": {
      "Javadoc": "\n     * A policy to determine the expiration time for key-value entries.\n     *\n     * @param <K> the key object type.\n     * @param <V> the value object type\n     * @since 4.0\n     ",
      "methods": {
        "expirationTime": {
          "Javadoc": "* Determine the expiration time for the given key-value entry.\n         *\n         * @param key the key for the entry.\n         * @param value the value for the entry.\n         * @return the expiration time value measured in milliseconds. A\n         *         negative return value indicates the entry never expires."
        }
      }
    },
    "org.apache.commons.collections4.map.PredicatedMap": {
      "Javadoc": "\n * Decorates another {@code Map} to validate that additions\n * match a specified predicate.\n * <p>\n * This map exists to provide validation for the decorated map.\n * It is normally created to decorate an empty map.\n * If an object cannot be added to the map, an IllegalArgumentException is thrown.\n * </p>\n * <p>\n * One usage would be to ensure that no null keys are added to the map.\n * </p>\n * <pre>Map map = PredicatedSet.decorate(new HashMap(), NotNullPredicate.INSTANCE, null);</pre>\n * <p>\n * <strong>Note that PredicatedMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "predicatedMap": {
          "Javadoc": "* Factory method to create a predicated (validating) map.\n     * <p>\n     * If there are any elements already in the list being decorated, they\n     * are validated.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyPredicate  the predicate to validate the keys, null means no check\n     * @param valuePredicate  the predicate to validate to values, null means no check\n     * @return a new predicated map\n     * @throws NullPointerException if the map is null\n     * @since 4.0"
        },
        "checkSetValue": {
          "Javadoc": "* Override to validate an object set into the map via {@code setValue}.\n     *\n     * @param value  the value to validate\n     * @return the value itself\n     * @throws IllegalArgumentException if invalid\n     * @since 3.1"
        },
        "isSetValueChecking": {
          "Javadoc": "* Override to only return true when there is a value transformer.\n     *\n     * @return true if a value predicate is in use\n     * @since 3.1"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1"
        },
        "validate": {
          "Javadoc": "* Validates a key value pair.\n     *\n     * @param key  the key to validate\n     * @param value  the value to validate\n     * @throws IllegalArgumentException if invalid"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.map.PredicatedSortedMap": {
      "Javadoc": "\n * Decorates another {@code SortedMap} to validate that additions\n * match a specified predicate.\n * <p>\n * This map exists to provide validation for the decorated map.\n * It is normally created to decorate an empty map.\n * If an object cannot be added to the map, an IllegalArgumentException is thrown.\n * </p>\n * <p>\n * One usage would be to ensure that no null keys are added to the map.\n * </p>\n * <pre>\n *   SortedMap map =\n *     PredicatedSortedMap.predicatedSortedMap(new TreeMap(),\n *                                             NotNullPredicate.notNullPredicate(),\n *                                             null);\n * </pre>\n * <p>\n * <strong>Note that PredicatedSortedMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "predicatedSortedMap": {
          "Javadoc": "* Factory method to create a predicated (validating) sorted map.\n     * <p>\n     * If there are any elements already in the list being decorated, they\n     * are validated.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyPredicate  the predicate to validate the keys, null means no check\n     * @param valuePredicate  the predicate to validate to values, null means no check\n     * @return a new predicated sorted map\n     * @throws NullPointerException if the map is null\n     * @since 4.0"
        },
        "getSortedMap": {
          "Javadoc": "* Gets the map being decorated.\n     *\n     * @return the decorated map"
        }
      }
    },
    "org.apache.commons.collections4.map.ReferenceIdentityMap": {
      "Javadoc": "\n * A {@code Map} implementation that allows mappings to be\n * removed by the garbage collector and matches keys and values based\n * on {@code ==} not {@code equals()}.\n * <p>\n * When you construct a {@code ReferenceIdentityMap}, you can specify what kind\n * of references are used to store the map's keys and values.\n * If non-hard references are used, then the garbage collector can remove\n * mappings if a key or value becomes unreachable, or if the JVM's memory is\n * running low. For information on how the different reference types behave,\n * see {@link Reference}.\n * </p>\n * <p>\n * Different types of references can be specified for keys and values.\n * The default constructor uses hard keys and soft values, providing a\n * memory-sensitive cache.\n * </p>\n * <p>\n * This map is similar to\n * {@link org.apache.commons.collections4.map.ReferenceMap ReferenceMap}.\n * It differs in that keys and values in this class are compared using {@code ==}.\n * </p>\n * <p>\n * This map will violate the detail of various Map and map view contracts.\n * As a general rule, don't compare this map to other maps.\n * </p>\n * <p>\n * This {@link java.util.Map Map} implementation does <i>not</i> allow null elements.\n * Attempting to add a null key or value to the map will raise a {@code NullPointerException}.\n * </p>\n * <p>\n * This implementation is not synchronized.\n * You can use {@link java.util.Collections#synchronizedMap} to\n * provide synchronized access to a {@code ReferenceIdentityMap}.\n * Remember that synchronization will not stop the garbage collector removing entries.\n * </p>\n * <p>\n * All the available iterators can be reset back to the start by casting to\n * {@code ResettableIterator} and calling {@code reset()}.\n * </p>\n * <p>\n * <strong>Note that ReferenceIdentityMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n *\n * @see java.lang.ref.Reference\n * @since 3.0 (previously in main package v2.1)\n ",
      "methods": {
        "hash": {
          "Javadoc": "* Gets the hash code for the key specified.\n     * <p>\n     * This implementation uses the identity hash code.\n     *\n     * @param key  the key to get a hash code for\n     * @return the hash code"
        },
        "hashEntry": {
          "Javadoc": "* Gets the hash code for a MapEntry.\n     * <p>\n     * This implementation uses the identity hash code.\n     *\n     * @param key  the key to get a hash code for, may be null\n     * @param value  the value to get a hash code for, may be null\n     * @return the hash code, as per the MapEntry specification"
        },
        "isEqualKey": {
          "Javadoc": "* Compares two keys for equals.\n     * <p>\n     * This implementation converts the key from the entry to a real reference\n     * before comparison and uses {@code ==}.\n     *\n     * @param key1  the first key to compare passed in from outside\n     * @param key2  the second key extracted from the entry via {@code entry.key}\n     * @return true if equal by identity"
        },
        "isEqualValue": {
          "Javadoc": "* Compares two values for equals.\n     * <p>\n     * This implementation uses {@code ==}.\n     *\n     * @param value1  the first value to compare passed in from outside\n     * @param value2  the second value extracted from the entry via {@code getValue()}\n     * @return true if equal by identity"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.map.ReferenceMap": {
      "Javadoc": "\n * A {@code Map} implementation that allows mappings to be\n * removed by the garbage collector.\n * <p>\n * When you construct a {@code ReferenceMap}, you can specify what kind\n * of references are used to store the map's keys and values.\n * If non-hard references are used, then the garbage collector can remove\n * mappings if a key or value becomes unreachable, or if the JVM's memory is\n * running low. For information on how the different reference types behave,\n * see {@link java.lang.ref.Reference Reference}.\n * </p>\n * <p>\n * Different types of references can be specified for keys and values.\n * The keys can be configured to be weak but the values hard,\n * in which case this class will behave like a\n * <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/WeakHashMap.html\">\n * {@code WeakHashMap}</a>. However, you can also specify hard keys and\n * weak values, or any other combination. The default constructor uses\n * hard keys and soft values, providing a memory-sensitive cache.\n * </p>\n * <p>\n * This map is similar to\n * {@link org.apache.commons.collections4.map.ReferenceIdentityMap ReferenceIdentityMap}.\n * It differs in that keys and values in this class are compared using {@code equals()}.\n * </p>\n * <p>\n * This {@link java.util.Map Map} implementation does <i>not</i> allow null elements.\n * Attempting to add a null key or value to the map will raise a {@code NullPointerException}.\n * </p>\n * <p>\n * This implementation is not synchronized.\n * You can use {@link java.util.Collections#synchronizedMap} to\n * provide synchronized access to a {@code ReferenceMap}.\n * Remember that synchronization will not stop the garbage collector removing entries.\n * </p>\n * <p>\n * All the available iterators can be reset back to the start by casting to\n * {@code ResettableIterator} and calling {@code reset()}.\n * </p>\n * <p>\n * <strong>Note that ReferenceMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n * <p>\n * NOTE: As from Commons Collections 3.1 this map extends {@code AbstractReferenceMap}\n * (previously it extended AbstractMap). As a result, the implementation is now\n * extensible and provides a {@code MapIterator}.\n * </p>\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n *\n * @see java.lang.ref.Reference\n * @since 3.0 (previously in main package v2.1)\n ",
      "methods": {
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.map.SingletonMap": {
      "Javadoc": "\n * A {@code Map} implementation that holds a single item and is fixed size.\n * <p>\n * The single key/value pair is specified at creation.\n * The map is fixed size so any action that would change the size is disallowed.\n * However, the {@code put} or {@code setValue} methods can <i>change</i>\n * the value associated with the key.\n * </p>\n * <p>\n * If trying to remove or clear the map, an UnsupportedOperationException is thrown.\n * If trying to put a new mapping into the map, an  IllegalArgumentException is thrown.\n * The put method will only succeed if the key specified is the same as the\n * singleton key.\n * </p>\n * <p>\n * The key and value can be obtained by:\n * </p>\n * <ul>\n * <li>normal Map methods and views\n * <li>the {@code MapIterator}, see {@link #mapIterator()}\n * <li>the {@code KeyValue} interface (just cast - no object creation)\n * </ul>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.1\n ",
      "methods": {
        "clear": {
          "Javadoc": "* Unsupported operation."
        },
        "clone": {
          "Javadoc": "* Clones the map without cloning the key or value.\n     *\n     * @return a shallow clone"
        },
        "containsKey": {
          "Javadoc": "* Checks whether the map contains the specified key.\n     *\n     * @param key  the key to search for\n     * @return true if the map contains the key"
        },
        "containsValue": {
          "Javadoc": "* Checks whether the map contains the specified value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the key"
        },
        "entrySet": {
          "Javadoc": "* Gets the entrySet view of the map.\n     * Changes made via {@code setValue} affect this map.\n     * To simply iterate through the entries, use {@link #mapIterator()}.\n     *\n     * @return the entrySet view"
        },
        "equals": {
          "Javadoc": "* Compares this map with another.\n     *\n     * @param obj  the object to compare to\n     * @return true if equal"
        },
        "firstKey": {
          "Javadoc": "* Gets the first (and only) key in the map.\n     *\n     * @return the key"
        },
        "get": {
          "Javadoc": "* Gets the value mapped to the key specified.\n     *\n     * @param key  the key\n     * @return the mapped value, null if no match"
        },
        "getKey": {
          "Javadoc": "* Gets the key.\n     *\n     * @return the key"
        },
        "getValue": {
          "Javadoc": "* Gets the value.\n     *\n     * @return the value"
        },
        "hashCode": {
          "Javadoc": "* Gets the standard Map hashCode.\n     *\n     * @return the hash code defined in the Map interface"
        },
        "isEmpty": {
          "Javadoc": "* Checks whether the map is currently empty, which it never is.\n     *\n     * @return false always"
        },
        "isEqualKey": {
          "Javadoc": "* Compares the specified key to the stored key.\n     *\n     * @param key  the key to compare\n     * @return true if equal"
        },
        "isEqualValue": {
          "Javadoc": "* Compares the specified value to the stored value.\n     *\n     * @param value  the value to compare\n     * @return true if equal"
        },
        "isFull": {
          "Javadoc": "* Is the map currently full, always true.\n     *\n     * @return true always"
        },
        "keySet": {
          "Javadoc": "* Gets the unmodifiable keySet view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the keys, use {@link #mapIterator()}.\n     *\n     * @return the keySet view"
        },
        "lastKey": {
          "Javadoc": "* Gets the last (and only) key in the map.\n     *\n     * @return the key"
        },
        "mapIterator": {
          "Javadoc": "* {@inheritDoc}"
        },
        "maxSize": {
          "Javadoc": "* Gets the maximum size of the map, always 1.\n     *\n     * @return 1 always"
        },
        "nextKey": {
          "Javadoc": "* Gets the next key after the key specified, always null.\n     *\n     * @param key  the next key\n     * @return null always"
        },
        "previousKey": {
          "Javadoc": "* Gets the previous key before the key specified, always null.\n     *\n     * @param key  the next key\n     * @return null always"
        },
        "put": {
          "Javadoc": "* Puts a key-value mapping into this map where the key must match the existing key.\n     * <p>\n     * An IllegalArgumentException is thrown if the key does not match as the map\n     * is fixed size.\n     *\n     * @param key  the key to set, must be the key of the map\n     * @param value  the value to set\n     * @return the value previously mapped to this key, null if none\n     * @throws IllegalArgumentException if the key does not match"
        },
        "putAll": {
          "Javadoc": "* Puts the values from the specified map into this map.\n     * <p>\n     * The map must be of size 0 or size 1.\n     * If it is size 1, the key must match the key of this map otherwise an\n     * IllegalArgumentException is thrown.\n     *\n     * @param map  the map to add, must be size 0 or 1, and the key must match\n     * @throws NullPointerException if the map is null\n     * @throws IllegalArgumentException if the key does not match"
        },
        "remove": {
          "Javadoc": "* Unsupported operation.\n     *\n     * @param key  the mapping to remove\n     * @return the value mapped to the removed key, null if key not in map\n     * @throws UnsupportedOperationException always"
        },
        "setValue": {
          "Javadoc": "* Sets the value.\n     *\n     * @param value  the new value to set\n     * @return the old value"
        },
        "size": {
          "Javadoc": "* Gets the size of the map, always 1.\n     *\n     * @return the size of 1"
        },
        "toString": {
          "Javadoc": "* Gets the map as a String.\n     *\n     * @return a string version of the map"
        },
        "values": {
          "Javadoc": "* Gets the unmodifiable values view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the values, use {@link #mapIterator()}.\n     *\n     * @return the values view"
        }
      }
    },
    "org.apache.commons.collections4.map.SingletonMapIterator": {
      "Javadoc": "\n     * SingletonMapIterator.\n     "
    },
    "org.apache.commons.collections4.map.SingletonValues": {
      "Javadoc": "\n     * Values implementation for the SingletonMap.\n     * This class is needed as values is a view that must update as the map updates.\n     "
    },
    "org.apache.commons.collections4.map.StaticBucketMap": {
      "Javadoc": "\n * A StaticBucketMap is an efficient, thread-safe implementation of\n * {@link java.util.Map} that performs well in a highly\n * thread-contentious environment.  The map supports very efficient\n * {@link #get(Object) get}, {@link #put(Object,Object) put},\n * {@link #remove(Object) remove} and {@link #containsKey(Object) containsKey}\n * operations, assuming (approximate) uniform hashing and\n * that the number of entries does not exceed the number of buckets.  If the\n * number of entries exceeds the number of buckets or if the hash codes of the\n * objects are not uniformly distributed, these operations have a worst case\n * scenario that is proportional to the number of elements in the map\n * (<i>O(n)</i>).<p>\n *\n * Each bucket in the hash table has its own monitor, so two threads can\n * safely operate on the map at the same time, often without incurring any\n * monitor contention.  This means that you don't have to wrap instances\n * of this class with {@link java.util.Collections#synchronizedMap(Map)};\n * instances are already thread-safe.  Unfortunately, however, this means\n * that this map implementation behaves in ways you may find disconcerting.\n * Bulk operations, such as {@link #putAll(Map) putAll} or the\n * {@link Collection#retainAll(Collection) retainAll} operation in collection\n * views, are <i>not</i> atomic.  If two threads are simultaneously\n * executing\n *\n * <pre>\n *   staticBucketMapInstance.putAll(map);\n * </pre>\n *\n * and\n *\n * <pre>\n *   staticBucketMapInstance.entrySet().removeAll(map.entrySet());\n * </pre>\n *\n * then the results are generally random.  Those two statement could cancel\n * each other out, leaving {@code staticBucketMapInstance} essentially\n * unchanged, or they could leave some random subset of {@code map} in\n * {@code staticBucketMapInstance}.<p>\n *\n * Also, much like an encyclopedia, the results of {@link #size()} and\n * {@link #isEmpty()} are out-of-date as soon as they are produced.<p>\n *\n * The iterators returned by the collection views of this class are <i>not</i>\n * fail-fast.  They will <i>never</i> raise a\n * {@link java.util.ConcurrentModificationException}.  Keys and values\n * added to the map after the iterator is created do not necessarily appear\n * during iteration.  Similarly, the iterator does not necessarily fail to\n * return keys and values that were removed after the iterator was created.<p>\n *\n * Finally, unlike {@link java.util.HashMap}-style implementations, this\n * class <i>never</i> rehashes the map.  The number of buckets is fixed\n * at construction time and never altered.  Performance may degrade if\n * you do not allocate enough buckets upfront.<p>\n *\n * The {@link #atomic(Runnable)} method is provided to allow atomic iterations\n * and bulk operations; however, overuse of {@link #atomic(Runnable) atomic}\n * will basically result in a map that's slower than an ordinary synchronized\n * {@link java.util.HashMap}.\n *\n * Use this class if you do not require reliable bulk operations and\n * iterations, or if you can make your own guarantees about how bulk\n * operations will affect the map.<p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0 (previously in main package v2.1)\n ",
      "methods": {
        "atomic": {
          "Javadoc": "*  Prevents any operations from occurring on this map while the\n     *  given {@link Runnable} executes.  This method can be used, for\n     *  instance, to execute a bulk operation atomically:\n     *\n     *  <pre>\n     *    staticBucketMapInstance.atomic(new Runnable() {\n     *        public void run() {\n     *            staticBucketMapInstance.putAll(map);\n     *        }\n     *    });\n     *  </pre>\n     *\n     *  It can also be used if you need a reliable iterator:\n     *\n     *  <pre>\n     *    staticBucketMapInstance.atomic(new Runnable() {\n     *        public void run() {\n     *            Iterator iterator = staticBucketMapInstance.iterator();\n     *            while (iterator.hasNext()) {\n     *                foo(iterator.next();\n     *            }\n     *        }\n     *    });\n     *  </pre>\n     *\n     *  <b>Implementation note:</b> This method requires a lot of time\n     *  and a ton of stack space.  Essentially a recursive algorithm is used\n     *  to enter each bucket's monitor.  If you have twenty thousand buckets\n     *  in your map, then the recursive method will be invoked twenty thousand\n     *  times.  You have been warned.\n     *\n     *  @param runnable  the code to execute atomically"
        },
        "clear": {
          "Javadoc": "* Clears the map of all entries."
        },
        "containsKey": {
          "Javadoc": "* Checks if the map contains the specified key.\n     *\n     * @param key  the key to check\n     * @return true if found"
        },
        "containsValue": {
          "Javadoc": "* Checks if the map contains the specified value.\n     *\n     * @param value  the value to check\n     * @return true if found"
        },
        "entrySet": {
          "Javadoc": "* Gets the entry set.\n     *\n     * @return the entry set"
        },
        "equals": {
          "Javadoc": "* Compares this map to another, as per the Map specification.\n     *\n     * @param obj  the object to compare to\n     * @return true if equal"
        },
        "get": {
          "Javadoc": "* Gets the value associated with the key.\n     *\n     * @param key  the key to retrieve\n     * @return the associated value"
        },
        "getHash": {
          "Javadoc": "* Determine the exact hash entry for the key.  The hash algorithm\n     * is rather simplistic, but it does the job:\n     *\n     * <pre>\n     *   He = |Hk mod n|\n     * </pre>\n     *\n     * <p>\n     *   He is the entry's hashCode, Hk is the key's hashCode, and n is\n     *   the number of buckets.\n     * </p>"
        },
        "hashCode": {
          "Javadoc": "* Gets the hash code, as per the Map specification.\n     *\n     * @return the hash code"
        },
        "isEmpty": {
          "Javadoc": "* Checks if the size is currently zero.\n     *\n     * @return true if empty"
        },
        "keySet": {
          "Javadoc": "* Gets the key set.\n     *\n     * @return the key set"
        },
        "put": {
          "Javadoc": "* Puts a new key value mapping into the map.\n     *\n     * @param key  the key to use\n     * @param value  the value to use\n     * @return the previous mapping for the key"
        },
        "putAll": {
          "Javadoc": "* Puts all the entries from the specified map into this map.\n     * This operation is <b>not atomic</b> and may have undesired effects.\n     *\n     * @param map  the map of entries to add"
        },
        "remove": {
          "Javadoc": "* Removes the specified key from the map.\n     *\n     * @param key  the key to remove\n     * @return the previous value at this key"
        },
        "size": {
          "Javadoc": "* Gets the current size of the map.\n     * The value is computed fresh each time the method is called.\n     *\n     * @return the current size"
        },
        "values": {
          "Javadoc": "* Gets the values.\n     *\n     * @return the values"
        }
      }
    },
    "org.apache.commons.collections4.map.BaseIterator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.KeyIterator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.Lock": {
      "Javadoc": "\n     * The lock object, which also includes a count of the nodes in this lock.\n     "
    },
    "org.apache.commons.collections4.map.Node": {
      "Javadoc": "\n     * The Map.Entry for the StaticBucketMap.\n     "
    },
    "org.apache.commons.collections4.map.ValueIterator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.TransformedMap": {
      "Javadoc": "\n * Decorates another {@code Map} to transform objects that are added.\n * <p>\n * The Map put methods and Map.Entry setValue method are affected by this class.\n * Thus objects must be removed or searched for using their transformed form.\n * For example, if the transformation converts Strings to Integers, you must\n * use the Integer form to remove objects.\n * </p>\n * <p>\n * <strong>Note that TransformedMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n *\n * @see org.apache.commons.collections4.splitmap.TransformedSplitMap\n * @since 3.0\n ",
      "methods": {
        "transformedMap": {
          "Javadoc": "* Factory method to create a transforming map that will transform\n     * existing contents of the specified map.\n     * <p>\n     * If there are any elements already in the map being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingMap(Map, Transformer, Transformer)}.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n     * @return a new transformed map\n     * @throws NullPointerException if map is null\n     * @since 4.0"
        },
        "transformingMap": {
          "Javadoc": "* Factory method to create a transforming map.\n     * <p>\n     * If there are any elements already in the map being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedMap(Map, Transformer, Transformer)}.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n     * @return a new transformed map\n     * @throws NullPointerException if map is null\n     * @since 4.0"
        },
        "checkSetValue": {
          "Javadoc": "* Override to transform the value when using {@code setValue}.\n     *\n     * @param value  the value to transform\n     * @return the transformed value\n     * @since 3.1"
        },
        "isSetValueChecking": {
          "Javadoc": "* Override to only return true when there is a value transformer.\n     *\n     * @return true if a value transformer is in use\n     * @since 3.1"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1"
        },
        "transformKey": {
          "Javadoc": "* Transforms a key.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object  the object to transform\n     * @return the transformed object"
        },
        "transformMap": {
          "Javadoc": "* Transforms a map.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param map  the map to transform\n     * @return the transformed object"
        },
        "transformValue": {
          "Javadoc": "* Transforms a value.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object  the object to transform\n     * @return the transformed object"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.map.TransformedSortedMap": {
      "Javadoc": "\n * Decorates another {@code SortedMap } to transform objects that are added.\n * <p>\n * The Map put methods and Map.Entry setValue method are affected by this class.\n * Thus objects must be removed or searched for using their transformed form.\n * For example, if the transformation converts Strings to Integers, you must\n * use the Integer form to remove objects.\n * </p>\n * <p>\n * <strong>Note that TransformedSortedMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "transformedSortedMap": {
          "Javadoc": "* Factory method to create a transforming sorted map that will transform\n     * existing contents of the specified map.\n     * <p>\n     * If there are any elements already in the map being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingSortedMap(SortedMap, Transformer, Transformer)}.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n     * @return a new transformed sorted map\n     * @throws NullPointerException if map is null\n     * @since 4.0"
        },
        "transformingSortedMap": {
          "Javadoc": "* Factory method to create a transforming sorted map.\n     * <p>\n     * If there are any elements already in the map being decorated, they are NOT transformed.\n     * Contrast this with {@link #transformedSortedMap(SortedMap, Transformer, Transformer)}.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the predicate to validate the keys, null means no transformation\n     * @param valueTransformer  the predicate to validate to values, null means no transformation\n     * @return a new transformed sorted map\n     * @throws NullPointerException if the map is null\n     * @since 4.0"
        },
        "getSortedMap": {
          "Javadoc": "* Gets the map being decorated.\n     *\n     * @return the decorated map"
        }
      }
    },
    "org.apache.commons.collections4.map.UnmodifiableEntrySet": {
      "Javadoc": "\n * Decorates a map entry {@code Set} to ensure it can't be altered.\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n *\n * @since 3.0\n ",
      "methods": {
        "unmodifiableEntrySet": {
          "Javadoc": "* Factory method to create an unmodifiable set of Map Entry objects.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param set  the set to decorate, must not be null\n     * @return a new unmodifiable entry set\n     * @throws NullPointerException if set is null\n     * @since 4.0"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        }
      }
    },
    "org.apache.commons.collections4.map.UnmodifiableEntry": {
      "Javadoc": "\n     * Implementation of a map entry that is unmodifiable.\n     "
    },
    "org.apache.commons.collections4.map.UnmodifiableEntrySetIterator": {
      "Javadoc": "\n     * Implementation of an entry set iterator.\n     "
    },
    "org.apache.commons.collections4.map.UnmodifiableMap": {
      "Javadoc": "\n * Decorates another {@code Map} to ensure it can't be altered.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "unmodifiableMap": {
          "Javadoc": "* Factory method to create an unmodifiable map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @return a new unmodifiable map\n     * @throws NullPointerException if map is null\n     * @since 4.0"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.map.UnmodifiableOrderedMap": {
      "Javadoc": "\n * Decorates another {@code OrderedMap} to ensure it can't be altered.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "unmodifiableOrderedMap": {
          "Javadoc": "* Factory method to create an unmodifiable sorted map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @return a new ordered map\n     * @throws NullPointerException if map is null\n     * @since 4.0"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.map.UnmodifiableSortedMap": {
      "Javadoc": "\n * Decorates another {@code SortedMap} to ensure it can't be altered.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n ",
      "methods": {
        "unmodifiableSortedMap": {
          "Javadoc": "* Factory method to create an unmodifiable sorted map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @return a new unmodifiable sorted map\n     * @throws NullPointerException if map is null\n     * @since 4.0"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream\n     * @since 3.1"
        }
      }
    },
    "org.apache.commons.collections4.MapIterator": {
      "Javadoc": "\n * Defines an iterator that operates over a {@code Map}.\n * <p>\n * This iterator is a special version designed for maps. It can be more\n * efficient to use this rather than an entry set iterator where the option\n * is available, and it is certainly more convenient.\n * </p>\n * <p>\n * A map that provides this interface may not hold the data internally using\n * Map Entry objects, thus this interface can avoid lots of object creation.\n * </p>\n * <p>\n * In use, this iterator iterates through the keys in the map. After each call\n * to {@code next()}, the {@code getValue()} method provides direct\n * access to the value. The value can also be set using {@code setValue()}.\n * </p>\n * <pre>{@code\n * MapIterator<String,Integer> it = map.mapIterator();\n * while (it.hasNext()) {\n *   String key = it.next();\n *   Integer value = it.getValue();\n *   it.setValue(value + 1);\n * }\n * }</pre>\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n * @since 3.0\n ",
      "methods": {
        "getKey": {
          "Javadoc": "* Gets the current key, which is the key returned by the last call\n     * to {@code next()}.\n     *\n     * @return the current key\n     * @throws IllegalStateException if {@code next()} has not yet been called"
        },
        "getValue": {
          "Javadoc": "* Gets the current value, which is the value associated with the last key\n     * returned by {@code next()}.\n     *\n     * @return the current value\n     * @throws IllegalStateException if {@code next()} has not yet been called"
        },
        "hasNext": {
          "Javadoc": "* Checks to see if there are more entries still to be iterated.\n     *\n     * @return {@code true} if the iterator has more elements"
        },
        "next": {
          "Javadoc": "* Gets the next <em>key</em> from the {@code Map}.\n     *\n     * @return the next key in the iteration\n     * @throws java.util.NoSuchElementException if the iteration is finished"
        },
        "remove": {
          "Javadoc": "* Removes the last returned key from the underlying {@code Map} (optional operation).\n     * <p>\n     * This method can be called once per call to {@code next()}.\n     *\n     * @throws UnsupportedOperationException if remove is not supported by the map\n     * @throws IllegalStateException if {@code next()} has not yet been called\n     * @throws IllegalStateException if {@code remove()} has already been called\n     *  since the last call to {@code next()}"
        },
        "setValue": {
          "Javadoc": "* Sets the value associated with the current key (optional operation).\n     *\n     * @param value  the new value\n     * @return the previous value\n     * @throws UnsupportedOperationException if setValue is not supported by the map\n     * @throws IllegalStateException if {@code next()} has not yet been called\n     * @throws IllegalStateException if {@code remove()} has been called since the\n     *  last call to {@code next()}"
        }
      }
    },
    "org.apache.commons.collections4.MapUtils": {
      "Javadoc": "\n * Provides utility methods and decorators for {@link Map} and {@link SortedMap} instances.\n * <p>\n * It contains various type safe methods as well as other useful features like deep copying.\n * </p>\n * <p>\n * It also provides the following decorators:\n * </p>\n *\n * <ul>\n * <li>{@link #fixedSizeMap(Map)}\n * <li>{@link #fixedSizeSortedMap(SortedMap)}\n * <li>{@link #lazyMap(Map,Factory)}\n * <li>{@link #lazyMap(Map,Transformer)}\n * <li>{@link #lazySortedMap(SortedMap,Factory)}\n * <li>{@link #lazySortedMap(SortedMap,Transformer)}\n * <li>{@link #predicatedMap(Map,Predicate,Predicate)}\n * <li>{@link #predicatedSortedMap(SortedMap,Predicate,Predicate)}\n * <li>{@link #transformedMap(Map, Transformer, Transformer)}\n * <li>{@link #transformedSortedMap(SortedMap, Transformer, Transformer)}\n * <li>{@link #multiValueMap( Map )}\n * <li>{@link #multiValueMap( Map, Class )}\n * <li>{@link #multiValueMap( Map, Factory )}\n * </ul>\n *\n * @since 1.0\n ",
      "methods": {
        "applyDefaultFunction": {
          "Javadoc": "* Applies the {@code getFunction} and returns its result if non-null, if null returns the result of applying the\n     * default function.\n     *\n     * @param <K> The key type.\n     * @param <R> The result type.\n     * @param map The map to query.\n     * @param key The key into the map.\n     * @param getFunction The get function.\n     * @param defaultFunction The function to provide a default value.\n     * @param defaultValue The default value.\n     * @return The result of applying a function."
        },
        "applyDefaultValue": {
          "Javadoc": "* Applies the {@code getFunction} and returns its result if non-null, if null returns the {@code defaultValue}.\n     *\n     * @param <K> The key type.\n     * @param <R> The result type.\n     * @param map The map to query.\n     * @param key The key into the map.\n     * @param getFunction The get function.\n     * @param defaultValue The default value.\n     * @return The result of applying a function."
        },
        "debugPrint": {
          "Javadoc": "* Prints the given map with nice line breaks.\n     * <p>\n     * This method prints a nicely formatted String describing the Map. Each map entry will be printed with key, value\n     * and value class name. When the value is a Map, recursive behavior occurs.\n     * </p>\n     * <p>\n     * This method is NOT thread-safe in any special way. You must manually synchronize on either this class or the\n     * stream as required.\n     * </p>\n     *\n     * @param out the stream to print to, must not be null\n     * @param label The label to be used, may be {@code null}. If {@code null}, the label is not output. It\n     *        typically represents the name of the property in a bean or similar.\n     * @param map The map to print, may be {@code null}. If {@code null}, the text 'null' is output.\n     * @throws NullPointerException if the stream is {@code null}"
        },
        "emptyIfNull": {
          "Javadoc": "* Returns an immutable empty map if the argument is {@code null}, or the argument itself otherwise.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map, possibly {@code null}\n     * @return an empty map if the argument is {@code null}"
        },
        "fixedSizeMap": {
          "Javadoc": "* Returns a fixed-sized map backed by the given map. Elements may not be added or removed from the returned map,\n     * but existing elements can be changed (for instance, via the {@link Map#put(Object,Object)} method).\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map whose size to fix, must not be null\n     * @return a fixed-size map backed by that map\n     * @throws NullPointerException if the Map is null"
        },
        "fixedSizeSortedMap": {
          "Javadoc": "* Returns a fixed-sized sorted map backed by the given sorted map. Elements may not be added or removed from the\n     * returned map, but existing elements can be changed (for instance, via the {@link Map#put(Object,Object)} method).\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map whose size to fix, must not be null\n     * @return a fixed-size map backed by that map\n     * @throws NullPointerException if the SortedMap is null"
        },
        "getBoolean": {
          "Javadoc": "* Looks up the given key in the given map, converting the result into a boolean, using the defaultFunction to\n     * produce the default value if the conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails\n     * @return the value in the map as a boolean, or defaultValue produced by the defaultFunction if the original value\n     *         is null, the map is null or the boolean conversion fails\n     * @since 4.5"
        },
        "getBooleanValue": {
          "Javadoc": "* Gets a boolean from a Map in a null-safe manner, using the default value produced by the defaultFunction if the\n     * conversion fails.\n     * <p>\n     * If the value is a {@code Boolean} its value is returned. If the value is a {@code String} and it equals\n     * 'true' ignoring case then {@code true} is returned, otherwise {@code false}. If the value is a\n     * {@code Number} an integer zero value returns {@code false} and non-zero returns {@code true}.\n     * Otherwise, defaultValue produced by the {@code defaultFunction} is returned.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails\n     * @return the value in the Map as a Boolean, default value produced by the {@code defaultFunction} if null map\n     *         input\n     * @since 4.5"
        },
        "getByte": {
          "Javadoc": "* Looks up the given key in the given map, converting the result into a byte, using the defaultFunction to produce\n     * the default value if the conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value\n     *         is null, the map is null or the number conversion fails\n     * @since 4.5"
        },
        "getByteValue": {
          "Javadoc": "* Gets a byte from a Map in a null-safe manner, using the default value produced by the defaultFunction if the\n     * conversion fails.\n     * <p>\n     * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails\n     * @return the value in the Map as a byte, default value produced by the {@code defaultFunction} if null map\n     *         input\n     * @since 4.5"
        },
        "getDouble": {
          "Javadoc": "* Looks up the given key in the given map, converting the result into a double, using the defaultFunction to\n     * produce the default value if the conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value\n     *         is null, the map is null or the number conversion fails\n     * @since 4.5"
        },
        "getDoubleValue": {
          "Javadoc": "* Gets a double from a Map in a null-safe manner, using the default value produced by the defaultFunction if the\n     * conversion fails.\n     * <p>\n     * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails\n     * @return the value in the Map as a double, default value produced by the {@code defaultFunction} if null map\n     *         input\n     * @since 4.5"
        },
        "getFloat": {
          "Javadoc": "* Looks up the given key in the given map, converting the result into a float, using the defaultFunction to produce\n     * the default value if the conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value\n     *         is null, the map is null or the number conversion fails\n     * @since 4.5"
        },
        "getFloatValue": {
          "Javadoc": "* Gets a float from a Map in a null-safe manner, using the default value produced by the defaultFunction if the\n     * conversion fails.\n     * <p>\n     * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails\n     * @return the value in the Map as a float, default value produced by the {@code defaultFunction} if null map\n     *         input\n     * @since 4.5"
        },
        "getInteger": {
          "Javadoc": "* Looks up the given key in the given map, converting the result into an integer, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the\n     *         number conversion fails"
        },
        "getIntValue": {
          "Javadoc": "* Gets an int from a Map in a null-safe manner, using the default value if the conversion fails.\n     * <p>\n     * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultValue return if the value is null or if the conversion fails\n     * @return the value in the Map as an int, {@code defaultValue} if null map input"
        },
        "getLong": {
          "Javadoc": "* Looks up the given key in the given map, converting the result into a long, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the\n     *         number conversion fails"
        },
        "getLongValue": {
          "Javadoc": "* Gets a long from a Map in a null-safe manner, using the default value if the conversion fails.\n     * <p>\n     * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultValue return if the value is null or if the conversion fails\n     * @return the value in the Map as a long, {@code defaultValue} if null map input"
        },
        "getMap": {
          "Javadoc": "* Looks up the given key in the given map, converting the result into a map, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the\n     *         map conversion fails"
        },
        "getNumber": {
          "Javadoc": "* Looks up the given key in the given map, converting the result into a number, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the\n     *         number conversion fails"
        },
        "getObject": {
          "Javadoc": "* Looks up the given key in the given map, converting null into the given default value.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null\n     * @return the value in the map, or defaultValue if the original value is null or the map is null"
        },
        "getShort": {
          "Javadoc": "* Looks up the given key in the given map, converting the result into a short, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the\n     *         number conversion fails"
        },
        "getShortValue": {
          "Javadoc": "* Gets a short from a Map in a null-safe manner, using the default value if the conversion fails.\n     * <p>\n     * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultValue return if the value is null or if the conversion fails\n     * @return the value in the Map as a short, {@code defaultValue} if null map input"
        },
        "getString": {
          "Javadoc": "* Looks up the given key in the given map, converting the result into a string, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a string, or defaultValue if the original value is null, the map is null or the\n     *         string conversion fails"
        },
        "invertMap": {
          "Javadoc": "* Inverts the supplied map returning a new HashMap such that the keys of the input are swapped with the values.\n     * <p>\n     * This operation assumes that the inverse mapping is well defined. If the input map had multiple entries with the\n     * same value mapped to different keys, the returned map will map one of those keys to the value, but the exact key\n     * which will be mapped is undefined.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to invert, must not be null\n     * @return a new HashMap containing the inverted data\n     * @throws NullPointerException if the map is null"
        },
        "isEmpty": {
          "Javadoc": "* Null-safe check if the specified map is empty.\n     * <p>\n     * Null returns true.\n     * </p>\n     *\n     * @param map the map to check, may be null\n     * @return true if empty or null\n     * @since 3.2"
        },
        "isNotEmpty": {
          "Javadoc": "* Null-safe check if the specified map is not empty.\n     * <p>\n     * Null returns false.\n     * </p>\n     *\n     * @param map the map to check, may be null\n     * @return true if non-null and non-empty\n     * @since 3.2"
        },
        "iterableMap": {
          "Javadoc": "* Gets the specified {@link Map} as an {@link IterableMap}.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map to wrap if necessary.\n     * @return IterableMap&lt;K, V&gt;\n     * @throws NullPointerException if map is null\n     * @since 4.0"
        },
        "iterableSortedMap": {
          "Javadoc": "* Gets the specified {@link SortedMap} as an {@link IterableSortedMap}.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param sortedMap to wrap if necessary\n     * @return {@link IterableSortedMap}&lt;K, V&gt;\n     * @throws NullPointerException if sortedMap is null\n     * @since 4.0"
        },
        "lazyMap": {
          "Javadoc": "* Returns a \"lazy\" map whose values will be created on demand.\n     * <p>\n     * When the key passed to the returned map's {@link Map#get(Object)} method is not present in the map, then the\n     * factory will be used to create a new object and that object will become the value associated with that key. The\n     * factory is a {@link Transformer} that will be passed the key which it must transform into the value.\n     * </p>\n     * <p>\n     * For instance:\n     * </p>\n     * <pre>\n     * Transformer factory = new Transformer() {\n     *     public Object transform(Object mapKey) {\n     *         return new File(mapKey);\n     *     }\n     * }\n     * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n     * Object obj = lazyMap.get(\"C:/dev\");\n     * </pre>\n     *\n     * <p>\n     * After the above code is executed, {@code obj} will contain a new {@code File} instance for the C drive\n     * dev directory. Furthermore, that {@code File} instance is the value for the {@code \"C:/dev\"} key in the\n     * map.\n     * </p>\n     * <p>\n     * If a lazy map is wrapped by a synchronized map, the result is a simple synchronized cache. When an object is not\n     * is the cache, the cache itself calls back to the factory Transformer to populate itself, all within the same\n     * synchronized block.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to make lazy, must not be null\n     * @param transformerFactory the factory for creating new objects, must not be null\n     * @return a lazy map backed by the given map\n     * @throws NullPointerException if the Map or Transformer is null"
        },
        "lazySortedMap": {
          "Javadoc": "* Returns a \"lazy\" sorted map whose values will be created on demand.\n     * <p>\n     * When the key passed to the returned map's {@link Map#get(Object)} method is not present in the map, then the\n     * factory will be used to create a new object and that object will become the value associated with that key. The\n     * factory is a {@link Transformer} that will be passed the key which it must transform into the value.\n     * </p>\n     * <p>\n     * For instance:\n     * </p>\n     * <pre>\n     * Transformer factory = new Transformer() {\n     *     public Object transform(Object mapKey) {\n     *         return new File(mapKey);\n     *     }\n     * }\n     * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n     * Object obj = lazy.get(\"C:/dev\");\n     * </pre>\n     * <p>\n     * After the above code is executed, {@code obj} will contain a new {@code File} instance for the C drive\n     * dev directory. Furthermore, that {@code File} instance is the value for the {@code \"C:/dev\"} key in the\n     * map.\n     * </p>\n     * <p>\n     * If a lazy map is wrapped by a synchronized map, the result is a simple synchronized cache. When an object is not\n     * is the cache, the cache itself calls back to the factory Transformer to populate itself, all within the same\n     * synchronized block.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to make lazy, must not be null\n     * @param transformerFactory the factory for creating new objects, must not be null\n     * @return a lazy map backed by the given map\n     * @throws NullPointerException if the Map or Transformer is null"
        },
        "multiValueMap": {
          "Javadoc": "* Creates a multi-value map backed by the given map which returns collections created by the specified collection\n     * factory.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param <C> the collection class type\n     * @param map the map to decorate\n     * @param collectionFactory a factor which creates collection objects\n     * @return a multi-value map backed by the given map which returns collections created by the specified collection\n     *         factory\n     * @see MultiValueMap\n     * @since 3.2\n     * @deprecated since 4.1, use {@link MultiValuedMap} instead"
        },
        "orderedMap": {
          "Javadoc": "* Returns a map that maintains the order of keys that are added backed by the given map.\n     * <p>\n     * If a key is added twice, the order is determined by the first add. The order is observed through the keySet,\n     * values and entrySet.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to order, must not be null\n     * @return an ordered map backed by the given map\n     * @throws NullPointerException if the Map is null"
        },
        "populateMap": {
          "Javadoc": "* Populates a MultiMap using the supplied {@code Transformer} to transform the elements into keys, using the\n     * unaltered element as the value in the {@code MultiMap}.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the {@code MultiMap} to populate.\n     * @param elements the {@code Iterable} to use as input values for the map.\n     * @param keyTransformer the {@code Transformer} used to transform the element into a key value\n     * @throws NullPointerException if the map, elements or transformer are null"
        },
        "predicatedMap": {
          "Javadoc": "* Returns a predicated (validating) map backed by the given map.\n     * <p>\n     * Only objects that pass the tests in the given predicates can be added to the map. Trying to add an invalid object\n     * results in an IllegalArgumentException. Keys must pass the key predicate, values must pass the value predicate.\n     * It is important not to use the original map after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to predicate, must not be null\n     * @param keyPred the predicate for keys, null means no check\n     * @param valuePred the predicate for values, null means no check\n     * @return a predicated map backed by the given map\n     * @throws NullPointerException if the Map is null"
        },
        "predicatedSortedMap": {
          "Javadoc": "* Returns a predicated (validating) sorted map backed by the given map.\n     * <p>\n     * Only objects that pass the tests in the given predicates can be added to the map. Trying to add an invalid object\n     * results in an IllegalArgumentException. Keys must pass the key predicate, values must pass the value predicate.\n     * It is important not to use the original map after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to predicate, must not be null\n     * @param keyPred the predicate for keys, null means no check\n     * @param valuePred the predicate for values, null means no check\n     * @return a predicated map backed by the given map\n     * @throws NullPointerException if the SortedMap is null"
        },
        "printIndent": {
          "Javadoc": "* Writes indentation to the given stream.\n     *\n     * @param out the stream to indent\n     * @param indent the index of the indentation"
        },
        "putAll": {
          "Javadoc": "* Puts all the keys and values from the specified array into the map.\n     * <p>\n     * This method is an alternative to the {@link java.util.Map#putAll(java.util.Map)} method and constructors. It\n     * allows you to build a map from an object array of various possible styles.\n     * </p>\n     * <p>\n     * If the first entry in the object array implements {@link java.util.Map.Entry} or {@link KeyValue} then the key\n     * and value are added from that object. If the first entry in the object array is an object array itself, then it\n     * is assumed that index 0 in the sub-array is the key and index 1 is the value. Otherwise, the array is treated as\n     * keys and values in alternate indices.\n     * </p>\n     * <p>\n     * For example, to create a color map:\n     * </p>\n     * <pre>\n     * Map colorMap = MapUtils.putAll(new HashMap(),\n     *         new String[][] { { \"RED\", \"#FF0000\" }, { \"GREEN\", \"#00FF00\" }, { \"BLUE\", \"#0000FF\" } });\n     * </pre>\n     * <p>\n     * or:\n     * </p>\n     * <pre>\n     * Map colorMap = MapUtils.putAll(new HashMap(),\n     *         new String[] { \"RED\", \"#FF0000\", \"GREEN\", \"#00FF00\", \"BLUE\", \"#0000FF\" });\n     * </pre>\n     * <p>\n     * or:\n     * </p>\n     * <pre>\n     * Map colorMap = MapUtils.putAll(new HashMap(), new Map.Entry[] { new DefaultMapEntry(\"RED\", \"#FF0000\"),\n     *         new DefaultMapEntry(\"GREEN\", \"#00FF00\"), new DefaultMapEntry(\"BLUE\", \"#0000FF\") });\n     * </pre>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to populate, must not be null\n     * @param array an array to populate from, null ignored\n     * @return the input map\n     * @throws NullPointerException if map is null\n     * @throws IllegalArgumentException if sub-array or entry matching used and an entry is invalid\n     * @throws ClassCastException if the array contents is mixed\n     * @since 3.2"
        },
        "safeAddToMap": {
          "Javadoc": "* Protects against adding null values to a map.\n     * <p>\n     * This method checks the value being added to the map, and if it is null it is replaced by an empty string.\n     * </p>\n     * <p>\n     * This could be useful if the map does not accept null values, or for receiving data from a source that may provide\n     * null or empty string which should be held in the same way in the map.\n     * </p>\n     * <p>\n     * Keys are not validated. Note that this method can be used to circumvent the map's value type at runtime.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to add to, must not be null\n     * @param key the key\n     * @param value the value, null converted to \"\"\n     * @throws NullPointerException if the map is null"
        },
        "size": {
          "Javadoc": "* Gets the given map size or 0 if the map is null\n     *\n     * @param map a Map or null\n     * @return the given map size or 0 if the map is null"
        },
        "synchronizedMap": {
          "Javadoc": "* Returns a synchronized map backed by the given map.\n     * <p>\n     * You must manually synchronize on the returned buffer's iterator to avoid non-deterministic behavior:\n     * </p>\n     * <pre>\n     * Map m = MapUtils.synchronizedMap(myMap);\n     * Sets s = m.keySet(); // outside synchronized block\n     * synchronized (m) { // synchronized on MAP!\n     *     Iterator i = s.iterator();\n     *     while (i.hasNext()) {\n     *         process(i.next());\n     *     }\n     * }\n     * </pre>\n     * <p>\n     * This method uses the implementation in {@link java.util.Collections Collections}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to synchronize, must not be null\n     * @return a synchronized map backed by the given map"
        },
        "synchronizedSortedMap": {
          "Javadoc": "* Returns a synchronized sorted map backed by the given sorted map.\n     * <p>\n     * You must manually synchronize on the returned buffer's iterator to avoid non-deterministic behavior:\n     * </p>\n     * <pre>\n     * Map m = MapUtils.synchronizedSortedMap(myMap);\n     * Sets s = m.keySet(); // outside synchronized block\n     * synchronized (m) { // synchronized on MAP!\n     *     Iterator i = s.iterator();\n     *     while (i.hasNext()) {\n     *         process(i.next());\n     *     }\n     * }\n     * </pre>\n     * <p>\n     * This method uses the implementation in {@link java.util.Collections Collections}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to synchronize, must not be null\n     * @return a synchronized map backed by the given map\n     * @throws NullPointerException if the map is null"
        },
        "toMap": {
          "Javadoc": "* Creates a new HashMap using data copied from a ResourceBundle.\n     *\n     * @param resourceBundle the resource bundle to convert, must not be null\n     * @return the HashMap containing the data\n     * @throws NullPointerException if the bundle is null"
        },
        "toProperties": {
          "Javadoc": "* Gets a new Properties object initialized with the values from a Map. A null input will return an empty properties\n     * object.\n     * <p>\n     * A Properties object may only store non-null keys and values, thus if the provided map contains either a key or\n     * value which is {@code null}, a {@link NullPointerException} will be thrown.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to convert to a Properties object\n     * @return the properties object\n     * @throws NullPointerException if a key or value in the provided map is {@code null}"
        },
        "transformedMap": {
          "Javadoc": "* Returns a transformed map backed by the given map.\n     * <p>\n     * This method returns a new map (decorating the specified map) that will transform any new entries added to it.\n     * Existing entries in the specified map will not be transformed. If you want that behavior, see\n     * {@link TransformedMap#transformedMap}.\n     * </p>\n     * <p>\n     * Each object is passed through the transformers as it is added to the Map. It is important not to use the original\n     * map after invoking this method, as it is a backdoor for adding untransformed objects.\n     * </p>\n     * <p>\n     * If there are any elements already in the map being decorated, they are NOT transformed.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to transform, must not be null, typically empty\n     * @param keyTransformer the transformer for the map keys, null means no transformation\n     * @param valueTransformer the transformer for the map values, null means no transformation\n     * @return a transformed map backed by the given map\n     * @throws NullPointerException if the Map is null"
        },
        "transformedSortedMap": {
          "Javadoc": "* Returns a transformed sorted map backed by the given map.\n     * <p>\n     * This method returns a new sorted map (decorating the specified map) that will transform any new entries added to\n     * it. Existing entries in the specified map will not be transformed. If you want that behavior, see\n     * {@link TransformedSortedMap#transformedSortedMap}.\n     * </p>\n     * <p>\n     * Each object is passed through the transformers as it is added to the Map. It is important not to use the original\n     * map after invoking this method, as it is a backdoor for adding untransformed objects.\n     * </p>\n     * <p>\n     * If there are any elements already in the map being decorated, they are NOT transformed.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to transform, must not be null, typically empty\n     * @param keyTransformer the transformer for the map keys, null means no transformation\n     * @param valueTransformer the transformer for the map values, null means no transformation\n     * @return a transformed map backed by the given map\n     * @throws NullPointerException if the SortedMap is null"
        },
        "unmodifiableMap": {
          "Javadoc": "* Returns an unmodifiable map backed by the given map.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to make unmodifiable, must not be null\n     * @return an unmodifiable map backed by the given map\n     * @throws NullPointerException if the map is null"
        },
        "unmodifiableSortedMap": {
          "Javadoc": "* Returns an unmodifiable sorted map backed by the given sorted map.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the sorted map to make unmodifiable, must not be null\n     * @return an unmodifiable map backed by the given map\n     * @throws NullPointerException if the map is null"
        },
        "verbosePrint": {
          "Javadoc": "* Prints the given map with nice line breaks.\n     * <p>\n     * This method prints a nicely formatted String describing the Map. Each map entry will be printed with key and\n     * value. When the value is a Map, recursive behavior occurs.\n     * </p>\n     * <p>\n     * This method is NOT thread-safe in any special way. You must manually synchronize on either this class or the\n     * stream as required.\n     * </p>\n     *\n     * @param out the stream to print to, must not be null\n     * @param label The label to be used, may be {@code null}. If {@code null}, the label is not output. It\n     *        typically represents the name of the property in a bean or similar.\n     * @param map The map to print, may be {@code null}. If {@code null}, the text 'null' is output.\n     * @throws NullPointerException if the stream is {@code null}"
        },
        "verbosePrintInternal": {
          "Javadoc": "* Implementation providing functionality for {@link #debugPrint} and for {@link #verbosePrint}. This prints the\n     * given map with nice line breaks. If the debug flag is true, it additionally prints the type of the object value.\n     * If the contents of a map include the map itself, then the text <em>(this Map)</em> is printed out. If the\n     * contents include a parent container of the map, the text <em>(ancestor[i] Map)</em> is printed, where it actually\n     * indicates the number of levels which must be traversed in the sequential list of ancestors (e.g. father,\n     * grandfather, great-grandfather, etc.).\n     *\n     * @param out the stream to print to\n     * @param label the label to be used, may be {@code null}. If {@code null}, the label is not output. It\n     *        typically represents the name of the property in a bean or similar.\n     * @param map the map to print, may be {@code null}. If {@code null}, the text 'null' is output\n     * @param lineage a stack consisting of any maps in which the previous argument is contained. This is checked to\n     *        avoid infinite recursion when printing the output\n     * @param debug flag indicating whether type names should be output.\n     * @throws NullPointerException if the stream is {@code null}"
        }
      }
    },
    "org.apache.commons.collections4.multimap.AbstractListValuedMap": {
      "Javadoc": "\n * Abstract implementation of the {@link ListValuedMap} interface to simplify\n * the creation of subclass implementations.\n * <p>\n * Subclasses specify a Map implementation to use as the internal storage and\n * the List implementation to use as values.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.1\n ",
      "methods": {
        "createCollection": {
          "Javadoc": "* Creates a new value collection using the provided factory.\n     * @return a new list"
        },
        "get": {
          "Javadoc": "* Gets the list of values associated with the specified key. This would\n     * return an empty list in case the mapping is not present\n     *\n     * @param key  the key to retrieve\n     * @return the {@code List} of values, will return an empty {@link List} for no mapping"
        },
        "remove": {
          "Javadoc": "* Removes all values associated with the specified key.\n     * <p>\n     * A subsequent {@code get(Object)} would return an empty list.\n     *\n     * @param key  the key to remove values from\n     * @return the {@code List} of values removed, will return an empty,\n     *   unmodifiable list for no mapping found."
        }
      }
    },
    "org.apache.commons.collections4.multimap.ValuesListIterator": {
      "Javadoc": " Values ListIterator "
    },
    "org.apache.commons.collections4.multimap.WrappedList": {
      "Javadoc": "\n     * Wrapped list to handle add and remove on the list returned by get(object)\n     "
    },
    "org.apache.commons.collections4.multimap.AbstractMultiValuedMap": {
      "Javadoc": "\n * Abstract implementation of the {@link MultiValuedMap} interface to simplify\n * the creation of subclass implementations.\n * <p>\n * Subclasses specify a Map implementation to use as the internal storage.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.1\n ",
      "methods": {
        "doReadObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     * @param in the input stream\n     * @throws IOException any of the usual I/O related exceptions\n     * @throws ClassNotFoundException if the stream contains an object which class can not be loaded\n     * @throws ClassCastException if the stream does not contain the correct objects"
        },
        "doWriteObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     * @param out the output stream\n     * @throws IOException any of the usual I/O related exceptions"
        },
        "get": {
          "Javadoc": "* Gets the collection of values associated with the specified key. This\n     * would return an empty collection in case the mapping is not present\n     *\n     * @param key the key to retrieve\n     * @return the {@code Collection} of values, will return an empty {@code Collection} for no mapping"
        },
        "getMap": {
          "Javadoc": "* Gets the map being wrapped.\n     *\n     * @return the wrapped map"
        },
        "keys": {
          "Javadoc": "* Returns a {@link MultiSet} view of the key mapping contained in this map.\n     * <p>\n     * Returns a MultiSet of keys with its values count as the count of the MultiSet.\n     * This multiset is backed by the map, so any changes in the map is reflected here.\n     * Any method which modifies this multiset like {@code add}, {@code remove},\n     * {@link Iterator#remove()} etc throws {@code UnsupportedOperationException}.\n     *\n     * @return a bag view of the key mapping contained in this map"
        },
        "put": {
          "Javadoc": "* Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal {@code Map} the previous value is not replaced.\n     * Instead the new value is added to the collection stored against the key.\n     *\n     * @param key the key to store against\n     * @param value the value to add to the collection at the key\n     * @return the value added if the map changed and null if the map did not change"
        },
        "putAll": {
          "Javadoc": "* Copies all of the mappings from the specified MultiValuedMap to this map.\n     * The effect of this call is equivalent to that of calling\n     * {@link #put(Object,Object) put(k, v)} on this map once for each mapping\n     * from key {@code k} to value {@code v} in the specified map. The\n     * behavior of this operation is undefined if the specified map is modified\n     * while the operation is in progress.\n     *\n     * @param map mappings to be stored in this map, may not be null\n     * @return true if the map changed as a result of this operation\n     * @throws NullPointerException if map is null"
        },
        "remove": {
          "Javadoc": "* Removes all values associated with the specified key.\n     * <p>\n     * A subsequent {@code get(Object)} would return an empty collection.\n     *\n     * @param key  the key to remove values from\n     * @return the {@code Collection} of values removed, will return an\n     *   empty, unmodifiable collection for no mapping found"
        },
        "removeMapping": {
          "Javadoc": "* Removes a specific key/value mapping from the multivalued map.\n     * <p>\n     * The value is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, an empty collection would be\n     * returned from a subsequent {@link #get(Object)}.\n     *\n     * @param key the key to remove from\n     * @param value the value to remove\n     * @return true if the mapping was removed, false otherwise"
        },
        "setMap": {
          "Javadoc": "* Sets the map being wrapped.\n     * <p>\n     * <b>NOTE:</b> this method should only be used during deserialization\n     *\n     * @param map the map to wrap"
        },
        "size": {
          "Javadoc": "* {@inheritDoc}\n     * <p>\n     * This implementation does <b>not</b> cache the total size\n     * of the multivalued map, but rather calculates it by iterating\n     * over the entries of the underlying map."
        },
        "values": {
          "Javadoc": "* Gets a collection containing all the values in the map.\n     * <p>\n     * Returns a collection containing all the values from all keys.\n     *\n     * @return a collection view of the values contained in this map"
        }
      }
    },
    "org.apache.commons.collections4.multimap.AsMap": {
      "Javadoc": "\n     * Inner class that provides the AsMap view.\n     "
    },
    "org.apache.commons.collections4.multimap.AsMapEntrySet": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.multimap.AsMapEntrySetIterator": {
      "Javadoc": "\n         * EntrySet iterator for the asMap view.\n         "
    },
    "org.apache.commons.collections4.multimap.EntryValues": {
      "Javadoc": "\n     * Inner class that provides the Entry<K, V> view\n     "
    },
    "org.apache.commons.collections4.multimap.KeysMultiSet": {
      "Javadoc": "\n     * Inner class that provides a MultiSet<K> keys view.\n     "
    },
    "org.apache.commons.collections4.multimap.MapEntryTransformer": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.multimap.MultiValuedMapEntry": {
      "Javadoc": "\n     * Inner class for MultiValuedMap Entries.\n     "
    },
    "org.apache.commons.collections4.multimap.MultiValuedMapIterator": {
      "Javadoc": "\n     * Inner class for MapIterator.\n     "
    },
    "org.apache.commons.collections4.multimap.Values": {
      "Javadoc": "\n     * Inner class that provides the values view.\n     "
    },
    "org.apache.commons.collections4.multimap.ValuesIterator": {
      "Javadoc": "\n     * Inner class that provides the values iterator.\n     "
    },
    "org.apache.commons.collections4.multimap.WrappedCollection": {
      "Javadoc": "\n     * Wrapped collection to handle add and remove on the collection returned\n     * by get(object).\n     * <p>\n     * Currently, the wrapped collection is not cached and has to be retrieved\n     * from the underlying map. This is safe, but not very efficient and\n     * should be improved in subsequent releases. For this purpose, the\n     * scope of this collection is set to package private to simplify later\n     * refactoring.\n     "
    },
    "org.apache.commons.collections4.multimap.AbstractMultiValuedMapDecorator": {
      "Javadoc": "\n * Decorates another {@code MultiValuedMap} to provide additional behavior.\n * <p>\n * Each method call made on this {@code MultiValuedMap} is forwarded to the\n * decorated {@code MultiValuedMap}. This class is used as a framework to build\n * to extensions such as synchronized and unmodifiable behavior.\n * </p>\n *\n * @param <K> the type of key elements\n * @param <V> the type of value elements\n *\n * @since 4.1\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* The decorated multivalued map.\n     *\n     * @return the map to decorate"
        }
      }
    },
    "org.apache.commons.collections4.multimap.AbstractSetValuedMap": {
      "Javadoc": "\n * Abstract implementation of the {@link SetValuedMap} interface to simplify the\n * creation of subclass implementations.\n * <p>\n * Subclasses specify a Map implementation to use as the internal storage and\n * the Set implementation to use as values.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.1\n ",
      "methods": {
        "createCollection": {
          "Javadoc": "* Creates a new value collection using the provided factory.\n     * @return a new set"
        },
        "get": {
          "Javadoc": "* Gets the set of values associated with the specified key. This would\n     * return an empty set in case the mapping is not present\n     *\n     * @param key  the key to retrieve\n     * @return the {@code Set} of values, will return an empty\n     *   {@code Set} for no mapping"
        },
        "remove": {
          "Javadoc": "* Removes all values associated with the specified key.\n     * <p>\n     * A subsequent {@code get(Object)} would return an empty set.\n     *\n     * @param key the key to remove values from\n     * @return the {@code Set} of values removed, will return an empty,\n     *   unmodifiable set for no mapping found."
        }
      }
    },
    "org.apache.commons.collections4.multimap.WrappedSet": {
      "Javadoc": "\n     * Wrapped set to handle add and remove on the collection returned by\n     * {@code get(Object)}.\n     "
    },
    "org.apache.commons.collections4.multimap.ArrayListValuedHashMap": {
      "Javadoc": "\n * Implements a {@code ListValuedMap}, using a {@link HashMap} to provide data\n * storage and {@link ArrayList}s as value collections. This is the standard\n * implementation of a ListValuedMap.\n * <p>\n * <strong>Note that ArrayListValuedHashMap is not synchronized and is not\n * thread-safe.</strong> If you wish to use this map from multiple threads\n * concurrently, you must use appropriate synchronization. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.1\n ",
      "methods": {
        "trimToSize": {
          "Javadoc": "* Trims the capacity of all value collections to their current size."
        }
      }
    },
    "org.apache.commons.collections4.multimap.HashSetValuedHashMap": {
      "Javadoc": "\n * Implements a {@code SetValuedMap}, using a {@link HashMap} to provide data\n * storage and {@link HashSet}s as value collections. This is the standard\n * implementation of a SetValuedMap.\n * <p>\n * <strong>Note that HashSetValuedHashMap is not synchronized and is not\n * thread-safe.</strong> If you wish to use this map from multiple threads\n * concurrently, you must use appropriate synchronization. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.1\n "
    },
    "org.apache.commons.collections4.multimap.TransformedMultiValuedMap": {
      "Javadoc": "\n * Decorates another {@code MultiValuedMap} to transform objects that are added.\n * <p>\n * This class affects the MultiValuedMap put methods. Thus objects must be\n * removed or searched for using their transformed form. For example, if the\n * transformation converts Strings to Integers, you must use the Integer form to\n * remove objects.\n * </p>\n * <p>\n * <strong>Note that TransformedMultiValuedMap is not synchronized and is not thread-safe.</strong>\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.1\n ",
      "methods": {
        "transformedMap": {
          "Javadoc": "* Factory method to create a transforming MultiValuedMap that will\n     * transform existing contents of the specified map.\n     * <p>\n     * If there are any elements already in the map being decorated, they will\n     * be transformed by this method. Contrast this with\n     * {@link #transformingMap(MultiValuedMap, Transformer, Transformer)}.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the MultiValuedMap to decorate, may not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n     * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n     * @return a new transformed MultiValuedMap\n     * @throws NullPointerException if map is null"
        },
        "transformingMap": {
          "Javadoc": "* Factory method to create a transforming MultiValuedMap.\n     * <p>\n     * If there are any elements already in the map being decorated, they are\n     * NOT transformed. Contrast this with\n     * {@link #transformedMap(MultiValuedMap, Transformer, Transformer)}.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the MultiValuedMap to decorate, may not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n     * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n     * @return a new transformed MultiValuedMap\n     * @throws NullPointerException if map is null"
        },
        "transformKey": {
          "Javadoc": "* Transforms a key.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object  the object to transform\n     * @return the transformed object"
        },
        "transformValue": {
          "Javadoc": "* Transforms a value.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object  the object to transform\n     * @return the transformed object"
        }
      }
    },
    "org.apache.commons.collections4.multimap.UnmodifiableMultiValuedMap": {
      "Javadoc": "\n * Decorates another {@link MultiValuedMap} to ensure it can't be altered.\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <K> the type of key elements\n * @param <V> the type of value elements\n *\n * @since 4.1\n ",
      "methods": {
        "unmodifiableMultiValuedMap": {
          "Javadoc": "* Factory method to create an unmodifiable MultiValuedMap.\n     * <p>\n     * If the map passed in is already unmodifiable, it is returned.\n     *\n     * @param <K> the type of key elements\n     * @param <V> the type of value elements\n     * @param map  the map to decorate, may not be null\n     * @return an unmodifiable MultiValuedMap\n     * @throws NullPointerException if map is null"
        }
      }
    },
    "org.apache.commons.collections4.MultiMap": {
      "Javadoc": "\n * Defines a map that holds a collection of values against each key.\n * <p>\n * A {@code MultiMap} is a Map with slightly different semantics.\n * Putting a value into the map will add the value to a Collection at that key.\n * Getting a value will return a Collection, holding all the values put to that key.\n * </p>\n * <p>\n * For example:\n * </p>\n * <pre>\n * MultiMap mhm = new MultiValueMap();\n * mhm.put(key, \"A\");\n * mhm.put(key, \"B\");\n * mhm.put(key, \"C\");\n * Collection coll = (Collection) mhm.get(key);</pre>\n * <p>\n * {@code coll} will be a collection containing \"A\", \"B\", \"C\".\n * </p>\n * <p>\n * NOTE: Additional methods were added to this interface in Commons Collections 3.1.\n * These were added solely for documentation purposes and do not change the interface\n * as they were defined in the superinterface {@code Map} anyway.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n *\n * @since 2.0\n * @deprecated since 4.1, use {@link MultiValuedMap} instead\n ",
      "methods": {
        "containsValue": {
          "Javadoc": "* Checks whether the map contains the value specified.\n     * <p>\n     * Implementations typically check all collections against all keys for the value.\n     * This cannot be mandated due to backwards compatibility of this interface.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     * @throws ClassCastException if the value is of an invalid type\n     * @throws NullPointerException if the value is null and null value are invalid"
        },
        "get": {
          "Javadoc": "* Gets the collection of values associated with the specified key.\n     * <p>\n     * The returned value will implement {@code Collection}. Implementations\n     * are free to declare that they return {@code Collection} subclasses\n     * such as {@code List} or {@code Set}.\n     * <p>\n     * Implementations typically return {@code null} if no values have\n     * been mapped to the key, however the implementation may choose to\n     * return an empty collection.\n     * <p>\n     * Implementations may choose to return a clone of the internal collection.\n     *\n     * @param key  the key to retrieve\n     * @return the {@code Collection} of values, implementations should\n     *  return {@code null} for no mapping, but may return an empty collection\n     * @throws ClassCastException if the key is of an invalid type\n     * @throws NullPointerException if the key is null and null keys are invalid"
        },
        "put": {
          "Javadoc": "* Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal {@code Map} the previous value is not replaced.\n     * Instead, the new value is added to the collection stored against the key.\n     * The collection may be a {@code List}, {@code Set} or other\n     * collection dependent on implementation.\n     *\n     * @param key  the key to store against\n     * @param value  the value to add to the collection at the key\n     * @return typically the value added if the map changed and null if the map did not change\n     * @throws UnsupportedOperationException if the map is unmodifiable\n     * @throws ClassCastException if the key or value is of an invalid type\n     * @throws NullPointerException if the key or value is null and null is invalid\n     * @throws IllegalArgumentException if the key or value is invalid"
        },
        "remove": {
          "Javadoc": "* Removes all values associated with the specified key.\n     * <p>\n     * Implementations typically return {@code null} from a subsequent\n     * {@code get(Object)}, however they may choose to return an empty collection.\n     *\n     * @param key  the key to remove values from\n     * @return the {@code Collection} of values removed, implementations should\n     *  return {@code null} for no mapping found, but may return an empty collection\n     * @throws UnsupportedOperationException if the map is unmodifiable\n     * @throws ClassCastException if the key is of an invalid type\n     * @throws NullPointerException if the key is null and null keys are invalid"
        },
        "removeMapping": {
          "Javadoc": "* Removes a specific value from map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, implementations typically\n     * return {@code null} from a subsequent {@code get(Object)}, however\n     * they may choose to return an empty collection.\n     *\n     * @param key  the key to remove from\n     * @param item  the item to remove\n     * @return {@code true} if the mapping was removed, {@code false} otherwise\n     * @throws UnsupportedOperationException if the map is unmodifiable\n     * @throws ClassCastException if the key or value is of an invalid type\n     * @throws NullPointerException if the key or value is null and null is invalid\n     * @since 4.0 (signature in previous releases: V remove(K, V))"
        },
        "size": {
          "Javadoc": "* Gets the number of keys in this map.\n     * <p>\n     * Implementations typically return only the count of keys in the map\n     * This cannot be mandated due to backwards compatibility of this interface.\n     *\n     * @return the number of key-collection mappings in this map"
        },
        "values": {
          "Javadoc": "* Gets a collection containing all the values in the map.\n     * <p>\n     * Implementations typically return a collection containing the combination\n     * of values from all keys.\n     * This cannot be mandated due to backwards compatibility of this interface.\n     *\n     * @return a collection view of the values contained in this map"
        }
      }
    },
    "org.apache.commons.collections4.MultiMapUtils": {
      "Javadoc": "\n * Provides utility methods and decorators for {@link MultiValuedMap} instances.\n * <p>\n * It contains various type safe and null safe methods. Additionally, it provides\n * the following decorators:\n * </p>\n * <ul>\n *   <li>{@link #unmodifiableMultiValuedMap(MultiValuedMap)}</li>\n *   <li>{@link #transformedMultiValuedMap(MultiValuedMap, Transformer, Transformer)}</li>\n * </ul>\n *\n * @since 4.1\n ",
      "methods": {
        "emptyIfNull": {
          "Javadoc": "* Returns an immutable empty {@code MultiValuedMap} if the argument is\n     * {@code null}, or the argument itself otherwise.\n     *\n     * @param <K> the type of key in the map\n     * @param <V> the type of value in the map\n     * @param map  the map, may be null\n     * @return an empty {@link MultiValuedMap} if the argument is null"
        },
        "emptyMultiValuedMap": {
          "Javadoc": "* Returns immutable EMPTY_MULTI_VALUED_MAP with generic type safety.\n     *\n     * @param <K> the type of key in the map\n     * @param <V> the type of value in the map\n     * @return immutable and empty {@code MultiValuedMap}"
        },
        "getCollection": {
          "Javadoc": "* Gets a Collection from {@code MultiValuedMap} in a null-safe manner.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the {@link MultiValuedMap} to use\n     * @param key  the key to look up\n     * @return the Collection in the {@link MultiValuedMap}, or null if input map is null"
        },
        "getValuesAsBag": {
          "Javadoc": "* Gets a Bag from {@code MultiValuedMap} in a null-safe manner.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the {@link MultiValuedMap} to use\n     * @param key  the key to look up\n     * @return the Collection in the {@link MultiValuedMap} as Bag, or null if input map is null"
        },
        "getValuesAsList": {
          "Javadoc": "* Gets a List from {@code MultiValuedMap} in a null-safe manner.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the {@link MultiValuedMap} to use\n     * @param key  the key to look up\n     * @return the Collection in the {@link MultiValuedMap} as List, or null if input map is null"
        },
        "getValuesAsSet": {
          "Javadoc": "* Gets a Set from {@code MultiValuedMap} in a null-safe manner.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the {@link MultiValuedMap} to use\n     * @param key  the key to look up\n     * @return the Collection in the {@link MultiValuedMap} as Set, or null if input map is null"
        },
        "isEmpty": {
          "Javadoc": "* Null-safe check if the specified {@code MultiValuedMap} is empty.\n     * <p>\n     * If the provided map is null, returns true.\n     *\n     * @param map  the map to check, may be null\n     * @return true if the map is empty or null"
        },
        "newListValuedHashMap": {
          "Javadoc": "* Creates a {@link ListValuedMap} with an {@link java.util.ArrayList ArrayList} as\n     * collection class to store the values mapped to a key.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @return a new {@code ListValuedMap}"
        },
        "newSetValuedHashMap": {
          "Javadoc": "* Creates a {@link SetValuedMap} with an {@link java.util.HashSet HashSet} as\n     * collection class to store the values mapped to a key.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @return a new {@link SetValuedMap}"
        },
        "transformedMultiValuedMap": {
          "Javadoc": "* Returns a {@code TransformedMultiValuedMap} backed by the given map.\n     * <p>\n     * This method returns a new {@code MultiValuedMap} (decorating the\n     * specified map) that will transform any new entries added to it. Existing\n     * entries in the specified map will not be transformed. If you want that\n     * behavior, see {@link TransformedMultiValuedMap#transformedMap}.\n     * <p>\n     * Each object is passed through the transformers as it is added to the Map.\n     * It is important not to use the original map after invoking this method,\n     * as it is a back door for adding untransformed objects.\n     * <p>\n     * If there are any elements already in the map being decorated, they are\n     * NOT transformed.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the {@link MultiValuedMap} to transform, must not be null, typically empty\n     * @param keyTransformer  the transformer for the map keys, null means no transformation\n     * @param valueTransformer  the transformer for the map values, null means no transformation\n     * @return a transformed {@code MultiValuedMap} backed by the given map\n     * @throws NullPointerException if map is null"
        },
        "unmodifiableMultiValuedMap": {
          "Javadoc": "* Returns an {@code UnmodifiableMultiValuedMap} backed by the given\n     * map.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the {@link MultiValuedMap} to decorate, must not be null\n     * @return an unmodifiable {@link MultiValuedMap} backed by the provided map\n     * @throws NullPointerException if map is null"
        }
      }
    },
    "org.apache.commons.collections4.multiset.AbstractMapMultiSet": {
      "Javadoc": "\n * Abstract implementation of the {@link MultiSet} interface to simplify the\n * creation of subclass implementations.\n * <p>\n * Subclasses specify a Map implementation to use as the internal storage. The\n * map will be used to map multiset elements to a number; the number represents the\n * number of occurrences of that element in the multiset.\n * </p>\n *\n * @param <E> the type held in the multiset\n * @since 4.1\n ",
      "methods": {
        "clear": {
          "Javadoc": "* Clears the multiset by clearing the underlying map."
        },
        "contains": {
          "Javadoc": "* Determines if the multiset contains the given element by checking if the\n     * underlying map contains the element as a key.\n     *\n     * @param object the object to search for\n     * @return true if the multiset contains the given element"
        },
        "doReadObject": {
          "Javadoc": "* Read the multiset in using a custom routine.\n     * @param in the input stream\n     * @throws IOException any of the usual I/O related exceptions\n     * @throws ClassNotFoundException if the stream contains an object which class can not be loaded\n     * @throws ClassCastException if the stream does not contain the correct objects"
        },
        "doWriteObject": {
          "Javadoc": "* Write the multiset out using a custom routine.\n     * @param out the output stream\n     * @throws IOException any of the usual I/O related exceptions"
        },
        "getCount": {
          "Javadoc": "* Returns the number of occurrence of the given element in this multiset by\n     * looking up its count in the underlying map.\n     *\n     * @param object the object to search for\n     * @return the number of occurrences of the object, zero if not found"
        },
        "getMap": {
          "Javadoc": "* Utility method for implementations to access the map that backs this multiset.\n     * Not intended for interactive use outside of subclasses.\n     *\n     * @return the map being used by the MultiSet"
        },
        "isEmpty": {
          "Javadoc": "* Returns true if the underlying map is empty.\n     *\n     * @return true if multiset is empty"
        },
        "iterator": {
          "Javadoc": "* Gets an iterator over the multiset elements. Elements present in the\n     * MultiSet more than once will be returned repeatedly.\n     *\n     * @return the iterator"
        },
        "setMap": {
          "Javadoc": "* Sets the map being wrapped.\n     * <p>\n     * <b>NOTE:</b> this method should only be used during deserialization\n     *\n     * @param map the map to wrap"
        },
        "size": {
          "Javadoc": "* Returns the number of elements in this multiset.\n     *\n     * @return current size of the multiset"
        },
        "toArray": {
          "Javadoc": "* Returns an array of all of this multiset's elements.\n     * If the input array has more elements than are in the multiset,\n     * trailing elements will be set to null.\n     *\n     * @param <T> the type of the array elements\n     * @param array the array to populate\n     * @return an array of all of this multiset's elements\n     * @throws ArrayStoreException if the runtime type of the specified array is not\n     *   a supertype of the runtime type of the elements in this list\n     * @throws NullPointerException if the specified array is null"
        }
      }
    },
    "org.apache.commons.collections4.multiset.EntrySetIterator": {
      "Javadoc": "\n     * Inner class EntrySetIterator.\n     "
    },
    "org.apache.commons.collections4.multiset.MapBasedMultiSetIterator": {
      "Javadoc": "\n     * Inner class iterator for the MultiSet.\n     ",
      "methods": {
        "hasNext": {
          "Javadoc": "{@inheritDoc}"
        },
        "next": {
          "Javadoc": "{@inheritDoc}"
        },
        "remove": {
          "Javadoc": "{@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.multiset.MultiSetEntry": {
      "Javadoc": "\n     * Inner class MultiSetEntry.\n     "
    },
    "org.apache.commons.collections4.multiset.MutableInteger": {
      "Javadoc": "\n     * Mutable integer class for storing the data.\n     "
    },
    "org.apache.commons.collections4.multiset.UniqueSetIterator": {
      "Javadoc": "\n     * Inner class UniqueSetIterator.\n     "
    },
    "org.apache.commons.collections4.multiset.AbstractMultiSet": {
      "Javadoc": "\n * Abstract implementation of the {@link MultiSet} interface to simplify the\n * creation of subclass implementations.\n *\n * @param <E> the type held in the multiset\n * @since 4.1\n ",
      "methods": {
        "clear": {
          "Javadoc": "* Clears the multiset removing all elements from the entrySet."
        },
        "contains": {
          "Javadoc": "* Determines if the multiset contains the given element.\n     *\n     * @param object the object to search for\n     * @return true if the multiset contains the given element"
        },
        "createEntrySet": {
          "Javadoc": "* Create a new view for the set of entries in this multiset.\n     *\n     * @return a view of the set of entries"
        },
        "createEntrySetIterator": {
          "Javadoc": "* Creates an entry set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the entrySet iterator"
        },
        "createUniqueSet": {
          "Javadoc": "* Create a new view for the set of unique elements in this multiset.\n     *\n     * @return a view of the set of unique elements"
        },
        "createUniqueSetIterator": {
          "Javadoc": "* Creates a unique set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the uniqueSet iterator"
        },
        "doReadObject": {
          "Javadoc": "* Read the multiset in using a custom routine.\n     * @param in the input stream\n     * @throws IOException any of the usual I/O related exceptions\n     * @throws ClassNotFoundException if the stream contains an object which class can not be loaded\n     * @throws ClassCastException if the stream does not contain the correct objects"
        },
        "doWriteObject": {
          "Javadoc": "* Write the multiset out using a custom routine.\n     * @param out the output stream\n     * @throws IOException any of the usual I/O related exceptions"
        },
        "entrySet": {
          "Javadoc": "* Returns an unmodifiable view of the entries of this multiset.\n     *\n     * @return the set of entries in this multiset"
        },
        "getCount": {
          "Javadoc": "* Returns the number of occurrence of the given element in this multiset by\n     * iterating over its entrySet.\n     *\n     * @param object the object to search for\n     * @return the number of occurrences of the object, zero if not found"
        },
        "iterator": {
          "Javadoc": "* Gets an iterator over the multiset elements. Elements present in the\n     * MultiSet more than once will be returned repeatedly.\n     *\n     * @return the iterator"
        },
        "size": {
          "Javadoc": "* Returns the number of elements in this multiset.\n     *\n     * @return current size of the multiset"
        },
        "toString": {
          "Javadoc": "* Implement a toString() method suitable for debugging.\n     *\n     * @return a debugging toString"
        },
        "uniqueElements": {
          "Javadoc": "* Returns the number of unique elements in this multiset.\n     *\n     * @return the number of unique elements"
        },
        "uniqueSet": {
          "Javadoc": "* Returns a view of the unique elements of this multiset.\n     *\n     * @return the set of unique elements in this multiset"
        }
      }
    },
    "org.apache.commons.collections4.multiset.AbstractEntry": {
      "Javadoc": "\n     * Inner class AbstractEntry.\n     "
    },
    "org.apache.commons.collections4.multiset.EntrySet": {
      "Javadoc": "\n     * Inner class EntrySet.\n     "
    },
    "org.apache.commons.collections4.multiset.MultiSetIterator": {
      "Javadoc": "\n     * Inner class iterator for the MultiSet.\n     ",
      "methods": {
        "hasNext": {
          "Javadoc": "{@inheritDoc}"
        },
        "next": {
          "Javadoc": "{@inheritDoc}"
        },
        "remove": {
          "Javadoc": "{@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.multiset.UniqueSet": {
      "Javadoc": "\n     * Inner class UniqueSet.\n     "
    },
    "org.apache.commons.collections4.multiset.AbstractMultiSetDecorator": {
      "Javadoc": "\n * Decorates another {@code MultiSet} to provide additional behavior.\n * <p>\n * Methods are forwarded directly to the decorated multiset.\n * </p>\n *\n * @param <E> the type held in the multiset\n * @since 4.1\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the multiset being decorated.\n     *\n     * @return the decorated multiset"
        }
      }
    },
    "org.apache.commons.collections4.multiset.HashMultiSet": {
      "Javadoc": "\n * Implements {@code MultiSet}, using a {@link HashMap} to provide the\n * data storage. This is the standard implementation of a multiset.\n * <p>\n * A {@code MultiSet} stores each object in the collection together with a\n * count of occurrences. Extra methods on the interface allow multiple copies\n * of an object to be added or removed at once.\n * </p>\n *\n * @param <E> the type held in the multiset\n * @since 4.1\n ",
      "methods": {
        "readObject": {
          "Javadoc": "* Read the multiset in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "writeObject": {
          "Javadoc": "* Write the multiset out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.multiset.PredicatedMultiSet": {
      "Javadoc": "\n * Decorates another {@link MultiSet} to validate that additions\n * match a specified predicate.\n * <p>\n * This multiset exists to provide validation for the decorated multiset.\n * It is normally created to decorate an empty multiset.\n * If an object cannot be added to the multiset, an {@link IllegalArgumentException}\n * is thrown.\n * </p>\n * <p>\n * One usage would be to ensure that no null entries are added to the multiset.\n * </p>\n * <pre>\n * MultiSet&lt;E&gt; set =\n *      PredicatedMultiSet.predicatedMultiSet(new HashMultiSet&lt;E&gt;(),\n *                                            NotNullPredicate.notNullPredicate());\n * </pre>\n *\n * @param <E> the type held in the multiset\n * @since 4.1\n ",
      "methods": {
        "predicatedMultiSet": {
          "Javadoc": "* Factory method to create a predicated (validating) multiset.\n     * <p>\n     * If there are any elements already in the multiset being decorated, they\n     * are validated.\n     *\n     * @param <E> the type of the elements in the multiset\n     * @param multiset  the multiset to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated MultiSet\n     * @throws NullPointerException if multiset or predicate is null\n     * @throws IllegalArgumentException if the multiset contains invalid elements"
        },
        "decorated": {
          "Javadoc": "* Gets the decorated multiset.\n     *\n     * @return the decorated multiset"
        }
      }
    },
    "org.apache.commons.collections4.multiset.SynchronizedMultiSet": {
      "Javadoc": "\n * Decorates another {@link MultiSet} to synchronize its behavior\n * for a multithreaded environment.\n * <p>\n * Methods are synchronized, then forwarded to the decorated multiset.\n * Iterators must be separately synchronized around the loop.\n * </p>\n *\n * @param <E> the type held in the multiset\n * @since 4.1\n ",
      "methods": {
        "synchronizedMultiSet": {
          "Javadoc": "* Factory method to create a synchronized multiset.\n     *\n     * @param <E> the type of the elements in the multiset\n     * @param multiset  the multiset to decorate, must not be null\n     * @return a new synchronized MultiSet\n     * @throws NullPointerException if multiset is null"
        },
        "decorated": {
          "Javadoc": "* Gets the multiset being decorated.\n     *\n     * @return the decorated multiset"
        }
      }
    },
    "org.apache.commons.collections4.multiset.SynchronizedSet": {
      "Javadoc": "\n     * Synchronized Set for the MultiSet class.\n     "
    },
    "org.apache.commons.collections4.multiset.UnmodifiableMultiSet": {
      "Javadoc": "\n * Decorates another {@link MultiSet} to ensure it can't be altered.\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <E> the type held in the multiset\n * @since 4.1\n ",
      "methods": {
        "unmodifiableMultiSet": {
          "Javadoc": "* Factory method to create an unmodifiable multiset.\n     * <p>\n     * If the multiset passed in is already unmodifiable, it is returned.\n     *\n     * @param <E>  the type of the elements in the multiset\n     * @param multiset  the multiset to decorate, may not be null\n     * @return an unmodifiable MultiSet\n     * @throws NullPointerException if multiset is null"
        },
        "readObject": {
          "Javadoc": "* Read the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @throws ClassCastException if deserialized object has wrong type"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        },
        "writeObject": {
          "Javadoc": "* Write the collection out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.MultiSet": {
      "Javadoc": "\n * Defines a collection that counts the number of times an object appears in\n * the collection.\n * <p>\n * Suppose you have a MultiSet that contains {@code {a, a, b, c}}.\n * Calling {@link #getCount(Object)} on {@code a} would return 2, while\n * calling {@link #uniqueSet()} would return {@code {a, b, c}}.\n * </p>\n *\n * @param <E> the type held in the multiset\n * @since 4.1\n ",
      "methods": {
        "add": {
          "Javadoc": "* Adds a number of occurrences of the specified object to the MultiSet.\n     * <p>\n     * If the object is already in the {@link #uniqueSet()} then increment its\n     * count as reported by {@link #getCount(Object)}. Otherwise, add it to the\n     * {@link #uniqueSet()} and report its count as {@code occurrences}.\n     *\n     * @param object  the object to add\n     * @param occurrences  the number of occurrences to add, may be zero,\n     *   in which case no change is made to the multiset\n     * @return the number of occurrences of the object in the multiset before\n     *   this operation; possibly zero\n     * @throws IllegalArgumentException if occurrences is negative"
        },
        "containsAll": {
          "Javadoc": "* Returns {@code true} if the MultiSet contains at least one\n     * occurrence for each element contained in the given collection.\n     *\n     * @param coll  the collection to check against\n     * @return {@code true} if the MultiSet contains all the collection"
        },
        "entrySet": {
          "Javadoc": "* Returns a {@link Set} of all entries contained in the MultiSet.\n     * <p>\n     * The returned set is backed by this multiset, so any change to either\n     * is immediately reflected in the other.\n     *\n     * @return the Set of MultiSet entries"
        },
        "equals": {
          "Javadoc": "* Compares this MultiSet to another object.\n     * <p>\n     * This MultiSet equals another object if it is also a MultiSet\n     * that contains the same number of occurrences of the same elements.\n     *\n     * @param obj  the object to compare to\n     * @return true if equal"
        },
        "getCount": {
          "Javadoc": "* Returns the number of occurrences of the given object currently\n     * in the MultiSet. If the object does not exist in the multiset,\n     * return 0.\n     *\n     * @param object  the object to search for\n     * @return the number of occurrences of the object, zero if not found"
        },
        "hashCode": {
          "Javadoc": "* Gets a hash code for the MultiSet compatible with the definition of equals.\n     * The hash code is defined as the sum total of a hash code for each element.\n     * The per element hash code is defined as\n     * {@code (e==null ? 0 : e.hashCode()) ^ noOccurrences)}.\n     *\n     * @return the hash code of the MultiSet"
        },
        "iterator": {
          "Javadoc": "* Returns an {@link Iterator} over the entire set of members,\n     * including copies due to cardinality. This iterator is fail-fast\n     * and will not tolerate concurrent modifications.\n     *\n     * @return iterator over all elements in the MultiSet"
        },
        "remove": {
          "Javadoc": "* Removes a number of occurrences of the specified object from the MultiSet.\n     * <p>\n     * If the number of occurrences to remove is greater than the actual number of\n     * occurrences in the multiset, the object will be removed from the multiset.\n     *\n     * @param object  the object to remove\n     * @param occurrences  the number of occurrences to remove, may be zero,\n     *   in which case no change is made to the multiset\n     * @return the number of occurrences of the object in the multiset\n     *   before the operation; possibly zero\n     * @throws IllegalArgumentException if occurrences is negative"
        },
        "removeAll": {
          "Javadoc": "* Remove all occurrences of all elements from this MultiSet represented\n     * in the given collection.\n     *\n     * @param coll  the collection of elements to remove\n     * @return {@code true} if this call changed the multiset"
        },
        "retainAll": {
          "Javadoc": "* Remove any elements of this MultiSet that are not contained in the\n     * given collection.\n     *\n     * @param coll  the collection of elements to retain\n     * @return {@code true} if this call changed the multiset"
        },
        "setCount": {
          "Javadoc": "* Sets the number of occurrences of the specified object in the MultiSet\n     * to the given count.\n     * <p>\n     * If the provided count is zero, the object will be removed from the\n     * {@link #uniqueSet()}.\n     *\n     * @param object  the object to update\n     * @param count  the number of occurrences of the object\n     * @return the number of occurrences of the object before this operation, zero\n     *   if the object was not contained in the multiset\n     * @throws IllegalArgumentException if count is negative"
        },
        "size": {
          "Javadoc": "* Returns the total number of items in the MultiSet.\n     *\n     * @return the total size of the multiset"
        },
        "uniqueSet": {
          "Javadoc": "* Returns a {@link Set} of unique elements in the MultiSet.\n     * <p>\n     * Uniqueness constraints are the same as those in {@link java.util.Set}.\n     * <p>\n     * The returned set is backed by this multiset, so any change to either\n     * is immediately reflected in the other. Only removal operations are\n     * supported, in which case all occurrences of the element are removed\n     * from the backing multiset.\n     *\n     * @return the Set of unique MultiSet elements"
        }
      }
    },
    "org.apache.commons.collections4.Entry": {
      "Javadoc": "\n     * An unmodifiable entry for an element and its occurrence as contained in a MultiSet.\n     * <p>\n     * The {@link MultiSet#entrySet()} method returns a view of the multiset whose elements\n     * implement this interface.\n     *\n     * @param <E>  the element type\n     ",
      "methods": {
        "equals": {
          "Javadoc": "* Compares the specified object with this entry for equality.\n         * Returns true if the given object is also a multiset entry\n         * and the two entries represent the same element with the same\n         * number of occurrences.\n         * <p>\n         * More formally, two entries {@code e1} and {@code e2} represent\n         * the same mapping if\n         * <pre>\n         *     (e1.getElement()==null ? e2.getElement()==null\n         *                            : e1.getElement().equals(e2.getElement())) &amp;&amp;\n         *     (e1.getCount()==e2.getCount())\n         * </pre>\n         *\n         * @param o object to be compared for equality with this multiset entry\n         * @return true if the specified object is equal to this multiset entry"
        },
        "getCount": {
          "Javadoc": "* Returns the number of occurrences for the element of this entry.\n         *\n         * @return the number of occurrences of the element"
        },
        "getElement": {
          "Javadoc": "* Returns the element corresponding to this entry.\n         *\n         * @return the element corresponding to this entry"
        },
        "hashCode": {
          "Javadoc": "* Returns the hash code value for this multiset entry.\n         * <p>\n         * The hash code of a multiset entry {@code e} is defined to be:\n         * <pre>\n         *      (e==null ? 0 : e.hashCode()) ^ noOccurrences)\n         * </pre>\n         *\n         * @return the hash code value for this multiset entry"
        }
      }
    },
    "org.apache.commons.collections4.MultiSetUtils": {
      "Javadoc": "\n * Provides utility methods and decorators for {@link MultiSet} instances.\n *\n * @since 4.1\n ",
      "methods": {
        "emptyMultiSet": {
          "Javadoc": "* Gets an empty {@code MultiSet}.\n     *\n     * @param <E> the element type\n     * @return an empty MultiSet"
        },
        "predicatedMultiSet": {
          "Javadoc": "* Returns a predicated (validating) multiset backed by the given multiset.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the multiset. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original multiset\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param multiset the multiset to predicate, must not be null\n     * @param predicate the predicate for the multiset, must not be null\n     * @return a predicated multiset backed by the given multiset\n     * @throws NullPointerException if the MultiSet or Predicate is null"
        },
        "synchronizedMultiSet": {
          "Javadoc": "* Returns a synchronized (thread-safe) multiset backed by the given multiset.\n     * In order to guarantee serial access, it is critical that all access to the\n     * backing multiset is accomplished through the returned multiset.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned multiset\n     * when iterating over it:\n     *\n     * <pre>\n     * MultiSet multiset = MultiSetUtils.synchronizedMultiSet(new HashMultiSet());\n     * ...\n     * synchronized(multiset) {\n     *     Iterator i = multiset.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param multiset the multiset to synchronize, must not be null\n     * @return a synchronized multiset backed by that multiset\n     * @throws NullPointerException if the MultiSet is null"
        },
        "unmodifiableMultiSet": {
          "Javadoc": "* Returns an unmodifiable view of the given multiset. Any modification attempts\n     * to the returned multiset will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param multiset the multiset whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that multiset\n     * @throws NullPointerException if the MultiSet is null"
        }
      }
    },
    "org.apache.commons.collections4.MultiValuedMap": {
      "Javadoc": "\n * Defines a map that holds a collection of values against each key.\n * <p>\n * A {@code MultiValuedMap} is a Map with slightly different semantics:\n * </p>\n * <ul>\n *   <li>Putting a value into the map will add the value to a {@link Collection} at that key.</li>\n *   <li>Getting a value will return a {@link Collection}, holding all the values put to that key.</li>\n * </ul>\n * <p>\n * For example:\n * </p>\n * <pre>{@code\n * MultiValuedMap<Integer, String> map = new ArrayListValuedHashMap<>();\n * map.put(1, \"A\");\n * map.put(1, \"B\");\n * map.put(1, \"C\");\n * Collection<String> coll = map.get(1);\n * }</pre>\n * <p>\n * {@code coll} will be a collection containing \"A\", \"B\", \"C\".\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.1\n ",
      "methods": {
        "asMap": {
          "Javadoc": "* Returns a view of this multivalued map as a {@code Map} from each distinct\n     * key to the non-empty collection of that key's associated values.\n     * <p>\n     * Note that {@code this.asMap().get(k)} is equivalent to {@code this.get(k)}\n     * only when {@code k} is a key contained in the multivalued map; otherwise it\n     * returns {@code null} as opposed to an empty collection.\n     * </p>\n     * <p>\n     * Changes to the returned map or the collections that serve as its values\n     * will update the underlying multivalued map, and vice versa. The map does\n     * not support {@code put} or {@code putAll}, nor do its entries support\n     * {@link java.util.Map.Entry#setValue(Object) setValue}.\n     * </p>\n     *\n     * @return a map view of the mappings in this multivalued map"
        },
        "clear": {
          "Javadoc": "* Removes all of the mappings from this map (optional operation).\n     * <p>\n     * The map will be empty after this call returns.\n     * </p>\n     *\n     * @throws UnsupportedOperationException if the map is unmodifiable"
        },
        "containsKey": {
          "Javadoc": "* Returns {@code true} if this map contains a mapping for the specified\n     * key. More formally, returns {@code true} if and only if this map contains\n     * a mapping for a key {@code k} such that {@code (key==null ? k==null : key.equals(k))}.\n     * (There can be at most one such mapping.)\n     *\n     * @param key  key whose presence in this map is to be tested\n     * @return true if this map contains a mapping for the specified key\n     * @throws NullPointerException if the specified key is null and this map\n     *   does not permit null keys (optional)"
        },
        "containsMapping": {
          "Javadoc": "* Checks whether the map contains a mapping for the specified key and value.\n     *\n     * @param key  the key to search for\n     * @param value  the value to search for\n     * @return true if the map contains the value"
        },
        "containsValue": {
          "Javadoc": "* Checks whether the map contains at least one mapping for the specified value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     * @throws NullPointerException if the value is null and null values are not supported\n     *   by the used collection types (optional)"
        },
        "entries": {
          "Javadoc": "* Returns a {@link Collection} view of the mappings contained in this multivalued map.\n     * <p>\n     * The collection is backed by the map, so changes to the map are reflected\n     * in the collection, and vice-versa.\n     * </p>\n     *\n     * @return a set view of the mappings contained in this map"
        },
        "get": {
          "Javadoc": "* Returns a view collection of the values associated with the specified key.\n     * <p>\n     * This method will return an <b>empty</b> collection if {@link #containsKey(Object)}\n     * returns {@code false}. Changes to the returned collection will update the underlying\n     * {@code MultiValuedMap} and vice-versa.\n     * </p>\n     *\n     * @param key  the key to retrieve\n     * @return the {@code Collection} of values, implementations should\n     *   return an empty collection for no mapping\n     * @throws NullPointerException if the key is null and null keys are invalid (optional)"
        },
        "isEmpty": {
          "Javadoc": "* Returns {@code true} if this map contains no key-value mappings.\n     *\n     * @return {@code true} if this map contains no key-value mappings"
        },
        "keys": {
          "Javadoc": "* Returns a {@link MultiSet} view of the keys contained in this multivalued map.\n     * <p>\n     * The {@link MultiSet#getCount(Object)} method of the returned multiset will give\n     * the same result a calling {@code get(Object).size()} for the same key.\n     * </p>\n     * <p>\n     * This multiset is backed by the map, so any changes in the map are reflected in\n     * the multiset.\n     * </p>\n     *\n     * @return a multiset view of the keys contained in this map"
        },
        "keySet": {
          "Javadoc": "* Returns a {@link Set} view of the keys contained in this multivalued map.\n     * <p>\n     * The set is backed by the map, so changes to the map are reflected\n     * in the set, and vice-versa.\n     * </p>\n     * <p>\n     * If the map is modified while an iteration over the set is in\n     * progress (except through the iterator's own {@code remove} operation),\n     * the result of the iteration is undefined. The set supports element\n     * removal, which removes the corresponding mapping from the map, via the\n     * {@code Iterator.remove}, {@code Set.remove}, {@code removeAll},\n     * {@code retainAll}, and {@code clear} operations. It does not support\n     * the {@code add} or {@code addAll} operations.\n     * </p>\n     *\n     * @return a set view of the keys contained in this map"
        },
        "mapIterator": {
          "Javadoc": "* Obtains a {@code MapIterator} over this multivalued map.\n     * <p>\n     * A map iterator is an efficient way of iterating over maps. There is no\n     * need to access the entries collection or use {@code Map.Entry} objects.\n     * </p>\n     *\n     * @return a map iterator"
        },
        "put": {
          "Javadoc": "* Adds a key-value mapping to this multivalued map.\n     * <p>\n     * Unlike a normal {@code Map} the previous value is not replaced.\n     * Instead, the new value is added to the collection stored against the key.\n     * Depending on the collection type used, duplicate key-value mappings may\n     * be allowed.\n     * </p>\n     * <p>\n     * The method will return {@code true} if the size of the multivalued map\n     * has been increased because of this operation.\n     * </p>\n     *\n     * @param key  the key to store against\n     * @param value  the value to add to the collection at the key\n     * @return true if the map changed as a result of this put operation, or false\n     *   if the map already contained the key-value mapping and the collection\n     *   type does not allow duplicate values, e.g. when using a Set\n     * @throws UnsupportedOperationException if the put operation is not supported by\n     *   this multivalued map, e.g. if it is unmodifiable\n     * @throws NullPointerException if the key or value is null and null is invalid (optional)\n     * @throws IllegalArgumentException if some aspect of the specified key or value prevents\n     *   it from being stored in this multivalued map"
        },
        "putAll": {
          "Javadoc": "* Copies all mappings from the specified map to this multivalued map\n     * (optional operation).\n     * <p>\n     * The effect of this call is equivalent to that of calling\n     * {@link #put(Object,Object) put(k, v)} on this map once for each\n     * mapping from key {@code k} to value {@code v} in the specified map.\n     * </p>\n     * <p>\n     * The behavior of this operation is undefined if the specified map is modified\n     * while the operation is in progress.\n     * </p>\n     *\n     * @param map  mappings to be stored in this map, may not be null\n     * @return true if the map changed as a result of this operation\n     * @throws UnsupportedOperationException if the {@code putAll} operation is\n     *   not supported by this map\n     * @throws NullPointerException if the specified map is null, or if this map\n     *   does not permit null keys or values, and the specified map\n     *   contains null keys or values (optional)\n     * @throws IllegalArgumentException if some property of a key or value in\n     *   the specified map prevents it from being stored in this map"
        },
        "remove": {
          "Javadoc": "* Removes all values associated with the specified key.\n     * <p>\n     * The returned collection <i>may</i> be modifiable, but updates will not be propagated\n     * to this multivalued map. In case no mapping was stored for the specified\n     * key, an empty, unmodifiable collection will be returned.\n     * </p>\n     *\n     * @param key  the key to remove values from\n     * @return the values that were removed\n     * @throws UnsupportedOperationException if the map is unmodifiable\n     * @throws NullPointerException if the key is null and null keys are invalid (optional)"
        },
        "removeMapping": {
          "Javadoc": "* Removes a key-value mapping from the map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * </p>\n     * <p>\n     * If the last value for a key is removed, implementations typically return\n     * an empty collection from a subsequent {@code get(Object)}.\n     * </p>\n     *\n     * @param key  the key to remove from\n     * @param item  the item to remove\n     * @return true if the mapping was removed, false otherwise\n     * @throws UnsupportedOperationException if the map is unmodifiable\n     * @throws NullPointerException if the key or value is null and null is invalid (optional)"
        },
        "size": {
          "Javadoc": "* Gets the total size of the map.\n     * <p>\n     * Implementations would return the total size of the map which is the count\n     * of the values from all keys.\n     * </p>\n     *\n     * @return the total size of the map"
        },
        "values": {
          "Javadoc": "* Gets a {@link Collection} view of all values contained in this multivalued map.\n     * <p>\n     * Implementations typically return a collection containing the combination\n     * of values from all keys.\n     * </p>\n     *\n     * @return a collection view of the values contained in this multivalued map"
        }
      }
    },
    "org.apache.commons.collections4.OrderedBidiMap": {
      "Javadoc": "\n * Defines a map that allows bidirectional lookup between key and values\n * and retains and provides access to an ordering.\n * <p>\n * Implementations should allow a value to be looked up from a key and\n * a key to be looked up from a value with equal performance.\n * </p>\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n *\n * @since 3.0\n ",
      "methods": {
        "inverseBidiMap": {
          "Javadoc": "* Gets a view of this map where the keys and values are reversed.\n     * <p>\n     * Changes to one map will be visible in the other and vice versa.\n     * This enables both directions of the map to be accessed equally.\n     * <p>\n     * Implementations should seek to avoid creating a new object every time this\n     * method is called. See {@code AbstractMap.values()} etc. Calling this\n     * method on the inverse map should return the original.\n     * <p>\n     * Implementations must return an {@code OrderedBidiMap} instance,\n     * usually by forwarding to {@code inverseOrderedBidiMap()}.\n     *\n     * @return an inverted bidirectional map"
        }
      }
    },
    "org.apache.commons.collections4.OrderedIterator": {
      "Javadoc": "\n * Defines an iterator that operates over an ordered container. Subset of {@link java.util.ListIterator}.\n * <p>\n * This iterator allows both forward and reverse iteration through the container.\n * </p>\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 3.0\n ",
      "methods": {
        "hasPrevious": {
          "Javadoc": "* Checks to see if there is a previous element that can be iterated to.\n     *\n     * @return {@code true} if the iterator has a previous element"
        },
        "previous": {
          "Javadoc": "* Gets the previous element from the container.\n     *\n     * @return the previous element in the iteration\n     * @throws java.util.NoSuchElementException if the iteration is finished"
        }
      }
    },
    "org.apache.commons.collections4.OrderedMap": {
      "Javadoc": "\n * Defines a map that maintains order and allows both forward and backward\n * iteration through that order.\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n *\n * @since 3.0\n ",
      "methods": {
        "firstKey": {
          "Javadoc": "* Gets the first key currently in this map.\n     *\n     * @return the first key currently in this map\n     * @throws java.util.NoSuchElementException if this map is empty"
        },
        "lastKey": {
          "Javadoc": "* Gets the last key currently in this map.\n     *\n     * @return the last key currently in this map\n     * @throws java.util.NoSuchElementException if this map is empty"
        },
        "mapIterator": {
          "Javadoc": "* Obtains an {@code OrderedMapIterator} over the map.\n     * <p>\n     * An ordered map iterator is an efficient way of iterating over maps\n     * in both directions.\n     *\n     * @return a map iterator"
        },
        "nextKey": {
          "Javadoc": "* Gets the next key after the one specified.\n     *\n     * @param key  the key to search for next from\n     * @return the next key, null if no match or at end"
        },
        "previousKey": {
          "Javadoc": "* Gets the previous key before the one specified.\n     *\n     * @param key  the key to search for previous from\n     * @return the previous key, null if no match or at start"
        }
      }
    },
    "org.apache.commons.collections4.OrderedMapIterator": {
      "Javadoc": "\n * Defines an iterator that operates over an ordered {@code Map}.\n * <p>\n * This iterator allows both forward and reverse iteration through the map.\n * </p>\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n * @since 3.0\n ",
      "methods": {
        "hasPrevious": {
          "Javadoc": "* Checks to see if there is a previous entry that can be iterated to.\n     *\n     * @return {@code true} if the iterator has a previous element"
        },
        "previous": {
          "Javadoc": "* Gets the previous <em>key</em> from the {@code Map}.\n     *\n     * @return the previous key in the iteration\n     * @throws java.util.NoSuchElementException if the iteration is finished"
        }
      }
    },
    "org.apache.commons.collections4.Predicate": {
      "Javadoc": "\n * Defines a functor interface implemented by classes that perform a predicate\n * test on an object.\n * <p>\n * A {@code Predicate} is the object equivalent of an {@code if} statement.\n * It uses the input object to return a true or false value, and is often used in\n * validation or filtering.\n * </p>\n * <p>\n * Standard implementations of common predicates are provided by\n * {@link PredicateUtils}. These include true, false, instanceof, equals, and,\n * or, not, method invocation and null testing.\n * </p>\n *\n * @param <T> the type that the predicate queries\n *\n * @since 1.0\n ",
      "methods": {
        "evaluate": {
          "Javadoc": "* Use the specified parameter to perform a test that returns true or false.\n     *\n     * @param object  the object to evaluate, should not be changed\n     * @return true or false\n     * @throws ClassCastException (runtime) if the input is the wrong class\n     * @throws IllegalArgumentException (runtime) if the input is invalid\n     * @throws FunctorException (runtime) if the predicate encounters a problem"
        }
      }
    },
    "org.apache.commons.collections4.PredicateUtils": {
      "Javadoc": "\n * {@code PredicateUtils} provides reference implementations and utilities\n * for the Predicate functor interface. The supplied predicates are:\n * <ul>\n * <li>Invoker - returns the result of a method call on the input object\n * <li>InstanceOf - true if the object is an instanceof a class\n * <li>Equal - true if the object equals() a specified object\n * <li>Identity - true if the object == a specified object\n * <li>Null - true if the object is null\n * <li>NotNull - true if the object is not null\n * <li>Unique - true if the object has not already been evaluated\n * <li>And/All - true if all of the predicates are true\n * <li>Or/Any - true if any of the predicates is true\n * <li>Either/One - true if only one of the predicate is true\n * <li>Neither/None - true if none of the predicates are true\n * <li>Not - true if the predicate is false, and vice versa\n * <li>Transformer - wraps a Transformer as a Predicate\n * <li>True - always return true\n * <li>False - always return false\n * <li>Exception - always throws an exception\n * <li>NullIsException/NullIsFalse/NullIsTrue - check for null input\n * <li>Transformed - transforms the input before calling the predicate\n * </ul>\n * All the supplied predicates are Serializable.\n *\n * @since 3.0\n ",
      "methods": {
        "allPredicate": {
          "Javadoc": "* Create a new Predicate that returns true only if all of the specified\n     * predicates are true.\n     * If the array of predicates is empty, then this predicate returns true.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicates  an array of predicates to check, may not be null\n     * @return the {@code all} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     * @see AllPredicate"
        },
        "andPredicate": {
          "Javadoc": "* Create a new Predicate that returns true only if both of the specified\n     * predicates are true.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate1  the first predicate, may not be null\n     * @param predicate2  the second predicate, may not be null\n     * @return the {@code and} predicate\n     * @throws NullPointerException if either predicate is null\n     * @see AndPredicate"
        },
        "anyPredicate": {
          "Javadoc": "* Create a new Predicate that returns true if any of the specified\n     * predicates are true.\n     * If the array of predicates is empty, then this predicate returns false.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicates  an array of predicates to check, may not be null\n     * @return the {@code any} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     * @see AnyPredicate"
        },
        "asPredicate": {
          "Javadoc": "* Create a new Predicate that wraps a Transformer. The Transformer must\n     * return either {@link Boolean#TRUE} or {@link Boolean#FALSE} otherwise a\n     * PredicateException will be thrown.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param transformer  the transformer to wrap, may not be null\n     * @return the transformer wrapping predicate\n     * @throws NullPointerException if the transformer is null\n     * @see TransformerPredicate"
        },
        "eitherPredicate": {
          "Javadoc": "* Create a new Predicate that returns true if one, but not both, of the\n     * specified predicates are true. XOR\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate1  the first predicate, may not be null\n     * @param predicate2  the second predicate, may not be null\n     * @return the {@code either} predicate\n     * @throws NullPointerException if either predicate is null\n     * @see OnePredicate"
        },
        "equalPredicate": {
          "Javadoc": "* Creates a Predicate that checks if the input object is equal to the\n     * specified object using equals().\n     *\n     * @param <T>  the type that the predicate queries\n     * @param value  the value to compare against\n     * @return the predicate\n     * @see EqualPredicate"
        },
        "exceptionPredicate": {
          "Javadoc": "* Gets a Predicate that always throws an exception.\n     * This could be useful during testing as a placeholder.\n     *\n     * @param <T>  the type that the predicate queries\n     * @return the predicate\n     * @see ExceptionPredicate"
        },
        "falsePredicate": {
          "Javadoc": "* Gets a Predicate that always returns false.\n     *\n     * @param <T>  the type that the predicate queries\n     * @return the predicate\n     * @see FalsePredicate"
        },
        "identityPredicate": {
          "Javadoc": "* Creates a Predicate that checks if the input object is equal to the\n     * specified object by identity.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param value  the value to compare against\n     * @return the predicate\n     * @see IdentityPredicate"
        },
        "instanceofPredicate": {
          "Javadoc": "* Creates a Predicate that checks if the object passed in is of\n     * a particular type, using instanceof. A {@code null} input\n     * object will return {@code false}.\n     *\n     * @param type  the type to check for, may not be null\n     * @return the predicate\n     * @throws NullPointerException if the class is null\n     * @see InstanceofPredicate"
        },
        "invokerPredicate": {
          "Javadoc": "* Creates a Predicate that invokes a method on the input object.\n     * The method must return either a boolean or a non-null Boolean,\n     * and have no parameters. If the input object is null, a\n     * PredicateException is thrown.\n     * <p>\n     * For example, {@code PredicateUtils.invokerPredicate(\"isEmpty\");}\n     * will call the {@code isEmpty} method on the input object to\n     * determine the predicate result.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param methodName  the method name to call on the input object, may not be null\n     * @param paramTypes  the parameter types\n     * @param args  the arguments\n     * @return the predicate\n     * @throws NullPointerException if the method name is null\n     * @throws IllegalArgumentException if the paramTypes and args don't match\n     * @see InvokerTransformer\n     * @see TransformerPredicate"
        },
        "neitherPredicate": {
          "Javadoc": "* Create a new Predicate that returns true if neither of the specified\n     * predicates are true.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate1  the first predicate, may not be null\n     * @param predicate2  the second predicate, may not be null\n     * @return the {@code neither} predicate\n     * @throws NullPointerException if either predicate is null\n     * @see NonePredicate"
        },
        "nonePredicate": {
          "Javadoc": "* Create a new Predicate that returns true if none of the specified\n     * predicates are true.\n     * If the array of predicates is empty, then this predicate returns true.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicates  an array of predicates to check, may not be null\n     * @return the {@code none} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     * @see NonePredicate"
        },
        "notNullPredicate": {
          "Javadoc": "* Gets a Predicate that checks if the input object passed in is not null.\n     *\n     * @param <T>  the type that the predicate queries\n     * @return the predicate\n     * @see NotNullPredicate"
        },
        "notPredicate": {
          "Javadoc": "* Create a new Predicate that returns true if the specified predicate\n     * returns false and vice versa.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate  the predicate to not\n     * @return the {@code not} predicate\n     * @throws NullPointerException if the predicate is null\n     * @see NotPredicate"
        },
        "nullIsExceptionPredicate": {
          "Javadoc": "* Gets a Predicate that throws an exception if the input object is null,\n     * otherwise it calls the specified Predicate. This allows null handling\n     * behavior to be added to Predicates that don't support nulls.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate  the predicate to wrap, may not be null\n     * @return the predicate\n     * @throws NullPointerException if the predicate is null.\n     * @see NullIsExceptionPredicate"
        },
        "nullIsFalsePredicate": {
          "Javadoc": "* Gets a Predicate that returns false if the input object is null, otherwise\n     * it calls the specified Predicate. This allows null handling behavior to\n     * be added to Predicates that don't support nulls.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate  the predicate to wrap, may not be null\n     * @return the predicate\n     * @throws NullPointerException if the predicate is null.\n     * @see NullIsFalsePredicate"
        },
        "nullIsTruePredicate": {
          "Javadoc": "* Gets a Predicate that returns true if the input object is null, otherwise\n     * it calls the specified Predicate. This allows null handling behavior to\n     * be added to Predicates that don't support nulls.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate  the predicate to wrap, may not be null\n     * @return the predicate\n     * @throws NullPointerException if the predicate is null.\n     * @see NullIsTruePredicate"
        },
        "nullPredicate": {
          "Javadoc": "* Gets a Predicate that checks if the input object passed in is null.\n     *\n     * @param <T>  the type that the predicate queries\n     * @return the predicate\n     * @see NullPredicate"
        },
        "onePredicate": {
          "Javadoc": "* Create a new Predicate that returns true if only one of the specified\n     * predicates are true.\n     * If the array of predicates is empty, then this predicate returns false.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicates  an array of predicates to check, may not be null\n     * @return the {@code one} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     * @see OnePredicate"
        },
        "orPredicate": {
          "Javadoc": "* Create a new Predicate that returns true if either of the specified\n     * predicates are true.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate1  the first predicate, may not be null\n     * @param predicate2  the second predicate, may not be null\n     * @return the {@code or} predicate\n     * @throws NullPointerException if either predicate is null\n     * @see OrPredicate"
        },
        "transformedPredicate": {
          "Javadoc": "* Creates a predicate that transforms the input object before passing it\n     * to the predicate.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param transformer  the transformer to call first\n     * @param predicate  the predicate to call with the result of the transform\n     * @return the predicate\n     * @throws NullPointerException if the transformer or the predicate is null\n     * @see TransformedPredicate\n     * @since 3.1"
        },
        "truePredicate": {
          "Javadoc": "* Gets a Predicate that always returns true.\n     *\n     * @param <T>  the type that the predicate queries\n     * @return the predicate\n     * @see TruePredicate"
        },
        "uniquePredicate": {
          "Javadoc": "* Creates a Predicate that returns true the first time an object is\n     * encountered, and false if the same object is received\n     * again. The comparison is by equals(). A {@code null} input object\n     * is accepted and will return true the first time, and false subsequently\n     * as well.\n     *\n     * @param <T>  the type that the predicate queries\n     * @return the predicate\n     * @see UniquePredicate"
        }
      }
    },
    "org.apache.commons.collections4.properties.AbstractPropertiesFactory": {
      "Javadoc": "\n * Subclasses create and load {@link Properties} and subclasses of {@link Properties} like {@link SortedProperties}.\n *\n * @param <T> {@link Properties} or a subclass like {@link SortedProperties}.\n * @see Properties\n * @since 4.4\n ",
      "methods": {
        "createProperties": {
          "Javadoc": "* Subclasses override to provide customized properties instances.\n     *\n     * @return a new Properties instance."
        },
        "load": {
          "Javadoc": "* Creates and loads properties from the given URL.\n     *\n     * @param url the location of the properties file.\n     * @return a new properties object.\n     * @throws IOException              Thrown if an error occurred reading the input stream.\n     * @throws IllegalArgumentException Thrown if the input contains a malformed Unicode escape sequence."
        }
      }
    },
    "org.apache.commons.collections4.properties.OrderedProperties": {
      "Javadoc": "\n * A drop-in replacement for {@link Properties} for ordered keys.\n * <p>\n * Overrides methods to keep keys in insertion order. Allows other methods in the superclass to work with ordered keys.\n * </p>\n *\n * @see OrderedPropertiesFactory#INSTANCE\n * @since 4.5\n "
    },
    "org.apache.commons.collections4.properties.OrderedPropertiesFactory": {
      "Javadoc": "\n * Creates and loads {@link OrderedProperties}.\n *\n * @see OrderedProperties\n * @since 4.5\n ",
      "methods": {
        "createProperties": {
          "Javadoc": "* Subclasses override to provide customized properties instances.\n     *\n     * @return a new Properties instance."
        }
      }
    },
    "org.apache.commons.collections4.properties.PropertiesFactory": {
      "Javadoc": "\n * Creates and loads {@link Properties}.\n *\n * @see Properties\n * @since 4.4\n ",
      "methods": {
        "createProperties": {
          "Javadoc": "* Subclasses override to provide customized properties instances.\n     *\n     * @return a new Properties instance."
        }
      }
    },
    "org.apache.commons.collections4.properties.EmptyProperties": {
      "Javadoc": "",
      "methods": {
        "load": {
          "Javadoc": "* Throws {@link UnsupportedOperationException}.\n         * Caller should use try-with-resources statement."
        },
        "loadFromXML": {
          "Javadoc": "* Throws {@link UnsupportedOperationException}.\n         * Caller should use try-with-resources statement."
        }
      }
    },
    "org.apache.commons.collections4.properties.SortedProperties": {
      "Javadoc": "\n * A drop-in replacement for {@link Properties} for sorting keys.\n * <p>\n * Overrides {@link Properties#keys()} to sort keys. Allows other methods on the superclass to work with sorted keys.\n * </p>\n *\n * @see SortedPropertiesFactory#INSTANCE\n * @since 4.2\n "
    },
    "org.apache.commons.collections4.properties.SortedPropertiesFactory": {
      "Javadoc": "\n * Creates and loads {@link SortedProperties}.\n *\n * @see SortedProperties\n * @since 4.4\n ",
      "methods": {
        "createProperties": {
          "Javadoc": "* Subclasses override to provide customized properties instances.\n     *\n     * @return a new Properties instance."
        }
      }
    },
    "org.apache.commons.collections4.Put": {
      "Javadoc": "\n * The \"write\" subset of the {@link Map} interface.\n * <p>\n * NOTE: in the original {@link Map} interface, {@link Map#put(Object, Object)} is known\n * to have the same return type as {@link Map#get(Object)}, namely {@code V}. {@link Put}\n * makes no assumptions in this regard (there is no association with, nor even knowledge\n * of, a \"reading\" interface) and thus defines {@link #put(Object, Object)} as returning\n * {@link Object}.\n * </p>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n *\n * @since 4.0\n * @see Get\n ",
      "methods": {
        "clear": {
          "Javadoc": "* @see Map#clear()"
        },
        "put": {
          "Javadoc": "* Note that the return type is Object, rather than V as in the Map interface.\n     * See the class Javadoc for further info.\n     *\n     * @param key key with which the specified value is to be associated\n     * @param value value to be associated with the specified key\n     * @return the previous value associated with {@code key}, or\n     *         {@code null} if there was no mapping for {@code key}.\n     *         (A {@code null} return can also indicate that the map\n     *         previously associated {@code null} with {@code key},\n     *         if the implementation supports {@code null} values.)\n     * @see Map#put(Object, Object)"
        },
        "putAll": {
          "Javadoc": "* @param t mappings to be stored in this map\n     * @see Map#putAll(Map)"
        }
      }
    },
    "org.apache.commons.collections4.queue.AbstractQueueDecorator": {
      "Javadoc": "\n * Decorates another {@link Queue} to provide additional behavior.\n * <p>\n * Methods are forwarded directly to the decorated queue.\n * </p>\n * <p>\n * This implementation does not forward the hashCode and equals methods through\n * to the backing object, but relies on Object's implementation. This is\n * necessary as some Queue implementations, e.g. LinkedList, have a custom\n * equals implementation for which symmetry can not be preserved.\n * See class Javadoc of AbstractCollectionDecorator for more information.\n * </p>\n *\n * @param <E> the type of the elements in the queue\n * @since 4.0\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the queue being decorated.\n     *\n     * @return the decorated queue"
        }
      }
    },
    "org.apache.commons.collections4.queue.CircularFifoQueue": {
      "Javadoc": "\n * CircularFifoQueue is a first-in first-out queue with a fixed size that\n * replaces its oldest element if full.\n * <p>\n * The removal order of a {@link CircularFifoQueue} is based on the\n * insertion order; elements are removed in the same order in which they\n * were added.  The iteration order is the same as the removal order.\n * </p>\n * <p>\n * The {@link #add(Object)}, {@link #remove()}, {@link #peek()}, {@link #poll()},\n * {@link #offer(Object)} operations all perform in constant time.\n * All other operations perform in linear time or worse.\n * </p>\n * <p>\n * This queue prevents null objects from being added.\n * </p>\n *\n * @param <E> the type of elements in this collection\n * @since 4.0\n ",
      "methods": {
        "add": {
          "Javadoc": "* Adds the given element to this queue. If the queue is full, the least recently added\n     * element is discarded so that a new element can be inserted.\n     *\n     * @param element  the element to add\n     * @return true, always\n     * @throws NullPointerException  if the given element is null"
        },
        "clear": {
          "Javadoc": "* Clears this queue."
        },
        "decrement": {
          "Javadoc": "* Decrements the internal index.\n     *\n     * @param index  the index to decrement\n     * @return the updated index"
        },
        "get": {
          "Javadoc": "* Returns the element at the specified position in this queue.\n     *\n     * @param index the position of the element in the queue\n     * @return the element at position {@code index}\n     * @throws NoSuchElementException if the requested position is outside the range [0, size)"
        },
        "increment": {
          "Javadoc": "* Increments the internal index.\n     *\n     * @param index  the index to increment\n     * @return the updated index"
        },
        "isAtFullCapacity": {
          "Javadoc": "* Returns {@code true} if the capacity limit of this queue has been reached,\n     * i.e. the number of elements stored in the queue equals its maximum size.\n     *\n     * @return {@code true} if the capacity limit has been reached, {@code false} otherwise\n     * @since 4.1"
        },
        "isEmpty": {
          "Javadoc": "* Returns true if this queue is empty; false otherwise.\n     *\n     * @return true if this queue is empty"
        },
        "isFull": {
          "Javadoc": "* {@inheritDoc}\n     * <p>\n     * A {@code CircularFifoQueue} can never be full, thus this returns always\n     * {@code false}.\n     *\n     * @return always returns {@code false}"
        },
        "iterator": {
          "Javadoc": "* Returns an iterator over this queue's elements.\n     *\n     * @return an iterator over this queue's elements"
        },
        "maxSize": {
          "Javadoc": "* Gets the maximum size of the collection (the bound).\n     *\n     * @return the maximum number of elements the collection can hold"
        },
        "offer": {
          "Javadoc": "* Adds the given element to this queue. If the queue is full, the least recently added\n     * element is discarded so that a new element can be inserted.\n     *\n     * @param element  the element to add\n     * @return true, always\n     * @throws NullPointerException  if the given element is null"
        },
        "readObject": {
          "Javadoc": "* Read the queue in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an I/O error occurs while writing to the output stream\n     * @throws ClassNotFoundException if the class of a serialized object can not be found"
        },
        "size": {
          "Javadoc": "* Returns the number of elements stored in the queue.\n     *\n     * @return this queue's size"
        },
        "writeObject": {
          "Javadoc": "* Write the queue out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an I/O error occurs while writing to the output stream"
        }
      }
    },
    "org.apache.commons.collections4.queue.PredicatedQueue": {
      "Javadoc": "\n * Decorates another {@link Queue} to validate that additions\n * match a specified predicate.\n * <p>\n * This queue exists to provide validation for the decorated queue.\n * It is normally created to decorate an empty queue.\n * If an object cannot be added to the queue, an IllegalArgumentException is thrown.\n * </p>\n * <p>\n * One usage would be to ensure that no null entries are added to the queue.\n * </p>\n * <pre>Queue queue = PredicatedQueue.predicatedQueue(new UnboundedFifoQueue(), NotNullPredicate.INSTANCE);</pre>\n *\n * @param <E> the type of elements held in this queue\n * @since 4.0\n ",
      "methods": {
        "predicatedQueue": {
          "Javadoc": "* Factory method to create a predicated (validating) queue.\n     * <p>\n     * If there are any elements already in the queue being decorated, they\n     * are validated.\n     *\n     * @param <E> the type of the elements in the queue\n     * @param Queue  the queue to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated queue\n     * @throws NullPointerException if queue or predicate is null\n     * @throws IllegalArgumentException if the queue contains invalid elements"
        },
        "decorated": {
          "Javadoc": "* Gets the queue being decorated.\n     *\n     * @return the decorated queue"
        },
        "offer": {
          "Javadoc": "* Override to validate the object being added to ensure it matches\n     * the predicate.\n     *\n     * @param object  the object being added\n     * @return the result of adding to the underlying queue\n     * @throws IllegalArgumentException if the add is invalid"
        }
      }
    },
    "org.apache.commons.collections4.queue.SynchronizedQueue": {
      "Javadoc": "\n * Decorates another {@link Queue} to synchronize its behavior for a multithreaded environment.\n * <p>\n * Methods are synchronized, then forwarded to the decorated queue. Iterators must be separately synchronized around the\n * loop.\n * </p>\n *\n * @param <E> the type of the elements in the collection\n * @since 4.2\n ",
      "methods": {
        "synchronizedQueue": {
          "Javadoc": "* Factory method to create a synchronized queue.\n     *\n     * @param <E>\n     *            the type of the elements in the queue\n     * @param queue\n     *            the queue to decorate, must not be null\n     * @return a new synchronized Queue\n     * @throws NullPointerException\n     *             if queue is null"
        },
        "decorated": {
          "Javadoc": "* Gets the queue being decorated.\n     *\n     * @return the decorated queue"
        }
      }
    },
    "org.apache.commons.collections4.queue.TransformedQueue": {
      "Javadoc": "\n * Decorates another {@link Queue} to transform objects that are added.\n * <p>\n * The add/offer methods are affected by this class.\n * Thus objects must be removed or searched for using their transformed form.\n * For example, if the transformation converts Strings to Integers, you must\n * use the Integer form to remove objects.\n * </p>\n *\n * @param <E> the type of elements held in this queue\n * @since 4.0\n ",
      "methods": {
        "transformedQueue": {
          "Javadoc": "* Factory method to create a transforming queue that will transform\n     * existing contents of the specified queue.\n     * <p>\n     * If there are any elements already in the queue being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingQueue(Queue, Transformer)}.\n     *\n     * @param <E> the type of the elements in the queue\n     * @param queue  the queue to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed Queue\n     * @throws NullPointerException if queue or transformer is null\n     * @since 4.0"
        },
        "transformingQueue": {
          "Javadoc": "* Factory method to create a transforming queue.\n     * <p>\n     * If there are any elements already in the queue being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedQueue(Queue, Transformer)}.\n     *\n     * @param <E> the type of the elements in the queue\n     * @param queue  the queue to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed Queue\n     * @throws NullPointerException if queue or transformer is null"
        },
        "getQueue": {
          "Javadoc": "* Gets the decorated queue.\n     *\n     * @return the decorated queue"
        }
      }
    },
    "org.apache.commons.collections4.queue.UnmodifiableQueue": {
      "Javadoc": "\n * Decorates another {@link Queue} to ensure it can't be altered.\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <E> the type of elements held in this queue\n * @since 4.0\n ",
      "methods": {
        "unmodifiableQueue": {
          "Javadoc": "* Factory method to create an unmodifiable queue.\n     * <p>\n     * If the queue passed in is already unmodifiable, it is returned.\n     *\n     * @param <E> the type of the elements in the queue\n     * @param queue  the queue to decorate, must not be null\n     * @return an unmodifiable Queue\n     * @throws NullPointerException if queue is null"
        },
        "readObject": {
          "Javadoc": "* Read the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an I/O error occurs while reading from the input stream\n     * @throws ClassNotFoundException if the class of a serialized object can not be found"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        },
        "writeObject": {
          "Javadoc": "* Write the collection out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an I/O error occurs while writing to the output stream"
        }
      }
    },
    "org.apache.commons.collections4.QueueUtils": {
      "Javadoc": "\n * Provides utility methods and decorators for {@link Queue} instances.\n *\n * @since 4.0\n ",
      "methods": {
        "emptyQueue": {
          "Javadoc": "* Gets an empty {@code Queue}.\n     *\n     * @param <E> the type of the elements in the queue\n     * @return an empty {@link Queue}"
        },
        "predicatedQueue": {
          "Javadoc": "* Returns a predicated (validating) queue backed by the given queue.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to the queue.\n     * Trying to add an invalid object results in an IllegalArgumentException.\n     * It is important not to use the original queue after invoking this method,\n     * as it is a backdoor for adding invalid objects.\n     *\n     * @param <E> the type of the elements in the queue\n     * @param queue  the queue to predicate, must not be null\n     * @param predicate  the predicate used to evaluate new elements, must not be null\n     * @return a predicated queue\n     * @throws NullPointerException if the queue or predicate is null"
        },
        "synchronizedQueue": {
          "Javadoc": "* Returns a synchronized (thread-safe) queue backed by the given queue.\n     * In order to guarantee serial access, it is critical that all access to the\n     * backing queue is accomplished through the returned queue.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned queue\n     * when iterating over it:\n     *\n     * <pre>\n     * Queue queue = QueueUtils.synchronizedQueue(new CircularFifoQueue());\n     * ...\n     * synchronized(queue) {\n     *     Iterator i = queue.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param queue the queue to synchronize, must not be null\n     * @return a synchronized queue backed by that queue\n     * @throws NullPointerException if the queue is null\n     * @since 4.2"
        },
        "transformingQueue": {
          "Javadoc": "* Returns a transformed queue backed by the given queue.\n     * <p>\n     * Each object is passed through the transformer as it is added to the\n     * Queue. It is important not to use the original queue after invoking this\n     * method, as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified queue will not be transformed.\n     * If you want that behavior, see {@link TransformedQueue#transformedQueue}.\n     *\n     * @param <E> the type of the elements in the queue\n     * @param queue  the queue to predicate, must not be null\n     * @param transformer  the transformer for the queue, must not be null\n     * @return a transformed queue backed by the given queue\n     * @throws NullPointerException if the queue or transformer is null"
        },
        "unmodifiableQueue": {
          "Javadoc": "* Returns an unmodifiable queue backed by the given queue.\n     *\n     * @param <E> the type of the elements in the queue\n     * @param queue  the queue to make unmodifiable, must not be null\n     * @return an unmodifiable queue backed by that queue\n     * @throws NullPointerException if the queue is null"
        }
      }
    },
    "org.apache.commons.collections4.ResettableIterator": {
      "Javadoc": "\n * Defines an iterator that can be reset back to an initial state.\n * <p>\n * This interface allows an iterator to be repeatedly reused.\n * </p>\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 3.0\n ",
      "methods": {
        "reset": {
          "Javadoc": "* Resets the iterator back to the position at which the iterator\n     * was created."
        }
      }
    },
    "org.apache.commons.collections4.ResettableListIterator": {
      "Javadoc": "\n * Defines a list iterator that can be reset back to an initial state.\n * <p>\n * This interface allows an iterator to be repeatedly reused.\n * </p>\n *\n * @param <E> the type of elements returned by this iterator.\n * @since 3.0\n "
    },
    "org.apache.commons.collections4.sequence.CommandVisitor": {
      "Javadoc": "\n * This interface should be implemented by user object to walk\n * through {@link EditScript EditScript} objects.\n * <p>\n * Users should implement this interface in order to walk through\n * the {@link EditScript EditScript} object created by the comparison\n * of two sequences. This is a direct application of the visitor\n * design pattern. The {@link EditScript#visit EditScript.visit}\n * method takes an object implementing this interface as an argument,\n * it will perform the loop over all commands in the script and the\n * proper methods of the user class will be called as the commands are\n * encountered.\n * </p>\n * <p>\n * The implementation of the user visitor class will depend on the\n * need. Here are two examples.\n * </p>\n * <p>\n * The first example is a visitor that build the longest common\n * subsequence:\n * </p>\n * <pre>\n * import org.apache.commons.collections4.comparators.sequence.CommandVisitor;\n *\n * import java.util.ArrayList;\n *\n * public class LongestCommonSubSequence implements CommandVisitor {\n *\n *   public LongestCommonSubSequence() {\n *     a = new ArrayList();\n *   }\n *\n *   public void visitInsertCommand(Object object) {\n *   }\n *\n *   public void visitKeepCommand(Object object) {\n *     a.add(object);\n *   }\n *\n *   public void visitDeleteCommand(Object object) {\n *   }\n *\n *   public Object[] getSubSequence() {\n *     return a.toArray();\n *   }\n *\n *   private ArrayList a;\n *\n * }\n * </pre>\n * <p>\n * The second example is a visitor that shows the commands and the way\n * they transform the first sequence into the second one:\n * </p>\n * <pre>\n * import org.apache.commons.collections4.comparators.sequence.CommandVisitor;\n *\n * import java.util.Arrays;\n * import java.util.ArrayList;\n * import java.util.Iterator;\n *\n * public class ShowVisitor implements CommandVisitor {\n *\n *   public ShowVisitor(Object[] sequence1) {\n *     v = new ArrayList();\n *     v.addAll(Arrays.asList(sequence1));\n *     index = 0;\n *   }\n *\n *   public void visitInsertCommand(Object object) {\n *     v.insertElementAt(object, index++);\n *     display(\"insert\", object);\n *   }\n *\n *   public void visitKeepCommand(Object object) {\n *     ++index;\n *     display(\"keep  \", object);\n *   }\n *\n *   public void visitDeleteCommand(Object object) {\n *     v.remove(index);\n *     display(\"delete\", object);\n *   }\n *\n *   private void display(String commandName, Object object) {\n *     System.out.println(commandName + \" \" + object + \" -&gt;\" + this);\n *   }\n *\n *   public String toString() {\n *     StringBuffer buffer = new StringBuffer();\n *     for (Iterator iter = v.iterator(); iter.hasNext();) {\n *       buffer.append(' ').append(iter.next());\n *     }\n *     return buffer.toString();\n *   }\n *\n *   private ArrayList v;\n *   private int index;\n *\n * }\n * </pre>\n *\n * @since 4.0\n ",
      "methods": {
        "visitDeleteCommand": {
          "Javadoc": "* Method called when a delete command is encountered.\n     *\n     * @param object object to delete (this object comes from the first sequence)"
        },
        "visitInsertCommand": {
          "Javadoc": "* Method called when an insert command is encountered.\n     *\n     * @param object object to insert (this object comes from the second sequence)"
        },
        "visitKeepCommand": {
          "Javadoc": "* Method called when a keep command is encountered.\n     *\n     * @param object object to keep (this object comes from the first sequence)"
        }
      }
    },
    "org.apache.commons.collections4.sequence.DeleteCommand": {
      "Javadoc": "\n * Command representing the deletion of one object of the first sequence.\n * <p>\n * When one object of the first sequence has no corresponding object in the\n * second sequence at the right place, the {@link EditScript edit script}\n * transforming the first sequence into the second sequence uses an instance of\n * this class to represent the deletion of this object. The objects embedded in\n * these type of commands always come from the first sequence.\n * </p>\n *\n * @see SequencesComparator\n * @see EditScript\n *\n * @since 4.0\n ",
      "methods": {
        "accept": {
          "Javadoc": "* Accept a visitor. When a {@code DeleteCommand} accepts a visitor, it calls\n     * its {@link CommandVisitor#visitDeleteCommand visitDeleteCommand} method.\n     *\n     * @param visitor  the visitor to be accepted"
        }
      }
    },
    "org.apache.commons.collections4.sequence.EditCommand": {
      "Javadoc": "\n * Abstract base class for all commands used to transform an objects sequence\n * into another one.\n * <p>\n * When two objects sequences are compared through the\n * {@link SequencesComparator#getScript SequencesComparator.getScript} method,\n * the result is provided has a {@link EditScript script} containing the commands\n * that progressively transform the first sequence into the second one.\n * </p>\n * <p>\n * There are only three types of commands, all of which are subclasses of this\n * abstract class. Each command is associated with one object belonging to at\n * least one of the sequences. These commands are {@link InsertCommand\n * InsertCommand} which correspond to an object of the second sequence being\n * inserted into the first sequence, {@link DeleteCommand DeleteCommand} which\n * correspond to an object of the first sequence being removed and\n * {@link KeepCommand KeepCommand} which correspond to an object of the first\n * sequence which {@code equals} an object in the second sequence. It is\n * guaranteed that comparison is always performed this way (i.e. the\n * {@code equals} method of the object from the first sequence is used and\n * the object passed as an argument comes from the second sequence) ; this can\n * be important if subclassing is used for some elements in the first sequence\n * and the {@code equals} method is specialized.\n * </p>\n *\n * @see SequencesComparator\n * @see EditScript\n *\n * @since 4.0\n ",
      "methods": {
        "accept": {
          "Javadoc": "* Accept a visitor.\n     * <p>\n     * This method is invoked for each command belonging to\n     * an {@link EditScript EditScript}, in order to implement the visitor design pattern\n     *\n     * @param visitor  the visitor to be accepted"
        },
        "getObject": {
          "Javadoc": "* Returns the object associated with this command.\n     *\n     * @return the object on which the command is applied"
        }
      }
    },
    "org.apache.commons.collections4.sequence.EditScript": {
      "Javadoc": "\n * This class gathers all the {@link EditCommand commands} needed to transform\n * one objects sequence into another objects sequence.\n * <p>\n * An edit script is the most general view of the differences between two\n * sequences. It is built as the result of the comparison between two sequences\n * by the {@link SequencesComparator SequencesComparator} class. The user can\n * walk through it using the <em>visitor</em> design pattern.\n * </p>\n * <p>\n * It is guaranteed that the objects embedded in the {@link InsertCommand insert\n * commands} come from the second sequence and that the objects embedded in\n * either the {@link DeleteCommand delete commands} or {@link KeepCommand keep\n * commands} come from the first sequence. This can be important if subclassing\n * is used for some elements in the first sequence and the {@code equals}\n * method is specialized.\n * </p>\n *\n * @see SequencesComparator\n * @see EditCommand\n * @see CommandVisitor\n * @see ReplacementsHandler\n *\n * @since 4.0\n ",
      "methods": {
        "append": {
          "Javadoc": "* Add a keep command to the script.\n     *\n     * @param command  command to add"
        },
        "getLCSLength": {
          "Javadoc": "* Gets the length of the Longest Common Subsequence (LCS). The length of the\n     * longest common subsequence is the number of {@link KeepCommand keep\n     * commands} in the script.\n     *\n     * @return length of the Longest Common Subsequence"
        },
        "getModifications": {
          "Javadoc": "* Gets the number of effective modifications. The number of effective\n     * modification is the number of {@link DeleteCommand delete} and\n     * {@link InsertCommand insert} commands in the script.\n     *\n     * @return number of effective modifications"
        },
        "visit": {
          "Javadoc": "* Visit the script. The script implements the <em>visitor</em> design\n     * pattern, this method is the entry point to which the user supplies its\n     * own visitor, the script will be responsible to drive it through the\n     * commands in order and call the appropriate method as each command is\n     * encountered.\n     *\n     * @param visitor  the visitor that will visit all commands in turn"
        }
      }
    },
    "org.apache.commons.collections4.sequence.InsertCommand": {
      "Javadoc": "\n * Command representing the insertion of one object of the second sequence.\n * <p>\n * When one object of the second sequence has no corresponding object in the\n * first sequence at the right place, the {@link EditScript edit script}\n * transforming the first sequence into the second sequence uses an instance of\n * this class to represent the insertion of this object. The objects embedded in\n * these type of commands always come from the second sequence.\n * </p>\n *\n * @see SequencesComparator\n * @see EditScript\n *\n * @since 4.0\n ",
      "methods": {
        "accept": {
          "Javadoc": "* Accept a visitor. When an {@code InsertCommand} accepts a visitor,\n     * it calls its {@link CommandVisitor#visitInsertCommand visitInsertCommand}\n     * method.\n     *\n     * @param visitor  the visitor to be accepted"
        }
      }
    },
    "org.apache.commons.collections4.sequence.KeepCommand": {
      "Javadoc": "\n * Command representing the keeping of one object present in both sequences.\n * <p>\n * When one object of the first sequence {@code equals} another objects in\n * the second sequence at the right place, the {@link EditScript edit script}\n * transforming the first sequence into the second sequence uses an instance of\n * this class to represent the keeping of this object. The objects embedded in\n * these type of commands always come from the first sequence.\n * </p>\n *\n * @see SequencesComparator\n * @see EditScript\n *\n * @since 4.0\n ",
      "methods": {
        "accept": {
          "Javadoc": "* Accept a visitor. When a {@code KeepCommand} accepts a visitor, it\n     * calls its {@link CommandVisitor#visitKeepCommand visitKeepCommand} method.\n     *\n     * @param visitor  the visitor to be accepted"
        }
      }
    },
    "org.apache.commons.collections4.sequence.ReplacementsFinder": {
      "Javadoc": "\n * This class handles sequences of replacements resulting from a comparison.\n * <p>\n * The comparison of two objects sequences leads to the identification of common\n * parts and parts which only belong to the first or to the second sequence. The\n * common parts appear in the edit script in the form of <em>keep</em> commands,\n * they can be considered as synchronization objects between the two sequences.\n * These synchronization objects split the two sequences in synchronized\n * sub-sequences. The first sequence can be transformed into the second one by\n * replacing each synchronized sub-sequence of the first sequence by the\n * corresponding sub-sequence of the second sequence. This is a synthetic way to\n * see an {@link EditScript edit script}, replacing individual\n * {@link DeleteCommand delete}, {@link KeepCommand keep} and\n * {@link InsertCommand insert} commands by fewer replacements acting on\n * complete sub-sequences.\n * </p>\n * <p>\n * This class is devoted to perform this interpretation. It visits an\n * {@link EditScript edit script} (because it implements the\n * {@link CommandVisitor CommandVisitor} interface) and calls a user-supplied\n * handler implementing the {@link ReplacementsHandler ReplacementsHandler}\n * interface to process the sub-sequences.\n * </p>\n *\n * @see ReplacementsHandler\n * @see EditScript\n * @see SequencesComparator\n *\n * @since 4.0\n ",
      "methods": {
        "visitDeleteCommand": {
          "Javadoc": "* Add an object to the pending deletions set.\n     *\n     * @param object  object to delete"
        },
        "visitInsertCommand": {
          "Javadoc": "* Add an object to the pending insertions set.\n     *\n     * @param object  object to insert"
        },
        "visitKeepCommand": {
          "Javadoc": "* Handle a synchronization object.\n     * <p>\n     * When a synchronization object is identified, the pending insertions and\n     * pending deletions sets are provided to the user handler as subsequences.\n     *\n     * @param object  synchronization object detected"
        }
      }
    },
    "org.apache.commons.collections4.sequence.ReplacementsHandler": {
      "Javadoc": "\n * This interface is devoted to handle synchronized replacement sequences.\n *\n * @see ReplacementsFinder\n * @since 4.0\n ",
      "methods": {
        "handleReplacement": {
          "Javadoc": "* Handle two synchronized sequences.\n     * <p>\n     * This method is called by a {@link ReplacementsFinder ReplacementsFinder}\n     * instance when it has synchronized two sub-sequences of object arrays\n     * being compared, and at least one of the sequences is non-empty. Since the\n     * sequences are synchronized, the objects before the two sub-sequences are\n     * equals (if they exist). This property also holds for the objects after\n     * the two sub-sequences.\n     * <p>\n     * The replacement is defined as replacing the {@code from}\n     * sub-sequence into the {@code to} sub-sequence.\n     *\n     * @param skipped  number of tokens skipped since the last call (i.e. number of\n     *   tokens that were in both sequences), this number should be strictly positive\n     *   except on the very first call where it can be zero (if the first object of\n     *   the two sequences are different)\n     * @param from  sub-sequence of objects coming from the first sequence\n     * @param to  sub-sequence of objects coming from the second sequence"
        }
      }
    },
    "org.apache.commons.collections4.sequence.SequencesComparator": {
      "Javadoc": "\n * This class allows to compare two objects sequences.\n * <p>\n * The two sequences can hold any object type, as only the {@code equals}\n * method is used to compare the elements of the sequences. It is guaranteed\n * that the comparisons will always be done as {@code o1.equals(o2)} where\n * {@code o1} belongs to the first sequence and {@code o2} belongs to\n * the second sequence. This can be important if subclassing is used for some\n * elements in the first sequence and the {@code equals} method is\n * specialized.\n * </p>\n * <p>\n * Comparison can be seen from two points of view: either as giving the smallest\n * modification allowing to transform the first sequence into the second one, or\n * as giving the longest sequence which is a subsequence of both initial\n * sequences. The {@code equals} method is used to compare objects, so any\n * object can be put into sequences. Modifications include deleting, inserting\n * or keeping one object, starting from the beginning of the first sequence.\n * </p>\n * <p>\n * This class implements the comparison algorithm, which is the very efficient\n * algorithm from Eugene W. Myers\n * <a href=\"https://www.cis.upenn.edu/~bcpierce/courses/dd/papers/diff.ps\">\n * An O(ND) Difference Algorithm and Its Variations</a>. This algorithm produces\n * the shortest possible\n * {@link EditScript edit script}\n * containing all the\n * {@link EditCommand commands}\n * needed to transform the first sequence into the second one.\n * </p>\n *\n * @see EditScript\n * @see EditCommand\n * @see CommandVisitor\n *\n * @since 4.0\n ",
      "methods": {
        "buildScript": {
          "Javadoc": "* Build an edit script.\n     *\n     * @param start1  the start of the first sequence to be compared\n     * @param end1  the end of the first sequence to be compared\n     * @param start2  the start of the second sequence to be compared\n     * @param end2  the end of the second sequence to be compared\n     * @param script the edited script"
        },
        "buildSnake": {
          "Javadoc": "* Build a snake.\n     *\n     * @param start  the value of the start of the snake\n     * @param diag  the value of the diagonal of the snake\n     * @param end1  the value of the end of the first sequence to be compared\n     * @param end2  the value of the end of the second sequence to be compared\n     * @return the snake built"
        },
        "getMiddleSnake": {
          "Javadoc": "* Gets the middle snake corresponding to two subsequences of the\n     * main sequences.\n     * <p>\n     * The snake is found using the MYERS Algorithm (this algorithm has\n     * also been implemented in the GNU diff program). This algorithm is\n     * explained in Eugene Myers article:\n     * <a href=\"https://web.archive.org/web/20040719035900/http%3A//www.cs.arizona.edu/people/gene/PAPERS/diff.ps\">\n     * An O(ND) Difference Algorithm and Its Variations</a>.\n     *\n     * @param start1  the start of the first sequence to be compared\n     * @param end1  the end of the first sequence to be compared\n     * @param start2  the start of the second sequence to be compared\n     * @param end2  the end of the second sequence to be compared\n     * @return the middle snake"
        },
        "getScript": {
          "Javadoc": "* Gets the {@link EditScript} object.\n     * <p>\n     * It is guaranteed that the objects embedded in the {@link InsertCommand\n     * insert commands} come from the second sequence and that the objects\n     * embedded in either the {@link DeleteCommand delete commands} or\n     * {@link KeepCommand keep commands} come from the first sequence. This can\n     * be important if subclassing is used for some elements in the first\n     * sequence and the {@code equals} method is specialized.\n     *\n     * @return the edit script resulting from the comparison of the two\n     *         sequences"
        }
      }
    },
    "org.apache.commons.collections4.sequence.Snake": {
      "Javadoc": "\n     * This class is a simple placeholder to hold the end part of a path\n     * under construction in a {@link SequencesComparator SequencesComparator}.\n     ",
      "methods": {
        "getDiag": {
          "Javadoc": "* Gets the diagonal number of the snake.\n         *\n         * @return diagonal number of the snake"
        },
        "getEnd": {
          "Javadoc": "* Gets the end index of the snake.\n         *\n         * @return end index of the snake"
        },
        "getStart": {
          "Javadoc": "* Gets the start index of the snake.\n         *\n         * @return start index of the snake"
        }
      }
    },
    "org.apache.commons.collections4.set.AbstractNavigableSetDecorator": {
      "Javadoc": "\n * Decorates another {@code NavigableSet} to provide additional behavior.\n * <p>\n * Methods are forwarded directly to the decorated set.\n * </p>\n *\n * @param <E> the type of the elements in the navigable set\n * @since 4.1\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the set being decorated.\n     *\n     * @return the decorated set"
        }
      }
    },
    "org.apache.commons.collections4.set.AbstractSerializableSetDecorator": {
      "Javadoc": "\n * Serializable subclass of AbstractSetDecorator.\n *\n * @param <E> the type of the elements in this set\n * @since 3.1\n ",
      "methods": {
        "readObject": {
          "Javadoc": "* Read the set in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "writeObject": {
          "Javadoc": "* Write the set out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.set.AbstractSetDecorator": {
      "Javadoc": "\n * Decorates another {@code Set} to provide additional behavior.\n * <p>\n * Methods are forwarded directly to the decorated set.\n * </p>\n *\n * @param <E> the type of the elements in this set\n * @since 3.0\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the set being decorated.\n     *\n     * @return the decorated set"
        }
      }
    },
    "org.apache.commons.collections4.set.AbstractSortedSetDecorator": {
      "Javadoc": "\n * Decorates another {@code SortedSet} to provide additional behavior.\n * <p>\n * Methods are forwarded directly to the decorated set.\n * </p>\n *\n * @param <E> the type of the elements in the sorted set\n * @since 3.0\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the set being decorated.\n     *\n     * @return the decorated set"
        }
      }
    },
    "org.apache.commons.collections4.set.CompositeSet": {
      "Javadoc": "\n * Decorates a set of other sets to provide a single unified view.\n * <p>\n * Changes made to this set will actually be made on the decorated set.\n * Add operations require the use of a pluggable strategy.\n * If no strategy is provided then add is unsupported.\n * </p>\n * <p>\n * From version 4.0, this class does not extend\n * {@link org.apache.commons.collections4.collection.CompositeCollection CompositeCollection}\n * anymore due to its input restrictions (only accepts Sets).\n * See <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-424\">COLLECTIONS-424</a>\n * for more details.\n * </p>\n *\n * @param <E> the type of the elements in this set\n * @since 3.0\n ",
      "methods": {
        "add": {
          "Javadoc": "* Adds an object to the collection, throwing UnsupportedOperationException\n     * unless a SetMutator strategy is specified.\n     *\n     * @param obj  the object to add\n     * @return {@code true} if the collection was modified\n     * @throws UnsupportedOperationException if SetMutator hasn't been set or add is unsupported\n     * @throws ClassCastException if the object cannot be added due to its type\n     * @throws NullPointerException if the object cannot be added because its null\n     * @throws IllegalArgumentException if the object cannot be added"
        },
        "addAll": {
          "Javadoc": "* Adds a collection of elements to this composite, throwing\n     * UnsupportedOperationException unless a SetMutator strategy is specified.\n     *\n     * @param coll  the collection to add\n     * @return true if the composite was modified\n     * @throws UnsupportedOperationException if SetMutator hasn't been set or add is unsupported\n     * @throws ClassCastException if the object cannot be added due to its type\n     * @throws NullPointerException if the object cannot be added because its null\n     * @throws IllegalArgumentException if the object cannot be added"
        },
        "addComposited": {
          "Javadoc": "* Adds these Sets to the list of sets in this composite.\n     *\n     * @param set1  the first Set to be appended to the composite\n     * @param set2  the second Set to be appended to the composite"
        },
        "clear": {
          "Javadoc": "* Removes all of the elements from this composite set.\n     * <p>\n     * This implementation calls {@code clear()} on each set.\n     *\n     * @throws UnsupportedOperationException if clear is unsupported"
        },
        "contains": {
          "Javadoc": "* Checks whether this composite set contains the object.\n     * <p>\n     * This implementation calls {@code contains()} on each set.\n     *\n     * @param obj  the object to search for\n     * @return true if obj is contained in any of the contained sets"
        },
        "containsAll": {
          "Javadoc": "* Checks whether this composite contains all the elements in the specified collection.\n     * <p>\n     * This implementation calls {@code contains()} for each element in the\n     * specified collection.\n     *\n     * @param coll  the collection to check for\n     * @return true if all elements contained"
        },
        "equals": {
          "Javadoc": "* {@inheritDoc}\n     * @see java.util.Set#equals"
        },
        "getMutator": {
          "Javadoc": "* Gets the set mutator to be used for this CompositeSet.\n     * @return the set mutator"
        },
        "getSets": {
          "Javadoc": "* Gets the sets being decorated.\n     *\n     * @return Unmodifiable list of all sets in this composite."
        },
        "hashCode": {
          "Javadoc": "* {@inheritDoc}\n     * @see java.util.Set#hashCode"
        },
        "isEmpty": {
          "Javadoc": "* Checks whether this composite set is empty.\n     * <p>\n     * This implementation calls {@code isEmpty()} on each set.\n     *\n     * @return true if all of the contained sets are empty"
        },
        "iterator": {
          "Javadoc": "* Gets an iterator over all the sets in this composite.\n     * <p>\n     * This implementation uses an {@code IteratorChain}.\n     *\n     * @return an {@code IteratorChain} instance which supports\n     *  {@code remove()}. Iteration occurs over contained collections in\n     *  the order they were added, but this behavior should not be relied upon.\n     * @see IteratorChain"
        },
        "remove": {
          "Javadoc": "* If a {@code CollectionMutator} is defined for this CompositeSet then this\n     * method will be called anyway.\n     *\n     * @param obj  object to be removed\n     * @return true if the object is removed, false otherwise"
        },
        "removeAll": {
          "Javadoc": "* Removes the elements in the specified collection from this composite set.\n     * <p>\n     * This implementation calls {@code removeAll} on each collection.\n     *\n     * @param coll  the collection to remove\n     * @return true if the composite was modified\n     * @throws UnsupportedOperationException if removeAll is unsupported"
        },
        "removeComposited": {
          "Javadoc": "* Removes a set from those being decorated in this composite.\n     *\n     * @param set  set to be removed"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        },
        "retainAll": {
          "Javadoc": "* Retains all the elements in the specified collection in this composite set,\n     * removing all others.\n     * <p>\n     * This implementation calls {@code retainAll()} on each collection.\n     *\n     * @param coll  the collection to remove\n     * @return true if the composite was modified\n     * @throws UnsupportedOperationException if retainAll is unsupported"
        },
        "setMutator": {
          "Javadoc": "* Specify a SetMutator strategy instance to handle changes.\n     *\n     * @param mutator  the mutator to use"
        },
        "size": {
          "Javadoc": "* Gets the size of this composite set.\n     * <p>\n     * This implementation calls {@code size()} on each set.\n     *\n     * @return total number of elements in all contained containers"
        },
        "toArray": {
          "Javadoc": "* Returns an object array, populating the supplied array if possible.\n     * See {@code Collection} interface for full details.\n     *\n     * @param <T>  the type of the elements in the collection\n     * @param array  the array to use, populating if possible\n     * @return an array of all the elements in the collection"
        },
        "toSet": {
          "Javadoc": "* Returns a new Set containing all of the elements.\n     *\n     * @return A new HashSet containing all of the elements in this composite.\n     *   The new collection is <i>not</i> backed by this composite."
        }
      }
    },
    "org.apache.commons.collections4.set.SetMutator": {
      "Javadoc": "\n     * Defines callbacks for mutation operations.\n     ",
      "methods": {
        "add": {
          "Javadoc": "* Called when an object is to be added to the composite.\n         *\n         * @param composite  the CompositeSet being changed\n         * @param sets  all of the Set instances in this CompositeSet\n         * @param obj  the object being added\n         * @return true if the collection is changed\n         * @throws UnsupportedOperationException if add is unsupported\n         * @throws ClassCastException if the object cannot be added due to its type\n         * @throws NullPointerException if the object cannot be added because its null\n         * @throws IllegalArgumentException if the object cannot be added"
        },
        "addAll": {
          "Javadoc": "* Called when a collection is to be added to the composite.\n         *\n         * @param composite  the CompositeSet being changed\n         * @param sets  all of the Set instances in this CompositeSet\n         * @param coll  the collection being added\n         * @return true if the collection is changed\n         * @throws UnsupportedOperationException if add is unsupported\n         * @throws ClassCastException if the object cannot be added due to its type\n         * @throws NullPointerException if the object cannot be added because its null\n         * @throws IllegalArgumentException if the object cannot be added"
        },
        "resolveCollision": {
          "Javadoc": "* Called when a Set is added to the CompositeSet and there is a\n         * collision between existing and added sets.\n         * <p>\n         * If {@code added} and {@code existing} still have any intersects\n         * after this method returns an IllegalArgumentException will be thrown.\n         *\n         * @param comp  the CompositeSet being modified\n         * @param existing  the Set already existing in the composite\n         * @param added  the Set being added to the composite\n         * @param intersects  the intersection of the existing and added sets"
        }
      }
    },
    "org.apache.commons.collections4.set.ListOrderedSet": {
      "Javadoc": "\n * Decorates another {@code Set} to ensure that the order of addition is\n * retained and used by the iterator.\n * <p>\n * If an object is added to the set for a second time, it will remain in the\n * original position in the iteration. The order can be observed from the set\n * via the iterator or toArray methods.\n * </p>\n * <p>\n * The ListOrderedSet also has various useful direct methods. These include many\n * from {@code List}, such as {@code get(int)},\n * {@code remove(int)} and {@code indexOf(int)}. An unmodifiable\n * {@code List} view of the set can be obtained via {@code asList()}.\n * </p>\n * <p>\n * This class cannot implement the {@code List} interface directly as\n * various interface methods (notably equals/hashCode) are incompatible with a\n * set.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <E> the type of the elements in this set\n * @since 3.0\n ",
      "methods": {
        "listOrderedSet": {
          "Javadoc": "* Factory method to create an ordered set specifying the list and set to use.\n     * <p>\n     * The list and set must both be empty.\n     *\n     * @param <E> the element type\n     * @param set the set to decorate, must be empty and not null\n     * @param list the list to decorate, must be empty and not null\n     * @return a new ordered set\n     * @throws NullPointerException if set or list is null\n     * @throws IllegalArgumentException if either the set or list is not empty\n     * @since 4.0"
        },
        "add": {
          "Javadoc": "* Inserts the specified element at the specified position if it is not yet\n     * contained in this ordered set (optional operation). Shifts the element\n     * currently at this position and any subsequent elements to the right.\n     *\n     * @param index the index at which the element is to be inserted\n     * @param object the element to be inserted\n     * @see List#add(int, Object)"
        },
        "addAll": {
          "Javadoc": "* Inserts all elements in the specified collection not yet contained in the\n     * ordered set at the specified position (optional operation). Shifts the\n     * element currently at the position and all subsequent elements to the\n     * right.\n     *\n     * @param index the position to insert the elements\n     * @param coll the collection containing the elements to be inserted\n     * @return {@code true} if this ordered set changed as a result of the call\n     * @see List#addAll(int, Collection)"
        },
        "asList": {
          "Javadoc": "* Gets an unmodifiable view of the order of the Set.\n     *\n     * @return an unmodifiable list view"
        },
        "get": {
          "Javadoc": "* Returns the element at the specified position in this ordered set.\n     *\n     * @param index the position of the element in the ordered {@link Set}.\n     * @return the element at position {@code index}\n     * @see List#get(int)"
        },
        "indexOf": {
          "Javadoc": "* Returns the index of the first occurrence of the specified element in\n     * ordered set.\n     *\n     * @param object the element to search for\n     * @return the index of the first occurrence of the object, or {@code -1} if\n     *         this ordered set does not contain this object\n     * @see List#indexOf(Object)"
        },
        "remove": {
          "Javadoc": "* Removes the element at the specified position from the ordered set.\n     * Shifts any subsequent elements to the left.\n     *\n     * @param index the index of the element to be removed\n     * @return the element that has been remove from the ordered set\n     * @see List#remove(int)"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        },
        "retainAll": {
          "Javadoc": "* {@inheritDoc}\n     * <p>\n     * This implementation iterates over the elements of this set, checking\n     * each element in turn to see if it's contained in {@code coll}.\n     * If it's not contained, it's removed from this set. As a consequence,\n     * it is advised to use a collection type for {@code coll} that provides\n     * a fast (e.g. O(1)) implementation of {@link Collection#contains(Object)}."
        }
      }
    },
    "org.apache.commons.collections4.set.OrderedSetIterator": {
      "Javadoc": "\n     * Internal iterator handle remove.\n     "
    },
    "org.apache.commons.collections4.set.MapBackedSet": {
      "Javadoc": "\n * Decorates a {@code Map} to obtain {@code Set} behavior.\n * <p>\n * This class is used to create a {@code Set} with the same properties as\n * the key set of any map. Thus, a ReferenceSet can be created by wrapping a\n * {@code ReferenceMap} in an instance of this class.\n * </p>\n * <p>\n * Most map implementation can be used to create a set by passing in dummy values.\n * Exceptions include {@code BidiMap} implementations, as they require unique values.\n * </p>\n *\n * @param <E> the type of the elements in this set\n * @param <V> the dummy value type in this map\n * @since 3.1\n ",
      "methods": {
        "mapBackedSet": {
          "Javadoc": "* Factory method to create a set from a map.\n     *\n     * @param <E> the element type\n     * @param <V> the dummy value type in the map\n     * @param map  the map to decorate, must not be null\n     * @param dummyValue  the dummy value to use\n     * @return a new map backed set\n     * @throws NullPointerException if map is null\n     * @since 4.0"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        }
      }
    },
    "org.apache.commons.collections4.set.PredicatedNavigableSet": {
      "Javadoc": "\n * Decorates another {@code NavigableSet} to validate that all additions\n * match a specified predicate.\n * <p>\n * This set exists to provide validation for the decorated set.\n * It is normally created to decorate an empty set.\n * If an object cannot be added to the set, an IllegalArgumentException is thrown.\n * </p>\n * <p>\n * One usage would be to ensure that no null entries are added to the set.\n * </p>\n * <pre>\n * NavigableSet set =\n *   PredicatedSortedSet.predicatedNavigableSet(new TreeSet(),\n *                                              NotNullPredicate.notNullPredicate());\n * </pre>\n *\n * @param <E> the type of the elements in this set\n * @since 4.1\n ",
      "methods": {
        "predicatedNavigableSet": {
          "Javadoc": "* Factory method to create a predicated (validating) navigable set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are validated.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated navigable set.\n     * @throws NullPointerException if set or predicate is null\n     * @throws IllegalArgumentException if the set contains invalid elements\n     * @since 4.0"
        },
        "decorated": {
          "Javadoc": "* Gets the navigable set being decorated.\n     *\n     * @return the decorated navigable set"
        }
      }
    },
    "org.apache.commons.collections4.set.PredicatedSet": {
      "Javadoc": "\n * Decorates another {@code Set} to validate that all additions\n * match a specified predicate.\n * <p>\n * This set exists to provide validation for the decorated set.\n * It is normally created to decorate an empty set.\n * If an object cannot be added to the set, an IllegalArgumentException is thrown.\n * </p>\n * <p>\n * One usage would be to ensure that no null entries are added to the set.\n * </p>\n * <pre>Set set = PredicatedSet.decorate(new HashSet(), NotNullPredicate.INSTANCE);</pre>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <E> the type of the elements in this set\n * @since 3.0\n ",
      "methods": {
        "predicatedSet": {
          "Javadoc": "* Factory method to create a predicated (validating) set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are validated.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a decorated set\n     * @throws NullPointerException if set or predicate is null\n     * @throws IllegalArgumentException if the set contains invalid elements\n     * @since 4.0"
        },
        "decorated": {
          "Javadoc": "* Gets the set being decorated.\n     *\n     * @return the decorated set"
        }
      }
    },
    "org.apache.commons.collections4.set.PredicatedSortedSet": {
      "Javadoc": "\n * Decorates another {@code SortedSet} to validate that all additions\n * match a specified predicate.\n * <p>\n * This set exists to provide validation for the decorated set.\n * It is normally created to decorate an empty set.\n * If an object cannot be added to the set, an IllegalArgumentException is thrown.\n * </p>\n * <p>\n * One usage would be to ensure that no null entries are added to the set.\n * </p>\n * <pre>\n * SortedSet set =\n *   PredicatedSortedSet.predicatedSortedSet(new TreeSet(),\n *                                           NotNullPredicate.notNullPredicate());\n * </pre>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <E> the type of the elements in this set\n * @since 3.0\n ",
      "methods": {
        "predicatedSortedSet": {
          "Javadoc": "* Factory method to create a predicated (validating) sorted set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are validated.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated sorted set.\n     * @throws NullPointerException if set or predicate is null\n     * @throws IllegalArgumentException if the set contains invalid elements\n     * @since 4.0"
        },
        "decorated": {
          "Javadoc": "* Gets the sorted set being decorated.\n     *\n     * @return the decorated sorted set"
        }
      }
    },
    "org.apache.commons.collections4.set.TransformedNavigableSet": {
      "Javadoc": "\n * Decorates another {@code NavigableSet} to transform objects that are added.\n * <p>\n * The add methods are affected by this class.\n * Thus objects must be removed or searched for using their transformed form.\n * For example, if the transformation converts Strings to Integers, you must\n * use the Integer form to remove objects.\n * </p>\n *\n * @param <E> the type of the elements in this set\n * @since 4.1\n ",
      "methods": {
        "transformedNavigableSet": {
          "Javadoc": "* Factory method to create a transforming navigable set that will transform\n     * existing contents of the specified navigable set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingNavigableSet(NavigableSet, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed {@link NavigableSet}\n     * @throws NullPointerException if set or transformer is null"
        },
        "transformingNavigableSet": {
          "Javadoc": "* Factory method to create a transforming navigable set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedNavigableSet(NavigableSet, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed {@link NavigableSet}\n     * @throws NullPointerException if set or transformer is null"
        },
        "decorated": {
          "Javadoc": "* Gets the decorated navigable set.\n     *\n     * @return the decorated navigable set"
        }
      }
    },
    "org.apache.commons.collections4.set.TransformedSet": {
      "Javadoc": "\n * Decorates another {@code Set} to transform objects that are added.\n * <p>\n * The add methods are affected by this class.\n * Thus objects must be removed or searched for using their transformed form.\n * For example, if the transformation converts Strings to Integers, you must\n * use the Integer form to remove objects.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <E> the type of the elements in this set\n * @since 3.0\n ",
      "methods": {
        "transformedSet": {
          "Javadoc": "* Factory method to create a transforming set that will transform\n     * existing contents of the specified set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingSet(Set, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed set\n     * @throws NullPointerException if set or transformer is null\n     * @since 4.0"
        },
        "transformingSet": {
          "Javadoc": "* Factory method to create a transforming set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedSet(Set, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed set\n     * @throws NullPointerException if set or transformer is null\n     * @since 4.0"
        }
      }
    },
    "org.apache.commons.collections4.set.TransformedSortedSet": {
      "Javadoc": "\n * Decorates another {@code SortedSet} to transform objects that are added.\n * <p>\n * The add methods are affected by this class.\n * Thus objects must be removed or searched for using their transformed form.\n * For example, if the transformation converts Strings to Integers, you must\n * use the Integer form to remove objects.\n * </p>\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n *\n * @param <E> the type of the elements in this set\n * @since 3.0\n ",
      "methods": {
        "transformedSortedSet": {
          "Javadoc": "* Factory method to create a transforming sorted set that will transform\n     * existing contents of the specified sorted set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingSortedSet(SortedSet, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed {@link SortedSet}\n     * @throws NullPointerException if set or transformer is null\n     * @since 4.0"
        },
        "transformingSortedSet": {
          "Javadoc": "* Factory method to create a transforming sorted set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedSortedSet(SortedSet, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed {@link SortedSet}\n     * @throws NullPointerException if set or transformer is null\n     * @since 4.0"
        },
        "getSortedSet": {
          "Javadoc": "* Gets the decorated set.\n     *\n     * @return the decorated set"
        }
      }
    },
    "org.apache.commons.collections4.set.UnmodifiableNavigableSet": {
      "Javadoc": "\n * Decorates another {@code NavigableSet} to ensure it can't be altered.\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <E> the type of the elements in this set\n * @since 4.1\n ",
      "methods": {
        "unmodifiableNavigableSet": {
          "Javadoc": "* Factory method to create an unmodifiable set.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @return a new unmodifiable {@link NavigableSet}\n     * @throws NullPointerException if set is null"
        },
        "pollFirst": {
          "Javadoc": "* @since 4.5"
        },
        "pollLast": {
          "Javadoc": "* @since 4.5"
        },
        "readObject": {
          "Javadoc": "* Read the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        },
        "writeObject": {
          "Javadoc": "* Write the collection out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.set.UnmodifiableSet": {
      "Javadoc": "\n * Decorates another {@code Set} to ensure it can't be altered.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <E> the type of the elements in this set\n * @since 3.0\n ",
      "methods": {
        "unmodifiableSet": {
          "Javadoc": "* Factory method to create an unmodifiable set.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @return a new unmodifiable set\n     * @throws NullPointerException if set is null\n     * @since 4.0"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        }
      }
    },
    "org.apache.commons.collections4.set.UnmodifiableSortedSet": {
      "Javadoc": "\n * Decorates another {@code SortedSet} to ensure it can't be altered.\n * <p>\n * This class is Serializable from Commons Collections 3.1.\n * </p>\n * <p>\n * Attempts to modify it will result in an UnsupportedOperationException.\n * </p>\n *\n * @param <E> the type of the elements in this set\n * @since 3.0\n ",
      "methods": {
        "unmodifiableSortedSet": {
          "Javadoc": "* Factory method to create an unmodifiable set.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @return a new unmodifiable {@link SortedSet}\n     * @throws NullPointerException if set is null\n     * @since 4.0"
        },
        "readObject": {
          "Javadoc": "* Read the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded"
        },
        "removeIf": {
          "Javadoc": "* @since 4.4"
        },
        "writeObject": {
          "Javadoc": "* Write the collection out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.SetUtils": {
      "Javadoc": "\n * Provides utility methods and decorators for\n * {@link Set} and {@link SortedSet} instances.\n *\n * @since 2.1\n ",
      "methods": {
        "difference": {
          "Javadoc": "* Returns an unmodifiable <b>view</b> containing the difference of the given\n     * {@link Set}s, denoted by {@code a \\ b} (or {@code a - b}).\n     * <p>\n     * The returned view contains all elements of {@code a} that are not a member\n     * of {@code b}.\n     *\n     * @param <E> the generic type that is able to represent the types contained\n     *   in both input sets.\n     * @param setA  the set to subtract from, must not be null\n     * @param setB  the set to subtract, must not be null\n     * @return a view of the relative complement of the two sets\n     * @since 4.1"
        },
        "disjunction": {
          "Javadoc": "* Returns an unmodifiable <b>view</b> of the symmetric difference of the given\n     * {@link Set}s.\n     * <p>\n     * The returned view contains all elements of {@code a} and {@code b} that are\n     * not a member of the other set.\n     * <p>\n     * This is equivalent to {@code union(difference(a, b), difference(b, a))}.\n     *\n     * @param <E> the generic type that is able to represent the types contained\n     *   in both input sets.\n     * @param setA  the first set, must not be null\n     * @param setB  the second set, must not be null\n     * @return a view of the symmetric difference of the two sets\n     * @since 4.1"
        },
        "emptyIfNull": {
          "Javadoc": "* Returns an immutable empty set if the argument is {@code null},\n     * or the argument itself otherwise.\n     *\n     * @param <T> the element type\n     * @param set the set, possibly {@code null}\n     * @return an empty set if the argument is {@code null}"
        },
        "emptySet": {
          "Javadoc": "* Gets a typed empty unmodifiable Set.\n     * @param <E> the element type\n     * @return an empty Set"
        },
        "emptySortedSet": {
          "Javadoc": "* Gets a typed empty unmodifiable sorted set.\n     * @param <E> the element type\n     * @return an empty sorted Set"
        },
        "hashCodeForSet": {
          "Javadoc": "* Generates a hash code using the algorithm specified in\n     * {@link java.util.Set#hashCode()}.\n     * <p>\n     * This method is useful for implementing {@code Set} when you cannot\n     * extend AbstractSet. The method takes Collection instances to enable other\n     * collection types to use the Set implementation algorithm.\n     *\n     * @param <T> the element type\n     * @see java.util.Set#hashCode()\n     * @param set  the set to calculate the hash code for, may be null\n     * @return the hash code"
        },
        "hashSet": {
          "Javadoc": "* Creates a set from the given items. If the passed var-args argument is {@code\n     * null}, then the method returns {@code null}.\n     * @param <E> the element type\n     * @param items the elements that make up the new set\n     * @return a set\n     * @since 4.3"
        },
        "intersection": {
          "Javadoc": "* Returns an unmodifiable <b>view</b> of the intersection of the given {@link Set}s.\n     * <p>\n     * The returned view contains all elements that are members of both input sets\n     * ({@code a} and {@code b}).\n     *\n     * @param <E> the generic type that is able to represent the types contained\n     *   in both input sets.\n     * @param setA  the first set, must not be null\n     * @param setB  the second set, must not be null\n     * @return a view of the intersection of the two sets\n     * @since 4.1"
        },
        "isEqualSet": {
          "Javadoc": "* Tests two sets for equality as per the {@code equals()} contract\n     * in {@link java.util.Set#equals(Object)}.\n     * <p>\n     * This method is useful for implementing {@code Set} when you cannot\n     * extend AbstractSet. The method takes Collection instances to enable other\n     * collection types to use the Set implementation algorithm.\n     * <p>\n     * The relevant text (slightly paraphrased as this is a static method) is:\n     * <blockquote>\n     * <p>Two sets are considered equal if they have\n     * the same size, and every member of the first set is contained in\n     * the second. This ensures that the {@code equals} method works\n     * properly across different implementations of the {@code Set}\n     * interface.</p>\n     *\n     * <p>\n     * This implementation first checks if the two sets are the same object:\n     * if so it returns {@code true}.  Then, it checks if the two sets are\n     * identical in size; if not, it returns false. If so, it returns\n     * {@code a.containsAll((Collection) b)}.</p>\n     * </blockquote>\n     *\n     * @see java.util.Set\n     * @param set1  the first set, may be null\n     * @param set2  the second set, may be null\n     * @return whether the sets are equal by value comparison"
        },
        "newIdentityHashSet": {
          "Javadoc": "* Returns a new hash set that matches elements based on {@code ==} not\n     * {@code equals()}.\n     * <p>\n     * <strong>This set will violate the detail of various Set contracts.</strong>\n     * As a general rule, don't compare this set to other sets. In particular, you can't\n     * use decorators like {@link ListOrderedSet} on it, which silently assume that these\n     * contracts are fulfilled.\n     * <p>\n     * <strong>Note that the returned set is not synchronized and is not thread-safe.</strong>\n     * If you wish to use this set from multiple threads concurrently, you must use\n     * appropriate synchronization. The simplest approach is to wrap this map\n     * using {@link java.util.Collections#synchronizedSet(Set)}. This class may throw\n     * exceptions when accessed by concurrent threads without synchronization.\n     *\n     * @param <E>  the element type\n     * @return a new identity hash set\n     * @since 4.1"
        },
        "orderedSet": {
          "Javadoc": "* Returns a set that maintains the order of elements that are added\n     * backed by the given set.\n     * <p>\n     * If an element is added twice, the order is determined by the first add.\n     * The order is observed through the iterator or toArray.\n     *\n     * @param <E> the element type\n     * @param set  the set to order, must not be null\n     * @return an ordered set backed by the given set\n     * @throws NullPointerException if the set is null"
        },
        "predicatedNavigableSet": {
          "Javadoc": "* Returns a predicated (validating) navigable set backed by the given navigable set.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to the set.\n     * Trying to add an invalid object results in an IllegalArgumentException.\n     * It is important not to use the original set after invoking this method,\n     * as it is a backdoor for adding invalid objects.\n     *\n     * @param <E> the element type\n     * @param set  the navigable set to predicate, must not be null\n     * @param predicate  the predicate for the navigable set, must not be null\n     * @return a predicated navigable set backed by the given navigable set\n     * @throws NullPointerException if the set or predicate is null\n     * @since 4.1"
        },
        "predicatedSet": {
          "Javadoc": "* Returns a predicated (validating) set backed by the given set.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to the set.\n     * Trying to add an invalid object results in an IllegalArgumentException.\n     * It is important not to use the original set after invoking this method,\n     * as it is a backdoor for adding invalid objects.\n     *\n     * @param <E> the element type\n     * @param set  the set to predicate, must not be null\n     * @param predicate  the predicate for the set, must not be null\n     * @return a predicated set backed by the given set\n     * @throws NullPointerException if the set or predicate is null"
        },
        "predicatedSortedSet": {
          "Javadoc": "* Returns a predicated (validating) sorted set backed by the given sorted set.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to the set.\n     * Trying to add an invalid object results in an IllegalArgumentException.\n     * It is important not to use the original set after invoking this method,\n     * as it is a backdoor for adding invalid objects.\n     *\n     * @param <E> the element type\n     * @param set  the sorted set to predicate, must not be null\n     * @param predicate  the predicate for the sorted set, must not be null\n     * @return a predicated sorted set backed by the given sorted set\n     * @throws NullPointerException if the set or predicate is null"
        },
        "synchronizedSet": {
          "Javadoc": "* Returns a synchronized set backed by the given set.\n     * <p>\n     * You must manually synchronize on the returned set's iterator to\n     * avoid non-deterministic behavior:\n     *\n     * <pre>\n     * Sets s = SetUtils.synchronizedSet(mySet);\n     * synchronized (s) {\n     *     Iterator i = s.iterator();\n     *     while (i.hasNext()) {\n     *         process (i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * This method is just a wrapper for {@link Collections#synchronizedSet(Set)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to synchronize, must not be null\n     * @return a synchronized set backed by the given set\n     * @throws NullPointerException if the set is null"
        },
        "synchronizedSortedSet": {
          "Javadoc": "* Returns a synchronized sorted set backed by the given sorted set.\n     * <p>\n     * You must manually synchronize on the returned set's iterator to\n     * avoid non-deterministic behavior:\n     *\n     * <pre>\n     * Set s = SetUtils.synchronizedSortedSet(mySet);\n     * synchronized (s) {\n     *     Iterator i = s.iterator();\n     *     while (i.hasNext()) {\n     *         process (i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * This method is just a wrapper for {@link Collections#synchronizedSortedSet(SortedSet)}.\n     *\n     * @param <E> the element type\n     * @param set  the sorted set to synchronize, must not be null\n     * @return a synchronized set backed by the given set\n     * @throws NullPointerException if the set is null"
        },
        "transformedNavigableSet": {
          "Javadoc": "* Returns a transformed navigable set backed by the given navigable set.\n     * <p>\n     * Each object is passed through the transformer as it is added to the\n     * Set. It is important not to use the original set after invoking this\n     * method, as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified set will not be transformed.\n     * If you want that behavior, see {@link TransformedNavigableSet#transformedNavigableSet}.\n     *\n     * @param <E> the element type\n     * @param set  the navigable set to transform, must not be null\n     * @param transformer  the transformer for the set, must not be null\n     * @return a transformed set backed by the given set\n     * @throws NullPointerException if the set or transformer is null\n     * @since 4.1"
        },
        "transformedSet": {
          "Javadoc": "* Returns a transformed set backed by the given set.\n     * <p>\n     * Each object is passed through the transformer as it is added to the\n     * Set. It is important not to use the original set after invoking this\n     * method, as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified set will not be transformed.\n     * If you want that behavior, see {@link TransformedSet#transformedSet}.\n     *\n     * @param <E> the element type\n     * @param set  the set to transform, must not be null\n     * @param transformer  the transformer for the set, must not be null\n     * @return a transformed set backed by the given set\n     * @throws NullPointerException if the set or transformer is null"
        },
        "transformedSortedSet": {
          "Javadoc": "* Returns a transformed sorted set backed by the given set.\n     * <p>\n     * Each object is passed through the transformer as it is added to the\n     * Set. It is important not to use the original set after invoking this\n     * method, as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified set will not be transformed.\n     * If you want that behavior, see {@link TransformedSortedSet#transformedSortedSet}.\n     *\n     * @param <E> the element type\n     * @param set  the set to transform, must not be null\n     * @param transformer  the transformer for the set, must not be null\n     * @return a transformed set backed by the given set\n     * @throws NullPointerException if the set or transformer is null"
        },
        "union": {
          "Javadoc": "* Returns an unmodifiable <b>view</b> of the union of the given {@link Set}s.\n     * <p>\n     * The returned view contains all elements of {@code a} and {@code b}.\n     *\n     * @param <E> the generic type that is able to represent the types contained\n     *   in both input sets.\n     * @param setA  the first set, must not be null\n     * @param setB  the second set, must not be null\n     * @return a view of the union of the two set\n     * @throws NullPointerException if either input set is null\n     * @since 4.1"
        },
        "unmodifiableNavigableSet": {
          "Javadoc": "* Returns an unmodifiable navigable set backed by the given navigable set.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     *\n     * @param <E> the element type\n     * @param set  the navigable set to make unmodifiable, must not be null\n     * @return an unmodifiable set backed by the given set\n     * @throws NullPointerException if the set is null\n     * @since 4.1"
        },
        "unmodifiableSet": {
          "Javadoc": "* Returns an unmodifiable set backed by the given set.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     *\n     * @param <E> the element type\n     * @param set  the set to make unmodifiable, must not be null\n     * @return an unmodifiable set backed by the given set\n     * @throws NullPointerException if the set is null"
        },
        "unmodifiableSortedSet": {
          "Javadoc": "* Returns an unmodifiable sorted set backed by the given sorted set.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     *\n     * @param <E> the element type\n     * @param set  the sorted set to make unmodifiable, must not be null\n     * @return an unmodifiable set backed by the given set\n     * @throws NullPointerException if the set is null"
        }
      }
    },
    "org.apache.commons.collections4.SetView": {
      "Javadoc": "\n     * An unmodifiable <b>view</b> of a set that may be backed by other sets.\n     * <p>\n     * If the decorated sets change, this view will change as well. The contents\n     * of this view can be transferred to another instance via the {@link #copyInto(Set)}\n     * and {@link #toSet()} methods.\n     *\n     * @param <E> the element type\n     * @since 4.1\n     ",
      "methods": {
        "copyInto": {
          "Javadoc": "* Copies the contents of this view into the provided set.\n         *\n         * @param <S> the set type\n         * @param set  the set for copying the contents"
        },
        "createIterator": {
          "Javadoc": "* Return an iterator for this view; the returned iterator is\n         * not required to be unmodifiable.\n         * @return a new iterator for this view"
        },
        "toSet": {
          "Javadoc": "* Returns a new set containing the contents of this view.\n         *\n         * @return a new set containing all elements of this view"
        }
      }
    },
    "org.apache.commons.collections4.SetValuedMap": {
      "Javadoc": "\n * Defines a map that holds a set of values against each key.\n * <p>\n * A {@code SetValuedMap} is a Map with slightly different semantics:\n * </p>\n * <ul>\n *   <li>Putting a value into the map will add the value to a {@link Set} at that key.</li>\n *   <li>Getting a value will return a {@link Set}, holding all the values put to that key.</li>\n * </ul>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.1\n ",
      "methods": {
        "get": {
          "Javadoc": "* Gets the set of values associated with the specified key.\n     * <p>\n     * Implementations typically return an empty {@code Set} if no values\n     * have been mapped to the key.\n     * <p>\n     *\n     * @param key  the key to retrieve\n     * @return the {@code Set} of values, implementations should return an\n     *   empty {@code Set} for no mapping\n     * @throws NullPointerException if the key is null and null keys are invalid"
        },
        "remove": {
          "Javadoc": "* Removes all values associated with the specified key.\n     * <p>\n     * The returned set <i>may</i> be modifiable, but updates will not be\n     * propagated to this set-valued map. In case no mapping was stored for the\n     * specified key, an empty, unmodifiable set will be returned.\n     *\n     * @param key  the key to remove values from\n     * @return the {@code Set} of values removed, implementations should\n     *   return null for no mapping found, but may return an empty collection\n     * @throws UnsupportedOperationException if the map is unmodifiable\n     * @throws NullPointerException if the key is null and null keys are invalid"
        }
      }
    },
    "org.apache.commons.collections4.SortedBag": {
      "Javadoc": "\n * Defines a type of {@code Bag} that maintains a sorted order among\n * its unique representative members.\n *\n * @param <E> the type of elements in this bag\n * @since 2.0\n ",
      "methods": {
        "comparator": {
          "Javadoc": "* Returns the comparator associated with this sorted set, or null\n     * if it uses its elements' natural ordering.\n     *\n     * @return the comparator in use, or null if natural ordering"
        },
        "first": {
          "Javadoc": "* Returns the first (lowest) member.\n     *\n     * @return the first element in the sorted bag"
        },
        "last": {
          "Javadoc": "* Returns the last (highest) member.\n     *\n     * @return the last element in the sorted bag"
        }
      }
    },
    "org.apache.commons.collections4.SortedBidiMap": {
      "Javadoc": "\n * Defines a map that allows bidirectional lookup between key and values\n * and retains both keys and values in sorted order.\n * <p>\n * Implementations should allow a value to be looked up from a key and\n * a key to be looked up from a value with equal performance.\n * </p>\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n * @since 3.0\n ",
      "methods": {
        "inverseBidiMap": {
          "Javadoc": "* Gets a view of this map where the keys and values are reversed.\n     * <p>\n     * Changes to one map will be visible in the other and vice versa.\n     * This enables both directions of the map to be accessed equally.\n     * <p>\n     * Implementations should seek to avoid creating a new object every time this\n     * method is called. See {@code AbstractMap.values()} etc. Calling this\n     * method on the inverse map should return the original.\n     * <p>\n     * Implementations must return a {@code SortedBidiMap} instance,\n     * usually by forwarding to {@code inverseSortedBidiMap()}.\n     *\n     * @return an inverted bidirectional map"
        },
        "valueComparator": {
          "Javadoc": "* Gets the comparator used for the values in the value-to-key map aspect.\n     * @return Comparator&lt;? super V&gt;"
        }
      }
    },
    "org.apache.commons.collections4.splitmap.AbstractIterableGetMapDecorator": {
      "Javadoc": "\n * {@link IterableGet} that uses a {@link Map}&lt;K, V&gt; for the\n * {@link org.apache.commons.collections4.Get Get}&lt;K, V&gt; implementation.\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.0\n ",
      "methods": {
        "decorated": {
          "Javadoc": "* Gets the map being decorated.\n     *\n     * @return the decorated map"
        },
        "mapIterator": {
          "Javadoc": "* Gets a MapIterator over this Get.\n     * @return MapIterator&lt;K, V&gt;"
        }
      }
    },
    "org.apache.commons.collections4.splitmap.TransformedSplitMap": {
      "Javadoc": "\n * Decorates another {@link Map} to transform objects that are added.\n * <p>\n * The Map put methods and Map.Entry setValue method are affected by this class.\n * Thus objects must be removed or searched for using their transformed form.\n * For example, if the transformation converts Strings to Integers, you must use\n * the Integer form to remove objects.\n * </p>\n * <p>\n * <strong>Note that TransformedMap is not synchronized and is not\n * thread-safe.</strong> If you wish to use this map from multiple threads\n * concurrently, you must use appropriate synchronization. The simplest approach\n * is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.\n * This class may throw exceptions when accessed by concurrent threads without\n * synchronization.\n * </p>\n * <p>\n * The \"put\" and \"get\" type constraints of this class are mutually independent;\n * contrast with {@link org.apache.commons.collections4.map.TransformedMap} which,\n * by virtue of its implementing {@link Map}&lt;K, V&gt;, must be constructed in such\n * a way that its read and write parameters are generalized to a common (super-)type.\n * In practice this would often mean {@code &gt;Object, Object&gt;}, defeating\n * much of the usefulness of having parameterized types.\n * </p>\n * <p>\n * On the downside, this class is not drop-in compatible with {@link java.util.Map}\n * but is intended to be worked with either directly or by {@link Put} and\n * {@link org.apache.commons.collections4.Get Get} generalizations.\n * </p>\n *\n * @param <J> the type of the keys to put in this map\n * @param <K> the type of the keys to get in this map\n * @param <U> the type of the values to put in this map\n * @param <V> the type of the values to get in this map\n * @since 4.0\n *\n * @see org.apache.commons.collections4.SplitMapUtils#readableMap(org.apache.commons.collections4.Get)\n * @see org.apache.commons.collections4.SplitMapUtils#writableMap(Put)\n ",
      "methods": {
        "transformingMap": {
          "Javadoc": "* Factory method to create a transforming map.\n     * <p>\n     * If there are any elements already in the map being decorated, they are\n     * NOT transformed.\n     *\n     * @param <J>  the input key type\n     * @param <K>  the output key type\n     * @param <U>  the input value type\n     * @param <V>  the output value type\n     * @param map the map to decorate, must not be null\n     * @param keyTransformer the transformer to use for key conversion, must not be null\n     * @param valueTransformer the transformer to use for value conversion, must not be null\n     * @return a new transformed map\n     * @throws NullPointerException if map or either of the transformers is null"
        },
        "checkSetValue": {
          "Javadoc": "* Override to transform the value when using {@code setValue}.\n     *\n     * @param value the value to transform\n     * @return the transformed value"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1"
        },
        "transformKey": {
          "Javadoc": "* Transforms a key.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object the object to transform\n     * @return the transformed object"
        },
        "transformMap": {
          "Javadoc": "* Transforms a map.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param map the map to transform\n     * @return the transformed object"
        },
        "transformValue": {
          "Javadoc": "* Transforms a value.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object the object to transform\n     * @return the transformed object"
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine.\n     *\n     * @param out the output stream\n     * @throws IOException if an error occurs while writing to the stream"
        }
      }
    },
    "org.apache.commons.collections4.SplitMapUtils": {
      "Javadoc": "\n * Utilities for working with \"split maps:\" objects that implement {@link Put}\n * and/or {@link Get} but not {@link Map}.\n *\n * @since 4.0\n *\n * @see Get\n * @see Put\n ",
      "methods": {
        "readableMap": {
          "Javadoc": "* Gets the specified {@link Get} as an instance of {@link IterableMap}.\n     * If {@code get} implements {@link IterableMap} directly, no conversion will take place.\n     * If {@code get} implements {@link Map} but not {@link IterableMap} it will be decorated.\n     * Otherwise, an {@link Unmodifiable} {@link IterableMap} will be returned.\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param get to wrap, must not be null\n     * @return {@link IterableMap}\n     * @throws NullPointerException if the argument is null"
        },
        "writableMap": {
          "Javadoc": "* Gets the specified {@link Put} as an instanceof {@link Map}.\n     * If {@code put} implements {@link Map} directly, no conversion will take place.\n     * Otherwise, a <em>write-only</em> {@link Map} will be returned.  On such a {@link Map}\n     * it is recommended that the result of #put(K, V) be discarded as it likely will not\n     * match {@code V} at runtime.\n     *\n     * @param <K> the key type\n     * @param <V> the element type\n     * @param put to wrap, must not be null\n     * @return {@link Map}\n     * @throws NullPointerException if the argument is null"
        }
      }
    },
    "org.apache.commons.collections4.WrappedGet": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.WrappedPut": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.Transformer": {
      "Javadoc": "\n * Defines a functor interface implemented by classes that transform one\n * object into another.\n * <p>\n * A {@code Transformer} converts the input object to the output object.\n * The input object should be left unchanged.\n * Transformers are typically used for type conversions, or extracting data\n * from an object.\n * </p>\n * <p>\n * Standard implementations of common transformers are provided by\n * {@link TransformerUtils}. These include method invocation, returning a constant,\n * cloning and returning the string value.\n * </p>\n *\n * @param <I> the input type to the transformer\n * @param <O> the output type from the transformer\n *\n * @since 1.0\n ",
      "methods": {
        "transform": {
          "Javadoc": "* Transforms the input object (leaving it unchanged) into some output object.\n     *\n     * @param input  the object to be transformed, should be left unchanged\n     * @return a transformed object\n     * @throws ClassCastException (runtime) if the input is the wrong class\n     * @throws IllegalArgumentException (runtime) if the input is invalid\n     * @throws FunctorException (runtime) if the transform cannot be completed"
        }
      }
    },
    "org.apache.commons.collections4.TransformerUtils": {
      "Javadoc": "\n * {@code TransformerUtils} provides reference implementations and\n * utilities for the Transformer functor interface. The supplied transformers are:\n * <ul>\n * <li>Invoker - returns the result of a method call on the input object\n * <li>Clone - returns a clone of the input object\n * <li>Constant - always returns the same object\n * <li>Closure - performs a Closure and returns the input object\n * <li>Predicate - returns the result of the predicate as a Boolean\n * <li>Factory - returns a new object from a factory\n * <li>Chained - chains two or more transformers together\n * <li>If - calls one transformer or another based on a predicate\n * <li>Switch - calls one transformer based on one or more predicates\n * <li>SwitchMap - calls one transformer looked up from a Map\n * <li>Instantiate - the Class input object is instantiated\n * <li>Map - returns an object from a supplied Map\n * <li>Null - always returns null\n * <li>NOP - returns the input object, which should be immutable\n * <li>Exception - always throws an exception\n * <li>StringValue - returns a {@link String} representation of the input object\n * </ul>\n * <p>\n * Since v4.1 only transformers which are considered to be safe are\n * Serializable. Transformers considered to be unsafe for serialization are:\n * </p>\n * <ul>\n * <li>Invoker\n * <li>Clone\n * <li>Instantiate\n * </ul>\n *\n * @since 3.0\n ",
      "methods": {
        "asTransformer": {
          "Javadoc": "* Creates a Transformer that calls a Predicate each time the transformer is used.\n     * The transformer will return either {@link Boolean#TRUE} or {@link Boolean#FALSE}.\n     *\n     * @param <T>  the input type\n     * @param predicate  the predicate to run each time in the transformer, not null\n     * @return the transformer\n     * @throws NullPointerException if the predicate is null\n     * @see PredicateTransformer"
        },
        "chainedTransformer": {
          "Javadoc": "* Create a new Transformer that calls each transformer in turn, passing the\n     * result into the next transformer.\n     *\n     * @param <T>  the input/output type\n     * @param transformers  an array of transformers to chain\n     * @return the transformer\n     * @throws NullPointerException if the transformers array or any of the transformers is null\n     * @see ChainedTransformer"
        },
        "cloneTransformer": {
          "Javadoc": "* Gets a transformer that returns a clone of the input object.\n     * The input object will be cloned using one of these techniques (in order):\n     * <ul>\n     * <li>public clone method</li>\n     * <li>public copy constructor</li>\n     * <li>serialization clone</li>\n     * </ul>\n     *\n     * @param <T>  the input/output type\n     * @return the transformer\n     * @see CloneTransformer"
        },
        "constantTransformer": {
          "Javadoc": "* Creates a Transformer that will return the same object each time the\n     * transformer is used.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param constantToReturn  the constant object to return each time in the transformer\n     * @return the transformer.\n     * @see ConstantTransformer"
        },
        "exceptionTransformer": {
          "Javadoc": "* Gets a transformer that always throws an exception.\n     * This could be useful during testing as a placeholder.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @return the transformer\n     * @see ExceptionTransformer"
        },
        "ifTransformer": {
          "Javadoc": "* Create a new Transformer that calls the transformer if the predicate is true,\n     * otherwise the input object is returned unchanged.\n     *\n     * @param <T>  the input / output type\n     * @param predicate  the predicate to switch on\n     * @param trueTransformer  the transformer called if the predicate is true\n     * @return the transformer\n     * @throws NullPointerException if either the predicate or transformer is null\n     * @see IfTransformer\n     * @since 4.1"
        },
        "instantiateTransformer": {
          "Javadoc": "* Creates a Transformer that expects an input Class object that it will\n     * instantiate. The constructor used is determined by the arguments specified\n     * to this method.\n     *\n     * @param <T>  the output type\n     * @param paramTypes  parameter types for the constructor, can be null\n     * @param args  the arguments to pass to the constructor, can be null\n     * @return the transformer\n     * @throws IllegalArgumentException if the paramTypes and args don't match\n     * @see InstantiateTransformer"
        },
        "invokerTransformer": {
          "Javadoc": "* Gets a Transformer that invokes a method on the input object.\n     * The method parameters are specified. If the input object is {@code null},\n     * {@code null} is returned.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param methodName  the name of the method\n     * @param paramTypes  the parameter types\n     * @param args  the arguments\n     * @return the transformer\n     * @throws NullPointerException if the method name is null\n     * @throws IllegalArgumentException if the paramTypes and args don't match\n     * @see InvokerTransformer"
        },
        "mapTransformer": {
          "Javadoc": "* Creates a Transformer that uses the passed in Map to transform the input\n     * object (as a simple lookup).\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param map  the map to use to transform the objects\n     * @return the transformer, or {@link ConstantTransformer#nullTransformer()} if the\n     *   {@code map} is {@code null}\n     * @see MapTransformer"
        },
        "nopTransformer": {
          "Javadoc": "* Gets a transformer that returns the input object.\n     * The input object should be immutable to maintain the\n     * contract of Transformer (although this is not checked).\n     *\n     * @param <T>  the input/output type\n     * @return the transformer\n     * @see NOPTransformer"
        },
        "nullTransformer": {
          "Javadoc": "* Gets a transformer that always returns null.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @return the transformer\n     * @see ConstantTransformer"
        },
        "stringValueTransformer": {
          "Javadoc": "* Gets a transformer that returns a {@link String}\n     * representation of the input object. This is achieved via the\n     * {@code toString} method, {@code null} returns 'null'.\n     *\n     * @param <T>  the input type\n     * @return the transformer\n     * @see StringValueTransformer"
        },
        "switchMapTransformer": {
          "Javadoc": "* Create a new Transformer that uses the input object as a key to find the\n     * transformer to call.\n     * <p>\n     * The Map consists of object keys and Transformer values. A transformer\n     * is called if the input object equals the key. If there is no match, the\n     * default transformer is called. The default transformer is set in the map\n     * using a null key. If no default is set, null will be returned in a default case.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param objectsAndTransformers  a map of objects to transformers\n     * @return the transformer\n     * @throws NullPointerException if the map is null\n     * @throws NullPointerException if any transformer in the map is null\n     * @see SwitchTransformer"
        },
        "switchTransformer": {
          "Javadoc": "* Create a new Transformer that calls one of the transformers depending\n     * on the predicates. The transformer at array location 0 is called if the\n     * predicate at array location 0 returned true. Each predicate is evaluated\n     * until one returns true. If no predicates evaluate to true, the default\n     * transformer is called. If the default transformer is null, null is returned.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param predicates  an array of predicates to check\n     * @param transformers  an array of transformers to call\n     * @param defaultTransformer  the default to call if no predicate matches, null means return null\n     * @return the transformer\n     * @throws NullPointerException if either array is null\n     * @throws NullPointerException if any element in the arrays is null\n     * @throws IllegalArgumentException if the arrays have different sizes\n     * @see SwitchTransformer"
        }
      }
    },
    "org.apache.commons.collections4.trie.AbstractBitwiseTrie": {
      "Javadoc": "\n * This class provides some basic {@link Trie} functionality and\n * utility methods for actual bitwise {@link Trie} implementations.\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.0\n ",
      "methods": {
        "compare": {
          "Javadoc": "* Delegates to {@link Objects#equals(Object, Object)}."
        },
        "bitIndex": {
          "Javadoc": "* Utility method for calling {@link KeyAnalyzer#bitIndex(Object, int, int, Object, int, int)}."
        },
        "bitsPerElement": {
          "Javadoc": "* Returns the number of bits per element in the key\n     *\n     * @see KeyAnalyzer#bitsPerElement()"
        },
        "castKey": {
          "Javadoc": "* A utility method to cast keys. It actually doesn't cast anything. It's just fooling the compiler!"
        },
        "compareKeys": {
          "Javadoc": "* A utility method for calling {@link KeyAnalyzer#compare(Object, Object)}"
        },
        "getKeyAnalyzer": {
          "Javadoc": "* Returns the {@link KeyAnalyzer} that constructed the {@link Trie}.\n     * @return the {@link KeyAnalyzer} used by this {@link Trie}"
        },
        "isBitSet": {
          "Javadoc": "* Returns whether or not the given bit on the key is set or false if the key is null.\n     *\n     * @see KeyAnalyzer#isBitSet(Object, int, int)"
        },
        "lengthInBits": {
          "Javadoc": "* Returns the length of the given key in bits\n     *\n     * @see KeyAnalyzer#lengthInBits(Object)"
        }
      }
    },
    "org.apache.commons.collections4.trie.BasicEntry": {
      "Javadoc": "\n     * A basic implementation of {@link Entry}.\n     ",
      "methods": {
        "setKeyValue": {
          "Javadoc": "* Replaces the current key and value with the provided key &amp; value."
        }
      }
    },
    "org.apache.commons.collections4.trie.AbstractPatriciaTrie": {
      "Javadoc": "\n * This class implements the base PATRICIA algorithm and everything that\n * is related to the {@link Map} interface.\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.0\n ",
      "methods": {
        "isValidUplink": {
          "Javadoc": "* Returns true if 'next' is a valid uplink coming from 'from'."
        },
        "addEntry": {
          "Javadoc": "* Adds the given {@link TrieEntry} to the {@link org.apache.commons.collections4.Trie}."
        },
        "ceilingEntry": {
          "Javadoc": "* Returns a key-value mapping associated with the least key greater\n     * than or equal to the given key, or null if there is no such key."
        },
        "decrementSize": {
          "Javadoc": "* A helper method to decrement the {@link org.apache.commons.collections4.Trie} size and increment the modification counter."
        },
        "firstEntry": {
          "Javadoc": "* Returns the first entry the {@link org.apache.commons.collections4.Trie} is storing.\n     * <p>\n     * This is implemented by going always to the left until\n     * we encounter a valid uplink. That uplink is the first key."
        },
        "floorEntry": {
          "Javadoc": "* Returns a key-value mapping associated with the greatest key\n     * less than or equal to the given key, or null if there is no such key."
        },
        "followLeft": {
          "Javadoc": "* Goes left through the tree until it finds a valid node."
        },
        "followRight": {
          "Javadoc": "* Traverses down the right path until it finds an uplink."
        },
        "getEntry": {
          "Javadoc": "* Returns the entry associated with the specified key in the\n     * PatriciaTrieBase.  Returns null if the map contains no mapping\n     * for this key.\n     * <p>\n     * This may throw ClassCastException if the object is not of type K."
        },
        "getNearestEntryForKey": {
          "Javadoc": "* Returns the nearest entry for a given key.  This is useful\n     * for finding knowing if a given key exists (and finding the value\n     * for it), or for inserting the key.\n     *\n     * The actual get implementation. This is very similar to\n     * selectR but with the exception that it might return the\n     * root Entry even if it's empty."
        },
        "getPrefixMapByBits": {
          "Javadoc": "* Returns a view of this {@link org.apache.commons.collections4.Trie} of all elements that are prefixed\n     * by the number of bits in the given Key.\n     * <p>\n     * The view that this returns is optimized to have a very efficient\n     * {@link Iterator}. The {@link SortedMap#firstKey()},\n     * {@link SortedMap#lastKey()} &amp; {@link Map#size()} methods must\n     * iterate over all possible values in order to determine the results.\n     * This information is cached until the PATRICIA {@link org.apache.commons.collections4.Trie} changes.\n     * All other methods (except {@link Iterator}) must compare the given\n     * key to the prefix to ensure that it is within the range of the view.\n     * The {@link Iterator}'s remove method must also relocate the subtree\n     * that contains the prefixes if the entry holding the subtree is\n     * removed or changes. Changing the subtree takes O(K) time.\n     *\n     * @param key  the key to use in the search\n     * @param offsetInBits  the prefix offset\n     * @param lengthInBits  the number of significant prefix bits\n     * @return a {@link SortedMap} view of this {@link org.apache.commons.collections4.Trie} with all elements whose\n     *   key is prefixed by the search key"
        },
        "higherEntry": {
          "Javadoc": "* Returns an entry strictly higher than the given key,\n     * or null if no such entry exists."
        },
        "incrementModCount": {
          "Javadoc": "* A helper method to increment the modification counter."
        },
        "incrementSize": {
          "Javadoc": "* A helper method to increment the {@link org.apache.commons.collections4.Trie} size and the modification counter."
        },
        "lastEntry": {
          "Javadoc": "* Returns the last entry the {@link org.apache.commons.collections4.Trie} is storing.\n     *\n     * <p>This is implemented by going always to the right until\n     * we encounter a valid uplink. That uplink is the last key."
        },
        "lowerEntry": {
          "Javadoc": "* Returns a key-value mapping associated with the greatest key\n     * strictly less than the given key, or null if there is no such key."
        },
        "nextEntry": {
          "Javadoc": "* Returns the entry lexicographically after the given entry.\n     * If the given entry is null, returns the first node."
        },
        "nextEntryImpl": {
          "Javadoc": "* Scans for the next node, starting at the specified point, and using 'previous'\n     * as a hint that the last node we returned was 'previous' (so we know not to return\n     * it again).  If 'tree' is non-null, this will limit the search to the given tree.\n     *\n     * The basic premise is that each iteration can follow the following steps:\n     *\n     * 1) Scan all the way to the left.\n     *   a) If we already started from this node last time, proceed to Step 2.\n     *   b) If a valid uplink is found, use it.\n     *   c) If the result is an empty node (root not set), break the scan.\n     *   d) If we already returned the left node, break the scan.\n     *\n     * 2) Check the right.\n     *   a) If we already returned the right node, proceed to Step 3.\n     *   b) If it is a valid uplink, use it.\n     *   c) Do Step 1 from the right node.\n     *\n     * 3) Back up through the parents until we encounter find a parent\n     *    that we're not the right child of.\n     *\n     * 4) If there's no right child of that parent, the iteration is finished.\n     *    Otherwise continue to Step 5.\n     *\n     * 5) Check to see if the right child is a valid uplink.\n     *    a) If we already returned that child, proceed to Step 6.\n     *       Otherwise, use it.\n     *\n     * 6) If the right child of the parent is the parent itself, we've\n     *    already found &amp; returned the end of the Trie, so exit.\n     *\n     * 7) Do Step 1 on the parent's right child."
        },
        "nextEntryInSubtree": {
          "Javadoc": "* Returns the entry lexicographically after the given entry.\n     * If the given entry is null, returns the first node.\n     *\n     * This will traverse only within the subtree.  If the given node\n     * is not within the subtree, this will have undefined results."
        },
        "previousEntry": {
          "Javadoc": "* Returns the node lexicographically before the given node (or null if none).\n     *\n     * This follows four simple branches:\n     *  - If the uplink that returned us was a right uplink:\n     *      - If predecessor's left is a valid uplink from predecessor, return it.\n     *      - Else, follow the right path from the predecessor's left.\n     *  - If the uplink that returned us was a left uplink:\n     *      - Loop back through parents until we encounter a node where\n     *        node != node.parent.left.\n     *          - If node.parent.left is uplink from node.parent:\n     *              - If node.parent.left is not root, return it.\n     *              - If it is root &amp; root isEmpty, return null.\n     *              - If it is root &amp; root !isEmpty, return root.\n     *          - If node.parent.left is not uplink from node.parent:\n     *              - Follow right path for first right child from node.parent.left\n     *\n     * @param start  the start entry"
        },
        "readObject": {
          "Javadoc": "* Reads the content of the stream."
        },
        "remove": {
          "Javadoc": "* {@inheritDoc}\n     *\n     * @throws ClassCastException if provided key is of an incompatible type"
        },
        "removeEntry": {
          "Javadoc": "* Removes a single entry from the {@link org.apache.commons.collections4.Trie}.\n     *\n     * If we found a Key (Entry h) then figure out if it's\n     * an internal (hard to remove) or external Entry (easy\n     * to remove)"
        },
        "removeExternalEntry": {
          "Javadoc": "* Removes an external entry from the {@link org.apache.commons.collections4.Trie}.\n     *\n     * If it's an external Entry then just remove it.\n     * This is very easy and straight forward."
        },
        "removeInternalEntry": {
          "Javadoc": "* Removes an internal entry from the {@link org.apache.commons.collections4.Trie}.\n     *\n     * If it's an internal Entry then \"good luck\" with understanding\n     * this code. The Idea is essentially that Entry p takes Entry h's\n     * place in the trie which requires some re-wiring."
        },
        "select": {
          "Javadoc": "* Returns the {@link java.util.Map.Entry} whose key is closest in a bitwise XOR\n     * metric to the given key. This is NOT lexicographic closeness.\n     * For example, given the keys:\n     *\n     * <ol>\n     * <li>D = 1000100\n     * <li>H = 1001000\n     * <li>L = 1001100\n     * </ol>\n     *\n     * If the {@link org.apache.commons.collections4.Trie} contained 'H' and 'L', a lookup of 'D' would\n     * return 'L', because the XOR distance between D &amp; L is smaller\n     * than the XOR distance between D &amp; H.\n     *\n     * @param key  the key to use in the search\n     * @return the {@link java.util.Map.Entry} whose key is closest in a bitwise XOR metric\n     *   to the provided key"
        },
        "selectKey": {
          "Javadoc": "* Returns the key that is closest in a bitwise XOR metric to the\n     * provided key. This is NOT lexicographic closeness!\n     *\n     * For example, given the keys:\n     *\n     * <ol>\n     * <li>D = 1000100\n     * <li>H = 1001000\n     * <li>L = 1001100\n     * </ol>\n     *\n     * If the {@link org.apache.commons.collections4.Trie} contained 'H' and 'L', a lookup of 'D' would\n     * return 'L', because the XOR distance between D &amp; L is smaller\n     * than the XOR distance between D &amp; H.\n     *\n     * @param key  the key to use in the search\n     * @return the key that is closest in a bitwise XOR metric to the provided key"
        },
        "selectValue": {
          "Javadoc": "* Returns the value whose key is closest in a bitwise XOR metric to\n     * the provided key. This is NOT lexicographic closeness!\n     *\n     * For example, given the keys:\n     *\n     * <ol>\n     * <li>D = 1000100\n     * <li>H = 1001000\n     * <li>L = 1001100\n     * </ol>\n     *\n     * If the {@link org.apache.commons.collections4.Trie} contained 'H' and 'L', a lookup of 'D' would\n     * return 'L', because the XOR distance between D &amp; L is smaller\n     * than the XOR distance between D &amp; H.\n     *\n     * @param key  the key to use in the search\n     * @return the value whose key is closest in a bitwise XOR metric\n     * to the provided key"
        },
        "subtree": {
          "Javadoc": "* Finds the subtree that contains the prefix.\n     *\n     * This is very similar to getR but with the difference that\n     * we stop the lookup if h.bitIndex > lengthInBits."
        },
        "writeObject": {
          "Javadoc": "* Writes the content to the stream for serialization."
        }
      }
    },
    "org.apache.commons.collections4.trie.AbstractRangeMap": {
      "Javadoc": "\n     * A range view of the {@link org.apache.commons.collections4.Trie}.\n     ",
      "methods": {
        "createEntrySet": {
          "Javadoc": "* Creates and returns an {@link #entrySet()} view of the {@link AbstractRangeMap}."
        },
        "createRangeMap": {
          "Javadoc": "* Creates and returns a sub-range view of the current {@link AbstractRangeMap}."
        },
        "getFromKey": {
          "Javadoc": "* Returns the FROM Key."
        },
        "getToKey": {
          "Javadoc": "* Returns the TO Key."
        },
        "inFromRange": {
          "Javadoc": "* Returns true if the provided key is in the FROM range of the {@link AbstractRangeMap}."
        },
        "inRange": {
          "Javadoc": "* Returns true if the provided key is greater than TO and less than FROM."
        },
        "inRange2": {
          "Javadoc": "* This form allows the high endpoint (as well as all legit keys)."
        },
        "inToRange": {
          "Javadoc": "* Returns true if the provided key is in the TO range of the {@link AbstractRangeMap}."
        },
        "isFromInclusive": {
          "Javadoc": "* Whether or not the {@link #getFromKey()} is in the range."
        },
        "isToInclusive": {
          "Javadoc": "* Whether or not the {@link #getToKey()} is in the range."
        }
      }
    },
    "org.apache.commons.collections4.trie.AbstractTrieIterator": {
      "Javadoc": "\n     * An iterator for the entries.\n     ",
      "methods": {
        "findNext": {
          "Javadoc": "* @see PatriciaTrie#nextEntry(TrieEntry)"
        },
        "nextEntry": {
          "Javadoc": "* Returns the next {@link TrieEntry}."
        }
      }
    },
    "org.apache.commons.collections4.trie.EntrySet": {
      "Javadoc": "\n     * This is an entry set view of the {@link org.apache.commons.collections4.Trie} as returned by {@link Map#entrySet()}.\n     "
    },
    "org.apache.commons.collections4.trie.EntryIterator": {
      "Javadoc": "\n         * An {@link Iterator} for {@link RangeEntrySet}s.\n         "
    },
    "org.apache.commons.collections4.trie.KeySet": {
      "Javadoc": "\n     * This is a key set view of the {@link org.apache.commons.collections4.Trie} as returned by {@link Map#keySet()}.\n     "
    },
    "org.apache.commons.collections4.trie.KeyIterator": {
      "Javadoc": "\n         * An {@link Iterator} that returns Key Objects.\n         "
    },
    "org.apache.commons.collections4.trie.PrefixRangeEntrySet": {
      "Javadoc": "\n     * A prefix {@link RangeEntrySet} view of the {@link org.apache.commons.collections4.Trie}.\n     "
    },
    "org.apache.commons.collections4.trie.SingletonIterator": {
      "Javadoc": "\n         * An {@link Iterator} that holds a single {@link TrieEntry}.\n         "
    },
    "org.apache.commons.collections4.trie.PrefixRangeMap": {
      "Javadoc": "\n     * A submap used for prefix views over the {@link org.apache.commons.collections4.Trie}.\n     ",
      "methods": {
        "fixup": {
          "Javadoc": "* This method does two things. It determines the FROM\n         * and TO range of the {@link PrefixRangeMap} and the number\n         * of elements in the range. This method must be called every\n         * time the {@link org.apache.commons.collections4.Trie} has changed."
        },
        "inFromRange": {
          "Javadoc": "* Returns true if the provided Key is in the FROM range of the {@link PrefixRangeMap}."
        },
        "inRange": {
          "Javadoc": "* Returns true if this {@link PrefixRangeMap}'s key is a prefix of the provided key."
        },
        "inRange2": {
          "Javadoc": "* Same as {@link #inRange(Object)}."
        },
        "inToRange": {
          "Javadoc": "* Returns true if the provided Key is in the TO range of the {@link PrefixRangeMap}."
        }
      }
    },
    "org.apache.commons.collections4.trie.RangeEntryMap": {
      "Javadoc": "\n     * A {@link AbstractRangeMap} that deals with {@link Entry}s.\n     "
    },
    "org.apache.commons.collections4.trie.RangeEntrySet": {
      "Javadoc": "\n     * A {@link Set} view of a {@link AbstractRangeMap}.\n     "
    },
    "org.apache.commons.collections4.trie.Reference": {
      "Javadoc": "\n     * A {@link Reference} allows us to return something through a Method's\n     * argument list. An alternative would be to an Array with a length of\n     * one (1) but that leads to compiler warnings. Computationally and memory\n     * wise there's no difference (except for the need to load the\n     * {@link Reference} Class but that happens only once).\n     "
    },
    "org.apache.commons.collections4.trie.TrieEntry": {
      "Javadoc": "\n     *  A {@link org.apache.commons.collections4.Trie} is a set of {@link TrieEntry} nodes.\n     ",
      "methods": {
        "isEmpty": {
          "Javadoc": "* Whether or not the entry is storing a key.\n         * Only the root can potentially be empty, all other\n         * nodes must have a key."
        },
        "isExternalNode": {
          "Javadoc": "* Either the left or right child is a loopback."
        },
        "isInternalNode": {
          "Javadoc": "* Neither the left nor right child is a loopback."
        }
      }
    },
    "org.apache.commons.collections4.trie.TrieMapIterator": {
      "Javadoc": "\n     * An {@link OrderedMapIterator} for a {@link org.apache.commons.collections4.Trie}.\n     "
    },
    "org.apache.commons.collections4.trie.Values": {
      "Javadoc": "\n     * This is a value view of the {@link org.apache.commons.collections4.Trie} as returned by {@link Map#values()}.\n     "
    },
    "org.apache.commons.collections4.trie.ValueIterator": {
      "Javadoc": "\n         * An {@link Iterator} that returns Value Objects.\n         "
    },
    "org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer": {
      "Javadoc": "\n * An {@link KeyAnalyzer} for {@link String}s.\n *\n * @since 4.0\n ",
      "methods": {
        "mask": {
          "Javadoc": "Returns a bit mask where the given bit is set."
        }
      }
    },
    "org.apache.commons.collections4.trie.KeyAnalyzer": {
      "Javadoc": "\n * Defines the interface to analyze {@link org.apache.commons.collections4.Trie Trie} keys on a bit level.\n * {@link KeyAnalyzer}'s methods return the length of the key in bits, whether or not a bit is set,\n * and bits per element in the key.\n * <p>\n * Additionally, a method determines if a key is a prefix of another\n * key and returns the bit index where one key is different from another\n * key (if the key and found key are equal than the return value is\n * {@link #EQUAL_BIT_KEY}).\n * </p>\n *\n * @param <K> the type of objects that may be compared by this analyzer\n * @since 4.0\n ",
      "methods": {
        "isEqualBitKey": {
          "Javadoc": "* Returns true if bitIndex is a {@link KeyAnalyzer#EQUAL_BIT_KEY}."
        },
        "isNullBitKey": {
          "Javadoc": "* Returns true if bitIndex is a {@link KeyAnalyzer#NULL_BIT_KEY}."
        },
        "isOutOfBoundsIndex": {
          "Javadoc": "* Returns true if bitIndex is a {@link KeyAnalyzer#OUT_OF_BOUNDS_BIT_KEY}."
        },
        "isValidBitIndex": {
          "Javadoc": "* Returns true if the given bitIndex is valid.\n     * Indices are considered valid if they're between 0 and {@link Integer#MAX_VALUE}"
        },
        "bitIndex": {
          "Javadoc": "* Returns the n-th different bit between key and other. This starts the comparison in\n     * key at 'offsetInBits' and goes for 'lengthInBits' bits, and compares to the other key starting\n     * at 'otherOffsetInBits' and going for 'otherLengthInBits' bits.\n     *\n     * @param key  the key to use\n     * @param offsetInBits  the bit offset in the key\n     * @param lengthInBits  the maximum key length in bits to use\n     * @param other  the other key to use\n     * @param otherOffsetInBits  the bit offset in the other key\n     * @param otherLengthInBits  the maximum key length in bits for the other key\n     * @return the bit index where the key and other first differ"
        },
        "bitsPerElement": {
          "Javadoc": "* Returns the number of bits per element in the key.\n     * This is only useful for variable-length keys, such as Strings.\n     *\n     * @return the number of bits per element"
        },
        "isBitSet": {
          "Javadoc": "* Returns whether or not a bit is set.\n     *\n     * @param key  the key to check, may not be null\n     * @param bitIndex  the bit index to check\n     * @param lengthInBits  the maximum key length in bits to check\n     * @return {@code true} if the bit is set in the given key and\n     *   {@code bitIndex} &lt; {@code lengthInBits}, {@code false} otherwise."
        },
        "isPrefix": {
          "Javadoc": "* Determines whether or not the given prefix (from offset to length) is a prefix of the given key.\n     *\n     * @param prefix  the prefix to check\n     * @param offsetInBits  the bit offset in the key\n     * @param lengthInBits  the maximum key length in bits to use\n     * @param key  the key to check\n     * @return {@code true} if this is a valid prefix for the given key"
        },
        "lengthInBits": {
          "Javadoc": "* Returns the length of the Key in bits.\n     *\n     * @param key  the key\n     * @return the bit length of the key"
        }
      }
    },
    "org.apache.commons.collections4.trie.PatriciaTrie": {
      "Javadoc": "\n * Implementation of a PATRICIA Trie (Practical Algorithm to Retrieve Information\n * Coded in Alphanumeric).\n * <p>\n * A PATRICIA {@link org.apache.commons.collections4.Trie} is a compressed\n * {@link org.apache.commons.collections4.Trie}. Instead of storing\n * all data at the edges of the {@link org.apache.commons.collections4.Trie}\n * (and having empty internal nodes), PATRICIA stores data in every node.\n * This allows for very efficient traversal, insert, delete, predecessor,\n * successor, prefix, range, and {@link #select(Object)}\n * operations. All operations are performed at worst in O(K) time, where K\n * is the number of bits in the largest item in the tree. In practice,\n * operations actually take O(A(K)) time, where A(K) is the average number of\n * bits of all items in the tree.\n * </p>\n * <p>\n * Most importantly, PATRICIA requires very few comparisons to keys while\n * doing any operation. While performing a lookup, each comparison (at most\n * K of them, described above) will perform a single bit comparison against\n * the given key, instead of comparing the entire key to another key.\n * </p>\n * <p>\n * The {@link org.apache.commons.collections4.Trie} can return operations in\n * lexicographical order using the 'prefixMap', 'submap', or 'iterator' methods.\n * The {@link org.apache.commons.collections4.Trie} can also\n * scan for items that are 'bitwise' (using an XOR metric) by the 'select' method.\n * Bitwise closeness is determined by the {@link KeyAnalyzer} returning true or\n * false for a bit being set or not in a given key.\n * </p>\n * <p>\n * This PATRICIA {@link org.apache.commons.collections4.Trie} supports both variable\n * length &amp; fixed length keys. Some methods, such as {@link org.apache.commons.collections4.Trie#prefixMap(Object)}\n * are suited only to variable length keys.\n * </p>\n *\n * @param <V> the type of the values in this map\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Radix_tree\">Radix Tree</a>\n * @see <a href=\"https://users.monash.edu/~lloyd/tildeAlgDS/Tree/PATRICIA/\">PATRICIA</a>\n * @see <a href=\"https://www.imperialviolet.org/binary/critbit.pdf\">Crit-Bit Tree</a>\n * @since 4.0\n "
    },
    "org.apache.commons.collections4.trie.UnmodifiableTrie": {
      "Javadoc": "\n * An unmodifiable {@link Trie}.\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.0\n ",
      "methods": {
        "unmodifiableTrie": {
          "Javadoc": "* Factory method to create an unmodifiable trie.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param trie  the trie to decorate, must not be null\n     * @return a new unmodifiable trie\n     * @throws NullPointerException if trie is null"
        }
      }
    },
    "org.apache.commons.collections4.Trie": {
      "Javadoc": "\n * Defines the interface for a prefix tree, an ordered tree data structure. For\n * more information, see <a href=\"https://en.wikipedia.org/wiki/Trie\">Tries</a>.\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 4.0\n ",
      "methods": {
        "prefixMap": {
          "Javadoc": "* Returns a view of this {@link Trie} of all elements that are prefixed\n     * by the given key.\n     * <p>\n     * In a {@link Trie} with fixed size keys, this is essentially a\n     * {@link #get(Object)} operation.\n     * <p>\n     * For example, if the {@link Trie} contains 'Anna', 'Anael',\n     * 'Analu', 'Andreas', 'Andrea', 'Andres', and 'Anatole', then\n     * a lookup of 'And' would return 'Andreas', 'Andrea', and 'Andres'.\n     *\n     * @param key  the key used in the search\n     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n     *   key is prefixed by the search key"
        }
      }
    },
    "org.apache.commons.collections4.TrieUtils": {
      "Javadoc": "\n * A collection of {@link Trie} utilities.\n *\n * @since 4.0\n ",
      "methods": {
        "unmodifiableTrie": {
          "Javadoc": "* Returns an unmodifiable instance of a {@link Trie}\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param trie  the trie to make unmodifiable, must not be null\n     * @return an unmodifiable trie backed by the given trie\n     * @throws NullPointerException if trie is null\n     *\n     * @see java.util.Collections#unmodifiableMap(java.util.Map)"
        }
      }
    },
    "org.apache.commons.collections4.Unmodifiable": {
      "Javadoc": "\n * Marker interface for collections, maps and iterators that are unmodifiable.\n * <p>\n * This interface enables testing such as:\n * </p>\n * <pre>\n * if (coll instanceof Unmodifiable) {\n *   coll = new ArrayList(coll);\n * }\n * // now we know coll is modifiable\n * </pre>\n * Of course all this only works if you use the Unmodifiable classes defined\n * in this library. If you use the JDK unmodifiable class via {@code java.util Collections}\n * then the interface won't be there.\n *\n * @since 3.0\n "
    },
    "org.apache.commons.collections4.AbstractArrayListTest": {
      "Javadoc": "\n * Abstract test class for ArrayList.\n ",
      "methods": {
        "makeObject": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.AbstractLinkedListTest": {
      "Javadoc": "\n * Tests base {@link java.util.LinkedList} methods and contracts.\n * <p>\n * To use, simply extend this class, and implement\n * the {@link #makeObject()} method.\n * <p>\n * If your {@link LinkedList} fails one of these tests by design,\n * you may still use this base set of cases.  Simply override the\n * test case (method) your {@link List} fails.\n ",
      "methods": {
        "getCollection": {
          "Javadoc": "*  Returns the {@link #collection} field cast to a {@link LinkedList}.\n     *\n     *  @return the collection field as a List"
        },
        "getConfirmedLinkedList": {
          "Javadoc": "*  Returns the {@link #confirmed} field cast to a {@link LinkedList}.\n     *\n     *  @return the confirmed field as a List"
        },
        "makeConfirmedCollection": {
          "Javadoc": "*  Returns an empty {@link LinkedList}."
        },
        "makeConfirmedFullCollection": {
          "Javadoc": "*  Returns a full {@link LinkedList}."
        },
        "testLinkedListAddFirst": {
          "Javadoc": "*  Tests {@link LinkedList#addFirst(Object)}."
        },
        "testLinkedListAddLast": {
          "Javadoc": "*  Tests {@link LinkedList#addLast(Object)}."
        },
        "testLinkedListGetFirst": {
          "Javadoc": "*  Tests {@link LinkedList#getFirst()}."
        },
        "testLinkedListGetLast": {
          "Javadoc": "*  Tests {@link LinkedList#getLast()}."
        },
        "testLinkedListRemoveFirst": {
          "Javadoc": "*  Tests {@link LinkedList#removeFirst()}."
        },
        "testLinkedListRemoveLast": {
          "Javadoc": "*  Tests {@link LinkedList#removeLast()}."
        }
      }
    },
    "org.apache.commons.collections4.AbstractObjectTest": {
      "Javadoc": "\n * Abstract test class for {@link Object} methods and contracts.\n * <p>\n * To use, simply extend this class, and implement\n * the {@link #makeObject()} method.\n * <p>\n * If your {@link Object} fails one of these tests by design,\n * you may still use this base set of cases.  Simply override the\n * test case (method) your {@link Object} fails.\n ",
      "methods": {
        "getCompatibilityVersion": {
          "Javadoc": "* Gets the version of Collections that this object tries to\n     * maintain serialization compatibility with. Defaults to 4, due to\n     * the package change to collections4 introduced in version 4.\n     *\n     * This constant makes it possible for TestMap (and other subclasses,\n     * if necessary) to automatically check SCM for a versionX copy of a\n     * Serialized object, so we can make sure that compatibility is maintained.\n     * See, for example, TestMap.getCanonicalFullMapName(Map map).\n     * Subclasses can override this variable, indicating compatibility\n     * with earlier Collections versions.\n     *\n     * @return The version, or {@code null} if this object shouldn't be\n     * tested for compatibility with previous versions."
        },
        "isEqualsCheckable": {
          "Javadoc": "* Returns true to indicate that the collection supports equals() comparisons.\n     * This implementation returns true;"
        },
        "isTestSerialization": {
          "Javadoc": "* Is serialization testing supported.\n     * Default is true."
        },
        "makeObject": {
          "Javadoc": "* Implement this method to return the object to test.\n     *\n     * @return the object to test"
        },
        "readExternalFormFromBytes": {
          "Javadoc": "* Read a Serialized or Externalized Object from bytes.\n     * Useful for verifying serialization in memory.\n     *\n     * @param b byte array containing a serialized Object\n     * @return Object contained in the bytes\n     * @throws IOException\n     * @throws ClassNotFoundException"
        },
        "readExternalFormFromDisk": {
          "Javadoc": "* Reads a Serialized or Externalized Object from disk.\n     * Useful for creating compatibility tests between\n     * different SCM versions of the same class\n     *\n     * @param path path to the serialized Object\n     * @return the Object at the given path\n     * @throws IOException\n     * @throws ClassNotFoundException"
        },
        "supportsEmptyCollections": {
          "Javadoc": "* Override this method if a subclass is testing an object\n     * that cannot serialize an \"empty\" Collection.\n     * (e.g. Comparators have no contents)\n     *\n     * @return true"
        },
        "supportsFullCollections": {
          "Javadoc": "* Override this method if a subclass is testing an object\n     * that cannot serialize a \"full\" Collection.\n     * (e.g. Comparators have no contents)\n     *\n     * @return true"
        },
        "testCanonicalEmptyCollectionExists": {
          "Javadoc": "* Tests serialization by comparing against a previously stored version in SCM.\n     * If the test object is serializable, confirm that a canonical form exists."
        },
        "testCanonicalFullCollectionExists": {
          "Javadoc": "* Tests serialization by comparing against a previously stored version in SCM.\n     * If the test object is serializable, confirm that a canonical form exists."
        },
        "testSimpleSerialization": {
          "Javadoc": "* Sanity check method, makes sure that any Serializable\n     * class can be serialized and de-serialized in memory,\n     * using the handy makeObject() method\n     *\n     * @throws IOException\n     * @throws ClassNotFoundException"
        },
        "writeExternalFormToBytes": {
          "Javadoc": "* Converts a Serializable or Externalizable object to\n     * bytes.  Useful for in-memory tests of serialization\n     *\n     * @param o Object to convert to bytes\n     * @return serialized form of the Object\n     * @throws IOException"
        },
        "writeExternalFormToDisk": {
          "Javadoc": "* Writes a Serializable or Externalizable object as\n     * a file at the given path.  NOT USEFUL as part\n     * of a unit test; this is just a utility method\n     * for creating disk-based objects in SCM that can become\n     * the basis for compatibility tests using\n     * readExternalFormFromDisk(String path)\n     *\n     * @param o Object to serialize\n     * @param path path to write the serialized Object\n     * @throws IOException"
        }
      }
    },
    "org.apache.commons.collections4.AbstractTreeMapTest": {
      "Javadoc": "\n * Tests TreeMap.\n ",
      "methods": {
        "makeObject": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.ArrayStackTest": {
      "Javadoc": "\n * Tests ArrayStack.\n "
    },
    "org.apache.commons.collections4.ArrayUtilsTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.LANG1261ParentObject": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.LANG1261ChildObject": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bag.AbstractBagTest": {
      "Javadoc": "\n * Abstract test class for {@link org.apache.commons.collections4.Bag Bag} methods and contracts.\n * <p>\n * To use, simply extend this class, and implement\n * the {@link #makeObject} method.\n * <p>\n * If your bag fails one of these tests by design,\n * you may still use this base set of cases.  Simply override the\n * test case (method) your bag fails.\n * <p>\n * <b>Note:</b> The Bag interface does not conform to the Collection interface\n * so the generic collection tests from AbstractCollectionTest would normally fail.\n * As a work-around since 4.0, a CollectionBag decorator can be used\n * to make any Bag implementation comply to the Collection contract.\n * <p>\n * This abstract test class does wrap the concrete bag implementation\n * with such a decorator, see the overridden {@link #resetEmpty()} and\n * {@link #resetFull()} methods.\n * <p>\n * In addition to the generic collection tests (prefix testCollection) inherited\n * from AbstractCollectionTest, there are test methods that test the \"normal\" Bag\n * interface (prefix testBag). For Bag specific tests use the {@link #makeObject()} and\n * {@link #makeFullCollection()} methods instead of {@link #resetEmpty()} and resetFull(),\n * otherwise the collection will be wrapped by a {@link CollectionBag} decorator.\n ",
      "methods": {
        "bulkTestBagUniqueSet": {
          "Javadoc": "* Bulk test {@link Bag#uniqueSet()}.  This method runs through all of\n     * the tests in {@link AbstractSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the bag and the other collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing the bag's unique set"
        },
        "getCollection": {
          "Javadoc": "* Returns the {@link #collection} field cast to a {@link Bag}.\n     *\n     * @return the collection field as a Bag"
        },
        "makeConfirmedCollection": {
          "Javadoc": "* Returns an empty {@link ArrayList}."
        },
        "makeConfirmedFullCollection": {
          "Javadoc": "* Returns a full collection."
        },
        "makeFullCollection": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeObject": {
          "Javadoc": "* Return a new, empty bag to used for testing.\n     *\n     * @return the bag to be tested"
        },
        "testEmptyBagCompatibility": {
          "Javadoc": "* Compare the current serialized form of the Bag\n     * against the canonical version in SCM."
        },
        "testFullBagCompatibility": {
          "Javadoc": "* Compare the current serialized form of the Bag\n     * against the canonical version in SCM."
        }
      }
    },
    "org.apache.commons.collections4.bag.TestBagUniqueSet": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bag.AbstractSortedBagTest": {
      "Javadoc": "\n * Abstract test class for\n * {@link org.apache.commons.collections4.SortedBag SortedBag}\n * methods and contracts.\n ",
      "methods": {
        "getCollection": {
          "Javadoc": "* Returns the {@link #collection} field cast to a {@link SortedBag}.\n     *\n     * @return the collection field as a SortedBag"
        },
        "getFullNonNullElements": {
          "Javadoc": "* Override to return comparable objects."
        },
        "getOtherNonNullElements": {
          "Javadoc": "* Override to return comparable objects."
        },
        "isNullSupported": {
          "Javadoc": "* Overridden because SortedBags don't allow null elements (normally).\n     * @return false"
        },
        "makeConfirmedCollection": {
          "Javadoc": "* Returns an empty {@link TreeBag} for use in modification testing.\n     *\n     * @return a confirmed empty collection"
        },
        "makeFullCollection": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeObject": {
          "Javadoc": "* {@inheritDoc}"
        },
        "verify": {
          "Javadoc": "* Verification extension, will check the order of elements,\n     * the sets should already be verified equal."
        }
      }
    },
    "org.apache.commons.collections4.bag.CollectionBagTest": {
      "Javadoc": "\n * Test class for {@link CollectionBag}.\n * <p>\n * Note: This test is mainly for serialization support, the CollectionBag decorator\n * is extensively used and tested in AbstractBagTest.\n ",
      "methods": {
        "makeConfirmedCollection": {
          "Javadoc": "* Returns an empty List for use in modification testing.\n     *\n     * @return a confirmed empty collection"
        },
        "makeConfirmedFullCollection": {
          "Javadoc": "* Returns a full Set for use in modification testing.\n     *\n     * @return a confirmed full collection"
        },
        "testEmptyBagCompatibility": {
          "Javadoc": "* Compares the current serialized form of the Bag\n     * against the canonical version in SCM."
        },
        "testFullBagCompatibility": {
          "Javadoc": "* Compares the current serialized form of the Bag\n     * against the canonical version in SCM."
        }
      }
    },
    "org.apache.commons.collections4.bag.CollectionSortedBagTest": {
      "Javadoc": "\n * Test class for {@link CollectionSortedBag}.\n * <p>\n * Note: This test is mainly for serialization support, the CollectionSortedBag decorator\n * is extensively used and tested in AbstractSortedBagTest.\n ",
      "methods": {
        "getFullNonNullElements": {
          "Javadoc": "* Override to return comparable objects."
        },
        "getOtherNonNullElements": {
          "Javadoc": "* Override to return comparable objects."
        },
        "isNullSupported": {
          "Javadoc": "* Overridden because SortedBags don't allow null elements (normally).\n     * @return false"
        },
        "makeConfirmedCollection": {
          "Javadoc": "* Returns an empty List for use in modification testing.\n     *\n     * @return a confirmed empty collection"
        },
        "makeConfirmedFullCollection": {
          "Javadoc": "* Returns a full Set for use in modification testing.\n     *\n     * @return a confirmed full collection"
        },
        "testEmptyBagCompatibility": {
          "Javadoc": "* Compare the current serialized form of the Bag\n     * against the canonical version in SCM."
        },
        "testFullBagCompatibility": {
          "Javadoc": "* Compare the current serialized form of the Bag\n     * against the canonical version in SCM."
        }
      }
    },
    "org.apache.commons.collections4.bag.HashBagTest": {
      "Javadoc": "\n * Extension of {@link AbstractBagTest} for exercising the {@link HashBag}\n * implementation.\n "
    },
    "org.apache.commons.collections4.bag.PredicatedBagTest": {
      "Javadoc": "\n * Extension of {@link AbstractBagTest} for exercising the {@link PredicatedBag}\n * implementation.\n "
    },
    "org.apache.commons.collections4.bag.PredicatedSortedBagTest": {
      "Javadoc": "\n * Extension of {@link AbstractSortedBagTest} for exercising the {@link PredicatedSortedBag}\n * implementation.\n "
    },
    "org.apache.commons.collections4.bag.SynchronizedBagTest": {
      "Javadoc": "\n * Extension of {@link AbstractBagTest} for exercising the {@link SynchronizedBag}\n * implementation.\n "
    },
    "org.apache.commons.collections4.bag.TransformedBagTest": {
      "Javadoc": "\n * Extension of {@link AbstractBagTest} for exercising the {@link TransformedBag}\n * implementation.\n "
    },
    "org.apache.commons.collections4.bag.TransformedSortedBagTest": {
      "Javadoc": "\n * Extension of {@link AbstractSortedBagTest} for exercising the {@link TransformedSortedBag}\n * implementation.\n "
    },
    "org.apache.commons.collections4.bag.TreeBagTest": {
      "Javadoc": "\n * Extension of {@link AbstractBagTest} for exercising the {@link TreeBag}\n * implementation.\n "
    },
    "org.apache.commons.collections4.bag.UnmodifiableBagTest": {
      "Javadoc": "\n * Extension of {@link AbstractCollectionTest} for exercising the\n * {@link UnmodifiableBag} implementation.\n "
    },
    "org.apache.commons.collections4.bag.UnmodifiableSortedBagTest": {
      "Javadoc": "\n * Extension of {@link AbstractCollectionTest} for exercising the\n * {@link UnmodifiableSortedBag} implementation.\n "
    },
    "org.apache.commons.collections4.BagUtilsTest": {
      "Javadoc": "\n * Tests for BagUtils factory methods.\n "
    },
    "org.apache.commons.collections4.bidimap.AbstractBidiMapTest": {
      "Javadoc": "\n * Abstract test class for {@link BidiMap} methods and contracts.\n ",
      "methods": {
        "getCompatibilityVersion": {
          "Javadoc": "* Override as DualHashBidiMap didn't exist until version 3."
        },
        "getMap": {
          "Javadoc": "* {@inheritDoc}"
        },
        "isAllowDuplicateValues": {
          "Javadoc": "* Override to indicate to AbstractTestMap this is a BidiMap."
        },
        "makeFullMap": {
          "Javadoc": "* Override to create a full {@code BidiMap} other than the default.\n     *\n     * @return a full {@code BidiMap} implementation."
        },
        "makeObject": {
          "Javadoc": "* Override to return the empty BidiMap."
        },
        "verify": {
          "Javadoc": "* Verifies that {@link #map} is still equal to {@link #confirmed}.\n     * <p>\n     * This implementation checks the inverse map as well."
        }
      }
    },
    "org.apache.commons.collections4.bidimap.TestBidiMapEntrySet": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bidimap.TestBidiMapIterator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bidimap.TestInverseBidiMap": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bidimap.AbstractOrderedBidiMapDecoratorTest": {
      "Javadoc": "\n * Test class for AbstractOrderedBidiMapDecorator.\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n ",
      "methods": {
        "makeObject": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.TestOrderedBidiMap": {
      "Javadoc": "\n     * Simple class to actually test.\n     "
    },
    "org.apache.commons.collections4.bidimap.AbstractOrderedBidiMapTest": {
      "Javadoc": "\n * Abstract test class for {@link OrderedBidiMap} methods and contracts.\n ",
      "methods": {
        "getMap": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.TestBidiOrderedMapIterator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bidimap.AbstractSortedBidiMapTest": {
      "Javadoc": "\n * Abstract test class for {@link SortedBidiMap} methods and contracts.\n ",
      "methods": {
        "makeFullMap": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeObject": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.DualHashBidiMapTest": {
      "Javadoc": "\n * JUnit tests.\n ",
      "methods": {
        "ignoredTests": {
          "Javadoc": "* Override to prevent infinite recursion of tests."
        },
        "makeObject": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.DualLinkedHashBidiMapTest": {
      "Javadoc": "\n * JUnit tests.\n ",
      "methods": {
        "ignoredTests": {
          "Javadoc": "* Override to prevent infinite recursion of tests."
        },
        "makeObject": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.DualTreeBidiMap2Test": {
      "Javadoc": "\n * JUnit tests.\n ",
      "methods": {
        "ignoredTests": {
          "Javadoc": "* Override to prevent infinite recursion of tests."
        }
      }
    },
    "org.apache.commons.collections4.bidimap.IntegerComparator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bidimap.DualTreeBidiMapTest": {
      "Javadoc": "\n * JUnit tests.\n ",
      "methods": {
        "ignoredTests": {
          "Javadoc": "* Override to prevent infinite recursion of tests."
        },
        "makeObject": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.bidimap.TreeBidiMapTest": {
      "Javadoc": "\n * JUnit tests.\n ",
      "methods": {
        "ignoredTests": {
          "Javadoc": "* Override to prevent infinite recursion of tests."
        }
      }
    },
    "org.apache.commons.collections4.bidimap.UnmodifiableBidiMapTest": {
      "Javadoc": "\n * JUnit tests.\n ",
      "methods": {
        "ignoredTests": {
          "Javadoc": "* Override to prevent infinite recursion of tests."
        }
      }
    },
    "org.apache.commons.collections4.bidimap.UnmodifiableOrderedBidiMapTest": {
      "Javadoc": "\n * JUnit tests.\n ",
      "methods": {
        "ignoredTests": {
          "Javadoc": "* Override to prevent infinite recursion of tests."
        }
      }
    },
    "org.apache.commons.collections4.bidimap.UnmodifiableSortedBidiMapTest": {
      "Javadoc": "\n * JUnit tests.\n "
    },
    "org.apache.commons.collections4.bloomfilter.AbstractBitMapProducerTest": {
      "Javadoc": "",
      "methods": {
        "createEmptyProducer": {
          "Javadoc": "* Creates an producer without data.\n     * @return a producer that has no data."
        },
        "createProducer": {
          "Javadoc": "* Creates a producer with some data.\n     * @return a producer with some data"
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.AbstractBloomFilterProducerTest": {
      "Javadoc": "",
      "methods": {
        "createUnderTest": {
          "Javadoc": "* Creates a BloomFilterProducer that returns the filters (or their copy) in the order presented.\n     * @param filters The filters to return.\n     * @return A BloomFilterProducer that returns the filters in order."
        },
        "getTestShape": {
          "Javadoc": "* The shape of the Bloom filters for testing.\n     * <ul>\n     *  <li>Hash functions (k) = 17\n     *  <li>Number of bits (m) = 72\n     * </ul>\n     * @return the testing shape."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.AbstractBloomFilterTest": {
      "Javadoc": "\n * Test standard methods in the {@link BloomFilter} interface.\n ",
      "methods": {
        "createEmptyFilter": {
          "Javadoc": "* Create an empty version of the BloomFilter implementation we are testing.\n     *\n     * @param shape the shape of the filter.\n     * @return a BloomFilter implementation."
        },
        "createFilter": {
          "Javadoc": "* Create the BloomFilter implementation we are testing.\n     *\n     * @param shape the shape of the filter.\n     * @param producer An Index producer to build the filter with.\n     * @return a BloomFilter implementation."
        },
        "getTestShape": {
          "Javadoc": "* The shape of the Bloom filters for testing.\n     * <ul>\n     *  <li>Hash functions (k) = 17\n     *  <li>Number of bits (m) = 72\n     * </ul>\n     * @return the testing shape."
        },
        "testAsBitMapArray": {
          "Javadoc": "* Tests that asBitMapArray works correctly."
        },
        "testCardinalityAndIsEmpty": {
          "Javadoc": "* Test cardinality and isEmpty. Bloom filter must be able to accept multiple\n     * IndexProducer merges until all the bits are populated.\n     *\n     * @param bf The Bloom filter to test."
        },
        "testEstimateIntersection": {
          "Javadoc": "* Tests that the estimated intersection calculations are correct."
        },
        "testEstimateN": {
          "Javadoc": "* Tests that the size estimate is correctly calculated."
        },
        "testEstimateUnion": {
          "Javadoc": "* Tests that the estimated union calculations are correct."
        },
        "testIsFull": {
          "Javadoc": "* Tests that isFull() returns the proper values."
        },
        "testMerge": {
          "Javadoc": "* Tests that merging bloom filters works as expected with a generic BloomFilter."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.BadHasher": {
      "Javadoc": "\n     * Testing class returns the value as the only value.\n     "
    },
    "org.apache.commons.collections4.bloomfilter.AbstractCellProducerTest": {
      "Javadoc": "",
      "methods": {
        "createEmptyProducer": {
          "Javadoc": "* Creates a producer without data.\n     * @return a producer that has no data."
        },
        "createProducer": {
          "Javadoc": "* Creates a producer with some data.\n     * @return a producer with some data"
        },
        "getExpectedValues": {
          "Javadoc": "* Creates an array of expected values that aligns with the expected indices entries.\n     * @return an array of expected values.\n     * @see AbstractIndexProducerTest#getExpectedIndices()"
        },
        "testBehaviourForEachCell": {
          "Javadoc": "* Test the behavior of {@link CellProducer#forEachCell(CellConsumer)} with respect\n     * to ordered and distinct indices. Currently the behavior is assumed to be the same as\n     * {@link IndexProducer#forEachIndex(java.util.function.IntPredicate)}."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.AbstractCountingBloomFilterTest": {
      "Javadoc": "\n * Tests for the {@link ArrayCountingBloomFilter}.\n ",
      "methods": {
        "assertCounts": {
          "Javadoc": "* Assert the counts match the expected values. Values are for indices starting\n     * at 0. Assert the cardinality equals the number of non-zero counts.\n     *\n     * @param bf the bloom filter\n     * @param expected the expected counts"
        },
        "testAdd": {
          "Javadoc": "* Tests that merge correctly updates the counts when a CountingBloomFilter is\n     * passed."
        },
        "testCountingSpecificConstructor": {
          "Javadoc": "* Tests that counts are correct when a hasher with duplicates is used in the\n     * constructor."
        },
        "testCountingSpecificMerge": {
          "Javadoc": "* Tests that merging bloom filters works as expected with a generic BloomFilter."
        },
        "testRemove": {
          "Javadoc": "* Tests that merge correctly updates the counts when a CountingBloomFilter is\n     * passed."
        },
        "testSubtract": {
          "Javadoc": "* Tests that merge correctly updates the counts when a CountingBloomFilter is\n     * passed."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.AbstractHasherTest": {
      "Javadoc": "",
      "methods": {
        "getHasherSize": {
          "Javadoc": "* A method to get the number of items in a hasher. Mostly applies to\n     * Collections of hashers.\n     * @param hasher the hasher to check.\n     * @return the number of hashers in the hasher"
        },
        "getTestShape": {
          "Javadoc": "* The shape of the Hashers filters for testing.\n     * <ul>\n     *  <li>Hash functions (k) = 17\n     *  <li>Number of bits (m) = 72\n     * </ul>\n     * @return the testing shape."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.AbstractIndexProducerTest": {
      "Javadoc": "\n * Test for IndexProducer.\n ",
      "methods": {
        "createEmptyProducer": {
          "Javadoc": "* Creates an producer without data.\n     * @return a producer that has no data."
        },
        "createProducer": {
          "Javadoc": "* Creates a producer with some data.\n     * @return a producer with some data"
        },
        "getAsIndexArrayBehaviour": {
          "Javadoc": "* Gets the behavior of the {@link IndexProducer#asIndexArray()} method.\n     * @return the behavior.\n     * @see #ORDERED\n     * @see #DISTINCT"
        },
        "getExpectedIndices": {
          "Javadoc": "* Creates an array of expected indices.\n     * The expected indices are dependent upon the producer created in the {@code createProducer()} method.\n     * @return an array of expected indices."
        },
        "getForEachIndexBehaviour": {
          "Javadoc": "* Gets the behavior of the {@link IndexProducer#forEachIndex(IntPredicate)} method.\n     * By default returns the value of {@code getAsIndexArrayBehaviour()} method.\n     * @return the behavior.\n     * @see #ORDERED\n     * @see #DISTINCT"
        },
        "testAsIndexArrayValues": {
          "Javadoc": "* Test to ensure that all expected values are generated at least once."
        },
        "testBehaviourAsIndexArray": {
          "Javadoc": "* Tests the behavior of {@code IndexProducer.asIndexArray()}.\n     * The expected behavior is defined by the {@code getBehaviour()} method.\n     * The index array may be Ordered, Distinct or both.\n     * If the index array is not distinct then all elements returned by the {@code getExpectedIndices()}\n     * method, including duplicates, are expected to be returned by the {@code asIndexArray()} method."
        },
        "testBehaviourForEachIndex": {
          "Javadoc": "* Tests the behavior of {@code IndexProducer.forEachIndex()}.\n     * The expected behavior is defined by the {@code getBehaviour()} method.\n     * The order is assumed to follow the order produced by {@code IndexProducer.asIndexArray()}."
        },
        "testConsistency": {
          "Javadoc": "* Test the distinct indices output from the producer are consistent."
        },
        "testForEachIndex": {
          "Javadoc": "* Test to ensure that for each index returns each expected index at least once."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.IntList": {
      "Javadoc": "\n     * An expandable list of int values.\n     ",
      "methods": {
        "add": {
          "Javadoc": "* Adds the value to the list.\n         *\n         * @param value the value\n         * @return true if the list was modified"
        },
        "toArray": {
          "Javadoc": "* Convert to an array.\n         *\n         * @return the array"
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.ArrayCountingBloomFilterTest": {
      "Javadoc": "\n * Tests for the {@link ArrayCountingBloomFilter}.\n "
    },
    "org.apache.commons.collections4.bloomfilter.ArrayHasher": {
      "Javadoc": "\n * A Testing Hasher that returns the array values % shape.getNumberOfBits().\n *\n * <p>To be used for testing only.</p>\n "
    },
    "org.apache.commons.collections4.bloomfilter.Producer": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.ArrayTrackerTest": {
      "Javadoc": "\n * Tests the Filter class.\n "
    },
    "org.apache.commons.collections4.bloomfilter.BitMapProducerFromArrayCountingBloomFilterTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.BitMapProducerFromIndexProducerTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.BitMapProducerFromLayeredBloomFilterTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.BitMapProducerFromLongArrayTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.BitMapProducerFromSimpleBloomFilterTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.BitMapProducerFromSparseBloomFilterTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.BitMapProducerFromWrappedBloomFilterTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.BitMapTest": {
      "Javadoc": "",
      "methods": {
        "assertMod": {
          "Javadoc": "* Assert the {@link BitMap#mod(long, int)} method functions as an unsigned modulus.\n     *\n     * @param dividend the dividend\n     * @param divisor the divisor"
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.BitMapTrackerTest": {
      "Javadoc": "\n * Tests the Filter class.\n "
    },
    "org.apache.commons.collections4.bloomfilter.BloomFilterProducerFromBloomFilterArrayTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.BloomFilterProducerFromLayeredBloomFilterTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.CellProducerFromArrayCountingBloomFilterTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.CellProducerFromDefaultIndexProducerTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.CellProducerFromLayeredBloomFilterTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.CountingPredicateTest": {
      "Javadoc": "",
      "methods": {
        "testPredicateLonger": {
          "Javadoc": "* Test when the predicate array is longer than other array as determined by the number\n     * of times cp.test() is called and all other values result in a true statement."
        },
        "testPredicateSameLength": {
          "Javadoc": "* Test when the predicate array is shorter than other array as determined by the number\n     * of times cp.test() is called and all other values result in a true statement."
        },
        "testPredicateShorter": {
          "Javadoc": "* Test when the predicate array is shorter than other array as determined by the number\n     * of times cp.test() is called and all other values result in a true statement."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.DefaultBitMapProducerTest": {
      "Javadoc": "",
      "methods": {
        "generateLongArray": {
          "Javadoc": "* Generates an array of random long values.\n     * @param size the number of values to generate\n     * @return the array of random values."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.DefaultBitMapProducer": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.DefaultBloomFilterProducerTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.DefaultBloomFilterTest": {
      "Javadoc": "\n * Tests for the {@link BloomFilter}.\n "
    },
    "org.apache.commons.collections4.bloomfilter.AbstractDefaultBloomFilter": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.BrokenCardinality": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.NonSparseDefaultBloomFilter": {
      "Javadoc": "\n     * A default implementation of a non-sparse Bloom filter.\n     "
    },
    "org.apache.commons.collections4.bloomfilter.SparseDefaultBloomFilter": {
      "Javadoc": "\n     * A default implementation of a Sparse bloom filter.\n     "
    },
    "org.apache.commons.collections4.bloomfilter.DefaultCellProducerTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.DefaultIndexProducerTest": {
      "Javadoc": "",
      "methods": {
        "generateIntArray": {
          "Javadoc": "* Generates an array of integers.\n     * @param size the size of the array\n     * @param bound the upper bound (exclusive) of the values in the array.\n     * @return an array of int."
        },
        "unique": {
          "Javadoc": "* Creates a sorted unique array of ints.\n     * @param ary the array to sort and make unique\n     * @return the sorted unique array."
        },
        "uniqueSet": {
          "Javadoc": "* Creates a BitSet of indices.\n     * @param ary the array\n     * @return the set."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.EnhancedDoubleHasherTest": {
      "Javadoc": "\n * Tests the {@link EnhancedDoubleHasher}.\n "
    },
    "org.apache.commons.collections4.bloomfilter.IncrementingHasher": {
      "Javadoc": "\n * A Hasher that implements simple combinatorial hashing as described by\n * <a href=\"https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf\">Krisch and Mitzenmacher</a>.\n *\n * <p>To be used for testing only.</p>\n "
    },
    "org.apache.commons.collections4.bloomfilter.IndexFilterTest": {
      "Javadoc": "\n * Tests the Filter class.\n "
    },
    "org.apache.commons.collections4.bloomfilter.IndexProducerFromArrayCountingBloomFilterTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.IndexProducerFromBitmapProducerTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.TestingBitMapProducer": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.IndexProducerFromHasherTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.IndexProducerFromIntArrayTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.IndexProducerFromSimpleBloomFilterTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.IndexProducerFromSparseBloomFilterTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.IndexProducerFromUniqueHasherTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.IndexProducerTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.LayeredBloomFilterTest": {
      "Javadoc": "",
      "methods": {
        "createTimedLayeredFilter": {
          "Javadoc": "* Creates a LayeredBloomFilter that retains enclosed filters for\n     * {@code duration} and limits the contents of each enclosed filter to a time\n     * {@code quanta}. This filter uses the timestamped Bloom filter internally.\n     *\n     * @param shape    The shape of the Bloom filters.\n     * @param duration The length of time to keep filters in the list.\n     * @param dUnit    The unit of time to apply to duration.\n     * @param quanta   The quantization factor for each filter. Individual filters\n     *                 will span at most this much time.\n     * @param qUnit    the unit of time to apply to quanta.\n     * @return LayeredBloomFilter with the above properties."
        },
        "testEstimateUnionCrossTypes": {
          "Javadoc": "* Tests that the estimated union calculations are correct."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.AdvanceOnTimeQuanta": {
      "Javadoc": "\n     * A Predicate that advances after a quantum of time.\n     "
    },
    "org.apache.commons.collections4.bloomfilter.CleanByTime": {
      "Javadoc": "\n     * A Consumer that cleans the list based on how long each filters has been in\n     * the list.\n     "
    },
    "org.apache.commons.collections4.bloomfilter.TimestampedBloomFilter": {
      "Javadoc": "\n     * A Bloomfilter implementation that tracks the creation time.\n     "
    },
    "org.apache.commons.collections4.bloomfilter.LayerManagerTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.bloomfilter.NullHasher": {
      "Javadoc": "\n * A Hasher that returns no values.\n *\n * <p>To be used for testing only.</p>\n "
    },
    "org.apache.commons.collections4.bloomfilter.SetOperationsTest": {
      "Javadoc": "\n * Test {@link SetOperations}.\n ",
      "methods": {
        "testCosineDistance": {
          "Javadoc": "* Tests that the Cosine similarity is correctly calculated."
        },
        "testCosineSimilarity": {
          "Javadoc": "* Tests that the Cosine similarity is correctly calculated."
        },
        "testHammingDistance": {
          "Javadoc": "* Tests that the Hamming distance is correctly calculated."
        },
        "testJaccardDistance": {
          "Javadoc": "* Tests that the Jaccard distance is correctly calculated."
        },
        "testJaccardSimilarity": {
          "Javadoc": "* Tests that the Jaccard similarity is correctly calculated."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.ShapeTest": {
      "Javadoc": "\n * Tests the {@link Shape} class.\n ",
      "methods": {
        "testBadNumberOfBits": {
          "Javadoc": "* Tests that if the number of bits is less than 1 an exception is thrown"
        },
        "testBadNumberOfHashFunctions": {
          "Javadoc": "* Tests that if the number of hash functions is less than 1 an exception is thrown."
        },
        "testBadNumberOfItems": {
          "Javadoc": "* Tests that if the number of items less than 1 an IllegalArgumentException is thrown."
        },
        "testBadProbability": {
          "Javadoc": "* Tests that if the calculated probability is greater than or equal to 1 an IllegalArgumentException is thrown"
        },
        "testEqualsAndHashCode": {
          "Javadoc": "* Test equality of shape."
        },
        "testFromKM": {
          "Javadoc": "* Tests that if the number of bits less than 1 an IllegalArgumentException is thrown."
        },
        "testFromNM": {
          "Javadoc": "* Tests that the number of items and number of bits is passed the other values are calculated correctly."
        },
        "testFromNMK": {
          "Javadoc": "* Tests that when the number of items, number of bits and number of hash functions is passed the values are\n     * calculated correctly."
        },
        "testFromNP": {
          "Javadoc": "* Tests the calculated values of calling the constructor with the probability, number of bits and number of hash\n     * functions."
        },
        "testFromPMK": {
          "Javadoc": "* Tests the calculated values of calling the constructor with the probability, number of bits and number of hash\n     * functions."
        },
        "testProbability": {
          "Javadoc": "* Tests that the probability is calculated correctly."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.SimpleBloomFilterTest": {
      "Javadoc": "\n * Tests for the {@link SimpleBloomFilter}.\n "
    },
    "org.apache.commons.collections4.bloomfilter.SparseBloomFilterTest": {
      "Javadoc": "\n * Tests for the {@link SparseBloomFilter}.\n "
    },
    "org.apache.commons.collections4.bloomfilter.TestingHashers": {
      "Javadoc": "\n * A collection of methods and statics that represent standard hashers in testing.\n ",
      "methods": {
        "mergeHashers": {
          "Javadoc": "* Merge several Hashers together into a single Bloom filter.\n     * @param <T> The type of bloom filter.\n     * @param filter The Bloom filter to populate\n     * @param hashers The hashers to merge\n     * @return {@code filter} for chaining"
        },
        "populateEntireFilter": {
          "Javadoc": "* Enables all bits in the filter.\n     * @param <T> the Bloom filter type.\n     * @param filter the Bloom filter to populate\n     * @return {@code filter} for chaining"
        },
        "populateFromHashersFrom1AndFrom11": {
          "Javadoc": "* Merge {@code from1} and {@code from11} into a single Bloom filter.\n     * @param <T> The type of bloom filter.\n     * @param filter The Bloom filter to populate\n     * @return {@code filter} for chaining"
        },
        "populateRange": {
          "Javadoc": "* Enables all bits in a range (inclusive).\n     * @param <T> the Bloom filter type.\n     * @param filter the Bloom filter to populate\n     * @param start the starting bit to enable.\n     * @param end the last bit to enable.\n     * @return {@code filter} for chaining"
        },
        "randomHasher": {
          "Javadoc": "* Creates an EnhancedDoubleHasher hasher from 2 random longs."
        }
      }
    },
    "org.apache.commons.collections4.bloomfilter.WrappedBloomFilterTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.BulkTest": {
      "Javadoc": "\n * A {@link TestCase} that can define both simple and bulk test methods.\n * <p>\n * A <I>simple test method</I> is the type of test traditionally\n * supplied by {@link TestCase}.  To define a simple test, create a public\n * no-argument method whose name starts with \"test\".  You can specify\n * the name of simple test in the constructor of {@code BulkTest};\n * a subsequent call to {@link TestCase#run} will run that simple test.\n * <p>\n * A <I>bulk test method</I>, on the other hand, returns a new instance\n * of {@code BulkTest}, which can itself define new simple and bulk\n * test methods.  By using the {@link #makeSuite} method, you can\n * automatically create a hierarchical suite of tests and child bulk tests.\n * <p>\n * For instance, consider the following two classes:\n *\n * <Pre>\n *  public class SetTest extends BulkTest {\n *\n *      private Set set;\n *\n *      public SetTest(Set set) {\n *          this.set = set;\n *      }\n *\n *      @Test\n *      public void testContains() {\n *          boolean r = set.contains(set.iterator().next()));\n *          assertTrue(\"Set should contain first element, r);\n *      }\n *\n *      @Test\n *      public void testClear() {\n *          set.clear();\n *          assertTrue(\"Set should be empty after clear\", set.isEmpty());\n *      }\n *  }\n *\n *\n *  public class HashMapTest extends BulkTest {\n *\n *      private Map makeFullMap() {\n *          HashMap result = new HashMap();\n *          result.put(\"1\", \"One\");\n *          result.put(\"2\", \"Two\");\n *          return result;\n *      }\n *\n *      @Test\n *      public void testClear() {\n *          Map map = makeFullMap();\n *          map.clear();\n *          assertTrue(\"Map empty after clear\", map.isEmpty());\n *      }\n *\n *      public BulkTest bulkTestKeySet() {\n *          return new SetTest(makeFullMap().keySet());\n *      }\n *\n *      public BulkTest bulkTestEntrySet() {\n *          return new SetTest(makeFullMap().entrySet());\n *      }\n *  }\n *  </Pre>\n *\n *  In the above examples, {@code SetTest} defines two\n *  simple test methods and no bulk test methods; {@code HashMapTest}\n *  defines one simple test method and two bulk test methods.  When\n *  {@code makeSuite(HashMapTest.class).run} is executed,\n *  <I>five</I> simple test methods will be run, in this order:<P>\n *\n *  <Ol>\n *  <Li>HashMapTest.testClear()\n *  <Li>HashMapTest.bulkTestKeySet().testContains();\n *  <Li>HashMapTest.bulkTestKeySet().testClear();\n *  <Li>HashMapTest.bulkTestEntrySet().testContains();\n *  <Li>HashMapTest.bulkTestEntrySet().testClear();\n *  </Ol>\n *\n *  In the graphical junit test runners, the tests would be displayed in\n *  the following tree:<P>\n *\n *  <UL>\n *  <LI>HashMapTest</LI>\n *      <UL>\n *      <LI>testClear\n *      <LI>bulkTestKeySet\n *          <UL>\n *          <LI>testContains\n *          <LI>testClear\n *          </UL>\n *      <LI>bulkTestEntrySet\n *          <UL>\n *          <LI>testContains\n *          <LI>testClear\n *          </UL>\n *      </UL>\n *  </UL>\n *\n *  A subclass can override a superclass's bulk test by\n *  returning {@code null} from the bulk test method.  If you only\n *  want to override specific simple tests within a bulk test, use the\n *  {@link #ignoredTests} method.<P>\n *\n *  Note that if you want to use the bulk test methods, you <I>must</I>\n *  define your {@code suite()} method to use {@link #makeSuite}.\n *  The ordinary {@link TestSuite} constructor doesn't know how to\n *  interpret bulk test methods.\n ",
      "methods": {
        "clone": {
          "Javadoc": "*  Creates a clone of this {@code BulkTest}.<P>\n     *\n     *  @return  a clone of this {@code BulkTest}"
        },
        "getName": {
          "Javadoc": "*  Returns the name of the simple test method of this {@code BulkTest}.\n     *\n     *  @return the name of the simple test method of this {@code BulkTest}"
        },
        "ignoredTests": {
          "Javadoc": "*  Returns an array of test names to ignore.<P>\n     *\n     *  If a test that's defined by this {@code BulkTest} or\n     *  by one of its bulk test methods has a name that's in the returned\n     *  array, then that simple test will not be executed.<P>\n     *\n     *  A test's name is formed by taking the class name of the\n     *  root {@code BulkTest}, eliminating the package name, then\n     *  appending the names of any bulk test methods that were invoked\n     *  to get to the simple test, and then appending the simple test\n     *  method name.  The method names are delimited by periods:\n     *\n     *  <pre>\n     *  HashMapTest.bulkTestEntrySet.testClear\n     *  </pre>\n     *\n     *  is the name of one of the simple tests defined in the sample classes\n     *  described above.  If the sample {@code HashMapTest} class\n     *  included this method:\n     *\n     *  <pre>\n     *  public String[] ignoredTests() {\n     *      return new String[] { \"HashMapTest.bulkTestEntrySet.testClear\" };\n     *  }\n     *  </pre>\n     *\n     *  then the entry set's clear method wouldn't be tested, but the key\n     *  set's clear method would.\n     *\n     *  @return an array of the names of tests to ignore, or null if\n     *   no tests should be ignored"
        },
        "toString": {
          "Javadoc": "*  Returns the display name of this {@code BulkTest}.\n     *\n     *  @return the display name of this {@code BulkTest}"
        }
      }
    },
    "org.apache.commons.collections4.ClosureUtilsTest": {
      "Javadoc": "\n * Tests the ClosureUtils class.\n ",
      "methods": {
        "testSingletonPatternInSerialization": {
          "Javadoc": "* Test that all Closure singletons hold singleton pattern in\n     * serialization/deserialization process."
        }
      }
    },
    "org.apache.commons.collections4.MockClosure": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.MockTransformer": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.collection.AbstractCollectionTest": {
      "Javadoc": "\n * Abstract test class for {@link java.util.Collection} methods and contracts.\n * <p>\n * You should create a concrete subclass of this class to test any custom\n * {@link Collection} implementation.  At minimum, you'll have to\n * implement the {@link #makeObject()}, {@link #makeConfirmedCollection()}\n * and {@link #makeConfirmedFullCollection()} methods.\n * You might want to override some of the additional public methods as well:\n * <p>\n * <b>Element Population Methods</b>\n * <p>\n * Override these if your collection restricts what kind of elements are\n * allowed (for instance, if {@code null} is not permitted):\n * <ul>\n * <li>{@link #getFullElements()}\n * <li>{@link #getOtherElements()}\n * </ul>\n * <p>\n * <b>Supported Operation Methods</b>\n * <p>\n * Override these if your collection doesn't support certain operations:\n * <ul>\n * <li>{@link #isAddSupported()}\n * <li>{@link #isRemoveSupported()}\n * <li>{@link #areEqualElementsDistinguishable()}\n * <li>{@link #isNullSupported()}\n * <li>{@link #isFailFastSupported()}\n * </ul>\n * <p>\n * <b>Indicate Collection Behaviour</b>\n * <p>\n * Override these if your collection makes specific behavior guarantees:\n * <ul>\n * <li>{@link #getIterationBehaviour()}</li>\n * </ul>\n * <p>\n * <b>Fixture Methods</b>\n * <p>\n * Fixtures are used to verify that the operation results in correct state\n * for the collection.  Basically, the operation is performed against your\n * collection implementation, and an identical operation is performed against a\n * <i>confirmed</i> collection implementation.  A confirmed collection\n * implementation is something like {@link java.util.ArrayList}, which is\n * known to conform exactly to its collection interface's contract.  After the\n * operation takes place on both your collection implementation and the\n * confirmed collection implementation, the two collections are compared to see\n * if their state is identical.  The comparison is usually much more involved\n * than a simple {@code equals} test.  This verification is used to ensure\n * proper modifications are made along with ensuring that the collection does\n * not change when read-only modifications are made.\n * <p>\n * The {@link #collection} field holds an instance of your collection\n * implementation; the {@link #confirmed} field holds an instance of the\n * confirmed collection implementation.  The {@link #resetEmpty()} and\n * {@link #resetFull()} methods set these fields to empty or full collections,\n * so that tests can proceed from a known state.\n * <p>\n * After a modification operation to both {@link #collection} and\n * {@link #confirmed}, the {@link #verify()} method is invoked to compare\n * the results.  You may want to override {@link #verify()} to perform\n * additional verifications.  For instance, when testing the collection\n * views of a map, {@link org.apache.commons.collections4.map.AbstractMapTest AbstractTestMap}\n * would override {@link #verify()} to make\n * sure the map is changed after the collection view is changed.\n * <p>\n * If you're extending this class directly, you will have to provide\n * implementations for the following:\n * <ul>\n * <li>{@link #makeConfirmedCollection()}\n * <li>{@link #makeConfirmedFullCollection()}\n * </ul>\n * <p>\n * Those methods should provide a confirmed collection implementation\n * that's compatible with your collection implementation.\n * <p>\n * If you're extending {@link org.apache.commons.collections4.list.AbstractListTest AbstractListTest},\n * {@link org.apache.commons.collections4.set.AbstractSetTest AbstractTestSet},\n * or {@link org.apache.commons.collections4.bag.AbstractBagTest AbstractBagTest},\n * you probably don't have to worry about the\n * above methods, because those three classes already override the methods\n * to provide standard JDK confirmed collections.<P>\n * <p>\n * <b>Other notes</b>\n * <p>\n * If your {@link Collection} fails one of these tests by design,\n * you may still use this base set of cases.  Simply override the\n * test case (method) your {@link Collection} fails.\n ",
      "methods": {
        "assertNotCollectionContains": {
          "Javadoc": "* Handle the optional exceptions declared by {@link Collection#contains(Object)}\n     * @param coll\n     * @param element"
        },
        "assertNotCollectionContainsAll": {
          "Javadoc": "* Handle the optional exceptions declared by {@link Collection#containsAll(Collection)}\n     * @param coll\n     * @param sub"
        },
        "assertNotRemoveAllFromCollection": {
          "Javadoc": "* Handle optional exceptions of {@link Collection#removeAll(Collection)}\n     * @param coll\n     * @param sub"
        },
        "assertNotRemoveFromCollection": {
          "Javadoc": "* Handle optional exceptions of {@link Collection#remove(Object)}\n     * @param coll\n     * @param element"
        },
        "assertUnorderedArrayEquals": {
          "Javadoc": "* Assert the arrays contain the same elements, ignoring the order.\n     *\n     * <p>Note this does not test the arrays are deeply equal. Array elements are compared\n     * using {@link Object#equals(Object)}.\n     *\n     * @param a1 First array\n     * @param a2 Second array\n     * @param msg Failure message prefix"
        },
        "areEqualElementsDistinguishable": {
          "Javadoc": "*  Specifies whether equal elements in the collection are, in fact,\n     *  distinguishable with information not readily available.  That is, if a\n     *  particular value is to be removed from the collection, then there is\n     *  one and only one value that can be removed, even if there are other\n     *  elements which are equal to it.\n     *\n     *  <P>In most collection cases, elements are not distinguishable (equal is\n     *  equal), thus this method defaults to return false.  In some cases,\n     *  however, they are.  For example, the collection returned from the map's\n     *  values() collection view are backed by the map, so while there may be\n     *  two values that are equal, their associated keys are not.  Since the\n     *  keys are distinguishable, the values are.\n     *\n     *  <P>This flag is used to skip some verifications for iterator.remove()\n     *  where it is impossible to perform an equivalent modification on the\n     *  confirmed collection because it is not possible to determine which\n     *  value in the confirmed collection to actually remove.  Tests that\n     *  override the default (i.e. where equal elements are distinguishable),\n     *  should provide additional tests on iterator.remove() to make sure the\n     *  proper elements are removed when remove() is called on the iterator.\n     *"
        },
        "cloneMapEntry": {
          "Javadoc": "* Creates a new Map Entry that is independent of the first and the map."
        },
        "getFullElements": {
          "Javadoc": "*  Returns an array of objects that are contained in a collection\n     *  produced by {@link #makeFullCollection()}.  Every element in the\n     *  returned array <I>must</I> be an element in a full collection.<P>\n     *  The default implementation returns a heterogeneous array of\n     *  objects with some duplicates. null is added if allowed.\n     *  Override if you require specific testing elements.  Note that if you\n     *  override {@link #makeFullCollection()}, you <I>must</I> override\n     *  this method to reflect the contents of a full collection."
        },
        "getFullNonNullElements": {
          "Javadoc": "*  Returns a list of elements suitable for return by\n     *  {@link #getFullElements()}.  The array returned by this method\n     *  does not include null, but does include a variety of objects\n     *  of different types.  Override getFullElements to return\n     *  the results of this method if your collection does not support\n     *  the null element."
        },
        "getFullNonNullStringElements": {
          "Javadoc": "*  Returns a list of string elements suitable for return by\n     *  {@link #getFullElements()}.  Override getFullElements to return\n     *  the results of this method if your collection does not support\n     *  heterogeneous elements or the null element."
        },
        "getIterationBehaviour": {
          "Javadoc": "* Return a flag specifying the iteration behavior of the collection.\n     * This is used to change the assertions used by specific tests.\n     * The default implementation returns 0 which indicates ordered iteration behavior.\n     *\n     * @return the iteration behavior\n     * @see #UNORDERED"
        },
        "getOtherElements": {
          "Javadoc": "*  Returns an array of elements that are <I>not</I> contained in a\n     *  full collection.  Every element in the returned array must\n     *  not exist in a collection returned by {@link #makeFullCollection()}.\n     *  The default implementation returns a heterogeneous array of elements\n     *  without null.  Note that some of the tests add these elements\n     *  to an empty or full collection, so if your collection restricts\n     *  certain kinds of elements, you should override this method."
        },
        "getOtherNonNullElements": {
          "Javadoc": "*  Returns the default list of objects returned by\n     *  {@link #getOtherElements()}.  Includes many objects\n     *  of different types."
        },
        "getOtherNonNullStringElements": {
          "Javadoc": "*  Returns a list of string elements suitable for return by\n     *  {@link #getOtherElements()}.  Override getOtherElements to return\n     *  the results of this method if your collection does not support\n     *  heterogeneous elements or the null element."
        },
        "isAddSupported": {
          "Javadoc": "*  Returns true if the collections produced by\n     *  {@link #makeObject()} and {@link #makeFullCollection()}\n     *  support the {@code add} and {@code addAll}\n     *  operations.<P>\n     *  Default implementation returns true.  Override if your collection\n     *  class does not support add or addAll."
        },
        "isEqualsCheckable": {
          "Javadoc": "* Returns true to indicate that the collection supports equals() comparisons.\n     * This implementation returns false;"
        },
        "isFailFastSupported": {
          "Javadoc": "* Returns true to indicate that the collection supports fail fast iterators.\n     * The default implementation returns true;"
        },
        "isNullSupported": {
          "Javadoc": "* Returns true to indicate that the collection supports holding null.\n     * The default implementation returns true;"
        },
        "isRemoveSupported": {
          "Javadoc": "*  Returns true if the collections produced by\n     *  {@link #makeObject()} and {@link #makeFullCollection()}\n     *  support the {@code remove}, {@code removeAll},\n     *  {@code retainAll}, {@code clear} and\n     *  {@code iterator().remove()} methods.\n     *  Default implementation returns true.  Override if your collection\n     *  class does not support removal operations."
        },
        "makeConfirmedCollection": {
          "Javadoc": "*  Returns a confirmed empty collection.\n     *  For instance, an {@link java.util.ArrayList} for lists or a\n     *  {@link java.util.HashSet} for sets.\n     *\n     *  @return a confirmed empty collection"
        },
        "makeConfirmedFullCollection": {
          "Javadoc": "*  Returns a confirmed full collection.\n     *  For instance, an {@link java.util.ArrayList} for lists or a\n     *  {@link java.util.HashSet} for sets.  The returned collection\n     *  should contain the elements returned by {@link #getFullElements()}.\n     *\n     *  @return a confirmed full collection"
        },
        "makeFullCollection": {
          "Javadoc": "*  Returns a full collection to be used for testing.  The collection\n     *  returned by this method should contain every element returned by\n     *  {@link #getFullElements()}.  The default implementation, in fact,\n     *  simply invokes {@code addAll} on an empty collection with\n     *  the results of {@link #getFullElements()}.  Override this default\n     *  if your collection doesn't support addAll."
        },
        "makeObject": {
          "Javadoc": "* Return a new, empty {@link Collection} to be used for testing."
        },
        "resetEmpty": {
          "Javadoc": "*  Resets the {@link #collection} and {@link #confirmed} fields to empty\n     *  collections.  Invoke this method before performing a modification\n     *  test."
        },
        "resetFull": {
          "Javadoc": "*  Resets the {@link #collection} and {@link #confirmed} fields to full\n     *  collections.  Invoke this method before performing a modification\n     *  test."
        },
        "setCollection": {
          "Javadoc": "* Sets the collection.\n     * @param collection the Collection<E> to set"
        },
        "setConfirmed": {
          "Javadoc": "* Sets the confirmed.\n     * @param confirmed the Collection<E> to set"
        },
        "testCollectionAdd": {
          "Javadoc": "*  Tests {@link Collection#add(Object)}."
        },
        "testCollectionAddAll": {
          "Javadoc": "*  Tests {@link Collection#addAll(Collection)}."
        },
        "testCollectionClear": {
          "Javadoc": "*  Test {@link Collection#clear()}."
        },
        "testCollectionContains": {
          "Javadoc": "*  Tests {@link Collection#contains(Object)}."
        },
        "testCollectionContainsAll": {
          "Javadoc": "*  Tests {@link Collection#containsAll(Collection)}."
        },
        "testCollectionIsEmpty": {
          "Javadoc": "*  Tests {@link Collection#isEmpty()}."
        },
        "testCollectionIterator": {
          "Javadoc": "*  Tests the read-only functionality of {@link Collection#iterator()}."
        },
        "testCollectionIteratorFailFast": {
          "Javadoc": "*  Tests that the collection's iterator is fail-fast."
        },
        "testCollectionIteratorRemove": {
          "Javadoc": "*  Tests removals from {@link Collection#iterator()}."
        },
        "testCollectionRemove": {
          "Javadoc": "*  Tests {@link Collection#remove(Object)}."
        },
        "testCollectionRemoveAll": {
          "Javadoc": "*  Tests {@link Collection#removeAll(Collection)}."
        },
        "testCollectionRemoveIf": {
          "Javadoc": "*  Tests {@link Collection#removeIf(Predicate)}."
        },
        "testCollectionRetainAll": {
          "Javadoc": "*  Tests {@link Collection#retainAll(Collection)}."
        },
        "testCollectionSize": {
          "Javadoc": "*  Tests {@link Collection#size()}."
        },
        "testCollectionToArray": {
          "Javadoc": "*  Tests {@link Collection#toArray()}."
        },
        "testCollectionToArray2": {
          "Javadoc": "*  Tests {@link Collection#toArray(Object[])}."
        },
        "testCollectionToString": {
          "Javadoc": "*  Tests {@code toString} on a collection."
        },
        "testUnsupportedAdd": {
          "Javadoc": "*  If {@link #isAddSupported()} returns false, tests that add operations\n     *  raise <code>UnsupportedOperationException."
        },
        "testUnsupportedRemove": {
          "Javadoc": "*  If isRemoveSupported() returns false, tests to see that remove\n     *  operations raise an UnsupportedOperationException."
        },
        "verify": {
          "Javadoc": "*  Verifies that {@link #collection} and {@link #confirmed} have\n     *  identical state."
        }
      }
    },
    "org.apache.commons.collections4.collection.CompositeCollectionTest": {
      "Javadoc": "\n * Extension of {@link AbstractCollectionTest} for exercising the\n * {@link CompositeCollection} implementation.\n ",
      "methods": {
        "isAddSupported": {
          "Javadoc": "* Run stock collection tests without Mutator, so turn off add, remove"
        },
        "makeConfirmedFullCollection": {
          "Javadoc": "* Full collection should look like a collection with 4 elements"
        },
        "makeFullCollection": {
          "Javadoc": "* Full collection consists of 4 collections, each with one element"
        },
        "makeObject": {
          "Javadoc": "* Empty collection is empty composite"
        },
        "testRemoveIf": {
          "Javadoc": ""
        },
        "testUnsupportedRemove": {
          "Javadoc": "* Override testUnsupportedRemove, since the default impl expects removeAll,\n     * retainAll and iterator().remove to throw"
        }
      }
    },
    "org.apache.commons.collections4.collection.IndexedCollectionTest": {
      "Javadoc": "\n * Extension of {@link AbstractCollectionTest} for exercising the\n * {@link IndexedCollection} implementation.\n "
    },
    "org.apache.commons.collections4.collection.IntegerTransformer": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.collection.PredicatedCollectionBuilderTest": {
      "Javadoc": "\n * Tests the PredicatedCollection.Builder class.\n ",
      "methods": {
        "testAddAllPass": {
          "Javadoc": "* Verify that only items that pass the Predicate end up in the buffer."
        },
        "testAddFail": {
          "Javadoc": "* Verify that failing the Predicate means NOT ending up in the buffer."
        },
        "testAddPass": {
          "Javadoc": "* Verify that passing the Predicate means ending up in the buffer."
        }
      }
    },
    "org.apache.commons.collections4.collection.OddPredicate": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.collection.PredicatedCollectionTest": {
      "Javadoc": "\n * Extension of {@link AbstractCollectionTest} for exercising the\n * {@link PredicatedCollection} implementation.\n "
    },
    "org.apache.commons.collections4.collection.SynchronizedCollectionTest": {
      "Javadoc": "\n * Extension of {@link AbstractCollectionTest} for exercising the\n * {@link SynchronizedCollection} implementation.\n "
    },
    "org.apache.commons.collections4.collection.TransformedCollectionTest": {
      "Javadoc": "\n * Extension of {@link AbstractCollectionTest} for exercising the {@link TransformedCollection}\n * implementation.\n "
    },
    "org.apache.commons.collections4.collection.StringToInteger": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.collection.ToLowerCase": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.collection.UnmodifiableBoundedCollectionTest": {
      "Javadoc": "\n * Extension of {@link AbstractCollectionTest} for exercising the\n * {@link UnmodifiableBoundedCollection} implementation.\n "
    },
    "org.apache.commons.collections4.collection.UnmodifiableCollectionTest": {
      "Javadoc": "\n * Extension of {@link AbstractCollectionTest} for exercising the\n * {@link UnmodifiableCollection} implementation.\n "
    },
    "org.apache.commons.collections4.CollectionUtilsTest": {
      "Javadoc": "\n * Tests for CollectionUtils.\n ",
      "methods": {
        "next": {
          "Javadoc": "* Records the next object returned for a mock iterator"
        },
        "testAddAllForIterable": {
          "Javadoc": "* This test ensures that {@link Iterable}s are supported by {@link CollectionUtils}.\n     * Specifically, it uses mocks to ensure that if the passed in\n     * {@link Iterable} is a {@link Collection} then\n     * {@link Collection#addAll(Collection)} is called instead of iterating."
        },
        "testGetFromList": {
          "Javadoc": "* Tests that {@link List}s are handled correctly - e.g. using\n     * {@link List#get(int)}."
        }
      }
    },
    "org.apache.commons.collections4.comparators.AbstractComparatorTest": {
      "Javadoc": "\n * Abstract test class for testing the Comparator interface.\n * <p>\n * Concrete subclasses declare the comparator to be tested.\n * They also declare certain aspects of the tests.\n ",
      "methods": {
        "getComparableObjectsOrdered": {
          "Javadoc": "* Implement this method to return a list of sorted objects.\n     *\n     * @return sorted objects"
        },
        "makeObject": {
          "Javadoc": "* Implements the abstract superclass method to return the comparator.\n     *\n     * @return a full iterator"
        },
        "randomizeObjects": {
          "Javadoc": "* Randomize the list."
        },
        "reverseObjects": {
          "Javadoc": "* Reverse the list."
        },
        "sortObjects": {
          "Javadoc": "* Sort the list."
        },
        "supportsEmptyCollections": {
          "Javadoc": "* Overrides superclass to block tests."
        },
        "supportsFullCollections": {
          "Javadoc": "* Overrides superclass to block tests."
        },
        "testComparatorCompatibility": {
          "Javadoc": "* Compare the current serialized form of the Comparator\n     * against the canonical version in SCM."
        },
        "testComparatorIsSerializable": {
          "Javadoc": "* Nearly all Comparators should be Serializable."
        },
        "testEmptyListSort": {
          "Javadoc": "* Test sorting an empty list"
        },
        "testRandomListSort": {
          "Javadoc": "* Test sorting a random list."
        },
        "testReverseListSort": {
          "Javadoc": "* Test sorting a reversed list."
        }
      }
    },
    "org.apache.commons.collections4.comparators.AbstractNullComparatorTest": {
      "Javadoc": "\n * Test the NullComparator.\n "
    },
    "org.apache.commons.collections4.comparators.TestNullComparator1": {
      "Javadoc": "\n     *  Test the NullComparator with nulls high, using comparable comparator\n     *"
    },
    "org.apache.commons.collections4.comparators.TestNullComparator2": {
      "Javadoc": "\n     *  Test the NullComparator with nulls low using the comparable comparator\n     *"
    },
    "org.apache.commons.collections4.comparators.BooleanComparatorTest": {
      "Javadoc": "\n * Tests for {@link BooleanComparator}.\n "
    },
    "org.apache.commons.collections4.comparators.ComparableComparatorTest": {
      "Javadoc": "\n * Tests for ComparableComparator.\n "
    },
    "org.apache.commons.collections4.comparators.ComparatorChainTest": {
      "Javadoc": "\n * Tests for ComparatorChain.\n "
    },
    "org.apache.commons.collections4.comparators.ColumnComparator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.comparators.PseudoRow": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.comparators.FixedOrderComparatorTest": {
      "Javadoc": "\n * Test class for FixedOrderComparator.\n ",
      "methods": {
        "assertComparatorYieldsOrder": {
          "Javadoc": "Shuffles the keys and asserts that the comparator sorts them back to\n     * their original order."
        },
        "testAddAsEqual": {
          "Javadoc": "* Tests addAsEqual method."
        },
        "testArrayConstructor": {
          "Javadoc": "* Tests that the array constructor compares items properly."
        },
        "testConstructorPlusAdd": {
          "Javadoc": "* Tests that the constructor plus add method compares items properly."
        },
        "testListConstructor": {
          "Javadoc": "* Tests the list constructor."
        },
        "testLock": {
          "Javadoc": "* Tests whether or not updates are disabled after a comparison is made."
        }
      }
    },
    "org.apache.commons.collections4.comparators.Equals": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.comparators.ReverseComparatorTest": {
      "Javadoc": "\n * Tests for ReverseComparator.\n ",
      "methods": {
        "makeObject": {
          "Javadoc": "* For the purposes of this test, return a\n     * ReverseComparator that wraps the java.util.Collections.reverseOrder()\n     * Comparator.  The resulting comparator should\n     * sort according to natural Order.  (Note: we wrap\n     * a Comparator taken from the JDK so that we can\n     * save a \"canonical\" form in SCM).\n     *\n     * @return Comparator that returns \"natural\" order"
        },
        "testSerializeDeserializeThenCompare": {
          "Javadoc": "* Override this inherited test since Collections.reverseOrder\n     * doesn't adhere to the \"soft\" Comparator contract, and we've\n     * already \"canonized\" the comparator returned by makeComparator."
        }
      }
    },
    "org.apache.commons.collections4.comparators.TransformingComparatorTest": {
      "Javadoc": "\n * Test class for TransformingComparator.\n "
    },
    "org.apache.commons.collections4.ComparatorUtilsTest": {
      "Javadoc": "\n * Tests ComparatorUtils.\n "
    },
    "org.apache.commons.collections4.EnumerationUtilsTest": {
      "Javadoc": "\n * Tests EnumerationUtils.\n "
    },
    "org.apache.commons.collections4.FactoryUtilsTest": {
      "Javadoc": "\n * Tests the org.apache.commons.collections.FactoryUtils class.\n ",
      "methods": {
        "testSingletonPatternInSerialization": {
          "Javadoc": "* Test that all Factory singletons hold singleton pattern in\n     * serialization/deserialization process."
        }
      }
    },
    "org.apache.commons.collections4.Mock1": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.Mock2": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.Mock3": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.FluentIterableTest": {
      "Javadoc": "\n * Tests for FluentIterable.\n "
    },
    "org.apache.commons.collections4.functors.AbstractAnyAllOnePredicateTest": {
      "Javadoc": "\n * Base class for tests of AnyPredicate, AllPredicate, and OnePredicate.\n ",
      "methods": {
        "singleElementArrayToGetInstance": {
          "Javadoc": "* Tests whether {@code getInstance} with a one element array returns the first element in the array."
        },
        "singletonCollectionToGetInstance": {
          "Javadoc": "* Tests that passing a singleton collection to {@code getInstance} returns the single element in the\n     * collection."
        },
        "singleValues": {
          "Javadoc": "* Tests creating composite predicate instances with single predicates and verifies that the composite returns\n     * the same value as the single predicate does."
        }
      }
    },
    "org.apache.commons.collections4.functors.AbstractClosureTest": {
      "Javadoc": "",
      "methods": {
        "generateClosure": {
          "Javadoc": "* @return a closure for general sanity tests."
        }
      }
    },
    "org.apache.commons.collections4.functors.AbstractCompositePredicateTest": {
      "Javadoc": "\n * Base class for tests of composite predicates.\n ",
      "methods": {
        "getPredicateInstance": {
          "Javadoc": "* Creates an instance of the predicate to test.\n     *\n     * @param predicates the arguments to {@code getInstance}.\n     *\n     * @return a predicate to test."
        },
        "nullArrayToGetInstance": {
          "Javadoc": "* Tests {@code getInstance} with a null predicate array."
        },
        "nullCollectionToGetInstance": {
          "Javadoc": "* Tests {@code getInstance} with a null predicate collection"
        },
        "nullElementInArrayToGetInstance": {
          "Javadoc": "* Tests {@code getInstance} with a single null element in the predicate array."
        },
        "nullElementsInArrayToGetInstance": {
          "Javadoc": "* Tests {@code getInstance} with two null elements in the predicate array."
        },
        "nullElementsInCollectionToGetInstance": {
          "Javadoc": "* Tests {@code getInstance} with a predicate collection that contains null elements"
        },
        "singleElementArrayToGetInstance": {
          "Javadoc": "* Tests whether {@code getInstance} with a one element array returns the first element in the array."
        },
        "singletonCollectionToGetInstance": {
          "Javadoc": "* Tests that passing a singleton collection to {@code getInstance} returns the single element in the\n     * collection."
        }
      }
    },
    "org.apache.commons.collections4.functors.AbstractMockPredicateTest": {
      "Javadoc": "\n * Base class for tests of predicates which delegate to other predicates when evaluating an object.  This class\n * provides methods to create and verify mock predicates to which to delegate.\n ",
      "methods": {
        "createMockPredicate": {
          "Javadoc": "* Creates a single mock predicate.\n     *\n     * @param returnValue the return value for the mock predicate, or null if the mock is not expected to be called.\n     *\n     * @return a single mock predicate."
        },
        "createVerifyList": {
          "Javadoc": "* Creates the list of predicates to verify."
        },
        "getTestValue": {
          "Javadoc": "* Gets the value which will be passed to the mock predicates.\n     *\n     * @return the test value."
        },
        "verifyPredicates": {
          "Javadoc": "* Verifies all the mock predicates created for the test."
        }
      }
    },
    "org.apache.commons.collections4.functors.AbstractPredicateTest": {
      "Javadoc": "",
      "methods": {
        "generatePredicate": {
          "Javadoc": "* @return a predicate for general sanity tests."
        }
      }
    },
    "org.apache.commons.collections4.functors.AllPredicateTest": {
      "Javadoc": "\n * Tests the org.apache.commons.collections.functors.AllPredicate class.\n ",
      "methods": {
        "getPredicateInstance": {
          "Javadoc": "* {@inheritDoc}"
        },
        "testAllTrue": {
          "Javadoc": "* Tests whether multiple true predicates evaluates to true."
        },
        "testEmptyArrayToGetInstance": {
          "Javadoc": "* Verifies that providing an empty predicate array evaluates to true."
        },
        "testEmptyCollectionToGetInstance": {
          "Javadoc": "* Verifies that providing an empty predicate collection evaluates to true."
        },
        "testOneFalsePredicate": {
          "Javadoc": "* Tests whether a single false predicate evaluates to true."
        },
        "testOneTruePredicate": {
          "Javadoc": "* Tests whether a single true predicate evaluates to true."
        },
        "testTrueAndFalseCombined": {
          "Javadoc": "* Tests whether combining some true and one false evaluates to false.  Also verifies that only the first\n     * false predicate is actually evaluated"
        }
      }
    },
    "org.apache.commons.collections4.functors.CatchAndRethrowClosureTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.functors.ComparatorPredicateTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.functors.TestComparator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.functors.EqualPredicateTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.functors.EqualsTestObject": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.functors.NullPredicateTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.GuavaTestlibTest": {
      "Javadoc": "\n * This test uses Google's Guava Testlib testing libraries to validate the\n * contract of collection classes in Commons Collections. This was introduced\n * after COLLECTIONS-802, where the issue reported was found with Testlib.\n *\n * @see <a href=\"https://github.com/google/guava/tree/master/guava-testlib\">https://github.com/google/guava/tree/master/guava-testlib</a>\n * @see <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-802\">https://issues.apache.org/jira/browse/COLLECTIONS-802</a>\n ",
      "methods": {
        "suiteList": {
          "Javadoc": "* Programmatically create a JUnit (3, 4) Test Suite for Guava testlib tests with Lists.\n     * @param name name of the test\n     * @param factory factory to create new Lists\n     * @param features test features used in the tests\n     * @return a JUnit 3, 4 Test Suite"
        },
        "suiteMap": {
          "Javadoc": "* Programmatically create a JUnit (3, 4) Test Suite for Guava testlib tests with Maps.\n     * @param name name of the test\n     * @param factory factory to create new Maps\n     * @return a JUnit 3, 4 Test Suite"
        }
      }
    },
    "org.apache.commons.collections4.IterableUtilsTest": {
      "Javadoc": "\n * Tests for IterableUtils.\n "
    },
    "org.apache.commons.collections4.iterators.AbstractIteratorTest": {
      "Javadoc": "\n * Abstract class for testing the Iterator interface.\n * <p>\n * This class provides a framework for testing an implementation of Iterator.\n * Concrete subclasses must provide the iterator to be tested.\n * They must also specify certain details of how the iterator operates by\n * overriding the supportsXxx() methods if necessary.\n ",
      "methods": {
        "makeEmptyIterator": {
          "Javadoc": "* Implement this method to return an iterator over an empty collection.\n     *\n     * @return an empty iterator"
        },
        "makeObject": {
          "Javadoc": "* Implements the abstract superclass method to return the full iterator.\n     *\n     * @return a full iterator"
        },
        "supportsEmptyIterator": {
          "Javadoc": "* Whether or not we are testing an iterator that can be empty.\n     * Default is true.\n     *\n     * @return true if Iterator can be empty"
        },
        "supportsFullIterator": {
          "Javadoc": "* Whether or not we are testing an iterator that can contain elements.\n     * Default is true.\n     *\n     * @return true if Iterator can be full"
        },
        "supportsRemove": {
          "Javadoc": "* Whether or not we are testing an iterator that supports remove().\n     * Default is true.\n     *\n     * @return true if Iterator supports remove"
        },
        "testEmptyIterator": {
          "Javadoc": "* Test the empty iterator."
        },
        "testFullIterator": {
          "Javadoc": "* Test normal iteration behavior."
        },
        "testRemove": {
          "Javadoc": "* Test remove behavior."
        },
        "verify": {
          "Javadoc": "* Allows subclasses to add complex cross verification"
        }
      }
    },
    "org.apache.commons.collections4.iterators.AbstractListIteratorTest": {
      "Javadoc": "\n * Abstract class for testing the ListIterator interface.\n * <p>\n * This class provides a framework for testing an implementation of ListIterator.\n * Concrete subclasses must provide the list iterator to be tested.\n * They must also specify certain details of how the list iterator operates by\n * overriding the supportsXxx() methods if necessary.\n ",
      "methods": {
        "addSetValue": {
          "Javadoc": "* The value to be used in the add and set tests.\n     * Default is null."
        },
        "makeEmptyIterator": {
          "Javadoc": "* Implements the abstract superclass method to return the list iterator.\n     *\n     * @return an empty iterator"
        },
        "makeObject": {
          "Javadoc": "* Implements the abstract superclass method to return the list iterator.\n     *\n     * @return a full iterator"
        },
        "supportsAdd": {
          "Javadoc": "* Whether or not we are testing an iterator that supports add().\n     * Default is true.\n     *\n     * @return true if Iterator supports add"
        },
        "supportsSet": {
          "Javadoc": "* Whether or not we are testing an iterator that supports set().\n     * Default is true.\n     *\n     * @return true if Iterator supports set"
        },
        "testAdd": {
          "Javadoc": "* Test add behavior."
        },
        "testAddThenRemove": {
          "Javadoc": "* Test remove after add behavior."
        },
        "testEmptyListIteratorIsIndeedEmpty": {
          "Javadoc": "* Test that the empty list iterator contract is correct."
        },
        "testSet": {
          "Javadoc": "* Test set behavior."
        },
        "testWalkForwardAndBack": {
          "Javadoc": "* Test navigation through the iterator."
        }
      }
    },
    "org.apache.commons.collections4.iterators.AbstractMapIteratorTest": {
      "Javadoc": "\n * Abstract class for testing the MapIterator interface.\n * <p>\n * This class provides a framework for testing an implementation of MapIterator.\n * Concrete subclasses must provide the list iterator to be tested.\n * They must also specify certain details of how the list iterator operates by\n * overriding the supportsXxx() methods if necessary.\n ",
      "methods": {
        "addSetValues": {
          "Javadoc": "* The values to be used in the add and set tests.\n     * Default is two strings."
        },
        "getConfirmedMap": {
          "Javadoc": "* Implement this method to return the confirmed map which contains the same\n     * data as the iterator.\n     *\n     * @return a full map which can be updated"
        },
        "getMap": {
          "Javadoc": "* Implement this method to return the map which contains the same data as the\n     * iterator.\n     *\n     * @return a full map which can be updated"
        },
        "isGetStructuralModify": {
          "Javadoc": "* Whether the get operation on the map structurally modifies the map,\n     * such as with LRUMap. Default is false.\n     *\n     * @return true if the get method structurally modifies the map"
        },
        "makeEmptyIterator": {
          "Javadoc": "* Implement this method to return a map iterator over an empty map.\n     *\n     * @return an empty iterator"
        },
        "makeObject": {
          "Javadoc": "* Implement this method to return a map iterator over a map with elements.\n     *\n     * @return a full iterator"
        },
        "supportsSetValue": {
          "Javadoc": "* Whether or not we are testing an iterator that supports setValue().\n     * Default is true.\n     *\n     * @return true if Iterator supports set"
        },
        "testEmptyMapIterator": {
          "Javadoc": "* Test that the empty list iterator contract is correct."
        },
        "testFullMapIterator": {
          "Javadoc": "* Test that the full list iterator contract is correct."
        }
      }
    },
    "org.apache.commons.collections4.iterators.AbstractOrderedMapIteratorTest": {
      "Javadoc": "\n * Abstract class for testing the OrderedMapIterator interface.\n * <p>\n * This class provides a framework for testing an implementation of MapIterator.\n * Concrete subclasses must provide the list iterator to be tested.\n * They must also specify certain details of how the list iterator operates by\n * overriding the supportsXxx() methods if necessary.\n ",
      "methods": {
        "testEmptyMapIterator": {
          "Javadoc": "* Test that the empty list iterator contract is correct."
        },
        "testFullMapIterator": {
          "Javadoc": "* Test that the full list iterator contract is correct."
        },
        "testMapIteratorOrder": {
          "Javadoc": "* Test that the iterator order matches the keySet order."
        }
      }
    },
    "org.apache.commons.collections4.iterators.ArrayIterator2Test": {
      "Javadoc": "\n * Tests the ArrayIterator with primitive type arrays.\n "
    },
    "org.apache.commons.collections4.iterators.ArrayIteratorTest": {
      "Javadoc": "\n * Tests the ArrayIterator to ensure that the next() method will actually\n * perform the iteration rather than the hasNext() method.\n * The code of this test was supplied by Mauricio S. Moura.\n "
    },
    "org.apache.commons.collections4.iterators.ArrayListIterator2Test": {
      "Javadoc": "\n * Test the ArrayListIterator class with primitives.\n "
    },
    "org.apache.commons.collections4.iterators.ArrayListIteratorTest": {
      "Javadoc": "\n * Test the ArrayListIterator class.\n ",
      "methods": {
        "testListIterator": {
          "Javadoc": "* Test the basic ListIterator functionality - going backwards using\n     * {@code previous()}."
        },
        "testListIteratorSet": {
          "Javadoc": "* Tests the {@link java.util.ListIterator#set} operation."
        }
      }
    },
    "org.apache.commons.collections4.iterators.BoundedIteratorTest": {
      "Javadoc": "\n * A unit test to test the basic functions of {@link BoundedIterator}.\n ",
      "methods": {
        "testBounded": {
          "Javadoc": "* Test a decorated iterator bounded such that the first element returned is\n     * at an index greater its first element, and the last element returned is\n     * at an index less than its last element."
        },
        "testEmptyBounded": {
          "Javadoc": "* Test a decorated iterator bounded to a {@code max} of 0. The\n     * BoundedIterator should behave as if there are no more elements to return,\n     * since it is technically an empty iterator."
        },
        "testMaxGreaterThanSize": {
          "Javadoc": "* Test the case if the {@code max} passed to the constructor is\n     * greater than the size of the decorated iterator. The last element\n     * returned should be the same as the last element of the decorated\n     * iterator."
        },
        "testNegativeMax": {
          "Javadoc": "* Test the case if a negative {@code max} is passed to the\n     * constructor. {@link IllegalArgumentException} is expected."
        },
        "testNegativeOffset": {
          "Javadoc": "* Test the case if a negative {@code offset} is passed to the\n     * constructor. {@link IllegalArgumentException} is expected."
        },
        "testOffsetGreaterThanSize": {
          "Javadoc": "* Test the case if the {@code offset} passed to the constructor is\n     * greater than the decorated iterator's size. The BoundedIterator should\n     * behave as if there are no more elements to return."
        },
        "testRemoveCalledTwice": {
          "Javadoc": "* Test the {@code remove()} method being called twice without calling\n     * {@code next()} in between."
        },
        "testRemoveFirst": {
          "Javadoc": "* Test removing the first element. Verify that the element is removed from\n     * the underlying collection."
        },
        "testRemoveLast": {
          "Javadoc": "* Test removing the last element. Verify that the element is removed from\n     * the underlying collection."
        },
        "testRemoveMiddle": {
          "Javadoc": "* Test removing an element in the middle of the iterator. Verify that the\n     * element is removed from the underlying collection."
        },
        "testRemoveUnsupported": {
          "Javadoc": "* Test the case if the decorated iterator does not support the\n     * {@code remove()} method and throws an {@link UnsupportedOperationException}."
        },
        "testRemoveWithoutCallingNext": {
          "Javadoc": "* Test the {@code remove()} method being called without\n     * {@code next()} being called first."
        },
        "testSameAsDecorated": {
          "Javadoc": "* Test a decorated iterator bounded such that the {@code offset} is\n     * zero and the {@code max} is its size, in that the BoundedIterator\n     * should return all the same elements as its decorated iterator."
        }
      }
    },
    "org.apache.commons.collections4.iterators.CollatingIteratorTest": {
      "Javadoc": "\n * Unit test suite for {@link CollatingIterator}.\n "
    },
    "org.apache.commons.collections4.iterators.FilterIteratorTest": {
      "Javadoc": "\n * Test the filter iterator.\n ",
      "methods": {
        "makeBlockAllFilter": {
          "Javadoc": "* Returns a FilterIterator that blocks\n     * all of its elements\n     *\n     * @param i      the Iterator to \"filter\"\n     * @return \"filtered\" iterator"
        },
        "makeEmptyIterator": {
          "Javadoc": "* Returns a full iterator wrapped in a\n     * FilterIterator that blocks all the elements\n     *\n     * @return \"empty\" FilterIterator"
        },
        "makeObject": {
          "Javadoc": "* Returns an array with elements wrapped in a pass-through\n     * FilterIterator\n     *\n     * @return a filtered iterator"
        },
        "makePassThroughFilter": {
          "Javadoc": "* Returns a FilterIterator that does not filter\n     * any of its elements\n     *\n     * @param i      the Iterator to \"filter\"\n     * @return \"filtered\" iterator"
        },
        "setUp": {
          "Javadoc": "* Sets up instance variables required by this test case."
        },
        "tearDown": {
          "Javadoc": "* Tear down instance variables required by this test case."
        },
        "testSetIterator": {
          "Javadoc": "* Test that when the iterator is changed, the hasNext method returns the\n     * correct response for the new iterator."
        },
        "testSetPredicate": {
          "Javadoc": "* Test that when the predicate is changed, the hasNext method returns the\n     * correct response for the new predicate."
        }
      }
    },
    "org.apache.commons.collections4.iterators.FilterListIteratorTest": {
      "Javadoc": "\n * Tests the FilterListIterator class.\n ",
      "methods": {
        "testCollections360": {
          "Javadoc": "* Test for {@link \"https://issues.apache.org/jira/browse/COLLECTIONS-360 COLLECTIONS-360\"}"
        }
      }
    },
    "org.apache.commons.collections4.iterators.IteratorChainTest": {
      "Javadoc": "\n * Tests the IteratorChain class.\n "
    },
    "org.apache.commons.collections4.iterators.IteratorEnumerationTest": {
      "Javadoc": "\n * Tests the IteratorEnumeration.\n "
    },
    "org.apache.commons.collections4.iterators.IteratorIterableTest": {
      "Javadoc": "\n * Tests for IteratorIterable.\n "
    },
    "org.apache.commons.collections4.iterators.LazyIteratorChainTest": {
      "Javadoc": "\n * Tests the LazyIteratorChain class.\n "
    },
    "org.apache.commons.collections4.iterators.ListIteratorWrapper2Test": {
      "Javadoc": "\n * Tests the ListIteratorWrapper to ensure that it behaves as expected when wrapping a ListIterator.\n "
    },
    "org.apache.commons.collections4.iterators.ListIteratorWrapperTest": {
      "Javadoc": "\n * Tests the ListIteratorWrapper to ensure that it simulates\n * a ListIterator correctly.\n "
    },
    "org.apache.commons.collections4.iterators.LoopingIteratorTest": {
      "Javadoc": "\n * Tests the LoopingIterator class.\n ",
      "methods": {
        "testConstructorEx": {
          "Javadoc": "* Tests constructor exception."
        },
        "testLooping0": {
          "Javadoc": "* Tests whether an empty looping iterator works as designed."
        },
        "testLooping1": {
          "Javadoc": "* Tests whether a populated looping iterator works as designed."
        },
        "testLooping2": {
          "Javadoc": "* Tests whether a populated looping iterator works as designed."
        },
        "testLooping3": {
          "Javadoc": "* Tests whether a populated looping iterator works as designed."
        },
        "testRemoving1": {
          "Javadoc": "* Tests the remove() method on a LoopingIterator wrapped ArrayList."
        },
        "testReset": {
          "Javadoc": "* Tests the reset() method on a LoopingIterator wrapped ArrayList."
        },
        "testSize": {
          "Javadoc": "* Tests the size() method on a LoopingIterator wrapped ArrayList."
        }
      }
    },
    "org.apache.commons.collections4.iterators.LoopingListIteratorTest": {
      "Javadoc": "\n * Tests the LoopingListIterator class.\n ",
      "methods": {
        "testAdd": {
          "Javadoc": "* Tests the add method."
        },
        "testConstructorEx": {
          "Javadoc": "* Tests constructor exception."
        },
        "testJoggingNotOverBoundary": {
          "Javadoc": "* Tests jogging back and forth between two elements, but not over\n     * the begin/end boundary of the list."
        },
        "testJoggingOverBoundary": {
          "Javadoc": "* Tests jogging back and forth between two elements over the\n     * begin/end boundary of the list."
        },
        "testLooping0": {
          "Javadoc": "* Tests whether an empty looping list iterator works."
        },
        "testLooping1": {
          "Javadoc": "* Tests whether a looping list iterator works on a list with only\n     * one element."
        },
        "testLooping2": {
          "Javadoc": "* Tests whether a looping list iterator works on a list with two\n     * elements."
        },
        "testNextAndPreviousIndex": {
          "Javadoc": "* Tests nextIndex and previousIndex."
        },
        "testRemovingElementsAndIteratingBackwards": {
          "Javadoc": "* Tests removing an element from a wrapped ArrayList."
        },
        "testRemovingElementsAndIteratingForward": {
          "Javadoc": "* Tests removing an element from a wrapped ArrayList."
        },
        "testReset": {
          "Javadoc": "* Tests the reset method."
        },
        "testSet": {
          "Javadoc": "* Tests using the set method to change elements."
        }
      }
    },
    "org.apache.commons.collections4.iterators.NodeListIteratorTest": {
      "Javadoc": "\n * Tests the NodeListIterator.\n ",
      "methods": {
        "testEmptyIteratorWithNodeConstructor": {
          "Javadoc": "* tests the convenience Constructor with parameter type org.w3c.Node"
        },
        "testFullIteratorWithNodeConstructor": {
          "Javadoc": "* tests the convenience Constructor with parameter type org.w3c.Node"
        }
      }
    },
    "org.apache.commons.collections4.iterators.ObjectArrayIteratorTest": {
      "Javadoc": "\n * Tests the ObjectArrayIterator.\n "
    },
    "org.apache.commons.collections4.iterators.ObjectArrayListIterator2Test": {
      "Javadoc": "\n * Tests the ObjectArrayListIterator class.\n "
    },
    "org.apache.commons.collections4.iterators.ObjectArrayListIteratorTest": {
      "Javadoc": "\n * Tests the ObjectArrayListIterator class.\n ",
      "methods": {
        "testListIterator": {
          "Javadoc": "* Test the basic ListIterator functionality - going backwards using\n     * {@code previous()}."
        },
        "testListIteratorSet": {
          "Javadoc": "* Tests the {@link java.util.ListIterator#set} operation."
        }
      }
    },
    "org.apache.commons.collections4.iterators.ObjectGraphIteratorTest": {
      "Javadoc": "\n * Testcase.\n "
    },
    "org.apache.commons.collections4.iterators.Branch": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.iterators.Forest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.iterators.Leaf": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.iterators.LeafFinder": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.iterators.Tree": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.iterators.PeekingIteratorTest": {
      "Javadoc": "\n * Tests the PeekingIterator.\n ",
      "methods": {
        "setUp": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.iterators.PermutationIteratorTest": {
      "Javadoc": "\n * Test class for PermutationIterator.\n ",
      "methods": {
        "testPermutationExhaustivity": {
          "Javadoc": "* test checking that all the permutations are returned"
        },
        "testPermutationUnicity": {
          "Javadoc": "* test checking that all the permutations are returned only once."
        }
      }
    },
    "org.apache.commons.collections4.iterators.PushbackIteratorTest": {
      "Javadoc": "\n * Tests the PushbackIterator.\n ",
      "methods": {
        "setUp": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.iterators.ReverseListIteratorTest": {
      "Javadoc": "\n * Tests the ReverseListIterator.\n "
    },
    "org.apache.commons.collections4.iterators.SingletonIterator2Test": {
      "Javadoc": "\n * Tests the SingletonIterator to ensure that the next() method will actually\n * perform the iteration rather than the hasNext() method.\n "
    },
    "org.apache.commons.collections4.iterators.SingletonIteratorTest": {
      "Javadoc": "\n * Tests the SingletonIterator to ensure that the next() method will actually\n * perform the iteration rather than the hasNext() method.\n ",
      "methods": {
        "makeEmptyIterator": {
          "Javadoc": "* Returns a SingletonIterator from which\n     * the element has already been removed."
        }
      }
    },
    "org.apache.commons.collections4.iterators.SingletonListIteratorTest": {
      "Javadoc": "\n * Tests the SingletonListIterator.\n ",
      "methods": {
        "makeEmptyIterator": {
          "Javadoc": "* Returns a SingletonListIterator from which\n     * the element has already been removed."
        }
      }
    },
    "org.apache.commons.collections4.iterators.SkippingIteratorTest": {
      "Javadoc": "\n * A unit test to test the basic functions of {@link SkippingIterator}.\n ",
      "methods": {
        "testNegativeOffset": {
          "Javadoc": "* Test the case if a negative {@code offset} is passed to the\n     * constructor. {@link IllegalArgumentException} is expected."
        },
        "testOffsetGreaterThanSize": {
          "Javadoc": "* Test the case if the {@code offset} passed to the constructor is\n     * greater than the decorated iterator's size. The SkippingIterator should\n     * behave as if there are no more elements to return."
        },
        "testRemoveCalledTwice": {
          "Javadoc": "* Test the {@code remove()} method being called twice without calling\n     * {@code next()} in between."
        },
        "testRemoveFirst": {
          "Javadoc": "* Test removing the first element. Verify that the element is removed from\n     * the underlying collection."
        },
        "testRemoveLast": {
          "Javadoc": "* Test removing the last element. Verify that the element is removed from\n     * the underlying collection."
        },
        "testRemoveMiddle": {
          "Javadoc": "* Test removing an element in the middle of the iterator. Verify that the\n     * element is removed from the underlying collection."
        },
        "testRemoveUnsupported": {
          "Javadoc": "* Test the case if the decorated iterator does not support the\n     * {@code remove()} method and throws an {@link UnsupportedOperationException}."
        },
        "testRemoveWithoutCallingNext": {
          "Javadoc": "* Test the {@code remove()} method being called without\n     * {@code next()} being called first."
        },
        "testSameAsDecorated": {
          "Javadoc": "* Test a decorated iterator bounded such that the {@code offset} is\n     * zero, in that the SkippingIterator should return all the same elements\n     * as its decorated iterator."
        },
        "testSkipping": {
          "Javadoc": "* Test a decorated iterator bounded such that the first element returned is\n     * at an index greater its first element, and the last element returned is\n     * at an index less than its last element."
        }
      }
    },
    "org.apache.commons.collections4.iterators.UniqueFilterIteratorTest": {
      "Javadoc": "\n * Tests the UniqueFilterIterator class.\n "
    },
    "org.apache.commons.collections4.iterators.UnmodifiableIteratorTest": {
      "Javadoc": "\n * Tests the UnmodifiableIterator.\n ",
      "methods": {
        "setUp": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.iterators.UnmodifiableListIteratorTest": {
      "Javadoc": "\n * Tests the UnmodifiableListIterator.\n ",
      "methods": {
        "setUp": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.iterators.UnmodifiableMapIteratorTest": {
      "Javadoc": "\n * Tests the UnmodifiableMapIterator.\n "
    },
    "org.apache.commons.collections4.iterators.UnmodifiableOrderedMapIteratorTest": {
      "Javadoc": "\n * Tests the UnmodifiableOrderedMapIterator.\n "
    },
    "org.apache.commons.collections4.iterators.ZippingIteratorTest": {
      "Javadoc": "\n * Unit test suite for {@link ZippingIterator}.\n "
    },
    "org.apache.commons.collections4.IteratorUtilsTest": {
      "Javadoc": "\n * Tests for IteratorUtils.\n ",
      "methods": {
        "createNodeList": {
          "Javadoc": "* Creates a NodeList containing the specified nodes."
        },
        "createNodes": {
          "Javadoc": "* creates an array of four Node instances, mocked by EasyMock."
        },
        "getImmutableIterator": {
          "Javadoc": "* Gets an immutable Iterator operating on the elements [\"a\", \"b\", \"c\", \"d\"]."
        },
        "getImmutableListIterator": {
          "Javadoc": "* Gets an immutable ListIterator operating on the elements [\"a\", \"b\", \"c\", \"d\"]."
        },
        "testCollatedIterator": {
          "Javadoc": "* Tests methods collatedIterator(...)"
        },
        "testEmptyIterator": {
          "Javadoc": "* Test empty iterator"
        },
        "testEmptyListIterator": {
          "Javadoc": "* Test empty list iterator"
        },
        "testEmptyMapIterator": {
          "Javadoc": "* Test empty map iterator"
        },
        "testEmptyOrderedIterator": {
          "Javadoc": "* Test empty map iterator"
        },
        "testEmptyOrderedMapIterator": {
          "Javadoc": "* Test empty map iterator"
        },
        "testNodeIterator": {
          "Javadoc": "* Tests method nodeListIterator(Node)"
        },
        "testNodeListIterator": {
          "Javadoc": "* Tests method nodeListIterator(NodeList)"
        },
        "testUnmodifiableIteratorImmutability": {
          "Javadoc": "* Test remove() for an immutable Iterator."
        },
        "testUnmodifiableIteratorIteration": {
          "Javadoc": "* Test next() and hasNext() for an immutable Iterator."
        },
        "testUnmodifiableListIteratorImmutability": {
          "Javadoc": "* Test remove() for an immutable ListIterator."
        },
        "testUnmodifiableListIteratorIteration": {
          "Javadoc": "* Test next(), hasNext(), previous() and hasPrevious() for an immutable ListIterator."
        }
      }
    },
    "org.apache.commons.collections4.junit.ObjectToStringComparator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.keyvalue.AbstractMapEntryTest": {
      "Javadoc": "\n * Abstract tests that can be extended to test any Map.Entry implementation.\n * Subclasses must implement {@link #makeMapEntry(Object, Object)} to return\n * a new Map.Entry of the type being tested. Subclasses must also implement\n * {@link #testConstructors()} to test the constructors of the Map.Entry\n * type being tested.\n ",
      "methods": {
        "makeKnownMapEntry": {
          "Javadoc": "* Makes a Map.Entry of a type that's known to work correctly."
        },
        "makeMapEntry": {
          "Javadoc": "* Make an instance of Map.Entry with the specified key and value.\n     * Subclasses should override this method to return a Map.Entry\n     * of the type being tested."
        },
        "testConstructors": {
          "Javadoc": "* Subclasses should provide tests for their constructors."
        }
      }
    },
    "org.apache.commons.collections4.keyvalue.DefaultKeyValueTest": {
      "Javadoc": "\n * Test the DefaultKeyValue class.\n ",
      "methods": {
        "makeDefaultKeyValue": {
          "Javadoc": "* Make an instance of DefaultKeyValue with the specified key and value.\n     * Subclasses should override this method to return a DefaultKeyValue\n     * of the type being tested."
        },
        "testConstructors": {
          "Javadoc": "* Subclasses should override this method to test their own constructors."
        }
      }
    },
    "org.apache.commons.collections4.keyvalue.DefaultMapEntryTest": {
      "Javadoc": "\n * Test the DefaultMapEntry class.\n ",
      "methods": {
        "makeMapEntry": {
          "Javadoc": "* Make an instance of Map.Entry with the specified key and value.\n     * Subclasses should override this method to return a Map.Entry\n     * of the type being tested."
        },
        "testConstructors": {
          "Javadoc": "* Subclasses should override this method."
        }
      }
    },
    "org.apache.commons.collections4.keyvalue.MultiKeyTest": {
      "Javadoc": "\n * Unit tests for {@link org.apache.commons.collections4.keyvalue.MultiKey}.\n "
    },
    "org.apache.commons.collections4.keyvalue.DerivedMultiKey": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.keyvalue.SystemHashCodeSimulatingKey": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.keyvalue.TiedMapEntryTest": {
      "Javadoc": "\n * Test the TiedMapEntry class.\n ",
      "methods": {
        "makeMapEntry": {
          "Javadoc": "* Gets the instance to test"
        },
        "testConstructors": {
          "Javadoc": "* Tests the constructors."
        },
        "testSetValue": {
          "Javadoc": "* Tests the constructors."
        }
      }
    },
    "org.apache.commons.collections4.keyvalue.UnmodifiableMapEntryTest": {
      "Javadoc": "\n * Test the UnmodifiableMapEntry class.\n ",
      "methods": {
        "makeMapEntry": {
          "Javadoc": "* Make an instance of Map.Entry with the specified key and value.\n     * Subclasses should override this method to return a Map.Entry\n     * of the type being tested."
        },
        "testConstructors": {
          "Javadoc": "* Subclasses should override this method."
        }
      }
    },
    "org.apache.commons.collections4.list.AbstractLinkedListTest": {
      "Javadoc": "\n * Test case for {@link AbstractLinkedList}.\n ",
      "methods": {
        "getCollection": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.list.AbstractListTest": {
      "Javadoc": "\n * Abstract test class for {@link java.util.List} methods and contracts.\n * <p>\n * To use, simply extend this class, and implement\n * the {@link #makeObject} method.\n * <p>\n * If your {@link List} fails one of these tests by design,\n * you may still use this base set of cases.  Simply override the\n * test case (method) your {@link List} fails or override one of the\n * protected methods from AbstractCollectionTest.\n ",
      "methods": {
        "backwardTest": {
          "Javadoc": "*  Traverses to the beginning of the given iterator.\n     *\n     *  @param iter  the iterator to traverse\n     *  @param i     the starting index"
        },
        "bulkTestSubList": {
          "Javadoc": "*  Returns a {@link BulkTest} for testing {@link List#subList(int,int)}.\n     *  The returned bulk test will run through every {@code TestList}\n     *  method, <i>including</i> another {@code bulkTestSubList}.\n     *  Sublists are tested until the size of the sublist is less than 10.\n     *  Each sublist is 6 elements smaller than its parent list.\n     *  (By default this means that two rounds of sublists will be tested).\n     *  The verify() method is overloaded to test that the original list is\n     *  modified when the sublist is."
        },
        "failFastAll": {
          "Javadoc": "* Invokes all the methods on the given sublist to make sure they raise\n     * a {@link java.util.ConcurrentModificationException ConcurrentModificationException}."
        },
        "failFastMethod": {
          "Javadoc": "* Invokes the given method on the given sublist to make sure it raises\n     * a {@link java.util.ConcurrentModificationException ConcurrentModificationException}.\n     *\n     * Unless the method happens to be the equals() method, in which case\n     * the test is skipped. There seems to be a bug in\n     * java.util.AbstractList.subList(int,int).equals(Object) -- it never\n     * raises a ConcurrentModificationException.\n     *\n     * @param list the sublist to test\n     * @param m the method to invoke"
        },
        "forwardTest": {
          "Javadoc": "*  Traverses to the end of the given iterator.\n     *\n     *  @param iter  the iterator to traverse\n     *  @param i     the starting index"
        },
        "getCollection": {
          "Javadoc": "* Returns the {@link #collection} field cast to a {@link List}.\n     *\n     * @return the collection field as a List"
        },
        "getConfirmed": {
          "Javadoc": "* Returns the {@link #confirmed} field cast to a {@link List}.\n     *\n     * @return the confirmed field as a List"
        },
        "isEqualsCheckable": {
          "Javadoc": "* List equals method is defined."
        },
        "isSetSupported": {
          "Javadoc": "*  Returns true if the collections produced by\n     *  {@link #makeObject()} and {@link #makeFullCollection()}\n     *  support the <code>set operation.<p>\n     *  Default implementation returns true.  Override if your collection\n     *  class does not support set."
        },
        "makeConfirmedCollection": {
          "Javadoc": "* Returns an empty {@link ArrayList}."
        },
        "makeConfirmedFullCollection": {
          "Javadoc": "* Returns a full {@link ArrayList}."
        },
        "makeFullCollection": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeObject": {
          "Javadoc": "* Returns {@link #makeObject()}.\n     *\n     * @return an empty list to be used for testing"
        },
        "testEmptyListCompatibility": {
          "Javadoc": "* Compare the current serialized form of the List\n     * against the canonical version in SCM."
        },
        "testFullListCompatibility": {
          "Javadoc": "* Compare the current serialized form of the List\n     * against the canonical version in SCM."
        },
        "testListAddByIndex": {
          "Javadoc": "*  Tests {@link List#add(int,Object)}."
        },
        "testListAddByIndexBoundsChecking": {
          "Javadoc": "*  Tests bounds checking for {@link List#add(int, Object)} on an\n     *  empty list."
        },
        "testListAddByIndexBoundsChecking2": {
          "Javadoc": "*  Tests bounds checking for {@link List#add(int, Object)} on a\n     *  full list."
        },
        "testListEquals": {
          "Javadoc": "*  Tests {@link List#equals(Object)}."
        },
        "testListGetByIndex": {
          "Javadoc": "*  Tests {@link List#get(int)}."
        },
        "testListGetByIndexBoundsChecking": {
          "Javadoc": "*  Tests bounds checking for {@link List#get(int)} on an\n     *  empty list."
        },
        "testListGetByIndexBoundsChecking2": {
          "Javadoc": "*  Tests bounds checking for {@link List#get(int)} on a\n     *  full list."
        },
        "testListHashCode": {
          "Javadoc": "*  Tests {@link List#hashCode()}."
        },
        "testListIndexOf": {
          "Javadoc": "*  Tests {@link List#indexOf}."
        },
        "testListIteratorAdd": {
          "Javadoc": "*  Tests the {@link ListIterator#add(Object)} method of the list\n     *  iterator."
        },
        "testListIteratorSet": {
          "Javadoc": "*  Tests the {@link ListIterator#set(Object)} method of the list\n     *  iterator."
        },
        "testListLastIndexOf": {
          "Javadoc": "*  Tests {@link List#lastIndexOf}."
        },
        "testListListIterator": {
          "Javadoc": "*  Tests the read-only bits of {@link List#listIterator()}."
        },
        "testListListIteratorByIndex": {
          "Javadoc": "*  Tests the read-only bits of {@link List#listIterator(int)}."
        },
        "testListListIteratorNextRemoveNext": {
          "Javadoc": "* Tests remove on list iterator is correct."
        },
        "testListListIteratorNextRemovePrevious": {
          "Javadoc": "* Tests remove on list iterator is correct."
        },
        "testListListIteratorPreviousRemoveNext": {
          "Javadoc": "* Tests remove on list iterator is correct."
        },
        "testListListIteratorPreviousRemovePrevious": {
          "Javadoc": "* Tests remove on list iterator is correct."
        },
        "testListRemoveByIndex": {
          "Javadoc": "*  Tests {@link List#remove(int)}."
        },
        "testListRemoveByIndexBoundsChecking": {
          "Javadoc": "*  Tests bounds checking for {@link List#remove(int)} on an\n     *  empty list."
        },
        "testListRemoveByIndexBoundsChecking2": {
          "Javadoc": "*  Tests bounds checking for {@link List#remove(int)} on a\n     *  full list."
        },
        "testListSetByIndex": {
          "Javadoc": "*  Test {@link List#set(int,Object)}."
        },
        "testListSetByIndexBoundsChecking": {
          "Javadoc": "*  Tests bounds checking for {@link List#set(int,Object)} on an\n     *  empty list."
        },
        "testListSetByIndexBoundsChecking2": {
          "Javadoc": "*  Tests bounds checking for {@link List#set(int,Object)} on a\n     *  full list."
        },
        "testListSubListFailFastOnAdd": {
          "Javadoc": "* Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}\n     * if elements are added to the original list."
        },
        "testListSubListFailFastOnRemove": {
          "Javadoc": "* Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}\n     * if elements are removed from the original list."
        },
        "testUnsupportedSet": {
          "Javadoc": "*  If {@link #isSetSupported()} returns false, tests that set operation\n     *  raises <Code>UnsupportedOperationException."
        },
        "verify": {
          "Javadoc": "*  Verifies that the test list implementation matches the confirmed list\n     *  implementation."
        }
      }
    },
    "org.apache.commons.collections4.list.BulkTestSubList": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.list.TestListIterator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.list.Collections701Test": {
      "Javadoc": "\n * Tests for COLLECTIONS-701.\n "
    },
    "org.apache.commons.collections4.list.CursorableLinkedListTest": {
      "Javadoc": "\n * Test class.\n ",
      "methods": {
        "ignoredTests": {
          "Javadoc": "*  Ignore the serialization tests for sublists and sub-sublists.\n     *\n     *  @return an array of sublist serialization test names"
        }
      }
    },
    "org.apache.commons.collections4.list.FixedSizeListTest": {
      "Javadoc": "\n * Extension of {@link AbstractListTest} for exercising the {@link FixedSizeList}\n * implementation.\n "
    },
    "org.apache.commons.collections4.list.GrowthListTest": {
      "Javadoc": "\n * Extension of {@link AbstractListTest} for exercising the {@link GrowthList}.\n ",
      "methods": {
        "testListAddByIndexBoundsChecking": {
          "Javadoc": "* Override."
        },
        "testListAddByIndexBoundsChecking2": {
          "Javadoc": "* Override."
        },
        "testListSetByIndexBoundsChecking": {
          "Javadoc": "* Override."
        },
        "testListSetByIndexBoundsChecking2": {
          "Javadoc": "* Override."
        }
      }
    },
    "org.apache.commons.collections4.list.LazyListTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.list.NodeCachingLinkedListTest": {
      "Javadoc": "\n * Test class for NodeCachingLinkedList, a performance optimized LinkedList.\n ",
      "methods": {
        "getCollection": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.list.PredicatedListTest": {
      "Javadoc": "\n * Extension of {@link AbstractListTest} for exercising the\n * {@link PredicatedList} implementation.\n "
    },
    "org.apache.commons.collections4.list.SetUniqueListTest": {
      "Javadoc": "\n * JUnit tests.\n "
    },
    "org.apache.commons.collections4.list.SetUniqueList307": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.list.TransformedListTest": {
      "Javadoc": "\n * Extension of {@link AbstractListTest} for exercising the {@link TransformedList}\n * implementation.\n "
    },
    "org.apache.commons.collections4.list.TreeListTest": {
      "Javadoc": "\n * JUnit tests\n "
    },
    "org.apache.commons.collections4.list.UnmodifiableListTest": {
      "Javadoc": "\n * Extension of {@link AbstractListTest} for exercising the\n * {@link UnmodifiableList} implementation.\n ",
      "methods": {
        "testUnmodifiable": {
          "Javadoc": "* Verify that base list and sublists are not modifiable"
        },
        "testUnmodifiableIterator": {
          "Javadoc": "* Verify that iterator is not modifiable"
        }
      }
    },
    "org.apache.commons.collections4.ListUtilsTest": {
      "Javadoc": "\n * Tests for ListUtils.\n ",
      "methods": {
        "testIndexOf": {
          "Javadoc": "* Tests the {@code indexOf} method in {@code ListUtils} class."
        },
        "testIntersectEmptyWithEmptyList": {
          "Javadoc": "* Tests intersecting a non-empty list with an empty list."
        },
        "testIntersectionOrderInsensitivity": {
          "Javadoc": "* Tests intersecting two lists in different orders."
        },
        "testIntersectListWithNoOverlapAndDifferentTypes": {
          "Javadoc": "* Tests intersecting a non-empty list with a subset of itself."
        },
        "testIntersectListWithSelf": {
          "Javadoc": "* Tests intersecting a non-empty list with itself."
        },
        "testIntersectNonEmptySubset": {
          "Javadoc": "* Tests intersecting a non-empty list with a subset of itself."
        },
        "testIntersectNonEmptyWithEmptyList": {
          "Javadoc": "* Tests intersecting a non-empty list with an empty list."
        }
      }
    },
    "org.apache.commons.collections4.map.AbstractIterableMapTest": {
      "Javadoc": "\n * Abstract test class for {@link IterableMap} methods and contracts.\n ",
      "methods": {
        "getMap": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeFullMap": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeObject": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.map.InnerTestMapIterator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.AbstractMapTest": {
      "Javadoc": "\n * Abstract test class for {@link java.util.Map} methods and contracts.\n * <p>\n * The forces at work here are similar to those in {@link AbstractCollectionTest}.\n * If your class implements the full Map interface, including optional\n * operations, simply extend this class, and implement the\n * {@link #makeObject()} method.\n * <p>\n * On the other hand, if your map implementation is weird, you may have to\n * override one or more of the other protected methods.  They're described\n * below.\n * <p>\n * <b>Entry Population Methods</b>\n * <p>\n * Override these methods if your map requires special entries:\n *\n * <ul>\n * <li>{@link #getSampleKeys()}\n * <li>{@link #getSampleValues()}\n * <li>{@link #getNewSampleValues()}\n * <li>{@link #getOtherKeys()}\n * <li>{@link #getOtherValues()}\n * </ul>\n *\n * <b>Indicate Map Behaviour</b>\n * <p>\n * Override these if your map makes specific behavior guarantees:\n * <ul>\n * <li>{@link #getIterationBehaviour()}</li>\n * </ul>\n *\n * <b>Supported Operation Methods</b>\n * <p>\n * Override these methods if your map doesn't support certain operations:\n *\n * <ul>\n * <li> {@link #isPutAddSupported()}\n * <li> {@link #isPutChangeSupported()}\n * <li> {@link #isSetValueSupported()}\n * <li> {@link #isRemoveSupported()}\n * <li> {@link #isGetStructuralModify()}\n * <li> {@link #isAllowDuplicateValues()}\n * <li> {@link #isAllowNullKey()}\n * <li> {@link #isAllowNullValue()}\n * </ul>\n *\n * <b>Fixture Methods</b>\n * <p>\n * For tests on modification operations (puts and removes), fixtures are used\n * to verify that that operation results in correct state for the map and its\n * collection views.  Basically, the modification is performed against your\n * map implementation, and an identical modification is performed against\n * a <I>confirmed</I> map implementation.  A confirmed map implementation is\n * something like <Code>java.util.HashMap</Code>, which is known to conform\n * exactly to the {@link Map} contract.  After the modification takes place\n * on both your map implementation and the confirmed map implementation, the\n * two maps are compared to see if their state is identical.  The comparison\n * also compares the collection views to make sure they're still the same.<P>\n *\n * The upshot of all that is that <I>any</I> test that modifies the map in\n * <I>any</I> way will verify that <I>all</I> of the map's state is still\n * correct, including the state of its collection views.  So for instance\n * if a key is removed by the map's key set's iterator, then the entry set\n * is checked to make sure the key/value pair no longer appears.<P>\n *\n * The {@link #map} field holds an instance of your collection implementation.\n * The {@link #entrySet}, {@link #keySet} and {@link #values} fields hold\n * that map's collection views.  And the {@link #confirmed} field holds\n * an instance of the confirmed collection implementation.  The\n * {@link #resetEmpty()} and {@link #resetFull()} methods set these fields to\n * empty or full maps, so that tests can proceed from a known state.<P>\n *\n * After a modification operation to both {@link #map} and {@link #confirmed},\n * the {@link #verify()} method is invoked to compare the results.  The\n * {@link #verify} method calls separate methods to verify the map and its three\n * collection views ({@link #verifyMap}, {@link #verifyEntrySet},\n * {@link #verifyKeySet}, and {@link #verifyValues}).  You may want to override\n * one of the verification methods to perform additional verifications.  For\n * instance, TestDoubleOrderedMap would want override its\n * {@link #verifyValues()} method to verify that the values are unique and in\n * ascending order.<P>\n *\n * <b>Other Notes</b>\n * <p>\n * If your {@link Map} fails one of these tests by design, you may still use\n * this base set of cases.  Simply override the test case (method) your map\n * fails and/or the methods that define the assumptions used by the test\n * cases.  For example, if your map does not allow duplicate values, override\n * {@link #isAllowDuplicateValues()} and have it return {@code false}\n ",
      "methods": {
        "cloneMapEntry": {
          "Javadoc": "* Creates a new Map Entry that is independent of the first and the map."
        },
        "addSampleMappings": {
          "Javadoc": "*  Helper method to add all the mappings described by\n     * {@link #getSampleKeys()} and {@link #getSampleValues()}."
        },
        "bulkTestMapEntrySet": {
          "Javadoc": "* Bulk test {@link Map#entrySet()}.  This method runs through all of\n     * the tests in {@link AbstractSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the map and the other collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing the map's entry set"
        },
        "bulkTestMapKeySet": {
          "Javadoc": "* Bulk test {@link Map#keySet()}.  This method runs through all of\n     * the tests in {@link AbstractSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the map and the other collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing the map's key set"
        },
        "bulkTestMapValues": {
          "Javadoc": "* Bulk test {@link Map#values()}.  This method runs through all of\n     * the tests in {@link AbstractCollectionTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the map and the other collection views are still valid.\n     *\n     * @return a {@link AbstractCollectionTest} instance for testing the map's\n     *    values collection"
        },
        "getCompatibilityVersion": {
          "Javadoc": "* Gets the compatibility version, needed for package access."
        },
        "getConfirmed": {
          "Javadoc": "* Gets the confirmed.\n     * @return Map<K, V>"
        },
        "getIterationBehaviour": {
          "Javadoc": "* Return a flag specifying the iteration behavior of the collection.\n     * This is used to change the assertions used by specific tests.\n     * The default implementation returns 0 which indicates ordered iteration behavior.\n     *\n     * @return the iteration behavior\n     * @see AbstractCollectionTest#UNORDERED"
        },
        "getMap": {
          "Javadoc": "* Gets the map.\n     * @return Map<K, V>"
        },
        "getNewSampleValues": {
          "Javadoc": "* Returns a set of values that can be used to replace the values\n     * returned from {@link #getSampleValues()}.  This method must return an\n     * array with the same length as {@link #getSampleValues()}.  The values\n     * returned from this method should not be the same as those returned from\n     * {@link #getSampleValues()}.  The default implementation constructs a\n     * set of String values and includes a single null value if\n     * {@link #isAllowNullValue()} returns {@code true}, and includes two values\n     * that are the same if {@link #isAllowDuplicateValues()} returns\n     * {@code true}."
        },
        "getOtherNonNullStringElements": {
          "Javadoc": "* Returns a list of string elements suitable for return by\n     * {@link #getOtherKeys()} or {@link #getOtherValues}.\n     *\n     * <p>Override getOtherElements to return the results of this method if your\n     * collection does not support heterogeneous elements or the null element.\n     * </p>"
        },
        "getSampleKeys": {
          "Javadoc": "*  Returns the set of keys in the mappings used to test the map.  This\n     *  method must return an array with the same length as {@link\n     *  #getSampleValues()} and all array elements must be different. The\n     *  default implementation constructs a set of String keys, and includes a\n     *  single null key if {@link #isAllowNullKey()} returns {@code true}."
        },
        "getSampleValues": {
          "Javadoc": "* Returns the set of values in the mappings used to test the map.  This\n     * method must return an array with the same length as\n     * {@link #getSampleKeys()}.  The default implementation constructs a set of\n     * String values and includes a single null value if\n     * {@link #isAllowNullValue()} returns {@code true}, and includes\n     * two values that are the same if {@link #isAllowDuplicateValues()} returns\n     * {@code true}."
        },
        "isAllowDuplicateValues": {
          "Javadoc": "* Returns true if the maps produced by\n     * {@link #makeObject()} and {@link #makeFullMap()}\n     * supports duplicate values.\n     * <p>\n     * Default implementation returns true.\n     * Override if your collection class does not support duplicate values."
        },
        "isAllowNullKey": {
          "Javadoc": "* Returns true if the maps produced by\n     * {@link #makeObject()} and {@link #makeFullMap()}\n     * supports null keys.\n     * <p>\n     * Default implementation returns true.\n     * Override if your collection class does not support null keys."
        },
        "isAllowNullValue": {
          "Javadoc": "* Returns true if the maps produced by\n     * {@link #makeObject()} and {@link #makeFullMap()}\n     * supports null values.\n     * <p>\n     * Default implementation returns true.\n     * Override if your collection class does not support null values."
        },
        "isFailFastExpected": {
          "Javadoc": "* Returns true if the maps produced by\n     * {@link #makeObject()} and {@link #makeFullMap()}\n     * provide fail-fast behavior on their various iterators.\n     * <p>\n     * Default implementation returns true.\n     * Override if your collection class does not support fast failure."
        },
        "isGetStructuralModify": {
          "Javadoc": "* Returns true if the maps produced by\n     * {@link #makeObject()} and {@link #makeFullMap()}\n     * can cause structural modification on a get(). The example is LRUMap.\n     * <p>\n     * Default implementation returns false.\n     * Override if your map class structurally modifies on get."
        },
        "isPutAddSupported": {
          "Javadoc": "* Returns true if the maps produced by\n     * {@link #makeObject()} and {@link #makeFullMap()}\n     * support the {@code put} and {@code putAll} operations\n     * adding new mappings.\n     * <p>\n     * Default implementation returns true.\n     * Override if your collection class does not support put adding."
        },
        "isPutChangeSupported": {
          "Javadoc": "* Returns true if the maps produced by\n     * {@link #makeObject()} and {@link #makeFullMap()}\n     * support the {@code put} and {@code putAll} operations\n     * changing existing mappings.\n     * <p>\n     * Default implementation returns true.\n     * Override if your collection class does not support put changing."
        },
        "isRemoveSupported": {
          "Javadoc": "* Returns true if the maps produced by\n     * {@link #makeObject()} and {@link #makeFullMap()}\n     * support the {@code remove} and {@code clear} operations.\n     * <p>\n     * Default implementation returns true.\n     * Override if your collection class does not support removal operations."
        },
        "isSetValueSupported": {
          "Javadoc": "* Returns true if the maps produced by\n     * {@link #makeObject()} and {@link #makeFullMap()}\n     * support the {@code setValue} operation on entrySet entries.\n     * <p>\n     * Default implementation returns isPutChangeSupported().\n     * Override if your collection class does not support setValue but does\n     * support put changing."
        },
        "isSubMapViewsSerializable": {
          "Javadoc": "* Returns whether the sub map views of SortedMap are serializable.\n     * If the class being tested is based around a TreeMap then you should\n     * override and return false as TreeMap has a bug in deserialization.\n     *\n     * @return false"
        },
        "makeConfirmedMap": {
          "Javadoc": "* Override to return a map other than HashMap as the confirmed map.\n     *\n     * @return a map that is known to be valid"
        },
        "makeEntryArray": {
          "Javadoc": "* Utility methods to create an array of Map.Entry objects\n     * out of the given key and value arrays.<P>\n     *\n     * @param keys    the array of keys\n     * @param values  the array of values\n     * @return an array of Map.Entry of those keys to those values"
        },
        "makeFullMap": {
          "Javadoc": "* Return a new, populated map.  The mappings in the map should match the\n     * keys and values returned from {@link #getSampleKeys()} and\n     * {@link #getSampleValues()}.  The default implementation uses makeEmptyMap()\n     * and calls {@link #addSampleMappings} to add all the mappings to the\n     * map.\n     *\n     * @return the map to be tested"
        },
        "makeObject": {
          "Javadoc": "* Return a new, empty {@link Map} to be used for testing.\n     *\n     * @return the map to be tested"
        },
        "resetEmpty": {
          "Javadoc": "* Resets the {@link #map}, {@link #entrySet}, {@link #keySet},\n     * {@link #values} and {@link #confirmed} fields to empty."
        },
        "resetFull": {
          "Javadoc": "* Resets the {@link #map}, {@link #entrySet}, {@link #keySet},\n     * {@link #values} and {@link #confirmed} fields to full."
        },
        "tearDown": {
          "Javadoc": "* Erases any leftover instance variables by setting them to null."
        },
        "testEmptyMapCompatibility": {
          "Javadoc": "* Compare the current serialized form of the Map\n     * against the canonical version in SCM."
        },
        "testEntrySetClearChangesMap": {
          "Javadoc": "* Tests that the {@link Map#entrySet()} collection is backed by\n     * the underlying map for clear()."
        },
        "testEntrySetIteratorRemoveChangesMap": {
          "Javadoc": "* Verify that entrySet.iterator.remove changes the underlying map."
        },
        "testEntrySetRemoveAll": {
          "Javadoc": "* Test entrySet.removeAll."
        },
        "testEntrySetRemoveChangesMap": {
          "Javadoc": "* Tests that the {@link Map#entrySet} set is backed by\n     * the underlying map by removing from the entrySet set\n     * and testing if the entry was removed from the map."
        },
        "testEntrySetRetainAll": {
          "Javadoc": "* Test entrySet.retainAll."
        },
        "testFullMapCompatibility": {
          "Javadoc": "* Compare the current serialized form of the Map\n     * against the canonical version in SCM."
        },
        "testKeySetClearChangesMap": {
          "Javadoc": "* Tests that the {@link Map#keySet} collection is backed by\n     * the underlying map for clear()."
        },
        "testKeySetIteratorRemoveChangesMap": {
          "Javadoc": "* Verify that keySet.iterator.remove changes the underlying map."
        },
        "testKeySetRemoveAll": {
          "Javadoc": "* Test keySet.removeAll."
        },
        "testKeySetRemoveChangesMap": {
          "Javadoc": "* Tests that the {@link Map#keySet} set is backed by\n     * the underlying map by removing from the keySet set\n     * and testing if the key was removed from the map."
        },
        "testKeySetRetainAll": {
          "Javadoc": "* Test keySet.retainAll."
        },
        "testMakeMap": {
          "Javadoc": "* Test to ensure that makeEmptyMap and makeFull returns a new non-null\n     * map with each invocation."
        },
        "testMapClear": {
          "Javadoc": "* Tests {@link Map#clear()}.  If the map {@link #isRemoveSupported()\n     * can add and remove elements}, then {@link Map#size()} and\n     * {@link Map#isEmpty()} are used to ensure that map has no elements after\n     * a call to clear.  If the map does not support adding and removing\n     * elements, this method checks to ensure clear throws an\n     * UnsupportedOperationException."
        },
        "testMapContainsKey": {
          "Javadoc": "* Tests Map.containsKey(Object) by verifying it returns false for all\n     * sample keys on a map created using an empty map and returns true for\n     * all sample keys returned on a full map."
        },
        "testMapContainsValue": {
          "Javadoc": "* Tests Map.containsValue(Object) by verifying it returns false for all\n     * sample values on an empty map and returns true for all sample values on\n     * a full map."
        },
        "testMapEquals": {
          "Javadoc": "* Tests Map.equals(Object)"
        },
        "testMapGet": {
          "Javadoc": "* Tests Map.get(Object)"
        },
        "testMapHashCode": {
          "Javadoc": "* Tests Map.hashCode()"
        },
        "testMapIsEmpty": {
          "Javadoc": "* Tests Map.isEmpty()"
        },
        "testMapPut": {
          "Javadoc": "* Tests Map.put(Object, Object)"
        },
        "testMapPutAll": {
          "Javadoc": "* Tests Map.putAll(map)"
        },
        "testMapPutNullKey": {
          "Javadoc": "* Tests Map.put(null, value)"
        },
        "testMapPutNullValue": {
          "Javadoc": "* Tests Map.put(null, value)"
        },
        "testMapRemove": {
          "Javadoc": "* Tests Map.remove(Object)"
        },
        "testMapSize": {
          "Javadoc": "* Tests Map.size()"
        },
        "testMapToString": {
          "Javadoc": "* Tests Map.toString().  Since the format of the string returned by the\n     * toString() method is not defined in the Map interface, there is no\n     * common way to test the results of the toString() method.  Therefore,\n     * it is encouraged that Map implementations override this test with one\n     * that checks the format matches any format defined in its API.  This\n     * default implementation just verifies that the toString() method does\n     * not return null."
        },
        "testSampleMappings": {
          "Javadoc": "* Test to ensure the test setup is working properly.  This method checks\n     * to ensure that the getSampleKeys and getSampleValues methods are\n     * returning results that look appropriate.  That is, they both return a\n     * non-null array of equal length.  The keys array must not have any\n     * duplicate values, and may only contain a (single) null key if\n     * isNullKeySupported() returns true.  The values array must only have a null\n     * value if useNullValue() is true and may only have duplicate values if\n     * isAllowDuplicateValues() returns true."
        },
        "testValuesClearChangesMap": {
          "Javadoc": "* Tests that the {@link Map#bitMaps} collection is backed by\n     * the underlying map for clear()."
        },
        "testValuesIteratorRemoveChangesMap": {
          "Javadoc": "* Verifies that values.iterator.remove changes the underlying map."
        },
        "testValuesRemoveAll": {
          "Javadoc": "* Tests values.removeAll."
        },
        "testValuesRemoveChangesMap": {
          "Javadoc": "* Tests that the {@link Map#bitMaps} collection is backed by\n     * the underlying map by removing from the values collection\n     * and testing if the value was removed from the map.\n     * <p>\n     * We should really test the \"vice versa\" case--that values removed\n     * from the map are removed from the values collection--also,\n     * but that's a more difficult test to construct (lacking a\n     * \"removeValue\" method.)\n     * </p>\n     * <p>\n     * See bug <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-92\">\n     * COLLECTIONS-92</a>.\n     * </p>"
        },
        "testValuesRetainAll": {
          "Javadoc": "* Test values.retainAll."
        },
        "verify": {
          "Javadoc": "* Verifies that {@link #map} is still equal to {@link #confirmed}.\n     * This method checks that the map is equal to the HashMap,\n     * <I>and</I> that the map's collection views are still equal to\n     * the HashMap's collection views.  An <Code>equals</Code> test\n     * is done on the maps and their collection views; their size and\n     * <Code>isEmpty</Code> results are compared; their hashCodes are\n     * compared; and <Code>containsAll</Code> tests are run on the\n     * collection views."
        },
        "views": {
          "Javadoc": "* Resets the collection view fields."
        }
      }
    },
    "org.apache.commons.collections4.map.TestMapEntrySet": {
      "Javadoc": "",
      "methods": {
        "getFullElements": {
          "Javadoc": "* {@inheritDoc}"
        },
        "getFullNonNullElements": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.map.TestMapKeySet": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.TestMapValues": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.AbstractOrderedMapTest": {
      "Javadoc": "\n * Abstract test class for {@link OrderedMap} methods and contracts.\n ",
      "methods": {
        "getMap": {
          "Javadoc": "* {@inheritDoc}"
        },
        "getSampleKeys": {
          "Javadoc": "* The only confirmed collection we have that is ordered is the sorted one.\n     * Thus, sort the keys."
        },
        "makeConfirmedMap": {
          "Javadoc": "* OrderedMap uses TreeMap as its known comparison.\n     *\n     * @return a map that is known to be valid"
        },
        "makeFullMap": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeObject": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.map.InnerTestOrderedMapIterator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.AbstractSortedMapTest": {
      "Javadoc": "\n * Abstract test class for {@link java.util.SortedMap} methods and contracts.\n ",
      "methods": {
        "getConfirmed": {
          "Javadoc": "* {@inheritDoc}"
        },
        "getMap": {
          "Javadoc": "* {@inheritDoc}"
        },
        "isAllowNullKey": {
          "Javadoc": "* Can't sort null keys.\n     *\n     * @return false"
        },
        "makeConfirmedMap": {
          "Javadoc": "* SortedMap uses TreeMap as its known comparison.\n     *\n     * @return a map that is known to be valid"
        },
        "makeFullMap": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeObject": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.map.TestHeadMap": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.TestSubMap": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.TestTailMap": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.TestViewMap": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.CaseInsensitiveMapTest": {
      "Javadoc": "\n * Tests for the {@link CaseInsensitiveMap} implementation.\n ",
      "methods": {
        "testInitialCapacityZero": {
          "Javadoc": "* Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>."
        }
      }
    },
    "org.apache.commons.collections4.map.CompositeMapTest": {
      "Javadoc": "\n * Extension of {@link AbstractMapTest} for exercising the\n * {@link CompositeMap} implementation.\n "
    },
    "org.apache.commons.collections4.map.DefaultedMapTest": {
      "Javadoc": "\n * Extension of {@link AbstractMapTest} for exercising the\n * {@link DefaultedMap} implementation.\n "
    },
    "org.apache.commons.collections4.map.EmptyMapMutator": {
      "Javadoc": "\n * This class is used in TestCompositeMap. When testing serialization,\n * the class has to be separate of TestCompositeMap, else the test\n * class also has to be serialized.\n "
    },
    "org.apache.commons.collections4.map.FixedSizeMapTest": {
      "Javadoc": "\n * Extension of {@link AbstractMapTest} for exercising the {@link FixedSizeMap}\n * implementation.\n "
    },
    "org.apache.commons.collections4.map.FixedSizeSortedMapTest": {
      "Javadoc": "\n * Extension of {@link AbstractSortedMapTest} for exercising the {@link FixedSizeSortedMap}\n * implementation.\n "
    },
    "org.apache.commons.collections4.map.Flat3MapTest": {
      "Javadoc": "\n * JUnit tests.\n "
    },
    "org.apache.commons.collections4.map.TestFlatMapIterator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.HashedMapTest": {
      "Javadoc": "\n * JUnit tests.\n ",
      "methods": {
        "testInitialCapacityZero": {
          "Javadoc": "* Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>."
        }
      }
    },
    "org.apache.commons.collections4.map.IdentityMap": {
      "Javadoc": "\n * A {@code Map} implementation that matches keys and values based\n * on {@code ==} not {@code equals()}.\n * <p>\n * <strong>This map will violate the detail of various Map and map view contracts.</strong>\n * As a general rule, don't compare this map to other maps. In particular, you can't\n * use decorators like {@link ListOrderedMap} on it, which silently assume that these\n * contracts are fulfilled.\n * <p>\n * <strong>Note that IdentityMap is not synchronized and is not thread-safe.</strong>\n * If you wish to use this map from multiple threads concurrently, you must use\n * appropriate synchronization. The simplest approach is to wrap this map\n * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n * exceptions when accessed by concurrent threads without synchronization.\n * <p>\n * From 4.0, this class is replaced by java.util.IdentityHashMap but kept as a\n * test-class because it is still used by the ReferenceIdentityMapTest.\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n ",
      "methods": {
        "clone": {
          "Javadoc": "* Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone"
        },
        "createEntry": {
          "Javadoc": "* Creates an entry to store the data.\n     * This implementation creates an IdentityEntry instance.\n     *\n     * @param next  the next entry in sequence\n     * @param hashCode  the hash code to use\n     * @param key  the key to store\n     * @param value  the value to store\n     * @return the newly created entry"
        },
        "hash": {
          "Javadoc": "* Gets the hash code for the key specified.\n     * This implementation uses the identity hash code.\n     *\n     * @param key  the key to get a hash code for\n     * @return the hash code"
        },
        "isEqualKey": {
          "Javadoc": "* Compares two keys for equals.\n     * This implementation uses {@code ==}.\n     *\n     * @param key1  the first key to compare\n     * @param key2  the second key to compare\n     * @return true if equal by identity"
        },
        "isEqualValue": {
          "Javadoc": "* Compares two values for equals.\n     * This implementation uses {@code ==}.\n     *\n     * @param value1  the first value to compare\n     * @param value2  the second value to compare\n     * @return true if equal by identity"
        },
        "readObject": {
          "Javadoc": "* Read the map in using a custom routine."
        },
        "writeObject": {
          "Javadoc": "* Write the map out using a custom routine."
        }
      }
    },
    "org.apache.commons.collections4.map.IdentityEntry": {
      "Javadoc": "\n     * HashEntry\n     "
    },
    "org.apache.commons.collections4.map.LazyMapTest": {
      "Javadoc": "\n * Extension of {@link AbstractMapTest} for exercising the\n * {@link LazyMap} implementation.\n "
    },
    "org.apache.commons.collections4.map.LazySortedMapTest": {
      "Javadoc": "\n * Extension of {@link LazyMapTest} for exercising the\n * {@link LazySortedMap} implementation.\n "
    },
    "org.apache.commons.collections4.map.ReverseStringComparator": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.LinkedMapTest": {
      "Javadoc": "\n * JUnit tests.\n ",
      "methods": {
        "getMap": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeFullMap": {
          "Javadoc": "* {@inheritDoc}"
        },
        "testInitialCapacityZero": {
          "Javadoc": "* Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>."
        }
      }
    },
    "org.apache.commons.collections4.map.TestListView": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.ListOrderedMap2Test": {
      "Javadoc": "\n * Extension of {@link AbstractOrderedMapTest} for exercising the {@link ListOrderedMap}\n * implementation.\n ",
      "methods": {
        "getMap": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeFullMap": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.map.ListOrderedMapTest": {
      "Javadoc": "\n * Extension of {@link AbstractOrderedMapTest} for exercising the {@link ListOrderedMap}\n * implementation.\n ",
      "methods": {
        "getMap": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeFullMap": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.map.TestKeyListView": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.TestValueListView": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.LRUMapTest": {
      "Javadoc": "\n * JUnit tests.\n ",
      "methods": {
        "getMap": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeFullMap": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.map.MockLRUMapSubclass": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.MockLRUMapSubclassBlocksRemove": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.MockLRUMapSubclassFirstBlocksRemove": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.SingleHashCode": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.MultiKeyMapTest": {
      "Javadoc": "\n * JUnit tests.\n ",
      "methods": {
        "getMap": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.map.MultiValueMapTest": {
      "Javadoc": "\n * TestMultiValueMap.\n "
    },
    "org.apache.commons.collections4.map.PassiveExpiringMapTest": {
      "Javadoc": "\n * JUnit tests.\n "
    },
    "org.apache.commons.collections4.map.TestExpirationPolicy": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.PredicatedMapTest": {
      "Javadoc": "\n * Extension of {@link AbstractMapTest} for exercising the\n * {@link PredicatedMap} implementation.\n "
    },
    "org.apache.commons.collections4.map.PredicatedSortedMapTest": {
      "Javadoc": "\n * Extension of {@link PredicatedMapTest} for exercising the\n * {@link PredicatedSortedMap} implementation.\n "
    },
    "org.apache.commons.collections4.map.ReferenceIdentityMapTest": {
      "Javadoc": "\n * Tests for ReferenceIdentityMap.\n ",
      "methods": {
        "testPurgeValues": {
          "Javadoc": "Tests whether purge values setting works"
        }
      }
    },
    "org.apache.commons.collections4.map.ReferenceMapTest": {
      "Javadoc": "\n * Tests for ReferenceMap.\n ",
      "methods": {
        "testDataSizeAfterSerialization": {
          "Javadoc": "* Test whether after serialization the \"data\" HashEntry array is the same size as the original.<p>\n     *\n     * See <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-599\">COLLECTIONS-599: HashEntry array object naming data initialized with double the size during deserialization</a>"
        },
        "testIteratorLastEntryCanBeRemovedAfterHasNext": {
          "Javadoc": "* Test whether remove is not removing last entry after calling hasNext.\n     * <p>\n     * See <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-802\">COLLECTIONS-802: ReferenceMap iterator remove violates contract</a>"
        },
        "testPurgeValues": {
          "Javadoc": "Tests whether purge values setting works"
        }
      }
    },
    "org.apache.commons.collections4.map.AccessibleEntry": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.map.SingletonMapTest": {
      "Javadoc": "\n * JUnit tests.\n "
    },
    "org.apache.commons.collections4.map.StaticBucketMapTest": {
      "Javadoc": "\n * Unit tests.\n * {@link StaticBucketMap}.\n ",
      "methods": {
        "isFailFastExpected": {
          "Javadoc": "* {@inheritDoc}"
        }
      }
    },
    "org.apache.commons.collections4.map.TransformedMapTest": {
      "Javadoc": "\n * Extension of {@link AbstractMapTest} for exercising the {@link TransformedMap}\n * implementation.\n "
    },
    "org.apache.commons.collections4.map.TransformedSortedMapTest": {
      "Javadoc": "\n * Extension of {@link AbstractSortedMapTest} for exercising the {@link TransformedSortedMap}\n * implementation.\n "
    },
    "org.apache.commons.collections4.map.UnmodifiableMapTest": {
      "Javadoc": "\n * Extension of {@link AbstractMapTest} for exercising the\n * {@link UnmodifiableMap} implementation.\n "
    },
    "org.apache.commons.collections4.map.UnmodifiableOrderedMapTest": {
      "Javadoc": "\n * Extension of {@link AbstractOrderedMapTest} for exercising the\n * {@link UnmodifiableOrderedMap} implementation.\n "
    },
    "org.apache.commons.collections4.map.UnmodifiableSortedMapTest": {
      "Javadoc": "\n * Extension of {@link AbstractSortedMapTest} for exercising the\n * {@link UnmodifiableSortedMap} implementation.\n "
    },
    "org.apache.commons.collections4.MapPerformance": {
      "Javadoc": "\n * {@code MapPerformanceTest} is designed to perform basic Map performance tests.\n ",
      "methods": {
        "main": {
          "Javadoc": "* Main method"
        }
      }
    },
    "org.apache.commons.collections4.DummyMap": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.MapUtilsTest": {
      "Javadoc": "\n * Tests for MapUtils.\n "
    },
    "org.apache.commons.collections4.X": {
      "Javadoc": "\n     * Test class for populateMap(MultiMap).\n     "
    },
    "org.apache.commons.collections4.MockTestCase": {
      "Javadoc": "\n * Provides utilities for making mock-based tests.  Most notable is the generic \"type-safe\"\n * {@link #createMock(Class)} method, and {@link #replay()} and {@link #verify()} methods\n * that call the respective methods on all created mock objects.\n "
    },
    "org.apache.commons.collections4.multimap.AbstractMultiValuedMapTest": {
      "Javadoc": "\n * Abstract test class for {@link MultiValuedMap} contract and methods.\n * <p>\n * To use, extend this class and implement the {@link #makeObject} method and if\n * necessary override the {@link #makeFullMap()} method.\n * </p>\n ",
      "methods": {
        "bulkTestMultiValuedMapEntries": {
          "Javadoc": "* Bulk test {@link MultiValuedMap#entries()}. This method runs through all\n     * of the tests in {@link AbstractCollectionTest}. After modification\n     * operations, {@link #verify()} is invoked to ensure that the map and the\n     * other collection views are still valid.\n     *\n     * @return a {@link AbstractCollectionTest} instance for testing the map's\n     *         values collection"
        },
        "bulkTestMultiValuedMapKeys": {
          "Javadoc": "* Bulk test {@link MultiValuedMap#keys()}. This method runs through all of\n     * the tests in {@link AbstractBagTest}. After modification operations,\n     * {@link #verify()} is invoked to ensure that the map and the other\n     * collection views are still valid.\n     *\n     * @return a {@link AbstractBagTest} instance for testing the map's values\n     *         collection"
        },
        "bulkTestMultiValuedMapKeySet": {
          "Javadoc": "* Bulk test {@link MultiValuedMap#keySet()}. This method runs through all\n     * of the tests in {@link AbstractSetTest}. After modification operations,\n     * {@link #verify()} is invoked to ensure that the map and the other\n     * collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing the map's key set"
        },
        "bulkTestMultiValuedMapValues": {
          "Javadoc": "* Bulk test {@link MultiValuedMap#values()}. This method runs through all\n     * of the tests in {@link AbstractCollectionTest}. After modification\n     * operations, {@link #verify()} is invoked to ensure that the map and the\n     * other collection views are still valid.\n     *\n     * @return a {@link AbstractCollectionTest} instance for testing the map's\n     *         values collection"
        },
        "getIterationBehaviour": {
          "Javadoc": "* Gets a flag specifying the iteration behavior of the map.\n     * This is used to change the assertions used by specific tests.\n     * The default implementation returns 0 which indicates ordered iteration behavior.\n     *\n     * @return the iteration behavior\n     * @see AbstractCollectionTest#UNORDERED"
        },
        "getSampleKeys": {
          "Javadoc": "* Returns the set of keys in the mappings used to test the map. This method\n     * must return an array with the same length as {@link #getSampleValues()}\n     * and all array elements must be different. The default implementation\n     * constructs a set of String keys, and includes a single null key if\n     * {@link #isAllowNullKey()} returns {@code true}."
        },
        "getSampleValues": {
          "Javadoc": "* Returns the set of values in the mappings used to test the map. This\n     * method must return an array with the same length as\n     * {@link #getSampleKeys()}. The default implementation constructs a set of\n     * String values"
        },
        "isAddSupported": {
          "Javadoc": "* Returns true if the maps produced by {@link #makeObject()} and\n     * {@link #makeFullMap()} support the {@code put} and\n     * {@code putAll} operations adding new mappings.\n     * <p>\n     * Default implementation returns true. Override if your collection class\n     * does not support put adding.\n     * </p>"
        },
        "isAllowNullKey": {
          "Javadoc": "* Returns true if the maps produced by {@link #makeObject()} and\n     * {@link #makeFullMap()} supports null keys.\n     * <p>\n     * Default implementation returns true. Override if your collection class\n     * does not support null keys.\n     * </p>"
        },
        "isHashSetValue": {
          "Javadoc": "* Returns true if the maps produced by {@link #makeObject()} and\n     * {@link #makeFullMap()} supports set value.\n     * <p>\n     * Default implementation returns false. Override if your collection class\n     * supports set value.\n     * </p>"
        },
        "isRemoveSupported": {
          "Javadoc": "* Returns true if the maps produced by {@link #makeObject()} and\n     * {@link #makeFullMap()} support the {@code remove} and\n     * {@code clear} operations.\n     * <p>\n     * Default implementation returns true. Override if your collection class\n     * does not support removal operations.\n     * </p>"
        },
        "makeConfirmedMap": {
          "Javadoc": "* Override to return a MultiValuedMap other than ArrayListValuedHashMap\n     * as the confirmed map.\n     *\n     * @return a MultiValuedMap that is known to be valid"
        },
        "resetEmpty": {
          "Javadoc": "* Resets the {@link #map} and {@link #confirmed} fields to empty."
        },
        "resetFull": {
          "Javadoc": "* Resets the {@link #map} and {@link #confirmed} fields to full."
        },
        "testEmptyMapCompatibility": {
          "Javadoc": "* Manual serialization testing as this class cannot easily extend the AbstractTestMap"
        }
      }
    },
    "org.apache.commons.collections4.multimap.TestMultiValuedMapAsMap": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.multimap.TestMultiValuedMapEntries": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.multimap.TestMultiValuedMapKeys": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.multimap.TestMultiValuedMapKeySet": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.multimap.TestMultiValuedMapValues": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.multimap.ArrayListValuedHashMapTest": {
      "Javadoc": "\n * Tests {@link ArrayListValuedHashMap}.\n "
    },
    "org.apache.commons.collections4.multimap.HashSetValuedHashMapTest": {
      "Javadoc": "\n * Tests {@link HashSetValuedHashMap}.\n "
    },
    "org.apache.commons.collections4.multimap.TransformedMultiValuedMapTest": {
      "Javadoc": "\n * Tests {@link TransformedMultiValuedMap}.\n "
    },
    "org.apache.commons.collections4.multimap.UnmodifiableMultiValuedMapTest": {
      "Javadoc": "\n * Tests {@link UnmodifiableMultiValuedMap}.\n ",
      "methods": {
        "assertMapContainsAllValues": {
          "Javadoc": "* Asserts the given map contains all added values after it was initialized\n     * with makeFullMap(). See COLLECTIONS-769.\n     *\n     * @param map the MultiValuedMap<K, V> to check"
        }
      }
    },
    "org.apache.commons.collections4.MultiMapUtilsTest": {
      "Javadoc": "\n * Tests for MultiMapUtils\n "
    },
    "org.apache.commons.collections4.multiset.AbstractMultiSetTest": {
      "Javadoc": "\n * Abstract test class for {@link org.apache.commons.collections4.MultiSet MultiSet}\n * methods and contracts.\n * <p>\n * To use, simply extend this class, and implement\n * the {@link #makeObject} method.\n * <p>\n * If your multiset fails one of these tests by design,\n * you may still use this base set of cases.  Simply override the\n * test case (method) your multiset fails.\n * <p>\n * This abstract test class does wrap the concrete multiset implementation\n * with such a decorator, see the overridden {@link #resetEmpty()} and\n * {@link #resetFull()} methods.\n * <p>\n * In addition to the generic collection tests (prefix testCollection) inherited\n * from AbstractCollectionTest, there are test methods that test the \"normal\" MultiSet\n * interface (prefix testMultiSet). For MultiSet specific tests use the {@link #makeObject()} and\n * {@link #makeFullCollection()} methods instead of {@link #resetEmpty()} and resetFull().\n ",
      "methods": {
        "bulkTestMultiSetUniqueSet": {
          "Javadoc": "* Bulk test {@link MultiSet#uniqueSet()}.  This method runs through all of\n     * the tests in {@link AbstractSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the multiset and the other collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing the multiset's unique set"
        },
        "getCollection": {
          "Javadoc": "* Returns the {@link #collection} field cast to a {@link MultiSet}.\n     *\n     * @return the collection field as a MultiSet"
        },
        "makeConfirmedCollection": {
          "Javadoc": "* Returns an empty {@link ArrayList}."
        },
        "makeConfirmedFullCollection": {
          "Javadoc": "* Returns a full collection."
        },
        "makeFullCollection": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeObject": {
          "Javadoc": "* Return a new, empty multiset to used for testing.\n     *\n     * @return the multiset to be tested"
        },
        "testEmptyMultiSetCompatibility": {
          "Javadoc": "* Compare the current serialized form of the MultiSet\n     * against the canonical version in SCM."
        },
        "testFullMultiSetCompatibility": {
          "Javadoc": "* Compare the current serialized form of the MultiSet\n     * against the canonical version in SCM."
        }
      }
    },
    "org.apache.commons.collections4.multiset.TestMultiSetUniqueSet": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.multiset.HashMultiSetTest": {
      "Javadoc": "\n * Extension of {@link AbstractMultiSetTest} for exercising the\n * {@link HashMultiSet} implementation.\n "
    },
    "org.apache.commons.collections4.multiset.PredicatedMultiSetTest": {
      "Javadoc": "\n * Extension of {@link AbstractMultiSetTest} for exercising the\n * {@link PredicatedMultiSet} implementation.\n "
    },
    "org.apache.commons.collections4.multiset.SynchronizedMultiSetTest": {
      "Javadoc": "\n * Extension of {@link AbstractMultiSetTest} for exercising the\n * {@link SynchronizedMultiSet} implementation.\n "
    },
    "org.apache.commons.collections4.multiset.UnmodifiableMultiSetTest": {
      "Javadoc": "\n * Extension of {@link AbstractMultiSetTest} for exercising the\n * {@link UnmodifiableMultiSet} implementation.\n "
    },
    "org.apache.commons.collections4.MultiSetUtilsTest": {
      "Javadoc": "\n * Tests for MultiSetUtils.\n ",
      "methods": {
        "testEmptyMultiSet": {
          "Javadoc": "* Tests {@link MultiSetUtils#emptyMultiSet()}."
        },
        "testPredicatedMultiSet": {
          "Javadoc": "* Tests {@link MultiSetUtils#predicatedMultiSet(org.apache.commons.collections4.MultiSet, org.apache.commons.collections4.Predicate)}."
        },
        "testSynchronizedMultiSet": {
          "Javadoc": "* Tests {@link MultiSetUtils#unmodifiableMultiSet(org.apache.commons.collections4.MultiSet) ()}."
        },
        "testUnmodifiableMultiSet": {
          "Javadoc": "* Tests {@link MultiSetUtils#unmodifiableMultiSet(org.apache.commons.collections4.MultiSet) ()}."
        }
      }
    },
    "org.apache.commons.collections4.PredicateUtilsTest": {
      "Javadoc": "\n * Tests the PredicateUtils class.\n ",
      "methods": {
        "testSingletonPatternInSerialization": {
          "Javadoc": "* Test that all Predicate singletons hold singleton pattern in\n     * serialization/deserialization process."
        }
      }
    },
    "org.apache.commons.collections4.properties.AbstractPropertiesFactoryTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.properties.EmptyPropertiesTest": {
      "Javadoc": "",
      "methods": {
        "getFirstLine": {
          "Javadoc": "* Returns the first line from multi-lined string separated by a line separator character\n     *\n     * @param x the multi-lined String\n     * @return the first line from x"
        }
      }
    },
    "org.apache.commons.collections4.properties.OrderedPropertiesFactoryTest": {
      "Javadoc": "\n * Tests {@link OrderedPropertiesFactory}.\n "
    },
    "org.apache.commons.collections4.properties.OrderedPropertiesTest": {
      "Javadoc": "\n * Tests {@link OrderedProperties}.\n "
    },
    "org.apache.commons.collections4.properties.PropertiesFactoryTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.properties.SortedPropertiesFactoryTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.properties.SortedPropertiesTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.queue.AbstractQueueTest": {
      "Javadoc": "\n * Abstract test class for {@link java.util.Queue} methods and contracts.\n * <p>\n * To use, simply extend this class, and implement\n * the {@link #makeObject} method.\n * <p>\n * If your {@link Queue} fails one of these tests by design,\n * you may still use this base set of cases.  Simply override the\n * test case (method) your {@link Queue} fails or override one of the\n * protected methods from AbstractCollectionTest.\n ",
      "methods": {
        "getCollection": {
          "Javadoc": "* Returns the {@link #collection} field cast to a {@link Queue}.\n     *\n     * @return the collection field as a Queue"
        },
        "isSetSupported": {
          "Javadoc": "*  Returns true if the collections produced by\n     *  {@link #makeObject()} and {@link #makeFullCollection()}\n     *  support the <code>set operation.<p>\n     *  Default implementation returns true.  Override if your collection\n     *  class does not support set."
        },
        "makeConfirmedCollection": {
          "Javadoc": "* Returns an empty {@link ArrayList}."
        },
        "makeConfirmedFullCollection": {
          "Javadoc": "* Returns a full {@link ArrayList}."
        },
        "makeFullCollection": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeObject": {
          "Javadoc": "* Returns {@link #makeObject()}.\n     *\n     * @return an empty queue to be used for testing"
        },
        "testEmptyQueueCompatibility": {
          "Javadoc": "* Compare the current serialized form of the Queue\n     * against the canonical version in SCM."
        },
        "testFullQueueCompatibility": {
          "Javadoc": "* Compare the current serialized form of the Queue\n     * against the canonical version in SCM."
        },
        "testQueueElement": {
          "Javadoc": "*  Tests {@link Queue#element()}."
        },
        "testQueueOffer": {
          "Javadoc": "*  Tests {@link Queue#offer(Object)}."
        },
        "testQueuePeek": {
          "Javadoc": "*  Tests {@link Queue#peek()}."
        },
        "testQueuePoll": {
          "Javadoc": "*  Tests {@link Queue#poll()}."
        },
        "testQueueRemove": {
          "Javadoc": "*  Tests {@link Queue#remove()}."
        },
        "verify": {
          "Javadoc": "*  Verifies that the test queue implementation matches the confirmed queue\n     *  implementation."
        }
      }
    },
    "org.apache.commons.collections4.queue.CircularFifoQueueTest": {
      "Javadoc": "\n * Test cases for CircularFifoQueue.\n ",
      "methods": {
        "getCollection": {
          "Javadoc": "* {@inheritDoc}"
        },
        "isFailFastSupported": {
          "Javadoc": "* Overridden because CircularFifoQueue isn't fail fast.\n     * @return false"
        },
        "isNullSupported": {
          "Javadoc": "* Overridden because CircularFifoQueue doesn't allow null elements.\n     * @return false"
        },
        "makeConfirmedCollection": {
          "Javadoc": "* Returns an empty ArrayList.\n     *\n     * @return an empty ArrayList"
        },
        "makeConfirmedFullCollection": {
          "Javadoc": "* Returns a full ArrayList.\n     *\n     * @return a full ArrayList"
        },
        "makeObject": {
          "Javadoc": "* Returns an empty CircularFifoQueue that won't overflow.\n     *\n     * @return an empty CircularFifoQueue"
        },
        "testCircularFifoQueueCircular": {
          "Javadoc": "* Tests that the removal operation actually removes the first element."
        },
        "testCircularFifoQueueRemove": {
          "Javadoc": "* Tests that the removal operation actually removes the first element."
        },
        "testConstructorException1": {
          "Javadoc": "* Tests that the constructor correctly throws an exception."
        },
        "testConstructorException2": {
          "Javadoc": "* Tests that the constructor correctly throws an exception."
        },
        "testConstructorException3": {
          "Javadoc": "* Tests that the constructor correctly throws an exception."
        },
        "verify": {
          "Javadoc": "*  Runs through the regular verifications, but also verifies that\n     *  the buffer contains the same elements in the same sequence as the\n     *  list."
        }
      }
    },
    "org.apache.commons.collections4.queue.PredicatedQueueTest": {
      "Javadoc": "\n * Extension of {@link PredicatedCollectionTest} for exercising the\n * {@link PredicatedQueue} implementation.\n "
    },
    "org.apache.commons.collections4.queue.SynchronizedQueueTest": {
      "Javadoc": "\n * Extension of {@link AbstractQueueTest} for exercising the {@link SynchronizedQueue} implementation.\n "
    },
    "org.apache.commons.collections4.queue.TransformedQueueTest": {
      "Javadoc": "\n * Extension of {@link AbstractCollectionTest} for exercising the\n * {@link TransformedQueue} implementation.\n "
    },
    "org.apache.commons.collections4.queue.UnmodifiableQueueTest": {
      "Javadoc": "\n * Extension of {@link AbstractCollectionTest} for exercising the\n * {@link UnmodifiableQueue} implementation.\n "
    },
    "org.apache.commons.collections4.QueueUtilsTest": {
      "Javadoc": "\n * Tests for QueueUtils factory methods.\n "
    },
    "org.apache.commons.collections4.sequence.SequencesComparatorTest": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.sequence.ExecutionVisitor": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.set.AbstractNavigableSetTest": {
      "Javadoc": "\n * Abstract test class for {@link NavigableSet} methods and contracts.\n * <p>\n * To use, subclass and override the {@link #makeObject()}\n * method.  You may have to override other protected methods if your\n * set is not modifiable, or if your set restricts what kinds of\n * elements may be added; see {@link AbstractSetTest} for more details.\n ",
      "methods": {
        "bulkTestNavigableSetHeadSet": {
          "Javadoc": "* Bulk test {@link NavigableSet#headSet(Object, boolean)}.\n     * This method runs through all of the tests in {@link AbstractNavigableSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the set and the other collection views are still valid.\n     *\n     * @return a {@link AbstractNavigableSetTest} instance for testing a headset."
        },
        "bulkTestNavigableSetSubSet": {
          "Javadoc": "* Bulk test {@link NavigableSet#subSet(Object, boolean, Object, boolean)}.\n     * This method runs through all of the tests in {@link AbstractNavigableSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the set and the other collection views are still valid.\n     *\n     * @return a {@link AbstractNavigableSetTest} instance for testing a subset."
        },
        "bulkTestNavigableSetTailSet": {
          "Javadoc": "* Bulk test {@link NavigableSet#tailSet(Object, boolean)}.\n     * This method runs through all of the tests in {@link AbstractNavigableSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the set and the other collection views are still valid.\n     *\n     * @return a {@link AbstractNavigableSetTest} instance for testing a tailset."
        },
        "getCollection": {
          "Javadoc": "* {@inheritDoc}"
        },
        "getConfirmed": {
          "Javadoc": "* {@inheritDoc}"
        },
        "getFullNonNullElements": {
          "Javadoc": "* Override to return comparable objects."
        },
        "getOtherNonNullElements": {
          "Javadoc": "* Override to return comparable objects."
        },
        "makeConfirmedCollection": {
          "Javadoc": "* Returns an empty {@link TreeSet} for use in modification testing.\n     *\n     * @return a confirmed empty collection"
        },
        "makeFullCollection": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeObject": {
          "Javadoc": "* {@inheritDoc}"
        },
        "verify": {
          "Javadoc": "* Verification extension, will check the order of elements,\n     * the sets should already be verified equal."
        }
      }
    },
    "org.apache.commons.collections4.set.TestNavigableSetSubSet": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.set.AbstractSetTest": {
      "Javadoc": "\n * Abstract test class for {@link Set} methods and contracts.\n * <p>\n * Since {@link Set} doesn't stipulate much new behavior that isn't already\n * found in {@link Collection}, this class basically just adds tests for\n * {@link Set#equals} and {@link Set#hashCode()} along with an updated\n * {@link #verify()} that ensures elements do not appear more than once in the\n * set.\n * <p>\n * To use, subclass and override the {@link #makeObject()}\n * method.  You may have to override other protected methods if your\n * set is not modifiable, or if your set restricts what kinds of\n * elements may be added; see {@link AbstractCollectionTest} for more details.\n ",
      "methods": {
        "getCollection": {
          "Javadoc": "* Gets the {@link AbstractCollectionTest#collection} fixture, but cast as a Set."
        },
        "getConfirmed": {
          "Javadoc": "* Gets the {@link AbstractCollectionTest#confirmed} fixture, but cast as a Set."
        },
        "isEqualsCheckable": {
          "Javadoc": "* Sets equals method is defined."
        },
        "makeConfirmedCollection": {
          "Javadoc": "* Returns an empty Set for use in modification testing.\n     *\n     * @return a confirmed empty collection"
        },
        "makeConfirmedFullCollection": {
          "Javadoc": "* Returns a full Set for use in modification testing.\n     *\n     * @return a confirmed full collection"
        },
        "makeFullCollection": {
          "Javadoc": "* Makes a full set by first creating an empty set and then adding\n     * all the elements returned by {@link #getFullElements()}.\n     *\n     * Override if your set does not support the add operation.\n     *\n     * @return a full set"
        },
        "makeObject": {
          "Javadoc": "* Makes an empty set.  The returned set should have no elements.\n     *\n     * @return an empty set"
        },
        "testSetEquals": {
          "Javadoc": "* Tests {@link Set#equals(Object)}."
        },
        "testSetHashCode": {
          "Javadoc": "* Tests {@link Set#hashCode()}."
        },
        "verify": {
          "Javadoc": "* Provides additional verifications for sets."
        }
      }
    },
    "org.apache.commons.collections4.set.AbstractSortedSetTest": {
      "Javadoc": "\n * Abstract test class for {@link SortedSet} methods and contracts.\n * <p>\n * To use, subclass and override the {@link #makeObject()}\n * method.  You may have to override other protected methods if your\n * set is not modifiable, or if your set restricts what kinds of\n * elements may be added; see {@link AbstractSetTest} for more details.\n ",
      "methods": {
        "bulkTestSortedSetHeadSet": {
          "Javadoc": "* Bulk test {@link SortedSet#headSet(Object)}.  This method runs through all of\n     * the tests in {@link AbstractSortedSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the set and the other collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing a headset."
        },
        "bulkTestSortedSetSubSet": {
          "Javadoc": "* Bulk test {@link SortedSet#subSet(Object, Object)}.  This method runs through all of\n     * the tests in {@link AbstractSortedSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the set and the other collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing a subset."
        },
        "bulkTestSortedSetTailSet": {
          "Javadoc": "* Bulk test {@link SortedSet#tailSet(Object)}.  This method runs through all of\n     * the tests in {@link AbstractSortedSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the set and the other collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing a tailset."
        },
        "getCollection": {
          "Javadoc": "* {@inheritDoc}"
        },
        "getConfirmed": {
          "Javadoc": "* {@inheritDoc}"
        },
        "getFullNonNullElements": {
          "Javadoc": "* Override to return comparable objects."
        },
        "getOtherNonNullElements": {
          "Javadoc": "* Override to return comparable objects."
        },
        "isNullSupported": {
          "Javadoc": "* Overridden because SortedSets don't allow null elements (normally).\n     * @return false"
        },
        "makeConfirmedCollection": {
          "Javadoc": "* Returns an empty {@link TreeSet} for use in modification testing.\n     *\n     * @return a confirmed empty collection"
        },
        "makeFullCollection": {
          "Javadoc": "* {@inheritDoc}"
        },
        "makeObject": {
          "Javadoc": "* {@inheritDoc}"
        },
        "verify": {
          "Javadoc": "* Verification extension, will check the order of elements,\n     * the sets should already be verified equal."
        }
      }
    },
    "org.apache.commons.collections4.set.TestSortedSetSubSet": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.set.CompositeSetTest": {
      "Javadoc": "\n * Extension of {@link AbstractSetTest} for exercising the\n * {@link CompositeSet} implementation.\n "
    },
    "org.apache.commons.collections4.set.EmptySetMutator": {
      "Javadoc": "\n * This class is used in CompositeSetTest. When testing serialization,\n * the class has to be separate of CompositeSetTest, else the test\n * class also has to be serialized.\n "
    },
    "org.apache.commons.collections4.set.ListOrderedSet2Test": {
      "Javadoc": "\n * Extension of {@link AbstractSetTest} for exercising the {@link ListOrderedSet}\n * implementation.\n "
    },
    "org.apache.commons.collections4.set.ListOrderedSetTest": {
      "Javadoc": "\n * Extension of {@link AbstractSetTest} for exercising the\n * {@link ListOrderedSet} implementation.\n "
    },
    "org.apache.commons.collections4.set.A": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.set.B": {
      "Javadoc": ""
    },
    "org.apache.commons.collections4.set.MapBackedSet2Test": {
      "Javadoc": "\n * JUnit test.\n "
    },
    "org.apache.commons.collections4.set.MapBackedSetTest": {
      "Javadoc": "\n * JUnit test.\n "
    },
    "org.apache.commons.collections4.set.PredicatedNavigableSetTest": {
      "Javadoc": "\n * Extension of {@link AbstractNavigableSetTest} for exercising the\n * {@link PredicatedNavigableSet} implementation.\n "
    },
    "org.apache.commons.collections4.set.PredicatedSetTest": {
      "Javadoc": "\n * Extension of {@link AbstractSetTest} for exercising the\n * {@link PredicatedSet} implementation.\n "
    },
    "org.apache.commons.collections4.set.PredicatedSortedSetTest": {
      "Javadoc": "\n * Extension of {@link AbstractSortedSetTest} for exercising the\n * {@link PredicatedSortedSet} implementation.\n "
    },
    "org.apache.commons.collections4.set.TransformedNavigableSetTest": {
      "Javadoc": "\n * Extension of {@link AbstractNavigableSetTest} for exercising the\n * {@link TransformedNavigableSet} implementation.\n "
    },
    "org.apache.commons.collections4.set.TransformedSetTest": {
      "Javadoc": "\n * Extension of {@link AbstractSetTest} for exercising the {@link TransformedSet}\n * implementation.\n "
    },
    "org.apache.commons.collections4.set.TransformedSortedSetTest": {
      "Javadoc": "\n * Extension of {@link AbstractSortedSetTest} for exercising the {@link TransformedSortedSet}\n * implementation.\n "
    },
    "org.apache.commons.collections4.set.UnmodifiableNavigableSetTest": {
      "Javadoc": "\n * Extension of {@link AbstractNavigableSetTest} for exercising the\n * {@link UnmodifiableNavigableSet} implementation.\n ",
      "methods": {
        "testUnmodifiable": {
          "Javadoc": "* Verify that base set and subsets are not modifiable"
        },
        "verifyUnmodifiable": {
          "Javadoc": "* Verifies that a set is not modifiable"
        }
      }
    },
    "org.apache.commons.collections4.set.UnmodifiableSetTest": {
      "Javadoc": "\n * Extension of {@link AbstractSetTest} for exercising the\n * {@link UnmodifiableSet} implementation.\n "
    },
    "org.apache.commons.collections4.set.UnmodifiableSortedSetTest": {
      "Javadoc": "\n * Extension of {@link AbstractSortedSetTest} for exercising the\n * {@link UnmodifiableSortedSet} implementation.\n ",
      "methods": {
        "testUnmodifiable": {
          "Javadoc": "* Verify that base set and subsets are not modifiable"
        },
        "verifyUnmodifiable": {
          "Javadoc": "* Verifies that a set is not modifiable"
        }
      }
    },
    "org.apache.commons.collections4.SetUtilsTest": {
      "Javadoc": "\n * Tests for SetUtils.\n "
    },
    "org.apache.commons.collections4.splitmap.TransformedSplitMapTest": {
      "Javadoc": "\n * Tests for {@link TransformedSplitMap}\n "
    },
    "org.apache.commons.collections4.SplitMapUtilsTest": {
      "Javadoc": "\n * Tests for {@link TransformedSplitMap}\n "
    },
    "org.apache.commons.collections4.TestUtils": {
      "Javadoc": "",
      "methods": {
        "assertSameAfterSerialization": {
          "Javadoc": "* Asserts that deserialization of the object returns the same object as the\n     * one that was serialized. Object is first serialized, then deserialized\n     * and finally check is performed to see if original and deserialized\n     * object references are the same.\n     * <p>\n     * This method is especially good for testing singleton pattern on classes\n     * that support serialization.\n     *\n     * @param msg the identifying message for the {@code AssertionError}.\n     * @param o object that will be tested.\n     * @see #assertSameAfterSerialization(Object)"
        }
      }
    },
    "org.apache.commons.collections4.TransformerUtilsTest": {
      "Javadoc": "\n * Tests the TransformerUtils class.\n ",
      "methods": {
        "testSingletonPatternInSerialization": {
          "Javadoc": "* Test that all Transformer singletons hold singleton pattern in\n     * serialization/deserialization process."
        }
      }
    },
    "org.apache.commons.collections4.trie.PatriciaTrie2Test": {
      "Javadoc": "\n * JUnit test of the OrderedMap interface of a PatriciaTrie.\n "
    },
    "org.apache.commons.collections4.trie.PatriciaTrieTest": {
      "Javadoc": "\n * JUnit tests for the PatriciaTrie.\n "
    },
    "org.apache.commons.collections4.trie.UnmodifiableTrieTest": {
      "Javadoc": "\n * Extension of {@link AbstractSortedMapTest} for exercising the\n * {@link UnmodifiableTrie} implementation.\n ",
      "methods": {
        "ignoredTests": {
          "Javadoc": "* Override to prevent infinite recursion of tests."
        }
      }
    },
    "org.apache.commons.collections4.TrieUtilsTest": {
      "Javadoc": "\n * Tests for TrieUtils factory methods.\n "
    }
  }
}