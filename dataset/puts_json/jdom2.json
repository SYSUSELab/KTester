{
  "dataset": "jdom2",
  "classes": {
    "org.jdom2.adapters.AbstractDOMAdapter": {
      "Javadoc": "\n * A DOMAdapter utility abstract base class. Uses the concrete implementation\n * to build a org.w3c.dom.Document instance, which in turn is used to apply\n * the DocType.\n * <p>\n * Special attention should be paid to the setInternalSubset protected method,\n * which may, or may not be supported by your actual DOM implementation.\n * \n * @author  Brett McLaughlin\n * @author  Jason Hunter\n ",
      "methods": {
        "createDocument": {
          "Javadoc": "* This creates an empty <code>Document</code> object based\n\t * on a specific parser implementation with the given DOCTYPE.\n\t * If the doctype parameter is null, the behavior is the same as\n\t * calling <code>createDocument()</code>.\n\t *\n\t * @param doctype Initial <code>DocType</code> of the document.\n\t * @return <code>Document</code> - created DOM Document.\n\t * @throws JDOMException when errors occur."
        },
        "setInternalSubset": {
          "Javadoc": "* This attempts to change the DocumentType to have the given internal DTD \n\t * subset value.  This is not a standard ability in DOM, so it's only\n\t * available with some parsers.  Subclasses can alter the mechanism by\n\t * which the attempt is made to set the value.\n\t *\n\t * @param dt DocumentType to be altered\n\t * @param s String to use as the internal DTD subset"
        }
      }
    },
    "org.jdom2.adapters.DOMAdapter": {
      "Javadoc": "\n * Defines a standard set of adapter methods for interfacing with a DOM parser\n * and obtaining a DOM {@link org.w3c.dom.Document org.w3c.dom.Document} object.\n * Instances of this interface are used by the {@link DOMOutputter} class to\n * create a DOM output result using the org.w3c.dom.Document implementation\n * returned by these methods.\n * <p>\n * You should never need to implement this interface unless you have a specific\n * need to use something other than the default JAXP-based mechanism.\n * <p>\n * JDOM only provides one 'concrete' implementation of the DOMAdapter: the\n * {@link JAXPDOMAdapter} class. That implementation is a thread-safe and\n * efficient implementation. It can be used as a template for building your own\n * custom DOMAdapter implementation, if you need it.\n * <p>\n * The {@link AbstractDOMAdapter} class could help you by implementing the\n * DocType-based method which leverages the base createDocument() method.\n * <p>\n * <strong>Special note for implementation of DOMAdapter</strong>: For backward\n * compatibility with JDOM 1.x (which allows a class-name to be used to specify\n * a DOMAdapter in the DOMOoutputter class), it is required that your\n * implementations of DOMAdapter have a no-argument default constructor. If you\n * require a constructor argument then you have to ensure that you use the\n * correct (non-deprecated) mechanisms on DOMOutputter to specify your custom\n * DOMAdapter.\n * \n *\n * @author  Brett McLaughlin\n * @author  Jason Hunter\n ",
      "methods": {
        "createDocument": {
          "Javadoc": "* This creates an empty <code>Document</code> object based\n\t * on a specific parser implementation with the given DOCTYPE.\n\t *\n\t * @param doctype Initial <code>DocType</code> of the document.\n\t * @return <code>Document</code> - created DOM Document.\n\t * @throws JDOMException if an error occurs."
        }
      }
    },
    "org.jdom2.adapters.JAXPDOMAdapter": {
      "Javadoc": "\n * A DOMAdapter that uses JAXP to obtain a org.w3c.dom.Document instance.\n * <p>\n * This class is fully thread-safe.\n * \n * @author  Jason Hunter\n * @author  Rolf Lear\n ",
      "methods": {
        "createDocument": {
          "Javadoc": "* This creates an empty <code>Document</code> object based\n\t * on the current JAXP parser implementation.\n\t *\n\t * @return <code>Document</code> - created DOM Document.\n\t * @throws JDOMException when errors occur in parsing."
        }
      }
    },
    "org.jdom2.Attribute": {
      "Javadoc": "\n * An XML attribute. Methods allow the user to obtain the value of the attribute\n * as well as namespace and type information.\n * <p>\n * <strong>JDOM 1.x Compatibility Note:</strong><br>\n * The Attribute class in JDOM 1.x had a number of int Constants declared to\n * represent different Attribute Types. JDOM2 has introduced an AttributeType\n * enumeration instead. To facilitate compatibility and to simplify JDOM 1.x\n * migrations, the replacement AttributeType enums are referenced still using\n * the JDOM 1.x constant names. In JDOM 1.x these names referenced constant\n * int values. In JDOM2 these names reference Enum constants. \n *\n * @author  Brett McLaughlin\n * @author  Jason Hunter\n * @author  Elliotte Rusty Harold\n * @author  Wesley Biggs\n * @author  Victor Toni\n * @author  Rolf Lear\n ",
      "methods": {
        "getParent": {
          "Javadoc": "* This will return the parent of this <code>Attribute</code>.\n\t * If there is no parent, then this returns <code>null</code>.\n\t * Use return-type covariance to override Content's getParent() method\n\t * to return an Element, not just a Parent\n\t *\n\t * @return parent of this <code>Attribute</code>"
        },
        "getDocument": {
          "Javadoc": "* Get this Attribute's Document.\n\t * @return The document to which this Attribute is associated, may be null."
        },
        "getName": {
          "Javadoc": "* This will retrieve the local name of the\n\t * <code>Attribute</code>. For any XML attribute\n\t * which appears as\n\t * <code>[namespacePrefix]:[attributeName]</code>,\n\t * the local name of the attribute would be\n\t * <code>[attributeName]</code>. When the attribute\n\t * has no namespace, the local name is simply the attribute\n\t * name.\n\t * <p>\n\t * To obtain the namespace prefix for this\n\t * attribute, the\n\t * <code>{@link #getNamespacePrefix()}</code>\n\t * method should be used.\n\t *\n\t * @return <code>String</code> - name of this attribute,\n\t *                               without any namespace prefix."
        },
        "setName": {
          "Javadoc": "* This sets the local name of the <code>Attribute</code>.\n\t *\n\t * @param name the new local name to set\n\t * @return <code>Attribute</code> - the attribute modified.\n\t * @throws IllegalNameException if the given name is illegal as an\n\t *         attribute name."
        },
        "getQualifiedName": {
          "Javadoc": "* This will retrieve the qualified name of the <code>Attribute</code>.\n\t * For any XML attribute whose name is\n\t * <code>[namespacePrefix]:[elementName]</code>,\n\t * the qualified name of the attribute would be\n\t * everything (both namespace prefix and\n\t * element name). When the attribute has no\n\t * namespace, the qualified name is simply the attribute's\n\t * local name.\n\t * <p>\n\t * To obtain the local name of the attribute, the\n\t * <code>{@link #getName()}</code> method should be used.\n\t * <p>\n\t * To obtain the namespace prefix for this attribute,\n\t * the <code>{@link #getNamespacePrefix()}</code>\n\t * method should be used.\n\t *\n\t * @return <code>String</code> - full name for this element."
        },
        "getNamespacePrefix": {
          "Javadoc": "* This will retrieve the namespace prefix of the\n\t * <code>Attribute</code>. For any XML attribute\n\t * which appears as\n\t * <code>[namespacePrefix]:[attributeName]</code>,\n\t * the namespace prefix of the attribute would be\n\t * <code>[namespacePrefix]</code>. When the attribute\n\t * has no namespace, an empty <code>String</code> is returned.\n\t *\n\t * @return <code>String</code> - namespace prefix of this\n\t *                               attribute."
        },
        "getNamespaceURI": {
          "Javadoc": "* This returns the URI mapped to this <code>Attribute</code>'s\n\t * prefix. If no mapping is found, an empty <code>String</code> is\n\t * returned.\n\t *\n\t * @return <code>String</code> - namespace URI for this <code>Attribute</code>."
        },
        "getNamespace": {
          "Javadoc": "* This will return this <code>Attribute</code>'s\n\t * <code>{@link Namespace}</code>.\n\t *\n\t * @return <code>Namespace</code> - Namespace object for this <code>Attribute</code>"
        },
        "setNamespace": {
          "Javadoc": "* This sets this <code>Attribute</code>'s <code>{@link Namespace}</code>.\n\t * If the provided namespace is null, the attribute will have no namespace.\n\t * The namespace must have a prefix.\n\t *\n\t * @param namespace the new namespace\n\t * @return <code>Element</code> - the element modified.\n\t * @throws IllegalNameException if the new namespace is the default\n\t *         namespace. Attributes cannot be in a default namespace."
        },
        "getValue": {
          "Javadoc": "* This will return the actual textual value of this\n\t * <code>Attribute</code>.  This will include all text\n\t * within the quotation marks.\n\t *\n\t * @return <code>String</code> - value for this attribute."
        },
        "setValue": {
          "Javadoc": "* This will set the value of the <code>Attribute</code>.\n\t *\n\t * @param value <code>String</code> value for the attribute.\n\t * @return <code>Attribute</code> - this Attribute modified.\n\t * @throws IllegalDataException if the given attribute value is\n\t *         illegal character data (as determined by\n\t *         {@link org.jdom2.Verifier#checkCharacterData})."
        },
        "getAttributeType": {
          "Javadoc": "* This will return the declared type of this <code>Attribute</code>.\n\t *\n\t * @return <code>AttributeType</code> - type for this attribute."
        },
        "setAttributeType": {
          "Javadoc": "* This will set the type of the <code>Attribute</code>.\n\t *\n\t * @param type <code>int</code> type for the attribute.\n\t * @return <code>Attribute</code> - this Attribute modified.\n\t * @throws IllegalDataException if the given attribute type is\n\t *         not one of the supported types.\n\t * @deprecated use {@link #setAttributeType(AttributeType)}"
        },
        "isSpecified": {
          "Javadoc": "* Get the 'specified' flag. True values indicate this attribute\n\t * was part of an XML document, false indicates it was defaulted\n\t * from a DTD.\n\t * @return the specified flag.\n\t * @since JDOM2"
        },
        "setSpecified": {
          "Javadoc": "* Change the specified flag to the given value.\n\t * @param specified The value to set the specified flag to.\n\t * @since JDOM2"
        },
        "toString": {
          "Javadoc": "* This returns a <code>String</code> representation of the\n\t * <code>Attribute</code>, suitable for debugging.\n\t *\n\t * @return <code>String</code> - information about the\n\t *         <code>Attribute</code>"
        },
        "detach": {
          "Javadoc": "* Detach this Attribute from its parent.\n\t * @return this Attribute (detached)."
        },
        "setParent": {
          "Javadoc": "* Set this Attribute's parent. This is not public!\n\t * @param parent The parent to set\n\t * @return this Attribute (state may be indeterminate depending on whether\n\t * this has been included in the Element's list yet)."
        },
        "getIntValue": {
          "Javadoc": "* This gets the value of the attribute, in\n\t * <code>int</code> form, and if no conversion\n\t * can occur, throws a\n\t * <code>{@link DataConversionException}</code>\n\t *\n\t * @return <code>int</code> value of attribute.\n\t * @throws DataConversionException when conversion fails."
        },
        "getLongValue": {
          "Javadoc": "* This gets the value of the attribute, in\n\t * <code>long</code> form, and if no conversion\n\t * can occur, throws a\n\t * <code>{@link DataConversionException}</code>\n\t *\n\t * @return <code>long</code> value of attribute.\n\t * @throws DataConversionException when conversion fails."
        },
        "getFloatValue": {
          "Javadoc": "* This gets the value of the attribute, in\n\t * <code>float</code> form, and if no conversion\n\t * can occur, throws a\n\t * <code>{@link DataConversionException}</code>\n\t *\n\t * @return <code>float</code> value of attribute.\n\t * @throws DataConversionException when conversion fails."
        },
        "getDoubleValue": {
          "Javadoc": "* This gets the value of the attribute, in\n\t * <code>double</code> form, and if no conversion\n\t * can occur, throws a\n\t * <code>{@link DataConversionException}</code>\n\t *\n\t * @return <code>double</code> value of attribute.\n\t * @throws DataConversionException when conversion fails."
        },
        "getBooleanValue": {
          "Javadoc": "* This gets the effective boolean value of the attribute, or throws a\n\t * <code>{@link DataConversionException}</code> if a conversion can't be\n\t * performed.  True values are: \"true\", \"on\", \"1\", and \"yes\".  False\n\t * values are: \"false\", \"off\", \"0\", and \"no\".  Values are trimmed before\n\t * comparison.  Values other than those listed here throw the exception.\n\t *\n\t * @return <code>boolean</code> value of attribute.\n\t * @throws DataConversionException when conversion fails."
        },
        "getNamespacesInScope": {
          "Javadoc": "* Get the namespaces that are in-scope on this Attribute.\n\t * <p>\n\t * Attribute has peculiarities that affect the in-scope Namespaces because\n\t * there are conditions in which the Attribute's scope is different to its\n\t * parent Element's scope. Specifically, if the parent Element is in a\n\t * 'default' Namespace that is not the empty Namespace (e.g.\n\t * xmlns=\"someurl\") and this Attribute is also in the default Namespace (has\n\t * no prefix - but for Attributes that means the Namespace URL is \"\"), then\n\t * this Attribute has a different namespace scope from it's parent Element\n\t * because it does not include the 'someurl' Namespace.\n\t * <p>\n\t * In the above conditions (no-prefix Attribute in an Element with a\n\t * non-empty no-prefix Namespace) this Attribute effectively re-binds the \"\"\n\t * prefix to the \"\" URL, thus the Attribute 'introduces' the Namespace.\n\t * It follows then that the getNamespacesIntroduced() will return a list\n\t * with the single member {@link Namespace#NO_NAMESPACE}.\n\t * <p>\n\t * Note that the Attribute's Namespace will always be reported first.\n\t * <p>\n\t * <strong>Description copied from</strong>\n\t * {@link NamespaceAware#getNamespacesInScope()}:\n\t * <p>\n\t * {@inheritDoc}"
        }
      }
    },
    "org.jdom2.AttributeList": {
      "Javadoc": "\n * <code>AttributeList</code> represents legal JDOM\n * <code>{@link Attribute}</code> content.\n * <p>\n * This class is NOT PUBLIC; users should see it as a simple List\n * implementation, although it behaves something like a Set because you cannot\n * add duplicate Attributes. An attribute is considered duplicate if it has the\n * same Namespace URI and Attribute name as another existing Attribute.\n * \n * @author Alex Rosen\n * @author Philippe Riand\n * @author Bradley S. Huffman\n * @author Rolf Lear\n ",
      "methods": {
        "uncheckedAddAttribute": {
          "Javadoc": "* Package internal method to support building from sources that are 100%\n\t * trusted.\n\t * \n\t * @param a\n\t *        an Attribute to add without any checks"
        },
        "add": {
          "Javadoc": "* Check and add <i>attribute</i> to this list at <i>index</i>.\n\t * \n\t * @param index\n\t *        where to add/insert the <code>Attribute</code>\n\t * @param attribute\n\t *        <code>Attribute</code> to add\n\t * @throws IllegalAddException\n\t *         if validation rules prevent the add"
        },
        "addAll": {
          "Javadoc": "* Inserts the <code>Attributes</code> in <i>collection</i> at the specified\n\t * <i>index</i> in this list.\n\t * \n\t * @param index\n\t *        The offset at which to start adding the <code>Attributes</code>\n\t * @param collection\n\t *        The <code>Collection</code> containing the <code>Attributes</code>\n\t *        to add.\n\t * @return <code>true</code> if the list was modified as a result of the\n\t *         add.\n\t * @throws IllegalAddException\n\t *         if validation rules prevent the addAll"
        },
        "clear": {
          "Javadoc": "* Clear the current list."
        },
        "clearAndSet": {
          "Javadoc": "* Clear the current list and set it to the contents of <i>collection</i>.\n\t * \n\t * @param collection\n\t *        The <code>Collection</code> to use.\n\t * @throws IllegalAddException\n\t *         if validation rules prevent the addAll"
        },
        "ensureCapacity": {
          "Javadoc": "* Increases the capacity of this <code>AttributeList</code> instance, if\n\t * necessary, to ensure that it can hold at least the number of items\n\t * specified by the minimum capacity argument.\n\t * \n\t * @param minCapacity\n\t *        the desired minimum capacity."
        },
        "get": {
          "Javadoc": "* Retrieve the <code>Attribute</code> with the given name and the same\n\t * <code>Namespace</code> URI as <i>namespace</i>.\n\t * \n\t * @param name\n\t *        name of attribute to return\n\t * @param namespace\n\t *        indicate what <code>Namespace</code> URI to consider\n\t * @return the <code>Attribute</code>, or null if one doesn't exist."
        },
        "indexOf": {
          "Javadoc": "* Return index of the <code>Attribute</code> with the given <i>name</i> and\n\t * the same Namespace URI as <i>namespace</i>.\n\t * \n\t * @param name\n\t *        name of <code>Attribute</code> to retrieve\n\t * @param namespace\n\t *        indicate what <code>Namespace</code> URI to consider\n\t * @return the index of the attribute that matches the conditions, or\n\t *         <code>-1</code> if there is none."
        },
        "remove": {
          "Javadoc": "* Remove the <code>Attribute</code> with the specified name and the same\n\t * URI as <i>namespace</i>.\n\t * \n\t * @param name\n\t *        name of <code>Attribute</code> to remove\n\t * @param namespace\n\t *        indicate what <code>Namespace</code> URI to consider\n\t * @return the <code>true</code> if attribute was removed,\n\t *         <code>false</code> otherwise"
        },
        "set": {
          "Javadoc": "* Set the <code>Attribute</code> at <i>index</i> to be <i>attribute</i>.\n\t * \n\t * @param index\n\t *        The location to set the value to.\n\t * @param attribute\n\t *        The <code>Attribute</code> to set.\n\t * @return The replaced <code>Attribute</code>.\n\t * @throws IllegalAddException\n\t *         if validation rules prevent the set"
        },
        "indexOfDuplicate": {
          "Javadoc": "* Return index of attribute with same name and Namespace, or -1 if one\n\t * doesn't exist"
        },
        "iterator": {
          "Javadoc": "* Returns an <code>Iterator</code> over the <code>Attributes</code> in this\n\t * list in the proper sequence.\n\t * \n\t * @return an iterator."
        },
        "size": {
          "Javadoc": "* Return the number of <code>Attributes</code> in this list\n\t * \n\t * @return The number of <code>Attributes</code> in this list."
        },
        "toString": {
          "Javadoc": "* Return this list as a <code>String</code>"
        },
        "binarySearch": {
          "Javadoc": "* Unlike the Arrays.binarySearch, this method never expects an\n\t * \"already exists\" condition, we only ever add, thus there will never\n\t * be a negative insertion-point.\n\t * @param indexes The pointers to search within\n\t * @param len The number of pointers to search within\n\t * @param val The pointer we are checking for.\n\t * @param comp The Comparator to compare with\n\t * @return the insertion point."
        },
        "sort": {
          "Javadoc": "* Sort the attributes using the supplied comparator. The attributes are\n\t * never added using regular mechanisms, so there are never problems with\n\t * detached or already-attached Attributes. The sort happens 'in place'.\n\t * <p>\n\t * If the comparator identifies two (or more) Attributes to be equal, then\n\t * the relative order of those attributes will not be changed.\n\t * \n\t * @param comp The Comparator to use for sorting."
        }
      }
    },
    "org.jdom2.ALIterator": {
      "Javadoc": "\n\t * A fast iterator that can beat AbstractList because we can access the data\n\t * directly. This is important because so much code now uses the for-each\n\t * type loop <code>for (Attribute a : element.getAttributes()) {...}</code>,\n\t * and that uses iterator().\n\t * \n\t * @author Rolf Lear\n\t "
    },
    "org.jdom2.CDATA": {
      "Javadoc": "\n * An XML CDATA section. Represents character-based content within an XML\n * document that should be output within special CDATA tags. Semantically it's\n * identical to a simple {@link Text} object, but output behavior is different.\n * CDATA makes no guarantees about the underlying textual representation of\n * character data, but does expose that data as a Java String.\n *\n * @author  Dan Schaffer\n * @author  Brett McLaughlin\n * @author  Jason Hunter\n * @author  Bradley S. Huffman\n * @author  Victor Toni\n * @author  Rolf Lear\n ",
      "methods": {
        "setText": {
          "Javadoc": "* This will set the value of this <code>CDATA</code> node.\n\t *\n\t * @param str value for node's content.\n\t * @return the object on which the method was invoked\n\t * @throws IllegalDataException if <code>str</code> contains an \n\t *         illegal character such as a vertical tab (as determined\n\t *          by {@link org.jdom2.Verifier#checkCharacterData})\n\t *         or the CDATA end delimiter <code>]]&gt;</code>."
        },
        "append": {
          "Javadoc": "* This will append the content of another <code>Text</code> node\n\t * to this node.\n\t *\n\t * @param text Text node to append."
        },
        "toString": {
          "Javadoc": "* This returns a <code>String</code> representation of the\n\t * <code>CDATA</code> node, suitable for debugging. If the XML\n\t * representation of the <code>CDATA</code> node is desired,\n\t * either <code>{@link #getText}</code> or\n\t * {@link org.jdom2.output.XMLOutputter#output(CDATA, java.io.Writer)}</code>\n\t * should be used.\n\t *\n\t * @return <code>String</code> - information about this node."
        }
      }
    },
    "org.jdom2.CloneBase": {
      "Javadoc": "\n * This simple class just tidies up any cloneable classes. This method deals\n * with any CloneNotSupported exceptions. THis class is package private only.\n * \n * @author Rolf Lear\n ",
      "methods": {
        "clone": {
          "Javadoc": "* Return a deep clone of this instance. Even if this instance has a parent,\n\t * the returned clone will not.\n\t * <p>\n\t * All JDOM core classes are Cloneable, and never throw\n\t * CloneNotSupportedException. Additionally all Cloneable JDOM classes\n\t * return the correct type of instance from this method and there is no\n\t * need to cast the result (co-variant return vaue).\n\t * <p>\n\t * Subclasses of this should still call super.clone() in their clone method."
        }
      }
    },
    "org.jdom2.Comment": {
      "Javadoc": "\n * An XML comment. Methods allow the user to get and set the text of the\n * comment.\n *\n * @author  Brett McLaughlin\n * @author  Jason Hunter\n ",
      "methods": {
        "getValue": {
          "Javadoc": "* Returns the XPath 1.0 string value of this element, which is the\n\t * text of this comment.\n\t *\n\t * @return the text of this comment"
        },
        "getText": {
          "Javadoc": "* This returns the textual data within the <code>Comment</code>.\n\t *\n\t * @return <code>String</code> - text of comment."
        },
        "setText": {
          "Javadoc": "* This will set the value of the <code>Comment</code>.\n\t *\n\t * @param text <code>String</code> text for comment.\n\t * @return <code>Comment</code> - this Comment modified.\n\t * @throws IllegalDataException if the given text is illegal for a\n\t *         Comment."
        },
        "toString": {
          "Javadoc": "* This returns a <code>String</code> representation of the\n\t * <code>Comment</code>, suitable for debugging. If the XML\n\t * representation of the <code>Comment</code> is desired,\n\t * {@link org.jdom2.output.XMLOutputter#outputString(Comment)}\n\t * should be used.\n\t *\n\t * @return <code>String</code> - information about the\n\t *         <code>Comment</code>"
        }
      }
    },
    "org.jdom2.Content": {
      "Javadoc": "\n * Superclass for JDOM objects which can be legal child content\n * of {@link org.jdom2.Parent} nodes.\n *\n * @see org.jdom2.Comment\n * @see org.jdom2.DocType\n * @see org.jdom2.Element\n * @see org.jdom2.EntityRef\n * @see org.jdom2.Parent\n * @see org.jdom2.ProcessingInstruction\n * @see org.jdom2.Text\n * \n * @author Bradley S. Huffman\n * @author Jason Hunter\n * @author Rolf Lear\n ",
      "methods": {
        "getCType": {
          "Javadoc": "* All content has an enumerated type expressing the type of content.\n\t * This makes it possible to use switch-type statements on the content.\n\t * @return A CType enumerated value representing this content."
        },
        "detach": {
          "Javadoc": "* Detaches this child from its parent or does nothing if the child\n\t * has no parent.\n\t * <p>\n\t * This method can be overridden by particular Content subclasses to return\n\t * a specific type of Content (co-variant return type). All overriding\n\t * subclasses <b>must</b> call <code>super.detach()</code>;\n\t *\n\t * @return this child detached"
        },
        "getParent": {
          "Javadoc": "* Return this child's parent, or null if this child is currently\n\t * not attached. The parent can be either an {@link Element}\n\t * or a {@link Document}.\n\t * <p>\n\t * This method can be overridden by particular Content subclasses to return\n\t * a specific type of Parent (co-variant return type). All overriding\n\t * subclasses <b>must</b> call <code>super.getParent()</code>;\n\t *\n\t * @return this child's parent or null if none"
        },
        "getParentElement": {
          "Javadoc": "* A convenience method that returns any parent element for this element,\n\t * or null if the element is unattached or is a root element.  This was the\n\t * original behavior of getParent() in JDOM Beta 9 which began returning\n\t * Parent in Beta 10.  This method provides a convenient upgrade path for\n\t * JDOM Beta 10 and 1.0 users.\n\t *\n\t * @return the containing Element or null if unattached or a root element"
        },
        "setParent": {
          "Javadoc": "* Sets the parent of this Content. The caller is responsible for removing\n\t * any pre-existing parentage.\n\t * <p>\n\t * This method can be overridden by particular Content subclasses to return\n\t * a specific type of Content (co-variant return type). All overriding\n\t * subclasses <b>must</b> call <code>super.setParent(Parent)</code>;\n\t *\n\t * @param  parent              new parent element\n\t * @return                     the target element"
        },
        "getDocument": {
          "Javadoc": "* Return this child's owning document or null if the branch containing\n\t * this child is currently not attached to a document.\n\t *\n\t * @return this child's owning document or null if none"
        },
        "getValue": {
          "Javadoc": "* Returns the XPath 1.0 string value of this child.\n\t *\n\t * @return xpath string value of this child."
        },
        "equals": {
          "Javadoc": "* This tests for equality of this Content object to the supplied object.\n\t * Content items are considered equal only if they are referentially equal\n\t * (i&#46;e&#46; the same object).  User code may choose to compare objects\n\t * based on their properties instead.\n\t *\n\t * @param ob <code>Object</code> to compare to.\n\t * @return <code>boolean</code> - whether the <code>Content</code> is\n\t *         equal to the supplied <code>Object</code>."
        },
        "hashCode": {
          "Javadoc": "* This returns the hash code for this <code>Content</code> item.\n\t *\n\t * @return <code>int</code> - hash code."
        }
      }
    },
    "org.jdom2.ContentList": {
      "Javadoc": "\n * A non-public list implementation holding only legal JDOM content, including\n * content for Document or Element nodes. Users see this class as a simple List\n * implementation.\n *\n * @see DocType\n * @see CDATA\n * @see Comment\n * @see Element\n * @see EntityRef\n * @see ProcessingInstruction\n * @see Text\n * @author Alex Rosen\n * @author Philippe Riand\n * @author Bradley S. Huffman\n * @author Rolf Lear\n ",
      "methods": {
        "uncheckedAddContent": {
          "Javadoc": "* Package internal method to support building from sources that are 100%\n\t * trusted.\n\t * \n\t * @param c\n\t *        content to add without any checks"
        },
        "setModCount": {
          "Javadoc": "* In the FilterList and FilterList iterators it becomes confusing as to\n\t * which modCount is being used. This formalizes the process, and using\n\t * (set/get/inc)ModCount() is the only thing you should see in the remainder\n\t * of this code.\n\t * \n\t * @param sizemod\n\t *        the value to set for the size-mod count.\n\t * @param datamod\n\t *        the value to set for the data-mod count."
        },
        "getModCount": {
          "Javadoc": "* In the FilterList and FilterList iterators it becomes confusing as to\n\t * which modCount is being used. This formalizes the process, and using\n\t * (set/get/inc)ModCount() is the only thing you should see in the remainder\n\t * of this code.\n\t * \n\t * @return mod the value."
        },
        "incModCount": {
          "Javadoc": "* In the FilterList and FilterList iterators it becomes confusing as to\n\t * which modCount is being used. This formalizes the process, and using\n\t * (set/get/inc)ModCount() is the only thing you should see in the remainder\n\t * of this code."
        },
        "getDataModCount": {
          "Javadoc": "* Get the modcount of data changes.\n\t * @return the current data mode count."
        },
        "add": {
          "Javadoc": "* Check and add the <code>Content</code> to this list at the given index.\n\t * Inserts the specified object at the specified position in this list.\n\t * Shifts the object currently at that position (if any) and any subsequent\n\t * objects to the right (adds one to their indices).\n\t * \n\t * @param index\n\t *        index where to add <code>Element</code>\n\t * @param child\n\t *        <code>Content</code> to add"
        },
        "addAll": {
          "Javadoc": "* Inserts the specified collection at the specified position in this list.\n\t * Shifts the object currently at that position (if any) and any subsequent\n\t * objects to the right (adds one to their indices).\n\t * \n\t * @param index\n\t *        The offset to start adding the data in the collection\n\t * @param collection\n\t *        The collection to insert into the list.\n\t * @return <code>true</code> if the list was modified as a result of the\n\t *         add. throws IndexOutOfBoundsException if index < 0 || index >\n\t *         size()"
        },
        "clear": {
          "Javadoc": "* Clear the current list."
        },
        "clearAndSet": {
          "Javadoc": "* Clear the current list and set it to the contents of the\n\t * <code>Collection</code>. object.\n\t * \n\t * @param collection\n\t *        The collection to use."
        },
        "ensureCapacity": {
          "Javadoc": "* Increases the capacity of this <code>ContentList</code> instance, if\n\t * necessary, to ensure that it can hold at least the number of items\n\t * specified by the minimum capacity argument.\n\t * \n\t * @param minCapacity\n\t *        the desired minimum capacity."
        },
        "get": {
          "Javadoc": "* Return the object at the specified offset.\n\t * \n\t * @param index\n\t *        The offset of the object.\n\t * @return The Object which was returned."
        },
        "getView": {
          "Javadoc": "* Return a view of this list based on the given filter.\n\t * \n\t * @param <E>\n\t *        The Generic type of the content as set by the Filter.\n\t * @param filter\n\t *        <code>Filter</code> for this view.\n\t * @return a list representing the rules of the <code>Filter</code>."
        },
        "indexOfFirstElement": {
          "Javadoc": "* Return the index of the first Element in the list. If the parent is a\n\t * <code>Document</code> then the element is the root element. If the list\n\t * contains no Elements, it returns -1.\n\t * \n\t * @return index of first element, or -1 if one doesn't exist"
        },
        "indexOfDocType": {
          "Javadoc": "* Return the index of the DocType element in the list. If the list contains\n\t * no DocType, it returns -1.\n\t * \n\t * @return index of the DocType, or -1 if it doesn't exist"
        },
        "remove": {
          "Javadoc": "* Remove the object at the specified offset.\n\t * \n\t * @param index\n\t *        The offset of the object.\n\t * @return The Object which was removed."
        },
        "removeParent": {
          "Javadoc": "Remove the parent of a Object"
        },
        "set": {
          "Javadoc": "* Set the object at the specified location to the supplied object.\n\t * \n\t * @param index\n\t *        The location to set the value to.\n\t * @param child\n\t *        The location to set the value to.\n\t * @return The object which was replaced. throws IndexOutOfBoundsException\n\t *         if index < 0 || index >= size()"
        },
        "size": {
          "Javadoc": "* Return the number of items in this list\n\t * \n\t * @return The number of items in this list."
        },
        "toString": {
          "Javadoc": "* Return this list as a <code>String</code>\n\t * \n\t * @return The String representation of this list."
        },
        "binarySearch": {
          "Javadoc": "* Unlike the Arrays.binarySearch, this method never expects an\n\t * \"already exists\" condition, we only ever add, thus there will never\n\t * be a negative insertion-point.\n\t * @param indexes THe pointers to search within\n\t * @param len The number of pointers to search within\n\t * @param val The pointer we are checking for.\n\t * @param comp The Comparator to compare with\n\t * @return the insertion point."
        }
      }
    },
    "org.jdom2.CLIterator": {
      "Javadoc": "\n\t * A fast implementation of Iterator.\n\t * <p>\n\t * It is fast because it is tailored to the ContentList, and not the\n\t * flexible implementation used by AbstractList. It needs to be fast because\n\t * iterator() is used extensively in the for-each type loop.\n\t * \n\t * @author Rolf Lear\n\t "
    },
    "org.jdom2.CLListIterator": {
      "Javadoc": "\n\t * A fast implementation of Iterator.\n\t * <p>\n\t * It is fast because it is tailored to the ContentList, and not the\n\t * flexible implementation used by AbstractList. It needs to be fast because\n\t * iterator() is used extensively in the for-each type loop.\n\t * \n\t * @author Rolf Lear\n\t ",
      "methods": {
        "hasNext": {
          "Javadoc": "* Returns <code>true</code> if this list iterator has a next element."
        },
        "hasPrevious": {
          "Javadoc": "* Returns <code>true</code> if this list iterator has more elements\n\t\t * when traversing the list in the reverse direction."
        },
        "nextIndex": {
          "Javadoc": "* Returns the index of the element that would be returned by a\n\t\t * subsequent call to <code>next</code>."
        },
        "previousIndex": {
          "Javadoc": "* Returns the index of the element that would be returned by a\n\t\t * subsequent call to <code>previous</code>. (Returns -1 if the list\n\t\t * iterator is at the beginning of the list.)"
        },
        "next": {
          "Javadoc": "* Returns the next element in the list."
        },
        "previous": {
          "Javadoc": "* Returns the previous element in the list."
        },
        "add": {
          "Javadoc": "* Inserts the specified element into the list ."
        },
        "remove": {
          "Javadoc": "* Removes from the list the last element that was returned by the last\n\t\t * call to <code>next</code> or <code>previous</code>."
        },
        "set": {
          "Javadoc": "* Replaces the last element returned by <code>next</code> or\n\t\t * <code>previous</code> with the specified element."
        }
      }
    },
    "org.jdom2.FilterList": {
      "Javadoc": "",
      "methods": {
        "isEmpty": {
          "Javadoc": "* Returns true if there is no content in this FilterList.\n\t\t * @return true if there is no content in this FilterList"
        },
        "resync": {
          "Javadoc": "* Synchronise our view to the backing list. Only synchronise the first\n\t\t * <code>index</code> view elements. For want of a better word, we'll\n\t\t * call this a 'Lazy' implementation.\n\t\t * \n\t\t * @param index\n\t\t *        how much we want to sync. Set to -1 to synchronise everything.\n\t\t * @return the index in the backing array of the <i>index'th</i> match.\n\t\t *         or the backing data size if there is no match for the index."
        },
        "add": {
          "Javadoc": "* Inserts the specified object at the specified position in this list.\n\t\t * Shifts the object currently at that position (if any) and any\n\t\t * subsequent objects to the right (adds one to their indices).\n\t\t * \n\t\t * @param index\n\t\t *        The location to set the value to.\n\t\t * @param obj\n\t\t *        The object to insert into the list. throws\n\t\t *        IndexOutOfBoundsException if index < 0 || index > size()"
        },
        "get": {
          "Javadoc": "* Return the object at the specified offset.\n\t\t * \n\t\t * @param index\n\t\t *        The offset of the object.\n\t\t * @return The Object which was returned."
        },
        "remove": {
          "Javadoc": "* Remove the object at the specified offset.\n\t\t * \n\t\t * @param index\n\t\t *        The offset of the object.\n\t\t * @return The Object which was removed."
        },
        "set": {
          "Javadoc": "* Set the object at the specified location to the supplied object.\n\t\t * \n\t\t * @param index\n\t\t *        The location to set the value to.\n\t\t * @param obj\n\t\t *        The location to set the value to.\n\t\t * @return The object which was replaced. throws\n\t\t *         IndexOutOfBoundsException if index < 0 || index >= size()"
        },
        "size": {
          "Javadoc": "* Return the number of items in this list\n\t\t * \n\t\t * @return The number of items in this list."
        },
        "fbinarySearch": {
          "Javadoc": "* Unlike the Arrays.binarySearch, this method never expects an\n\t\t * \"already exists\" condition, we only ever add, thus there will never\n\t\t * be a negative insertion-point.\n\t\t * @param indexes THe pointers to search within\n\t\t * @param len The number of pointers to search within\n\t\t * @param val The pointer we are checking for.\n\t\t * @param comp The Comparator to compare with\n\t\t * @return the insertion point."
        }
      }
    },
    "org.jdom2.FilterListIterator": {
      "Javadoc": "",
      "methods": {
        "hasNext": {
          "Javadoc": "* Returns <code>true</code> if this list iterator has a next element."
        },
        "hasPrevious": {
          "Javadoc": "* Returns <code>true</code> if this list iterator has more elements\n\t\t * when traversing the list in the reverse direction."
        },
        "nextIndex": {
          "Javadoc": "* Returns the index of the element that would be returned by a\n\t\t * subsequent call to <code>next</code>."
        },
        "previousIndex": {
          "Javadoc": "* Returns the index of the element that would be returned by a\n\t\t * subsequent call to <code>previous</code>. (Returns -1 if the list\n\t\t * iterator is at the beginning of the list.)"
        },
        "next": {
          "Javadoc": "* Returns the next element in the list."
        },
        "previous": {
          "Javadoc": "* Returns the previous element in the list."
        },
        "add": {
          "Javadoc": "* Inserts the specified element into the list ."
        },
        "remove": {
          "Javadoc": "* Removes from the list the last element that was returned by the last\n\t\t * call to <code>next</code> or <code>previous</code>."
        },
        "set": {
          "Javadoc": "* Replaces the last element returned by <code>next</code> or\n\t\t * <code>previous</code> with the specified element."
        }
      }
    },
    "org.jdom2.DataConversionException": {
      "Javadoc": "\n * Thrown when a data conversion from a string to value type fails, such as\n * can happen with the {@link Attribute} convenience getter functions.\n *\n * @author  Brett McLaughlin\n * @author  Jason Hunter\n "
    },
    "org.jdom2.DefaultJDOMFactory": {
      "Javadoc": "\n * Creates the standard top-level JDOM classes (Element, Document, Comment,\n * etc). A subclass of this factory might construct custom classes.\n * \n * @author Ken Rune Holland\n * @author Phil Nelson\n * @author Bradley S. Huffman\n * @author Rolf Lear\n "
    },
    "org.jdom2.DescendantIterator": {
      "Javadoc": "\n * Traverse all a parent's descendants (all children at any level below\n * the parent - excludes the parent itself).\n *\n * @author Bradley S. Huffman\n * @author Jason Hunter\n * @author Rolf Lear\n ",
      "methods": {
        "hasNext": {
          "Javadoc": "* Returns <b>true</b> if the iteration has more {@link Content} descendants.\n\t *\n\t * @return true is the iterator has more descendants"
        },
        "next": {
          "Javadoc": "* Returns the next {@link Content} descendant.\n\t *\n\t * @return the next descendant"
        },
        "remove": {
          "Javadoc": "* Detaches the last {@link org.jdom2.Content} returned by the last call to\n\t * next from it's parent.  <b>Note</b>: this <b>does not</b> affect\n\t * iteration and all children, siblings, and any node following the\n\t * removed node (in document order) will be visited."
        }
      }
    },
    "org.jdom2.DocType": {
      "Javadoc": "\n * An XML DOCTYPE declaration.  Method allow the user to get and set the\n * root element name, public id, system id and internal subset.\n *\n * @author Brett McLaughlin\n * @author Jason Hunter\n ",
      "methods": {
        "getElementName": {
          "Javadoc": "* This will retrieve the element name being constrained.\n\t *\n\t * @return <code>String</code> - element name for DOCTYPE"
        },
        "setElementName": {
          "Javadoc": "* This will set the root element name declared by this\n\t * DOCTYPE declaration.\n\t *\n\t * @return this <code>DocType</code> instance\n\t * @param elementName <code>String</code> name of\n\t *        root element being constrained.\n\t * @throws IllegalNameException if the given root element name is not a\n\t *         legal XML element name."
        },
        "getPublicID": {
          "Javadoc": "* This will retrieve the public ID of an externally\n\t * referenced DTD, or an empty <code>String</code> if\n\t * none is referenced.\n\t *\n\t * @return <code>String</code> - public ID of referenced DTD."
        },
        "setPublicID": {
          "Javadoc": "* This will set the public ID of an externally\n\t * referenced DTD.\n\t *\n\t * @param publicID id to set\n\t * @return DocType <code>DocType</code> this DocType object\n\t * @throws IllegalDataException if the given public ID is not a legal\n\t *         public ID."
        },
        "getSystemID": {
          "Javadoc": "* This will retrieve the system ID of an externally\n\t * referenced DTD, or an empty <code>String</code> if\n\t * none is referenced.\n\t *\n\t * @return <code>String</code> - system ID of referenced DTD."
        },
        "setSystemID": {
          "Javadoc": "* This will set the system ID of an externally\n\t * referenced DTD.\n\t *\n\t * @param systemID id to set\n\t * @return systemID <code>String</code> system ID of\n\t *                  referenced DTD.\n\t * @throws IllegalDataException if the given system ID is not a legal\n\t *         system literal."
        },
        "getValue": {
          "Javadoc": "* Returns the empty string since doctypes don't have an XPath\n\t * 1.0 string value.\n\t * @return the empty string"
        },
        "setInternalSubset": {
          "Javadoc": "* This sets the data for the internal subset.\n\t *\n\t * @param newData data for the internal subset, as a\n\t *        <code>String</code>."
        },
        "getInternalSubset": {
          "Javadoc": "* This returns the data for the internal subset.\n\t *\n\t * @return <code>String</code> - the internal subset"
        },
        "toString": {
          "Javadoc": "* This returns a <code>String</code> representation of the\n\t * <code>DocType</code>, suitable for debugging.\n\t *\n\t * @return <code>String</code> - information about the\n\t *         <code>DocType</code>"
        }
      }
    },
    "org.jdom2.Document": {
      "Javadoc": "\n * An XML document. Methods allow access to the root element as well as the\n * {@link DocType} and other document-level information.\n *\n * @author  Brett McLaughlin\n * @author  Jason Hunter\n * @author  Jools Enticknap\n * @author  Bradley S. Huffman\n * @author  Rolf Lear\n ",
      "methods": {
        "hasRootElement": {
          "Javadoc": "* This will return <code>true</code> if this document has a\n\t * root element, <code>false</code> otherwise.\n\t *\n\t * @return <code>true</code> if this document has a root element,\n\t *         <code>false</code> otherwise."
        },
        "getRootElement": {
          "Javadoc": "* This will return the root <code>Element</code>\n\t * for this <code>Document</code>\n\t *\n\t * @return <code>Element</code> - the document's root element\n\t * @throws IllegalStateException if the root element hasn't been set"
        },
        "setRootElement": {
          "Javadoc": "* This sets the root <code>{@link Element}</code> for the\n\t * <code>Document</code>. If the document already has a root\n\t * element, it is replaced.\n\t *\n\t * @param rootElement <code>Element</code> to be new root.\n\t * @return <code>Document</code> - modified Document.\n\t * @throws IllegalAddException if the given rootElement already has\n\t *         a parent."
        },
        "detachRootElement": {
          "Javadoc": "* Detach the root <code>{@link Element}</code> from this document.\n\t *\n\t * @return removed root <code>Element</code>"
        },
        "getDocType": {
          "Javadoc": "* This will return the <code>{@link DocType}</code>\n\t * declaration for this <code>Document</code>, or\n\t * <code>null</code> if none exists.\n\t *\n\t * @return <code>DocType</code> - the DOCTYPE declaration."
        },
        "setDocType": {
          "Javadoc": "* This will set the <code>{@link DocType}</code>\n\t * declaration for this <code>Document</code>. Note\n\t * that a DocType can only be attached to one Document.\n\t * Attempting to set the DocType to a DocType object\n\t * that already belongs to a Document will result in an\n\t * IllegalAddException being thrown.\n\t *\n\t * @param docType <code>DocType</code> declaration.\n\t * @return object on which the method was invoked\n\t * @throws IllegalAddException if the given docType is\n\t *   already attached to a Document."
        },
        "addContent": {
          "Javadoc": "* Inserts the content in a collection into the content list\n\t * at the given index.  In event of an exception the original content\n\t * will be unchanged and the objects in the supplied collection will be\n\t * unaltered.\n\t *\n\t * @param index location for adding the collection\n\t * @param c  collection to insert\n\t * @return            the parent on which the method was called\n\t * @throws IndexOutOfBoundsException if index is negative or beyond\n\t *         the current number of children\n\t * @throws IllegalAddException if any item in the collection\n\t *         already has a parent or is of an illegal type."
        },
        "getContent": {
          "Javadoc": "* Return a filtered view of this <code>Document</code>'s content.\n\t *\n\t * <p>\n\t * Sequential traversal through the List is best done with a Iterator\n\t * since the underlying implement of List.size() may require walking the\n\t * entire list.\n\t * </p>\n\t *\n\t * @param filter <code>Filter</code> to apply\n\t * @return <code>List</code> - filtered Document content\n\t * @throws IllegalStateException if the root element hasn't been set"
        },
        "removeContent": {
          "Javadoc": "* Remove all child content from this parent matching the supplied filter.\n\t *\n\t * @param filter filter to select which content to remove\n\t * @return list of the old children detached from this parent"
        },
        "setContent": {
          "Javadoc": "* Set this document's content to be the supplied child.\n\t * <p>\n\t * If the supplied child is legal content for a Document and before\n\t * it is added, all content in the current content list will\n\t * be cleared and all current children will have their parentage set to\n\t * null.\n\t * <p>\n\t * This has the effect that any active list (previously obtained with\n\t * a call to one of the {@link #getContent} methods will also change\n\t * to reflect the new content.  In addition, all content in the supplied\n\t * collection will have their parentage set to this Document.  If the user\n\t * wants to continue working with a <b>\"live\"</b> list of this Document's\n\t * child, then a call to setContent should be followed by a call to one\n\t * of the {@link #getContent} methods to obtain a <b>\"live\"</b>\n\t * version of the children.\n\t * <p>\n\t * Passing a null child clears the existing content.\n\t * <p>\n\t * In event of an exception the original content will be unchanged and\n\t * the supplied child will be unaltered.\n\t *\n\t * @param child new content to replace existing content\n\t * @return           the parent on which the method was called\n\t * @throws IllegalAddException if the supplied child is already attached\n\t *                             or not legal content for this parent"
        },
        "setBaseURI": {
          "Javadoc": "*\n\t * <p>\n\t * Sets the effective URI from which this document was loaded,\n\t * and against which relative URLs in this document will be resolved.\n\t * </p>\n\t *\n\t * @param uri the base URI of this document"
        },
        "getBaseURI": {
          "Javadoc": "* <p>\n\t *   Returns the URI from which this document was loaded,\n\t *   or null if this is not known.\n\t * </p>\n\t *\n\t * @return the base URI of this document"
        },
        "toString": {
          "Javadoc": "* This returns a <code>String</code> representation of the\n\t * <code>Document</code>, suitable for debugging. If the XML\n\t * representation of the <code>Document</code> is desired,\n\t * {@link org.jdom2.output.XMLOutputter#outputString(Document)}\n\t * should be used.\n\t *\n\t * @return <code>String</code> - information about the\n\t *         <code>Document</code>"
        },
        "equals": {
          "Javadoc": "* This tests for equality of this <code>Document</code> to the supplied\n\t * <code>Object</code>.\n\t *\n\t * @param ob <code>Object</code> to compare to\n\t * @return <code>boolean</code> whether the <code>Document</code> is\n\t *         equal to the supplied <code>Object</code>"
        },
        "hashCode": {
          "Javadoc": "* This returns the hash code for this <code>Document</code>.\n\t *\n\t * @return <code>int</code> hash code"
        },
        "clone": {
          "Javadoc": "* This will return a deep clone of this <code>Document</code>.\n\t *\n\t * @return <code>Object</code> clone of this <code>Document</code>"
        },
        "getDescendants": {
          "Javadoc": "* Returns an iterator that walks over all descendants in document order\n\t * applying the Filter to return only elements that match the filter rule.\n\t * With filters you can match only Elements, only Comments, Elements or\n\t * Comments, only Elements with a given name and/or prefix, and so on.\n\t *\n\t * @param filter filter to select which descendants to see\n\t * @return an iterator to walk descendants within a filter"
        },
        "getParent": {
          "Javadoc": "* Always returns null, Document cannot have a parent.\n\t * @return null"
        },
        "getDocument": {
          "Javadoc": "* Always returns this Document Instance\n\t * @return 'this' because this Document is it's own Document"
        },
        "setProperty": {
          "Javadoc": "* Assigns an arbitrary object to be associated with this document under\n\t * the given \"id\" string.  Null values are permitted.  'id' Strings beginning\n\t * with \"http://www.jdom.org/ are reserved for JDOM use. Properties set with\n\t * this method will not be serialized with the rest of this Document, should\n\t * serialization need to be done.\n\t *\n\t * @param id     the id of the stored <code>Object</code>\n\t * @param value  the <code>Object</code> to store"
        },
        "getProperty": {
          "Javadoc": "* Returns the object associated with this document under the given \"id\"\n\t * string, or null if there is no binding or if the binding explicitly\n\t * stored a null value.\n\t *\n\t * @param id   the id of the stored <code>Object</code> to return\n\t * @return     the <code>Object</code> associated with the given id"
        },
        "getNamespacesInScope": {
          "Javadoc": "* Get the Namespaces that are in-scope on this Document.\n\t * <p>\n\t * Document always has exactly two Namespaces in-scope:\n\t * {@link Namespace#NO_NAMESPACE} and {@link Namespace#XML_NAMESPACE}.\n\t * <p>\n\t * These namespaces are always introduced by the Document, and thus they are\n\t * both returned by {@link #getNamespacesIntroduced()}, and additionally\n\t * {@link #getNamespacesInherited()} will always be empty.\n\t * <p>\n\t * <strong>Description copied from</strong>\n\t * {@link NamespaceAware#getNamespacesInScope()}:\n\t * <p>\n\t * {@inheritDoc}"
        },
        "writeObject": {
          "Javadoc": "* Serialize out the Element.\n\t * \n\t * @serialData\n\t * <strong>Document Properties are not serialized!</strong>\n\t * <p>\n\t * The Stream protocol is:\n\t * <ol>\n\t *   <li>The BaseURI using default Serialization.\n\t *   <li>The count of child Content\n\t *   <li>The actual Child Content.\n\t * </ol>\n\t * \n\t * @param out where to write the Element to.\n\t * @throws IOException if there is a writing problem."
        },
        "readObject": {
          "Javadoc": "* Read an Element off the ObjectInputStream.\n\t * \n\t * @see #writeObject(ObjectOutputStream)\n\t * @param in where to read the Element from.\n\t * @throws IOException if there is a reading problem.\n\t * @throws ClassNotFoundException when a class cannot be found"
        }
      }
    },
    "org.jdom2.Element": {
      "Javadoc": "\n * An XML element. Methods allow the user to get and manipulate its child\n * elements and content, directly access the element's textual content,\n * manipulate its attributes, and manage namespaces.\n * <p>\n * See {@link NamespaceAware} and {@link #getNamespacesInScope()} for more\n * details on what the Namespace scope is and how it is managed in JDOM and\n * specifically by this Element class.\n * \n * @see NamespaceAware\n * @see Content\n * \n * @author  Brett McLaughlin\n * @author  Jason Hunter\n * @author  Lucas Gonze\n * @author  Kevin Regan\n * @author  Dan Schaffer\n * @author  Yusuf Goolamabbas\n * @author  Kent C. Johnson\n * @author  Jools Enticknap\n * @author  Alex Rosen\n * @author  Bradley S. Huffman\n * @author  Victor Toni\n * @author  Rolf Lear\n * \n ",
      "methods": {
        "getName": {
          "Javadoc": "* Returns the (local) name of the element (without any namespace prefix).\n\t *\n\t * @return                     local element name"
        },
        "setName": {
          "Javadoc": "* Sets the (local) name of the element.\n\t *\n\t * @param  name                 the new (local) name of the element\n\t * @return                      the target element\n\t * @throws IllegalNameException if the given name is illegal as an Element\n\t *                              name"
        },
        "getNamespace": {
          "Javadoc": "* Returns the {@link Namespace} corresponding to the given prefix in scope\n\t * for this element. This involves searching up the tree, so the results\n\t * depend on the current location of the element. Returns null if there is\n\t * no namespace in scope with the given prefix at this point in the\n\t * document.\n\t *\n\t * @param  prefix              namespace prefix to look up\n\t * @return                     the Namespace for this prefix at this\n\t *                             location, or null if none"
        },
        "setNamespace": {
          "Javadoc": "* Sets the element's {@link Namespace}. If the provided namespace is null,\n\t * the element will have no namespace.\n\t *\n\t * @param  namespace           the new namespace. A null implies Namespace.NO_NAMESPACE.\n\t * @return                     the target element\n\t * @throws IllegalAddException if there is a Namespace conflict"
        },
        "getNamespacePrefix": {
          "Javadoc": "* Returns the namespace prefix of the element or an empty string if none\n\t * exists.\n\t *\n\t * @return                     the namespace prefix"
        },
        "getNamespaceURI": {
          "Javadoc": "* Returns the namespace URI mapped to this element's prefix (or the\n\t * in-scope default namespace URI if no prefix). If no mapping is found, an\n\t * empty string is returned.\n\t *\n\t * @return                     the namespace URI for this element"
        },
        "getQualifiedName": {
          "Javadoc": "* Returns the full name of the element, in the form\n\t * [namespacePrefix]:[localName]. If the element does not have a namespace\n\t * prefix, then the local name is returned.\n\t *\n\t * @return                     qualified name of the element (including\n\t *                             namespace prefix)"
        },
        "addNamespaceDeclaration": {
          "Javadoc": "* Adds a namespace declarations to this element. This should <i>not</i> be\n\t * used to add the declaration for this element itself; that should be\n\t * assigned in the construction of the element. Instead, this is for adding\n\t * namespace declarations on the element not relating directly to itself.\n\t * It's used during output to for stylistic reasons move namespace\n\t * declarations higher in the tree than they would have to be.\n\t *\n\t * @param  additionalNamespace namespace to add\n\t * @return true if the namespace is added (false if it was previously added)\n\t * @throws IllegalAddException if the namespace prefix collides with another\n\t *                             namespace prefix on the element"
        },
        "removeNamespaceDeclaration": {
          "Javadoc": "* Removes an additional namespace declarations from this element. This\n\t * should <i>not</i> be used to remove the declaration for this element\n\t * itself; that should be handled in the construction of the element.\n\t * Instead, this is for removing namespace declarations on the element not\n\t * relating directly to itself. If the declaration is not present, this\n\t * method does nothing.\n\t *\n\t * @param additionalNamespace namespace to remove. A null Namespace does nothing."
        },
        "getAdditionalNamespaces": {
          "Javadoc": "* Returns a list of the additional namespace declarations on this element.\n\t * This includes only additional namespace, not the namespace of the element\n\t * itself, which can be obtained through {@link #getNamespace()}. If there\n\t * are no additional declarations, this returns an empty list. Note, the\n\t * returned list is unmodifiable.\n\t *\n\t * @return                     a List of the additional namespace\n\t *                             declarations"
        },
        "getValue": {
          "Javadoc": "* Returns the XPath 1.0 string value of this element, which is the\n\t * complete, ordered content of all text node descendants of this element\n\t * (i&#46;e&#46; the text that's left after all references are resolved\n\t * and all other markup is stripped out.)\n\t *\n\t * @return a concatentation of all text node descendants"
        },
        "isRootElement": {
          "Javadoc": "* Returns whether this element is a root element. This can be used in\n\t * tandem with {@link #getParent} to determine if an element has any\n\t * \"attachments\" to a parent element or document.\n\t * <p>\n\t * An element is a root element when it has a parent and that parent is a\n\t * Document. In particular, this means that detatched Elements are <b>not</b>\n\t * root elements.\n\t *\n\t * @return                     whether this is a root element"
        },
        "getText": {
          "Javadoc": "* Returns the textual content directly held under this element as a string.\n\t * This includes all text within this single element, including whitespace\n\t * and CDATA sections if they exist. It's essentially the concatenation of\n\t * all {@link Text} and {@link CDATA} nodes returned by {@link #getContent}.\n\t * The call does not recurse into child elements. If no textual value exists\n\t * for the element, an empty string is returned.\n\t *\n\t * @return                     text content for this element, or empty\n\t *                             string if none"
        },
        "getTextTrim": {
          "Javadoc": "* Returns the textual content of this element with all surrounding\n\t * whitespace removed. If no textual value exists for the element, or if\n\t * only whitespace exists, the empty string is returned.\n\t *\n\t * @return                     trimmed text content for this element, or\n\t *                             empty string if none"
        },
        "getTextNormalize": {
          "Javadoc": "* Returns the textual content of this element with all surrounding\n\t * whitespace removed and internal whitespace normalized to a single space.\n\t * If no textual value exists for the element, or if only whitespace exists,\n\t * the empty string is returned.\n\t *\n\t * @return                     normalized text content for this element, or\n\t *                             empty string if none"
        },
        "getChildText": {
          "Javadoc": "* Returns the textual content of the named child element, or null if\n\t * there's no such child.\n\t * \n\t * @param cname\n\t *        the name of the child\n\t * @param ns\n\t *        the namespace of the child. A null implies Namespace.NO_NAMESPACE.\n\t * @return text content for the named child, or null if no such child"
        },
        "getChildTextTrim": {
          "Javadoc": "* Returns the trimmed textual content of the named child element, or null\n\t * if there's no such child.\n\t * \n\t * @param cname\n\t *        the name of the child\n\t * @param ns\n\t *        the namespace of the child. A null implies Namespace.NO_NAMESPACE.\n\t * @return trimmed text content for the named child, or null if no such\n\t *         child"
        },
        "getChildTextNormalize": {
          "Javadoc": "* Returns the normalized textual content of the named child element, or\n\t * null if there's no such child.\n\t * \n\t * @param cname\n\t *        the name of the child\n\t * @param ns\n\t *        the namespace of the child. A null implies Namespace.NO_NAMESPACE.\n\t * @return normalized text content for the named child, or null if no such\n\t *         child"
        },
        "setText": {
          "Javadoc": "* Sets the content of the element to be the text given. All existing text\n\t * content and non-text context is removed. If this element should have both\n\t * textual content and nested elements, use <code>{@link #setContent}</code>\n\t * instead. Setting a null text value is equivalent to setting an empty\n\t * string value.\n\t *\n\t * @param  text                 new text content for the element\n\t * @return                      the target element\n\t * @throws IllegalDataException if the assigned text contains an illegal\n\t *                              character such as a vertical tab (as\n\t *                              determined by {@link\n\t *                              org.jdom2.Verifier#checkCharacterData})"
        },
        "coalesceText": {
          "Javadoc": "* Adjacent Text content is merged into the first Text in document order,\n\t * and the redundant Text items are removed (including any empty Text).\n\t * \n\t * @param recursively\n\t *        true if you want the text of child elements coalesced too. False\n\t *        if you only want to coalesce this Element's Text.\n\t * @return true if any content was changed by this operation."
        },
        "getContent": {
          "Javadoc": "* Return a filter view of this <code>Element</code>'s content.\n\t *\n\t * <p>\n\t * Sequential traversal through the List is best done with a Iterator\n\t * since the underlying implement of List.size() may require walking the\n\t * entire list.\n\t * </p>\n\t *\n\t * @param filter <code>Filter</code> to apply\n\t * @return <code>List</code> - filtered Element content"
        },
        "removeContent": {
          "Javadoc": "* Remove all child content from this parent matching the supplied filter.\n\t *\n\t * @param filter filter to select which content to remove\n\t * @return list of the old children detached from this parent"
        },
        "setContent": {
          "Javadoc": "* Set this element's content to be the supplied child.\n\t * <p>\n\t * If the supplied child is legal content for this parent and before\n\t * it is added, all content in the current content list will\n\t * be cleared and all current children will have their parentage set to\n\t * null.\n\t * <p>\n\t * This has the effect that any active list (previously obtained with\n\t * a call to one of the {@link #getContent} methods will also change\n\t * to reflect the new content.  In addition, all content in the supplied\n\t * collection will have their parentage set to this parent.  If the user\n\t * wants to continue working with a <b>\"live\"</b> list of this parent's\n\t * child, then a call to setContent should be followed by a call to one\n\t * of the {@link #getContent} methods to obtain a <b>\"live\"</b>\n\t * version of the children.\n\t * <p>\n\t * Passing a null child clears the existing content.\n\t * <p>\n\t * In event of an exception the original content will be unchanged and\n\t * the supplied child will be unaltered.\n\t *\n\t * @param child new content to replace existing content\n\t * @return           the parent on which the method was called\n\t * @throws IllegalAddException if the supplied child is already attached\n\t *                             or not legal content for an Element"
        },
        "addContent": {
          "Javadoc": "* Inserts the content in a collection into the content list\n\t * at the given index.  In event of an exception the original content\n\t * will be unchanged and the objects in the supplied collection will be\n\t * unaltered.\n\t *\n\t * @param index location for adding the collection\n\t * @param newContent  <code>Collection</code> of content to insert\n\t * @return            the parent on which the method was called\n\t * @throws IndexOutOfBoundsException if index is negative or beyond\n\t *         the current number of children\n\t * @throws IllegalAddException if any item in the collection\n\t *         already has a parent or is of an inappropriate type."
        },
        "isAncestor": {
          "Javadoc": "* Determines if this element is the ancestor of another element.\n\t *\n\t * @param element <code>Element</code> to check against\n\t * @return <code>true</code> if this element is the ancestor of the\n\t *         supplied element"
        },
        "hasAttributes": {
          "Javadoc": "* Indicate whether this Element has any attributes.\n\t * Where possible you should call this method before calling getAttributes()\n\t * because calling getAttributes() will create the necessary Attribute List\n\t * memory structures, even if there are no Attributes attached to the\n\t * Element. Calling hasAttributes() first can save memory.\n\t * @return true if this Element has attributes."
        },
        "hasAdditionalNamespaces": {
          "Javadoc": "* Indicate whether this Element has any additional Namespace declarations.\n\t * Where possible you should call this method before calling\n\t * {@link #getAdditionalNamespaces()} because calling getAttributes() will\n\t * create an unnecessary List even if there are no Additional Namespaces\n\t * attached to the Element. Calling this method first can save memory and\n\t * time.\n\t * @return true if this Element has additional Namespaces."
        },
        "getAttributeList": {
          "Javadoc": "* Lazy initialiser for the Attribute list.\n\t * @return this Element's Attribute List (creating it if necessary)."
        },
        "getAttributes": {
          "Javadoc": "* <p>\n\t * This returns the complete set of attributes for this element, as a\n\t * <code>List</code> of <code>Attribute</code> objects in no particular\n\t * order, or an empty list if there are none.\n\t * The returned list is \"live\" and changes to it affect the\n\t * element's actual attributes.\n\t * </p>\n\t *\n\t * @return attributes for the element"
        },
        "getAttribute": {
          "Javadoc": "* <p>\n\t * This returns the attribute for this element with the given name\n\t * and within the given Namespace, or null if no such attribute exists.\n\t * </p>\n\t *\n\t * @param attname name of the attribute to return\n\t * @param ns <code>Namespace</code> to search within. A null implies Namespace.NO_NAMESPACE.\n\t * @return attribute for the element"
        },
        "getAttributeValue": {
          "Javadoc": "* <p>\n\t * This returns the attribute value for the attribute with the given name\n\t * and within the given Namespace, or the passed-in default if there is no\n\t * such attribute.\n\t * </p>\n\t *\n\t * @param attname name of the attribute whose valud is to be returned\n\t * @param ns <code>Namespace</code> to search within. A null implies Namespace.NO_NAMESPACE.\n\t * @param def a default value to return if the attribute does not exist\n\t * @return the named attribute's value, or the default if no such attribute"
        },
        "setAttributes": {
          "Javadoc": "* <p>\n\t * This sets the attributes of the element.  The supplied Collection should\n\t * contain only objects of type <code>Attribute</code>.\n\t * </p>\n\t *\n\t * <p>\n\t * When all objects in the supplied List are legal and before the new\n\t * attributes are added, all old attributes will have their\n\t * parentage set to null (no parent) and the old attribute list will be\n\t * cleared. This has the effect that any active attribute list (previously\n\t * obtained with a call to {@link #getAttributes}) will also change to\n\t * reflect the new attributes.  In addition, all attributes in the supplied\n\t * List will have their parentage set to this element, but the List itself\n\t * will not be \"live\" and further removals and additions will have no\n\t * effect on this elements attributes. If the user wants to continue\n\t * working with a \"live\" attribute list, then a call to setAttributes\n\t * should be followed by a call to {@link #getAttributes} to obtain a\n\t * \"live\" version of the attributes.\n\t * </p>\n\t *\n\t * <p>\n\t * Passing a null or empty List clears the existing attributes.\n\t * </p>\n\t *\n\t * <p>\n\t * In cases where the List contains duplicate attributes, only the last\n\t * one will be retained.  This has the same effect as calling\n\t * {@link #setAttribute(Attribute)} sequentially.\n\t * </p>\n\t *\n\t * <p>\n\t * In event of an exception the original attributes will be unchanged and\n\t * the attributes in the supplied attributes will be unaltered.\n\t * </p>\n\t *\n\t * @param newAttributes <code>Collection</code> of attributes to set\n\t * @return this element modified\n\t * @throws IllegalAddException if the List contains objects\n\t *         that are not instances of <code>Attribute</code>,\n\t *         or if any of the <code>Attribute</code> objects have\n\t *         conflicting namespace prefixes."
        },
        "setAttribute": {
          "Javadoc": "* <p>\n\t * This sets an attribute value for this element.  Any existing attribute\n\t * with the same name and namespace URI is removed.\n\t * </p>\n\t *\n\t * @param attribute <code>Attribute</code> to set\n\t * @return this element modified\n\t * @throws IllegalAddException if the attribute being added already has a\n\t *   parent or if the attribute namespace prefix collides with another\n\t *   namespace prefix on the element."
        },
        "removeAttribute": {
          "Javadoc": "* <p>\n\t * This removes the supplied Attribute should it exist.\n\t * </p>\n\t *\n\t * @param attribute Reference to the attribute to be removed.\n\t * @return whether the attribute was removed"
        },
        "toString": {
          "Javadoc": "* <p>\n\t *  This returns a <code>String</code> representation of the\n\t *    <code>Element</code>, suitable for debugging. If the XML\n\t *    representation of the <code>Element</code> is desired,\n\t *    {@link org.jdom2.output.XMLOutputter#outputString(Element)}\n\t *    should be used.\n\t * </p>\n\t *\n\t * @return <code>String</code> - information about the\n\t *         <code>Element</code>"
        },
        "clone": {
          "Javadoc": "* <p>\n\t *  This returns a deep clone of this element.\n\t *  The new element is detached from its parent, and getParent()\n\t *  on the clone will return null.\n\t * </p>\n\t *\n\t * @return the clone of this element"
        },
        "getDescendants": {
          "Javadoc": "* Returns an iterator that walks over all descendants in document order\n\t * applying the Filter to return only content that match the filter rule.\n\t * With filters you can match only Elements, only Comments, Elements or\n\t * Comments, only Elements with a given name and/or prefix, and so on.\n\t *\n\t * @param filter filter to select which descendants to see\n\t * @return an iterator to walk descendants within a filter"
        },
        "getChildren": {
          "Javadoc": "* This returns a <code>List</code> of all the child elements\n\t * nested directly (one level deep) within this element with the given\n\t * local name and belonging to the given Namespace, returned as\n\t * <code>Element</code> objects.  If this target element has no nested\n\t * elements with the given name in the given Namespace, an empty List\n\t * is returned.  The returned list is \"live\" in document order\n\t * and changes to it affect the element's actual contents.\n\t * <p>\n\t * Please see the notes for <code>{@link #getChildren}</code>\n\t * for a code example.\n\t * </p>\n\t *\n\t * @param cname local name for the children to match\n\t * @param ns <code>Namespace</code> to search within. A null implies Namespace.NO_NAMESPACE.\n\t * @return all matching child elements"
        },
        "getChild": {
          "Javadoc": "* This returns the first child element within this element with the\n\t * given local name and belonging to no namespace.\n\t * If no elements exist for the specified name and namespace, null is\n\t * returned.\n\t *\n\t * @param cname local name of child element to match\n\t * @return the first matching child element, or null if not found"
        },
        "removeChild": {
          "Javadoc": "* <p>\n\t * This removes the first child element (one level deep) with the\n\t * given local name and belonging to the given namespace.\n\t * Returns true if a child was removed.\n\t * </p>\n\t *\n\t * @param cname the name of child element to remove\n\t * @param ns <code>Namespace</code> to search within. A null implies Namespace.NO_NAMESPACE.\n\t * @return whether deletion occurred"
        },
        "removeChildren": {
          "Javadoc": "* <p>\n\t * This removes all child elements (one level deep) with the\n\t * given local name and belonging to the given namespace.\n\t * Returns true if any were removed.\n\t * </p>\n\t *\n\t * @param cname the name of child elements to remove\n\t * @param ns <code>Namespace</code> to search within. A null implies Namespace.NO_NAMESPACE.\n\t * @return whether deletion occurred"
        },
        "getNamespacesInScope": {
          "Javadoc": "* Get the Namespaces that are in-scope on this Element. Element has the\n\t * most complex rules for the namespaces-in-scope.\n\t * <p>\n\t * The scope is built up from a number of sources following the rules of\n\t * XML namespace inheritence as follows:\n\t * <ul>\n\t * <li>The {@link Namespace#XML_NAMESPACE} is added\n\t * <li>The element's namespace is added (commonly \n\t * {@link Namespace#NO_NAMESPACE})\n\t * <li>All the attributes are inspected and their Namespaces are included\n\t * <li>All Namespaces declared on this Element using\n\t * {@link #addNamespaceDeclaration(Namespace)} are included.\n\t * <li>If the element has a parent then the parent's Namespace scope is\n\t * inspected, and any prefixes in the parent scope that are not yet bound\n\t * in this Element's scope are included.\n\t * <li>If the default Namespace (the no-prefix namespace) has not been\n\t * encountered for this Element then {@link Namespace#NO_NAMESPACE} is\n\t * included.\n\t * </ul> \n\t * The Element's Namespace scope consist of it's inherited Namespaces and\n\t * any modifications to that scope derived from the Element itself. If the\n\t * element is detached then it's inherited scope consists of just \n\t * If an element has no parent then \n\t * <p>\n\t * Note that the Element's Namespace will always be reported first.\n\t * <p>\n\t * <strong>Description copied from</strong>\n\t * {@link NamespaceAware#getNamespacesInScope()}:\n\t * <p>\n\t * {@inheritDoc}\n\t * \n\t * @see NamespaceAware"
        },
        "sortContent": {
          "Javadoc": "* Sort the child content of this Element that matches the Filter, using a\n\t * mechanism that is safe for JDOM content. Other child content (that does\n\t * not match the filter) will be unaffected.\n\t * <p>\n\t * The algorithm used for sorting affects the child content in the following\n\t * ways:\n\t * <ol>\n\t * <li>Items not matching the Filter will be unchanged. This includes the\n\t * absolute position of that content in this Element. i.e. if child content\n\t * <code>cc</code> does not match the Filter, then <code>indexOf(cc)</code>\n\t * will not be changed by this sort.\n\t * <li>Items matching the Filter will be reordered according to the\n\t * comparator. Only the relative order of the Filtered data will change.\n\t * <li>Items that compare as 'equals' using the comparator will keep the\n\t * the same relative order as before the sort. \n\t * </ol>\n\t * <p>\n\t * {@link Collections#sort(List, Comparator)} is not appropriate for sorting\n\t * the Lists returned from {@link Element#getContent()} because those are\n\t * 'live' lists, and the Collections.sort() method uses an algorithm that\n\t * adds the content in the new location before removing it from the old.\n\t * This creates validation issues with content attempting to attach to a\n\t * parent before detaching first.\n\t * <p>\n\t * This method provides a safe means to conveniently sort the content.\n\t * @param <E> The generic type of the Filter used to select the content to\n\t * sort. \n\t * @param filter The Filter used to select which child content to sort.\n\t * @param comparator The Comparator to use for the sorting."
        },
        "sortChildren": {
          "Javadoc": "* Sort the child Elements of this Element using a mechanism that is safe\n\t * for JDOM content. Other child content will be unaffected. See the notes\n\t * on {@link #sortContent(Filter, Comparator)} for how the algorithm works.\n\t * <p>\n\t * {@link Collections#sort(List, Comparator)} is not appropriate for sorting\n\t * the Lists returned from {@link Element#getContent()} because those are\n\t * 'live' lists, and the Collections.sort() method uses an algorithm that\n\t * adds the content in the new location before removing it from the old.\n\t * This creates validation issues with content attempting to attach to a\n\t * parent before detaching first.\n\t * <p>\n\t * This method provides a safe means to conveniently sort the content.\n\t * \n\t * @param comparator The Comparator to use for the sorting."
        },
        "sortAttributes": {
          "Javadoc": "* Sort the Attributes of this Element using a mechanism that is safe\n\t * for JDOM. Other child content will be unaffected. See the notes\n\t * on {@link #sortContent(Filter, Comparator)} for how the algorithm works.\n\t * <p>\n\t * {@link Collections#sort(List, Comparator)} is not appropriate for sorting\n\t * the Lists returned from {@link Element#getContent()} because those are\n\t * 'live' lists, and the Collections.sort() method uses an algorithm that\n\t * adds the content in the new location before removing it from the old.\n\t * This creates validation issues with content attempting to attach to a\n\t * parent before detaching first.\n\t * <p>\n\t * This method provides a safe means to conveniently sort the content.\n\t * <p>\n\t * A null comparator will sort the Attributes alphabetically first by prefix,\n\t * then by name\n\t * \n\t * @param comparator The Comparator to use for the sorting."
        },
        "resolve": {
          "Javadoc": "* Simple method that supports getXMLBaseURI().\n\t * @param uri 'currently' URI as a string\n\t * @param relative the relative URI we are trying to make absolute\n\t * @return the resulting URI, may be null.\n\t * @throws URISyntaxException for URI problems."
        },
        "getXMLBaseURI": {
          "Javadoc": "* Calculate the XMLBase URI for this Element using the rules defined in the\n\t * XMLBase specification, as well as the values supplied in the xml:base\n\t * attributes on this Element and its ancestry.\n\t * <p>\n\t * This method assumes that all values in <code>xml:base</code> attributes\n\t * are valid URI values according to the <code>java.net.URI</code>\n\t * implementation. The same implementation is used to resolve relative URI\n\t * values, and thus this code follows the assumptions in java.net.URI.\n\t * <p>\n\t * This technically deviates from the XMLBase spec because to fully support\n\t * legacy HTML the xml:base attribute could contain what is called a 'LIERI'\n\t * which is a superset of true URI values, but for practical purposes JDOM\n\t * users should never encounter such values because they are not processing\n\t * raw HTML (but xhtml maybe). \n\t * \n\t * @return a URI representing the XMLBase value for the supplied Element, or\n\t *         null if one could not be calculated.\n\t * @throws URISyntaxException\n\t *         if it is not possible to create java.net.URI values from the data\n\t *         in the <code>xml:base</code> attributes."
        },
        "writeObject": {
          "Javadoc": "* Serialize out the Element.\n\t * \n\t * @serialData\n\t * The Stream protocol is:\n\t * <ol>\n\t *   <li>The Element name and Namespace using default Serialization.\n\t *   <li>The count of additional Namespace Declarations.\n\t *   <li>The actual additional Namespace Declarations.\n\t *   <li>The count of Attributes.\n\t *   <li>The actual Attributes.\n\t *   <li>The count of child Content\n\t *   <li>The actual Child Content.\n\t * </ol>\n\t * \n\t * @param out where to write the Element to.\n\t * @throws IOException if there is a writing problem."
        },
        "readObject": {
          "Javadoc": "* Read an Element off the ObjectInputStream.\n\t * \n\t * @see #writeObject(ObjectOutputStream)\n\t * @param in where to read the Element from.\n\t * @throws IOException if there is a reading problem.\n\t * @throws ClassNotFoundException when a class cannot be found"
        }
      }
    },
    "org.jdom2.EntityRef": {
      "Javadoc": "\n * An XML entity reference. Methods allow the user to manage its name, public\n * id, and system id.\n *\n * @author  Brett McLaughlin\n * @author  Jason Hunter\n * @author  Philip Nelson\n * @author  Rolf Lear\n ",
      "methods": {
        "getName": {
          "Javadoc": "* This returns the name of the <code>EntityRef</code>.\n\t *\n\t * @return <code>String</code> - entity name."
        },
        "getValue": {
          "Javadoc": "* Returns the empty string since entity references don't have an XPath\n\t * 1.0 string value.\n\t * @return the empty string"
        },
        "getPublicID": {
          "Javadoc": "* This will return the publid ID of this <code>EntityRef</code>.\n\t * If there is no public ID, then this returns <code>null</code>.\n\t *\n\t * @return public ID of this <code>EntityRef</code>"
        },
        "getSystemID": {
          "Javadoc": "* This will return the system ID of this <code>EntityRef</code>.\n\t * If there is no system ID, then this returns <code>null</code>.\n\t *\n\t * @return system ID of this <code>EntityRef</code>"
        },
        "setName": {
          "Javadoc": "* This will set the name of this <code>EntityRef</code>.\n\t *\n\t * @param name new name of the entity\n\t * @return this <code>EntityRef</code> modified.\n\t * @throws IllegalNameException if the given name is not a legal\n\t *         XML name."
        },
        "setPublicID": {
          "Javadoc": "* This will set the public ID of this <code>EntityRef</code>.\n\t *\n\t * @param publicID new public id\n\t * @return this <code>EntityRef</code> modified.\n\t * @throws IllegalDataException if the given public ID is not a legal\n\t *         public ID."
        },
        "setSystemID": {
          "Javadoc": "* This will set the system ID of this <code>EntityRef</code>.\n\t *\n\t * @param systemID new system id\n\t * @throws IllegalDataException if the given system ID is not a legal\n\t *         system literal.\n\t * @return this <code>EntityRef</code> modified."
        },
        "toString": {
          "Javadoc": "* This returns a <code>String</code> representation of the\n\t * <code>EntityRef</code>, suitable for debugging.\n\t *\n\t * @return <code>String</code> - information about the\n\t *         <code>EntityRef</code>"
        }
      }
    },
    "org.jdom2.filter.AbstractFilter": {
      "Javadoc": "\n * Partial implementation of {@link Filter}.\n *\n * @author Bradley S. Huffman\n * @author Rolf Lear\n * @param <T> The Generic type of content returned by this Filter\n "
    },
    "org.jdom2.filter.AndFilter": {
      "Javadoc": "\n * Allow two filters to be chained together with a logical\n * <b>and</b> operation.\n *\n * @author Bradley S. Huffman\n * @author Rolf Lear\n * @param <T> The Generic type of content returned by this Filter\n"
    },
    "org.jdom2.filter.AttributeFilter": {
      "Javadoc": "\n * A Filter that only matches {@link org.jdom2.Attribute} objects.\n *\n * @author  Rolf Lear\n ",
      "methods": {
        "filter": {
          "Javadoc": "* Check to see if the Content matches a predefined set of rules.\n\t *\n\t * @param content The Content to verify.\n\t * @return <code>true</code> if the objected matched a predfined\n\t *           set of rules."
        },
        "equals": {
          "Javadoc": "* Returns whether the two filters are equivalent (i&#46;e&#46; the\n\t * matching names and namespace are equivalent).\n\t *\n\t * @param  obj                   the object to compare against\n\t * @return                     whether the two filters are equal"
        }
      }
    },
    "org.jdom2.filter.ClassFilter": {
      "Javadoc": "\n * Filter input according to the input class.\n * \n * @author Rolf Lear\n *\n * @param <T> The generic type of the filtered data.\n "
    },
    "org.jdom2.filter.ContentFilter": {
      "Javadoc": "\n * A general purpose Filter able to represent all legal JDOM objects or a\n * specific subset. Filtering is accomplished by way of a filtering mask in\n * which each bit represents whether a JDOM object is visible or not.\n * For example to view all Text and CDATA nodes in the content of element x.\n * <pre><code>\n *      Filter filter = new ContentFilter(ContentFilter.TEXT |\n *                                        ContentFilter.CDATA);\n *      List content = x.getContent(filter);\n * </code></pre>\n * <p>\n * For those who don't like bit-masking, set methods are provided as an\n * alternative.  For example to allow everything except Comment nodes.\n * <pre><code>\n *      Filter filter =  new ContentFilter();\n *      filter.setCommentVisible(false);\n *      List content = x.getContent(filter);\n * </code></pre>\n * <p>\n * The default is to allow all valid JDOM objects.\n *\n * @author Bradley S. Huffman\n ",
      "methods": {
        "getFilterMask": {
          "Javadoc": "* Return current filtering mask.\n\t *\n\t * @return the current filtering mask"
        },
        "setFilterMask": {
          "Javadoc": "* Set filtering mask.\n\t *\n\t * @param mask the new filtering mask"
        },
        "setDefaultMask": {
          "Javadoc": "* Set this filter to allow all legal JDOM objects."
        },
        "setDocumentContent": {
          "Javadoc": "* Set filter to match only JDOM objects that are legal\n\t * document content."
        },
        "setElementContent": {
          "Javadoc": "* Set filter to match only JDOM objects that are legal\n\t * element content."
        },
        "setElementVisible": {
          "Javadoc": "* Set visiblity of <code>Element</code> objects.\n\t *\n\t * @param visible whether Elements are visible, <code>true</code>\n\t *        if yes, <code>false</code> if not"
        },
        "setCDATAVisible": {
          "Javadoc": "* Set visiblity of <code>CDATA</code> objects.\n\t *\n\t * @param visible whether CDATA nodes are visible, <code>true</code>\n\t *        if yes, <code>false</code> if not"
        },
        "setTextVisible": {
          "Javadoc": "* Set visiblity of <code>Text</code> objects.\n\t *\n\t * @param visible whether Text nodes are visible, <code>true</code>\n\t *        if yes, <code>false</code> if not"
        },
        "setCommentVisible": {
          "Javadoc": "* Set visiblity of <code>Comment</code> objects.\n\t *\n\t * @param visible whether Comments are visible, <code>true</code>\n\t *        if yes, <code>false</code> if not"
        },
        "setPIVisible": {
          "Javadoc": "* Set visiblity of <code>ProcessingInstruction</code> objects.\n\t *\n\t * @param visible whether ProcessingInstructions are visible,\n\t *        <code>true</code> if yes, <code>false</code> if not"
        },
        "setEntityRefVisible": {
          "Javadoc": "* Set visiblity of <code>EntityRef</code> objects.\n\t *\n\t * @param visible whether EntityRefs are visible, <code>true</code>\n\t *        if yes, <code>false</code> if not"
        },
        "setDocTypeVisible": {
          "Javadoc": "* Set visiblity of <code>DocType</code> objects.\n\t *\n\t * @param visible whether the DocType is visible, <code>true</code>\n\t *        if yes, <code>false</code> if not"
        },
        "filter": {
          "Javadoc": "* Check to see if the object matches according to the filter mask.\n\t *\n\t * @param obj The object to verify.\n\t * @return <code>true</code> if the objected matched a predfined\n\t *           set of rules."
        },
        "equals": {
          "Javadoc": "* Returns whether the two filters are equivalent (i&#46;e&#46; the\n\t * matching mask values are identical).\n\t *\n\t * @param  obj                 the object to compare against\n\t * @return                     whether the two filters are equal"
        }
      }
    },
    "org.jdom2.filter.ElementFilter": {
      "Javadoc": "\n * A Filter that only matches {@link org.jdom2.Element} objects.\n *\n * @author  Jools Enticknap\n * @author  Bradley S. Huffman\n ",
      "methods": {
        "filter": {
          "Javadoc": "* Check to see if the object matches a predefined set of rules.\n\t *\n\t * @param content The object to verify.\n\t * @return <code>true</code> if the objected matched a predfined\n\t *           set of rules."
        },
        "equals": {
          "Javadoc": "* Returns whether the two filters are equivalent (i&#46;e&#46; the\n\t * matching names and namespace are equivalent).\n\t *\n\t * @param  obj                   the object to compare against\n\t * @return                     whether the two filters are equal"
        }
      }
    },
    "org.jdom2.filter.Filter": {
      "Javadoc": "\n * A generalized filter to restrict visibility or mutability on a list.\n *\n * @author  Jools Enticknap\n * @author  Bradley S. Huffman\n * @author  Rolf Lear\n * @param <T> The Generic type of content returned by this Filter\n ",
      "methods": {
        "filter": {
          "Javadoc": "* Check to see if the content matches this Filter.\n\t * If it does, return the content cast as this filter's return type,\n\t * otherwise return null.\n\t * @param content The content to test.\n\t * @return The content if it matches the filter, cast as this Filter's type."
        },
        "matches": {
          "Javadoc": "* Check to see if the object matches a predefined set of rules.\n\t *\n\t * @param content The object to verify.\n\t * @return <code>true</code> if the object matches a predfined \n\t *           set of rules."
        },
        "negate": {
          "Javadoc": "* Creates an 'inverse' filter\n\t * @return a Filter that returns all content except what this Filter\n\t * \t\tinstance would."
        },
        "or": {
          "Javadoc": "* Creates an ORing filter\n\t * @param filter a second Filter to OR with.\n\t * @return a new Filter instance that returns the 'union' of this filter and\n\t *      the specified filter."
        },
        "and": {
          "Javadoc": "* Creates an ANDing filter. The generic type of the result is the same as\n\t * this Filter.\n\t * \n\t * @param filter a second Filter to AND with.\n\t * @return a new Filter instance that returns the 'intersection' of this\n\t *     filter and the specified filter."
        },
        "refine": {
          "Javadoc": "* This is similar to the and(Filter) method except the generic type is\n\t * different.\n\t * @param <R> The Generic type of the returned data is taken from the input\n\t * instance. \n\t * @param filter The filter to refine our results with.\n\t * @return A Filter that requires content to both match our instance and the\n\t *     refining instance, but the generic type of the retuned data is based\n\t *     on the refining instance, not this instance."
        }
      }
    },
    "org.jdom2.filter.Filters": {
      "Javadoc": "\n * Factory class of convenience methods to create Filter instances of common\n * types. Methods that return Filters that act on core JDOM classes (Element,\n * Text, etc.) are simply named after the content they return.\n * <p>\n * Filters that\n * match non-core classes (Boolean, Object, etc.) are all prefixed with the\n * letter 'f' (for <strong>f</strong>ilter).\n * <p>\n * The Filter returned by {@link #fpassthrough()} is not really a filter in the\n * sense that it will never filter anything out - everything matches. This can\n * be useful to accomplish some tasks, for example the JDOM XPath API uses it\n * extensively.\n * \n * @author Rolf Lear\n *\n ",
      "methods": {
        "content": {
          "Javadoc": "* Return a Filter that matches any {@link Content} data.\n\t * \n\t * @return a Filter that matches any {@link Content} data."
        },
        "attribute": {
          "Javadoc": "* Return a Filter that matches any {@link Attribute} data with the\n\t * specified namespace.\n\t * \n\t * @param ns The Namespace for all the Attributes to have.\n\t * @return a Filter that matches any {@link Attribute} data with the\n\t * specified namespace."
        },
        "comment": {
          "Javadoc": "* Return a Filter that matches any {@link Comment} data.\n\t * \n\t * @return a Filter that matches any {@link Comment} data."
        },
        "cdata": {
          "Javadoc": "* Return a Filter that matches any {@link CDATA} data.\n\t * \n\t * @return a Filter that matches any {@link CDATA} data."
        },
        "doctype": {
          "Javadoc": "* Return a Filter that matches any {@link DocType} data.\n\t * \n\t * @return a Filter that matches any {@link DocType} data."
        },
        "entityref": {
          "Javadoc": "* Return a Filter that matches any {@link EntityRef} data.\n\t * \n\t * @return a Filter that matches any {@link EntityRef} data."
        },
        "element": {
          "Javadoc": "* Return a Filter that matches any {@link Element} data with the specified\n\t * Namespace.\n\t * \n\t * @param ns The Namespace to match\n\t * @return a Filter that matches any {@link Element} data with the specified\n\t * Namespace."
        },
        "document": {
          "Javadoc": "* Return a Filter that matches any {@link Document} data.\n\t * \n\t * @return a Filter that matches any {@link Document} data."
        },
        "processinginstruction": {
          "Javadoc": "* Return a Filter that matches any {@link ProcessingInstruction} data.\n\t * \n\t * @return a Filter that matches any {@link ProcessingInstruction} data."
        },
        "text": {
          "Javadoc": "* Return a Filter that matches any {@link Text} data (which includes \n\t * {@link CDATA} since that is a subclass of Text).\n\t * \n\t * @return a Filter that matches any {@link Text} data (which includes \n\t * {@link CDATA} since that is a subclass of Text)."
        },
        "textOnly": {
          "Javadoc": "* Return a Filter that matches any {@link Text} data (excludes \n\t * {@link CDATA} instances).\n\t * \n\t * @return a Filter that matches any {@link Text} data (which excludes \n\t * {@link CDATA} instances)."
        },
        "fboolean": {
          "Javadoc": "* Return a Filter that matches any Boolean data.\n\t * \n\t * @return a Filter that matches any Boolean data."
        },
        "fstring": {
          "Javadoc": "* Return a Filter that matches any String data.\n\t * \n\t * @return a Filter that matches any String data."
        },
        "fdouble": {
          "Javadoc": "* Return a Filter that matches any Double data.\n\t * \n\t * @return a Filter that matches any Double data."
        },
        "fclass": {
          "Javadoc": "* Return a Filter that matches any data of the specified Class.\n\t * \n\t * @param <F> The generic type of the content returned by this Filter\n\t * @param clazz the Class type to match in the filter\n\t * @return a Filter that matches any data of the specified Class."
        },
        "fpassthrough": {
          "Javadoc": "* Return a filter that does no filtering at all - everything matches.\n\t * @return A Pass-Through Filter."
        }
      }
    },
    "org.jdom2.filter.NegateFilter": {
      "Javadoc": "\n * Filter that is the logical <b>negation</b> operation of another filter.\n *\n *\n * @author Bradley S. Huffman\n "
    },
    "org.jdom2.filter.OrFilter": {
      "Javadoc": "\n * Allow two filters to be chained together with a logical\n * <b>or</b> operation.\n *\n * @author Bradley S. Huffman\n "
    },
    "org.jdom2.filter.PassThroughFilter": {
      "Javadoc": "\n * A filter that does not actual filtering.\n * This is made available through {@link Filters#fpassthrough()}.\n * \n * @author Rolf Lear\n *\n "
    },
    "org.jdom2.filter.TextOnlyFilter": {
      "Javadoc": "\n * A filter that matches Text, but not CDATA content.\n * This filter is made accessible through {@link Filters#textOnly()}\n * \n * @author Rolf Lear\n *\n "
    },
    "org.jdom2.FilterIterator": {
      "Javadoc": "\n * Traverse a parent's children that match the supplied filter.\n *\n * @author Bradley S. Huffman\n * @author Rolf Lear\n * @param <T> The Generic type of content returned by this FilterIterator.\n "
    },
    "org.jdom2.IllegalAddException": {
      "Javadoc": "\n * Thrown when trying to add an illegal object to a JDOM construct.\n *\n * @author  Brett McLaughlin\n * @author  Jason Hunter\n "
    },
    "org.jdom2.IllegalDataException": {
      "Javadoc": "\n * Thrown when illegal text is supplied to a JDOM construct.\n *\n * @author  Brett McLaughlin\n * @author  Elliotte Rusty Harold\n "
    },
    "org.jdom2.IllegalNameException": {
      "Javadoc": "\n * Thrown when a name is supplied in construction of a JDOM construct whose\n * where the name breaks XML naming conventions.\n * \n * @author  Brett McLaughlin\n * @author  Elliotte Rusty Harold\n "
    },
    "org.jdom2.IllegalTargetException": {
      "Javadoc": "\n * Thrown when a target is supplied in construction of a JDOM {@link\n * ProcessingInstruction}, and that name breaks XML naming conventions.\n * \n * @author  Brett McLaughlin\n "
    },
    "org.jdom2.input.DOMBuilder": {
      "Javadoc": "\n * Builds a JDOM Document from a pre-existing DOM {@link org.w3c.dom.Document \n * org.w3c.dom.Document}.\n * <p>\n * If you are building a document that has Namespace declarations, you should\n * ensure that the Namespaces are correctly recorded in the DOM document before\n * building the JDOM document from the DOM. By default, the native Java\n * DOMBuilderFactory is configured to ignore Namespaces, and thus they are\n * 'lost' in the DOM tree. JDOM expects Namespace-aware documents, so you\n * should ensure that you change the default settings on the\n * DOMBuilderFactory before parsing the DOM document. For example:\n * <p>\n * <pre>\n *     DocumentBuilderFactory domfactory = DocumentBuilderFactory.newInstance();\n *     domfactory.setNamespaceAware(true);\n *     DocumentBuilder dombuilder = domfac.newDocumentBuilder();\n *     org.w3c.dom.Document doc = dombuilder.parse(....);\n * </pre>\n * \n * @author  Brett McLaughlin\n * @author  Jason Hunter\n * @author  Philip Nelson\n * @author  Kevin Regan\n * @author  Yusuf Goolamabbas\n * @author  Dan Schaffer\n * @author  Bradley S. Huffman\n ",
      "methods": {
        "setFactory": {
          "Javadoc": "* This sets a custom JDOMFactory for the builder.  Use this to build\n\t * the tree with your own subclasses of the JDOM classes.\n\t *\n\t * @param factory <code>JDOMFactory</code> to use"
        },
        "getFactory": {
          "Javadoc": "* Returns the current {@link org.jdom2.JDOMFactory} in use.\n\t * @return the factory in use"
        },
        "build": {
          "Javadoc": "* This will build a JDOM Element from an existing DOM Element\n\t *\n\t * @param doctype <code> org.w3c.dom.Element</code> object\n\t * @return <code>Element</code> - JDOM Element object\n\t * @since JDOM2"
        },
        "buildTree": {
          "Javadoc": "* This takes a DOM <code>Node</code> and builds up\n\t * a JDOM tree, recursing until the DOM tree is exhausted\n\t * and the JDOM tree results.\n\t *\n\t * @param node <code>Code</node> to examine.\n\t * @param doc JDOM <code>Document</code> being built.\n\t * @param current <code>Element</code> that is current parent.\n\t * @param atRoot <code>boolean</code> indicating whether at root level."
        }
      }
    },
    "org.jdom2.input.JDOMParseException": {
      "Javadoc": "\n * Thrown during parse errors, with information about where the parse error\n * occurred as well as access to the partially built document.\n *\n * @author  Laurent Bihanic\n ",
      "methods": {
        "getPartialDocument": {
          "Javadoc": "* Returns the partial document that was successfully built before\n\t * the error occurred.\n\t *\n\t * @return the partial document or null if none."
        },
        "getPublicId": {
          "Javadoc": "* Returns the public identifier of the entity where the\n\t * parse error occurred.\n\t *\n\t * @return a string containing the public identifier, or\n\t *         <code>null</code> if the information is not available."
        },
        "getSystemId": {
          "Javadoc": "* Returns the system identifier of the entity where the\n\t * parse error occurred.\n\t *\n\t * @return a string containing the system identifier, or\n\t *         <code>null</code> if the information is not available."
        },
        "getLineNumber": {
          "Javadoc": "* Returns the line number of the end of the text where the\n\t * parse error occurred.\n\t * <p>\n\t * The first line in the document is line 1.</p>\n\t *\n\t * @return an integer representing the line number, or -1\n\t *         if the information is not available."
        },
        "getColumnNumber": {
          "Javadoc": "* Returns the column number of the end of the text where the\n\t * parse error occurred.\n\t * <p>\n\t * The first column in a line is position 1.</p>\n\t *\n\t * @return an integer representing the column number, or -1\n\t *         if the information is not available."
        }
      }
    },
    "org.jdom2.input.sax.AbstractReaderSchemaFactory": {
      "Javadoc": "\n * This {@link AbstractReaderSchemaFactory} class returns XMLReaders configured to\n * validate against the supplied Schema instance. The Schema could be an XSD\n * schema or some other schema supported by SAX (e.g. RelaxNG). It takes a pre-declared\n * <p>\n * If you want to validate an XML document against the XSD references embedded\n * in the XML itself (xsdSchemaLocation) then you do not want to use this class\n * but rather use an alternate means like\n * {@link XMLReaders#XSDVALIDATING}.\n * <p>\n * See the {@link org.jdom2.input.sax package documentation} for the best\n * alternatives.\n * \n * @see org.jdom2.input.sax\n * @author Rolf Lear\n "
    },
    "org.jdom2.input.sax.AbstractReaderXSDFactory": {
      "Javadoc": "\n * This AbstractReaderJDOMFactory class returns XMLReaders configured to validate\n * against the supplied XML Schema (XSD) instance.\n * <p>\n * This class has var-arg constructors, accepting potentially many XSD sources.\n * It is just as simple though to have a single source:\n * \n * <pre>\n * File xsdfile = new File(&quot;schema.xsd&quot;);\n * XMLReaderJDOMFactory schemafac = new XMLReaderXSDFactory(xsdfile);\n * SAXBuilder builder = new SAXBuilder(schemafac);\n * File xmlfile = new File(&quot;data.xml&quot;);\n * Document validdoc = builder.build(xmlfile);\n * </pre>\n * \n * @see org.jdom2.input.sax\n * @author Rolf Lear\n ",
      "methods": {
        "getSchemaFromString": {
          "Javadoc": "* Compile an array of String URLs in to Sources which are then compiled in\n\t * to a single Schema\n\t * \n\t * @param systemID\n\t *        The source URLs to compile\n\t * @return the resulting Schema\n\t * @throws JDOMException\n\t *         if there is a problem with the Sources"
        },
        "getSchemaFromFile": {
          "Javadoc": "* Compile an array of Files in to URLs which are then compiled in to a\n\t * single Schema\n\t * \n\t * @param systemID\n\t *        The source Files to compile\n\t * @return the resulting Schema\n\t * @throws JDOMException\n\t *         if there is a problem with the Sources"
        },
        "getSchemaFromURL": {
          "Javadoc": "* Compile an array of URLs in to Sources which are then compiled in to a\n\t * single Schema\n\t * \n\t * @param systemID\n\t *        The source URLs to compile\n\t * @return the resulting Schema\n\t * @throws JDOMException\n\t *         if there is a problem with the Sources"
        },
        "getSchemaFromSource": {
          "Javadoc": "* Compile an array of Sources in to a single Schema\n\t * \n\t * @param sources\n\t *        The sources to compile\n\t * @return the resulting Schema\n\t * @throws JDOMException\n\t *         if there is a problem with the Sources"
        }
      }
    },
    "org.jdom2.input.sax.SchemaFactoryProvider": {
      "Javadoc": "\n\t * Simple interface makes it easier to pass logic around in static methods.\n\t * @author Rolf Lear\n\t *\n\t ",
      "methods": {
        "getSchemaFactory": {
          "Javadoc": "* Return a SchemaFactory\n\t\t * @return a SchemaFactory"
        }
      }
    },
    "org.jdom2.input.sax.BuilderErrorHandler": {
      "Javadoc": "",
      "methods": {
        "warning": {
          "Javadoc": "* This method is called when a warning has occurred; this indicates that\n\t * while no XML rules were broken, something appears to be incorrect or\n\t * missing. The implementation of this method here is a \"no op\".\n\t * \n\t * @param exception\n\t *        <code>SAXParseException</code> that occurred.\n\t * @throws SAXException\n\t *         when things go wrong"
        },
        "error": {
          "Javadoc": "* This method is called in response to an error that has occurred; this\n\t * indicates that a rule was broken, typically in validation, but that\n\t * parsing could reasonably continue. The implementation of this method here\n\t * is to rethrow the exception.\n\t * \n\t * @param exception\n\t *        <code>SAXParseException</code> that occurred.\n\t * @throws SAXException\n\t *         when things go wrong"
        },
        "fatalError": {
          "Javadoc": "* This method is called in response to a fatal error; this indicates that a\n\t * rule has been broken that makes continued parsing either impossible or an\n\t * almost certain waste of time. The implementation of this method here is\n\t * to rethrow the exception.\n\t * \n\t * @param exception\n\t *        <code>SAXParseException</code> that occurred.\n\t * @throws SAXException\n\t *         when things go wrong"
        }
      }
    },
    "org.jdom2.input.sax.DefaultSAXHandlerFactory": {
      "Javadoc": "\n * This SAXHandlerFactory instance provides default-configured SAXHandler\n * instances for all non-custom situations.\n * \n * @author Rolf Lear\n "
    },
    "org.jdom2.input.sax.DefaultSAXHandler": {
      "Javadoc": "\n\t * For performance reasons it helps to use 'final' instances of classes.\n\t * This makes the SAXHandler class a 'final' class for all normal\n\t * SAXBuilders. It adds no other functionality.\n\t * \n\t * @author Rolf Lear\n\t "
    },
    "org.jdom2.input.sax.SAXBuilderEngine": {
      "Javadoc": "\n * Builds a JDOM document from files, streams, readers, URLs, or a SAX\n * {@link org.xml.sax.InputSource} instance using a SAX parser. This Engine is\n * built by the SAXBuilder based on the state of the SAXBuilder when the engine\n * was produced. It is not possible to reconfigure the engine once built, but it\n * can be reused many times (though not concurrently). This makes it the fastest\n * way to process many multitudes of XML documents (if those documents are all\n * parsed the same way). If you want to process in multiple threads you can\n * safely have one SAXBuilderEngine in each thread on the condition that:\n * <ol>\n * <li>The JDOMFactory is thread-safe (the JDOM-supplied JDOMFactories are)\n * <li>There is no XMLFilter given to the SAXBuilder, or, if there is, then it\n * is thread-safe.\n * <li>If you have a custom {@link XMLReaderJDOMFactory} that it supplies a new\n * instance of an XMLReader on each call (the JDOM-supplied ones all do).\n * <li>If you have a custom {@link SAXHandlerFactory} that it supplies a new\n * instance of a SAXHanfler on each call (the JDOM-supplied one does)\n * </ol>\n * \n * @see org.jdom2.input.sax\n * @author Rolf Lear\n ",
      "methods": {
        "fileToURL": {
          "Javadoc": "* Custom File.toUrl() implementation to handle special chars in file names\n\t * Actually, we can now rely on the core Java toURI function,\n\t * \n\t * @param file\n\t *        file object whose path will be converted\n\t * @return URL form of the file, with special characters handled\n\t * @throws MalformedURLException\n\t *         if there's a problem constructing a URL"
        }
      }
    },
    "org.jdom2.input.sax.SAXEngine": {
      "Javadoc": "\n * SAXEngine provides an interface to interact with either the SAXBuilder or the\n * SAXBuilderEngine. This makes it possible to do pooling of SAXEngines for\n * parsing using instances of either SAXBuilder or SAXBuilderEngine.\n * \n * @see org.jdom2.input.sax\n * @author Rolf Lear\n ",
      "methods": {
        "getJDOMFactory": {
          "Javadoc": "* Returns the current {@link org.jdom2.JDOMFactory} in use.\n\t * \n\t * @return the factory in use"
        },
        "isValidating": {
          "Javadoc": "* Returns whether validation is to be performed during the build.\n\t * \n\t * @return whether validation is to be performed during the build"
        },
        "getErrorHandler": {
          "Javadoc": "* Returns the {@link ErrorHandler} assigned, or null if none.\n\t * \n\t * @return the ErrorHandler assigned, or null if none"
        },
        "getEntityResolver": {
          "Javadoc": "* Returns the {@link EntityResolver} assigned, or null if none.\n\t * \n\t * @return the EntityResolver assigned"
        },
        "getDTDHandler": {
          "Javadoc": "* Returns the {@link DTDHandler} assigned, or null if none.\n\t * \n\t * @return the DTDHandler assigned"
        },
        "getIgnoringElementContentWhitespace": {
          "Javadoc": "* Returns whether element content whitespace is to be ignored during the\n\t * build.\n\t * \n\t * @return whether element content whitespace is to be ignored during the\n\t *         build"
        },
        "getIgnoringBoundaryWhitespace": {
          "Javadoc": "* Returns whether or not the parser will elminate element content\n\t * containing only whitespace.\n\t * \n\t * @return <code>boolean</code> - whether only whitespace content will be\n\t *         ignored during build."
        },
        "getExpandEntities": {
          "Javadoc": "* Returns whether or not entities are being expanded into normal text\n\t * content.\n\t * \n\t * @return whether entities are being expanded"
        },
        "build": {
          "Javadoc": "* <p>\n\t * This builds a document from the supplied URI.\n\t * </p>\n\t * \n\t * @param systemId\n\t *        URI for the input\n\t * @return <code>Document</code> resultant Document object\n\t * @throws JDOMException\n\t *         when errors occur in parsing\n\t * @throws IOException\n\t *         when an I/O error prevents a document from being fully parsed"
        }
      }
    },
    "org.jdom2.input.sax.SAXHandler": {
      "Javadoc": "\n * A support class for {@link SAXBuilder} which listens for SAX events.\n * <p>\n * People overriding this class are cautioned to ensure that the implementation\n * of the cleanUp() method resets to a virgin state. The cleanUp() method will\n * be called when this SAXHandler is reset(), which may happen multiple times\n * between parses. The cleanUp() method must ensure that there are no references\n * remaining to any external instances.\n * <p>\n * Overriding of this class is permitted to allow for different handling of SAX\n * events. Once you have created a subclass of this, you also need to create a\n * custom implementation of {@link SAXHandlerFactory} to supply your instances\n * to {@link SAXBuilder}\n * <p>\n * If the XMLReader producing the SAX Events supports a document Locator, then\n * this instance will use the locator to supply the line and column data from\n * the SAX locator to the JDOMFactory. <strong>Note:</strong> the SAX\n * specification for the SAX Locator indicates that the line and column\n * represent the position of the <strong>end</strong> of the SAX Event. For\n * example, the line and column of the simple XML <code>&lt;root /&gt;</code>\n * would be line 1, column 9.\n * \n * @see org.jdom2.input.sax\n * @author Brett McLaughlin\n * @author Jason Hunter\n * @author Philip Nelson\n * @author Bradley S. Huffman\n * @author phil@triloggroup.com\n * @author Rolf Lear\n ",
      "methods": {
        "resetSubCLass": {
          "Javadoc": "* Override this method if you are a subclasser, and you want to clear the\n\t * state of your SAXHandler instance in preparation for a new parse."
        },
        "reset": {
          "Javadoc": "* Restore this SAXHandler to a clean state ready for another parse round.\n\t * All internal variables are cleared to an initialized state, and then the\n\t * resetSubClass() method is called to clear any methods that a subclass may\n\t * need to have reset."
        },
        "pushElement": {
          "Javadoc": "* Pushes an element onto the tree under construction. Allows subclasses to\n\t * put content under a dummy root element which is useful for building\n\t * content that would otherwise be a non-well formed document.\n\t * \n\t * @param element\n\t *        root element under which content will be built"
        },
        "getDocument": {
          "Javadoc": "* Returns the document. Should be called after parsing is complete.\n\t * \n\t * @return <code>Document</code> - Document that was built"
        },
        "getFactory": {
          "Javadoc": "* Returns the factory used for constructing objects.\n\t * \n\t * @return <code>JDOMFactory</code> - the factory used for constructing\n\t *         objects.\n\t * @see #SAXHandler(org.jdom2.JDOMFactory)"
        },
        "setExpandEntities": {
          "Javadoc": "* This sets whether or not to expand entities during the build. A true\n\t * means to expand entities as normal content. A false means to leave\n\t * entities unexpanded as <code>EntityRef</code> objects. The default is\n\t * true.\n\t * \n\t * @param expand\n\t *        <code>boolean</code> indicating whether entity expansion should\n\t *        occur."
        },
        "getExpandEntities": {
          "Javadoc": "* Returns whether or not entities will be expanded during the build.\n\t * \n\t * @return <code>boolean</code> - whether entity expansion will occur during\n\t *         build.\n\t * @see #setExpandEntities"
        },
        "setIgnoringElementContentWhitespace": {
          "Javadoc": "* Specifies whether or not the parser should elminate whitespace in element\n\t * content (sometimes known as \"ignorable whitespace\") when building the\n\t * document. Only whitespace which is contained within element content that\n\t * has an element only content model will be eliminated (see XML Rec 3.2.1).\n\t * For this setting to take effect requires that validation be turned on.\n\t * The default value of this setting is <code>false</code>.\n\t * \n\t * @param ignoringWhite\n\t *        Whether to ignore ignorable whitespace"
        },
        "setIgnoringBoundaryWhitespace": {
          "Javadoc": "* Specifies whether or not the parser should eliminate text() nodes\n\t * containing only whitespace when building the document. See\n\t * {@link SAXBuilder#setIgnoringBoundaryWhitespace(boolean)}.\n\t * \n\t * @param ignoringBoundaryWhite\n\t *        Whether to ignore only whitespace content"
        },
        "getIgnoringBoundaryWhitespace": {
          "Javadoc": "* Returns whether or not the parser will elminate element content\n\t * containing only whitespace.\n\t * \n\t * @return <code>boolean</code> - whether only whitespace content will be\n\t *         ignored during build.\n\t * @see #setIgnoringBoundaryWhitespace"
        },
        "getIgnoringElementContentWhitespace": {
          "Javadoc": "* Returns whether or not the parser will elminate whitespace in element\n\t * content (sometimes known as \"ignorable whitespace\") when building the\n\t * document.\n\t * \n\t * @return <code>boolean</code> - whether ignorable whitespace will be\n\t *         ignored during build.\n\t * @see #setIgnoringElementContentWhitespace"
        },
        "externalEntityDecl": {
          "Javadoc": "* This is called when the parser encounters an external entity declaration.\n\t * \n\t * @param name\n\t *        entity name\n\t * @param publicID\n\t *        public id\n\t * @param systemID\n\t *        system id\n\t * @throws SAXException\n\t *         when things go wrong"
        },
        "attributeDecl": {
          "Javadoc": "* This handles an attribute declaration in the internal subset.\n\t * \n\t * @param eName\n\t *        <code>String</code> element name of attribute\n\t * @param aName\n\t *        <code>String</code> attribute name\n\t * @param type\n\t *        <code>String</code> attribute type\n\t * @param valueDefault\n\t *        <code>String</code> default value of attribute\n\t * @param value\n\t *        <code>String</code> value of attribute"
        },
        "elementDecl": {
          "Javadoc": "* Handle an element declaration in a DTD.\n\t * \n\t * @param name\n\t *        <code>String</code> name of element\n\t * @param model\n\t *        <code>String</code> model of the element in DTD syntax"
        },
        "internalEntityDecl": {
          "Javadoc": "* Handle an internal entity declaration in a DTD.\n\t * \n\t * @param name\n\t *        <code>String</code> name of entity\n\t * @param value\n\t *        <code>String</code> value of the entity"
        },
        "processingInstruction": {
          "Javadoc": "* This will indicate that a processing instruction has been encountered.\n\t * (The XML declaration is not a processing instruction and will not be\n\t * reported.)\n\t * \n\t * @param target\n\t *        <code>String</code> target of PI\n\t * @param data\n\t *        <code>String</code> containing all data sent to the PI. This\n\t *        typically looks like one or more attribute value pairs.\n\t * @throws SAXException\n\t *         when things go wrong"
        },
        "skippedEntity": {
          "Javadoc": "* This indicates that an unresolvable entity reference has been\n\t * encountered, normally because the external DTD subset has not been read.\n\t * \n\t * @param name\n\t *        <code>String</code> name of entity\n\t * @throws SAXException\n\t *         when things go wrong"
        },
        "startPrefixMapping": {
          "Javadoc": "* This will add the prefix mapping to the JDOM <code>Document</code>\n\t * object.\n\t * \n\t * @param prefix\n\t *        <code>String</code> namespace prefix.\n\t * @param uri\n\t *        <code>String</code> namespace URI."
        },
        "startElement": {
          "Javadoc": "* This reports the occurrence of an actual element. It will include the\n\t * element's attributes, with the exception of XML vocabulary specific\n\t * attributes, such as <code>xmlns:[namespace prefix]</code> and\n\t * <code>xsi:schemaLocation</code>.\n\t * \n\t * @param namespaceURI\n\t *        <code>String</code> namespace URI this element is associated with,\n\t *        or an empty <code>String</code>\n\t * @param localName\n\t *        <code>String</code> name of element (with no namespace prefix, if\n\t *        one is present)\n\t * @param qName\n\t *        <code>String</code> XML 1.0 version of element name: [namespace\n\t *        prefix]:[localName]\n\t * @param atts\n\t *        <code>Attributes</code> list for this element\n\t * @throws SAXException\n\t *         when things go wrong"
        },
        "transferNamespaces": {
          "Javadoc": "* This will take the supplied <code>{@link Element}</code> and transfer its\n\t * namespaces to the global namespace storage.\n\t * \n\t * @param element\n\t *        <code>Element</code> to read namespaces from."
        },
        "characters": {
          "Javadoc": "* This will report character data (within an element).\n\t * \n\t * @param ch\n\t *        <code>char[]</code> character array with character data\n\t * @param start\n\t *        <code>int</code> index in array where data starts.\n\t * @param length\n\t *        <code>int</code> length of data."
        },
        "ignorableWhitespace": {
          "Javadoc": "* Capture ignorable whitespace as text. If\n\t * setIgnoringElementContentWhitespace(true) has been called then this\n\t * method does nothing.\n\t * \n\t * @param ch\n\t *        <code>[]</code> - char array of ignorable whitespace\n\t * @param start\n\t *        <code>int</code> - starting position within array\n\t * @param length\n\t *        <code>int</code> - length of whitespace after start\n\t * @throws SAXException\n\t *         when things go wrong"
        },
        "flushCharacters": {
          "Javadoc": "* Flush the given string into the document. This is a protected method so\n\t * subclassers can control text handling without knowledge of the internals\n\t * of this class.\n\t * \n\t * @param data\n\t *        string to flush\n\t * @throws SAXException\n\t *         if the state of the handler does not allow this."
        },
        "endElement": {
          "Javadoc": "* Indicates the end of an element (<code>&lt;/[element name]&gt;</code>) is\n\t * reached. Note that the parser does not distinguish between empty elements\n\t * and non-empty elements, so this will occur uniformly.\n\t * \n\t * @param namespaceURI\n\t *        <code>String</code> URI of namespace this element is associated\n\t *        with\n\t * @param localName\n\t *        <code>String</code> name of element without prefix\n\t * @param qName\n\t *        <code>String</code> name of element in XML 1.0 form\n\t * @throws SAXException\n\t *         when things go wrong"
        },
        "startDTD": {
          "Javadoc": "* This will signify that a DTD is being parsed, and can be used to ensure\n\t * that comments and other lexical structures in the DTD are not added to\n\t * the JDOM <code>Document</code> object.\n\t * \n\t * @param name\n\t *        <code>String</code> name of element listed in DTD\n\t * @param publicID\n\t *        <code>String</code> public ID of DTD\n\t * @param systemID\n\t *        <code>String</code> system ID of DTD"
        },
        "endDTD": {
          "Javadoc": "* This signifies that the reading of the DTD is complete."
        },
        "startCDATA": {
          "Javadoc": "* Report a CDATA section"
        },
        "endCDATA": {
          "Javadoc": "* Report a CDATA section"
        },
        "comment": {
          "Javadoc": "* This reports that a comments is parsed. If not in the DTD, this comment\n\t * is added to the current JDOM <code>Element</code>, or the\n\t * <code>Document</code> itself if at that level.\n\t * \n\t * @param ch\n\t *        <code>ch[]</code> array of comment characters.\n\t * @param start\n\t *        <code>int</code> index to start reading from.\n\t * @param length\n\t *        <code>int</code> length of data.\n\t * @throws SAXException\n\t *         if the state of the handler disallows this call"
        },
        "notationDecl": {
          "Javadoc": "* Handle the declaration of a Notation in a DTD\n\t * \n\t * @param name\n\t *        name of the notation\n\t * @param publicID\n\t *        the public ID of the notation\n\t * @param systemID\n\t *        the system ID of the notation"
        },
        "unparsedEntityDecl": {
          "Javadoc": "* Handler for unparsed entity declarations in the DTD\n\t * \n\t * @param name\n\t *        <code>String</code> of the unparsed entity decl\n\t * @param publicID\n\t *        <code>String</code> of the unparsed entity decl\n\t * @param systemID\n\t *        <code>String</code> of the unparsed entity decl\n\t * @param notationName\n\t *        <code>String</code> of the unparsed entity decl"
        },
        "appendExternalId": {
          "Javadoc": "* Appends an external ID to the internal subset buffer. Either publicID or\n\t * systemID may be null, but not both.\n\t * \n\t * @param publicID\n\t *        the public ID\n\t * @param systemID\n\t *        the system ID"
        },
        "getCurrentElement": {
          "Javadoc": "* Returns the being-parsed element.\n\t * \n\t * @return <code>Element</code> - element being built.\n\t * @throws SAXException\n\t *         if the state of the handler disallows this call"
        },
        "setDocumentLocator": {
          "Javadoc": "* Receives an object for locating the origin of SAX document events. This\n\t * method is invoked by the SAX parser.\n\t * <p>\n\t * {@link org.jdom2.JDOMFactory} implementations can use the\n\t * {@link #getDocumentLocator} method to get access to the {@link Locator}\n\t * during parse.\n\t * </p>\n\t * \n\t * @param locator\n\t *        <code>Locator</code> an object that can return the location of any\n\t *        SAX document event."
        },
        "getDocumentLocator": {
          "Javadoc": "* Provides access to the {@link Locator} object provided by the SAX parser.\n\t * \n\t * @return <code>Locator</code> an object that can return the location of\n\t *         any SAX document event."
        }
      }
    },
    "org.jdom2.input.sax.SAXHandlerFactory": {
      "Javadoc": "\n * Provides SAXBuilder with SAXHandler instances to support SAX parsing. Users\n * wanting to customise the way that JDOM processes the SAX events should\n * override the {@link SAXHandler} class, and then use an implementation of this\n * factory to feed instances of that new class to SAXBuilder.\n * \n * @see SAXHandler\n * @see org.jdom2.input.sax\n * @author Rolf Lear\n ",
      "methods": {
        "createSAXHandler": {
          "Javadoc": "* Create a new SAXHandler instance for SAXBuilder to use.\n\t * \n\t * @param factory\n\t *        The {@link JDOMFactory} to use for creating JDOM content.\n\t * @return a new instance of a SAXHandler (or subclass) class."
        }
      }
    },
    "org.jdom2.input.sax.TestTextBuffer": {
      "Javadoc": ""
    },
    "org.jdom2.input.sax.TextBuffer": {
      "Javadoc": "\n * A non-public utility class similar to StringBuilder but optimized for XML\n * parsing where the common case is that you get only one chunk of characters\n * per text section. TextBuffer stores the first chunk of characters in a\n * String, which can just be returned directly if no second chunk is received.\n * Subsequent chunks are stored in a supplemental char array (like StringBuilder\n * uses). In this case, the returned text will be the first String chunk,\n * concatenated with the subsequent chunks stored in the char array. This\n * provides optimal performance in the common case, while still providing very\n * good performance in the uncommon case. Furthermore, avoiding StringBuilder\n * means that no extra unused char array space will be kept around after parsing\n * is through.\n * \n * @author Bradley S. Huffman\n * @author Alex Rosen\n ",
      "methods": {
        "append": {
          "Javadoc": "* Append the specified text to the text value of this buffer.\n\t * \n\t * @param source\n\t *        The char[] data to add\n\t * @param start\n\t *        The offset in the data to start adding from\n\t * @param count\n\t *        The number of chars to add."
        },
        "clear": {
          "Javadoc": "* Clears the text value and prepares the TextBuffer for reuse."
        },
        "isAllWhitespace": {
          "Javadoc": "* Inspects the character data for non-whitespace\n\t * \n\t * @return true if all chars are whitespace"
        },
        "toString": {
          "Javadoc": "Returns the text value stored in the buffer."
        }
      }
    },
    "org.jdom2.input.sax.XMLReaderJAXPFactory": {
      "Javadoc": "\n * Create XMLReaders directly from the javax.xml.parsers.SAXParserFactory API using an explicit\n * implementation of the parser instead of relying on the default JAXP search path.\n * <p>\n * If you want to rely on the default JAXP search mechanism you should instead use one of the simple\n * members of the {@link XMLReaders} enumeration, or use one of the simple constructors on\n * {@link XMLReaderXSDFactory} or {@link XMLReaderSchemaFactory}.\n * <p>\n * See the documentation for {@link SAXParserFactory} for the details on what the factoryClassName\n * and classLoader should be.\n * \n * @see org.jdom2.input.sax\n * @since 2.0.3\n * @author Rolf Lear\n "
    },
    "org.jdom2.input.sax.XMLReaderJDOMFactory": {
      "Javadoc": "\n * This interface can be used to supply custom XMLReaders to {@link SAXBuilder}.\n * <p>\n * See the {@link org.jdom2.input.sax package documentation} for details on what\n * XMLReaderJDOMFactory implementations are available and when they are\n * recommended.\n * \n * @see org.jdom2.input.sax\n * @author Rolf Lear\n ",
      "methods": {
        "createXMLReader": {
          "Javadoc": "* Return a new XMLReader according to the implementation of this\n\t * XMLReaderJDOMFactory instance. The XMLReader is expected to be a new\n\t * instance that is unrelated to any other XMLReaders, and can be reused at\n\t * will by {@link SAXBuilder}.\n\t * \n\t * @return a new XMLReader\n\t * @throws JDOMException\n\t *         if an XMLReader was not available."
        },
        "isValidating": {
          "Javadoc": "* Does an XMLReader from this factory do more than just well-formed checks.\n\t * \n\t * @return true if the XMLReader validates"
        }
      }
    },
    "org.jdom2.input.sax.FactorySupplier": {
      "Javadoc": ""
    },
    "org.jdom2.input.sax.XMLReaderSAX2Factory": {
      "Javadoc": "\n * Create XMLReaders directly from the SAX2.0 API using a SAX Driver class name\n * or the default SAX2.0 location process.\n * <p>\n * Unless you have good reason to use this mechanism you should rather use the\n * JAXP-based processes. Read the {@link org.jdom2.input.sax package\n * documentation} for other alternatives.\n * \n * @see org.jdom2.input.sax\n * @author Rolf Lear\n ",
      "methods": {
        "getDriverClassName": {
          "Javadoc": "* Get the SAX Driver class name used to boostrap XMLReaders.\n\t * \n\t * @return The name of the SAX Driver class (null for SAX2 default class)."
        }
      }
    },
    "org.jdom2.input.sax.XMLReaderSchemaFactory": {
      "Javadoc": "\n * This {@link XMLReaderJDOMFactory} class returns XMLReaders configured to\n * validate against the supplied Schema instance. The Schema could be an XSD\n * schema or some other schema supported by SAX (e.g. RelaxNG). The SAX Parser\n * is obtained through the JAXP process.\n * <p>\n * If you want to validate an XML document against the XSD references embedded\n * in the XML itself (xsdSchemaLocation) then you do not want to use this class\n * but rather use an alternate means like\n * {@link XMLReaders#XSDVALIDATING}.\n * <p>\n * See the {@link org.jdom2.input.sax package documentation} for the best\n * alternatives.\n * \n * @see org.jdom2.input.sax\n * @author Rolf Lear\n "
    },
    "org.jdom2.input.sax.XMLReaderXSDFactory": {
      "Javadoc": "\n * This XMLReaderJDOMFactory class returns XMLReaders configured to validate\n * against the supplied XML Schema (XSD) instance. The SAX Parser is obtained through\n * the JAXP process.\n * \n * <p>\n * This class has var-arg constructors, accepting potentially many XSD sources.\n * It is just as simple though to have a single source:\n * \n * <pre>\n * File xsdfile = new File(&quot;schema.xsd&quot;);\n * XMLReaderJDOMFactory schemafac = new XMLReaderXSDFactory(xsdfile);\n * SAXBuilder builder = new SAXBuilder(schemafac);\n * File xmlfile = new File(&quot;data.xml&quot;);\n * Document validdoc = builder.build(xmlfile);\n * </pre>\n * \n * @see org.jdom2.input.sax\n * @author Rolf Lear\n "
    },
    "org.jdom2.input.SAXBuilder": {
      "Javadoc": "\n * Builds a JDOM Document using a SAX parser.\n * <p>\n * SAXbuilder uses a third-party SAX parser (chosen by JAXP by default, or you\n * can configure it manually) to handle the parsing duties and uses an instance\n * of a SAXHandler to listen to the SAX events in order to construct a document\n * with JDOM content using a JDOMFactory. Information about SAX can be found at\n * <a href=\"http://www.saxproject.org\">http://www.saxproject.org</a>.\n * <p>\n * For a complete description of how SAXBuilder is used, and how to customise\n * the process you should look at the {@link org.jdom2.input.sax} package\n * documentation.\n * <p>\n * JDOM users needing to customise the SAX parsing process have traditionally\n * sub-classed this SAXBuilder class. In JDOM2 this should never be necessary.\n * Please read the full documentation of this class, {@link SAXHandler},\n * {@link SAXHandlerFactory}, {@link JDOMFactory}, and the package documentation\n * for {@link org.jdom2.input.sax} before overriding this class. Future versions\n * of JDOM2 may make this class 'final'. I you feel you have a good reason to\n * subclass SAXBuilder please mention it on <a\n * href=\"http://www.jdom.org/involved/lists.html\">jdom-interest</a> mailing list\n * so that SAXBuilder can be extended or adapted to handle your use-case.\n * <p>\n * Neither SAXBuilder nor anything derived from SAXBuilder is thread-safe. You\n * must ensure that SAXBuilder is used in a single thread, or that sufficient\n * locking is in place to ensure that SAXBuilder is not concurrently accessed.\n * See the special note on {@link #buildEngine()}. \n * <p>\n * Known issues:\n * <ul>\n * <li>Relative paths for a {@link DocType} or {@link EntityRef} may be\n * converted by the SAX parser into absolute paths.\n * <li>SAX does not recognise whitespace character content outside the root\n * element (nor does JDOM) so any formatting outside the root Element will be\n * lost.\n * </ul>\n * \n * @see org.jdom2.input.sax\n * @author Jason Hunter\n * @author Brett McLaughlin\n * @author Dan Schaffer\n * @author Philip Nelson\n * @author Alex Rosen\n * @author Rolf Lear\n ",
      "methods": {
        "getDriverClass": {
          "Javadoc": "* Returns the driver class assigned in the constructor, or null if none.\n\t * The driver class is only available if a SAX2 source was specified. This\n\t * method is available for backward-compatibility with JDOM 1.x\n\t * \n\t * @return the driver class assigned in the constructor\n\t * @deprecated as the driver class is only available in limited situations\n\t *             and anyway it had to be supplied in a constructor as either a\n\t *             direct value or as an {@link XMLReaderSAX2Factory} instance."
        },
        "getFactory": {
          "Javadoc": "* Returns the current {@link org.jdom2.JDOMFactory} in use.\n\t * \n\t * @return the factory in use\n\t * @deprecated as it is replaced by {@link #getJDOMFactory()}"
        },
        "getJDOMFactory": {
          "Javadoc": "* Returns the current {@link org.jdom2.JDOMFactory} in use.\n\t * \n\t * @return the factory in use"
        },
        "setFactory": {
          "Javadoc": "* This sets a custom JDOMFactory for the builder. Use this to build the\n\t * tree with your own subclasses of the JDOM classes.\n\t * \n\t * @param factory\n\t *        <code>JDOMFactory</code> to use\n\t * @deprecated as it is replaced by {@link #setJDOMFactory(JDOMFactory)}"
        },
        "setJDOMFactory": {
          "Javadoc": "* This sets a custom JDOMFactory for the builder. Use this to build the\n\t * tree with your own subclasses of the JDOM classes.\n\t * \n\t * @param factory\n\t *        <code>JDOMFactory</code> to use"
        },
        "getXMLReaderFactory": {
          "Javadoc": "* Get the current XMLReader factory.\n\t * \n\t * @return the current JDOMXMLReaderFactory"
        },
        "setXMLReaderFactory": {
          "Javadoc": "* Set the current XMLReader factory.\n\t * \n\t * @param rfac\n\t *        the JDOMXMLReaderFactory to set. A null rfac will indicate the\n\t *        default {@link XMLReaders#NONVALIDATING}"
        },
        "getSAXHandlerFactory": {
          "Javadoc": "* Get the SAXHandlerFactory used to supply SAXHandlers to this SAXBuilder.\n\t * \n\t * @return the current SAXHandlerFactory (never null)."
        },
        "setSAXHandlerFactory": {
          "Javadoc": "* Set the SAXHandlerFactory to be used by this SAXBuilder.\n\t * \n\t * @param factory\n\t *        the required SAXHandlerFactory. A null input factory will request\n\t *        the {@link DefaultSAXHandlerFactory}."
        },
        "getValidation": {
          "Javadoc": "* Returns whether validation is to be performed during the build.\n\t * \n\t * @return whether validation is to be performed during the build\n\t * @deprecated in lieu of {@link #isValidating()}"
        },
        "isValidating": {
          "Javadoc": "* Returns whether validation is to be performed during the build.\n\t * \n\t * @return whether validation is to be performed during the build"
        },
        "setValidation": {
          "Javadoc": "* This sets validation for the builder.\n\t * <p>\n\t * <b>Do Not Use</b>\n\t * <p>\n\t * JDOM2 introduces the concept of XMLReader factories. The XMLReader is\n\t * what determines the type of validation. A simple boolean is not enough to\n\t * indicate what sort of validation is required. The\n\t * {@link #setXMLReaderFactory(XMLReaderJDOMFactory)} method provides a\n\t * means to be more specific about validation.\n\t * <p>\n\t * For backward compatibility this method has been retained, but its use is\n\t * discouraged. It does make some logical choices though. The code is\n\t * equivalent to:\n\t * <p>\n\t * \n\t * <pre>\n\t * setXMLReaderFactory(XMLReaders.DTDVALIDATING)\n\t * </pre>\n\t * \n\t * for true, and\n\t * \n\t * <pre>\n\t * setXMLReaderFactory(XMLReaders.NONVALIDATING)\n\t * </pre>\n\t * \n\t * for false.\n\t * \n\t * @see #setXMLReaderFactory(XMLReaderJDOMFactory)\n\t * @see XMLReaders#NONVALIDATING\n\t * @see XMLReaders#DTDVALIDATING\n\t * @param validate\n\t *        <code>boolean</code> indicating whether validation should occur.\n\t * @deprecated use {@link #setXMLReaderFactory(XMLReaderJDOMFactory)}"
        },
        "getErrorHandler": {
          "Javadoc": "* Returns the {@link ErrorHandler} assigned, or null if none. When the\n\t * SAXBuilder parses a document it will always have an ErrorHandler but it\n\t * will be an instance of {@link BuilderErrorHandler} unless you specify a\n\t * different ErrorHandler in {@link #setErrorHandler(ErrorHandler)}. In\n\t * other words, a null return value from here indicates a default will be\n\t * used.\n\t * \n\t * @return the ErrorHandler assigned, or null if SAXBuilder will create a\n\t *         default ErrorHandler when needed."
        },
        "setErrorHandler": {
          "Javadoc": "* This sets custom ErrorHandler for the Builder. Setting a null value will\n\t * indicate SAXBuilder should create a default ErrorHandler when needed.\n\t * \n\t * @param errorHandler\n\t *        <code>ErrorHandler</code>"
        },
        "getEntityResolver": {
          "Javadoc": "* Returns the {@link EntityResolver} assigned, or null if none.\n\t * \n\t * @return the EntityResolver assigned"
        },
        "setEntityResolver": {
          "Javadoc": "* This sets custom EntityResolver for the <code>Builder</code>.\n\t * \n\t * @param entityResolver\n\t *        <code>EntityResolver</code>"
        },
        "getDTDHandler": {
          "Javadoc": "* Returns the {@link DTDHandler} assigned, or null if the assigned\n\t * {@link SAXHandler} will be used for DTD SAX events.\n\t * \n\t * @return the DTDHandler assigned"
        },
        "setDTDHandler": {
          "Javadoc": "* This sets custom DTDHandler for the <code>Builder</code>. Setting a null\n\t * value indicates that SAXBuilder should use the assigned SAXHandler for\n\t * DTD processing.\n\t * \n\t * @param dtdHandler\n\t *        <code>DTDHandler</code>"
        },
        "getXMLFilter": {
          "Javadoc": "* Returns the {@link XMLFilter} used during parsing, or null if none.\n\t * \n\t * @return the XMLFilter used during parsing"
        },
        "setXMLFilter": {
          "Javadoc": "* This sets a custom {@link org.xml.sax.XMLFilter} for the builder.\n\t * <p>\n\t * Care should be taken to ensure that the specified xmlFilter is reentrant\n\t * and thread-safe.\n\t * <p>\n\t * SAXBuilder will set this instance as the parent instance for all\n\t * XMLReaders that may be created, and these may (depending on SAXBuilder\n\t * usage) be accessed concurrently. It is the responsibility of the JDOM\n\t * user to ensure that if the XMLFilter is not thread-safe then neither the\n\t * SAXBuilder nor any of it's SAXEngines are accessed concurrently.\n\t * \n\t * @param xmlFilter\n\t *        the XMLFilter to use"
        },
        "getIgnoringElementContentWhitespace": {
          "Javadoc": "* Returns whether element content whitespace is to be ignored during the\n\t * build.\n\t * \n\t * @return whether element content whitespace is to be ignored during the\n\t *         build"
        },
        "setIgnoringElementContentWhitespace": {
          "Javadoc": "* Specifies whether or not the parser should eliminate whitespace in\n\t * element content (sometimes known as \"ignorable whitespace\") when building\n\t * the document. Only whitespace which is contained within element content\n\t * that has an element only content model will be eliminated (see XML Rec\n\t * 3.2.1). For this setting to take effect requires that validation be\n\t * turned on. The default value of this setting is <code>false</code>.\n\t * \n\t * @param ignoringWhite\n\t *        Whether to ignore ignorable whitespace"
        },
        "getIgnoringBoundaryWhitespace": {
          "Javadoc": "* Returns whether or not the parser will eliminate element content\n\t * containing only whitespace.\n\t * \n\t * @return <code>boolean</code> - whether only whitespace content will be\n\t *         ignored during build.\n\t * @see #setIgnoringBoundaryWhitespace"
        },
        "setIgnoringBoundaryWhitespace": {
          "Javadoc": "* Specifies whether or not the parser should elminate boundary whitespace,\n\t * a term that indicates whitespace-only text between element tags. This\n\t * feature is a lot like\n\t * {@link #setIgnoringElementContentWhitespace(boolean)} but this feature is\n\t * more aggressive and doesn't require validation be turned on. The\n\t * {@link #setIgnoringElementContentWhitespace(boolean)} call impacts the\n\t * SAX parse process while this method impacts the JDOM build process, so it\n\t * can be beneficial to turn both on for efficiency. For implementation\n\t * efficiency, this method actually removes all whitespace-only text()\n\t * nodes. That can, in some cases (like between an element tag and a\n\t * comment) include whitespace that isn't just boundary whitespace. The\n\t * default is <code>false</code>.\n\t * \n\t * @param ignoringBoundaryWhite\n\t *        Whether to ignore whitespace-only text nodes"
        },
        "getExpandEntities": {
          "Javadoc": "* Returns whether or not entities are being expanded into normal text\n\t * content.\n\t * \n\t * @return whether entities are being expanded"
        },
        "setExpandEntities": {
          "Javadoc": "* <p>\n\t * This sets whether or not to expand entities for the builder. A true means\n\t * to expand entities as normal content. A false means to leave entities\n\t * unexpanded as <code>EntityRef</code> objects. The default is true.\n\t * </p>\n\t * <p>\n\t * When this setting is false, the internal DTD subset is retained; when\n\t * this setting is true, the internal DTD subset is not retained.\n\t * </p>\n\t * <p>\n\t * Note that Xerces (at least up to 1.4.4) has a bug where entities in\n\t * attribute values will be incorrectly reported if this flag is turned off,\n\t * resulting in entities appearing within element content. When turning\n\t * entity expansion off either avoid entities in attribute values, or use\n\t * another parser like Crimson.\n\t * http://nagoya.apache.org/bugzilla/show_bug.cgi?id=6111\n\t * </p>\n\t * \n\t * @param expand\n\t *        <code>boolean</code> indicating whether entity expansion should\n\t *        occur."
        },
        "getReuseParser": {
          "Javadoc": "* Returns whether the contained SAX parser instance is reused across\n\t * multiple parses. The default is true.\n\t * \n\t * @return whether the contained SAX parser instance is reused across\n\t *         multiple parses"
        },
        "setReuseParser": {
          "Javadoc": "* Specifies whether this builder will reuse the same SAX parser when\n\t * performing subsequent parses or allocate a new parser for each parse. The\n\t * default value of this setting is <code>true</code> (parser reuse).\n\t * <p>\n\t * <strong>Note</strong>: SAX parser instances are not thread safe (they are\n\t * not even reentrant), and nor are SAXBuilder instances. Setting parser\n\t * reuse does not imply the parser is thread-safe.\n\t * </p>\n\t * \n\t * @param reuseParser\n\t *        Whether to reuse the SAX parser."
        },
        "setFastReconfigure": {
          "Javadoc": "* Specifies whether this builder will do fast reconfiguration of the\n\t * underlying SAX parser when reuseParser is true. This improves performance\n\t * in cases where SAXBuilders are reused and lots of small documents are\n\t * frequently parsed. This avoids attempting to set features on the SAX\n\t * parser each time build() is called which result in\n\t * SaxNotRecognizedExceptions. This should ONLY be set for builders where\n\t * this specific case is an issue. The default value of this setting is\n\t * <code>false</code> (no fast reconfiguration). If reuseParser is false,\n\t * calling this has no effect.\n\t * \n\t * @param fastReconfigure\n\t *        Whether to do a fast reconfiguration of the parser\n\t * @deprecated All reused Parsers are now fast-reconfigured. No need to set\n\t *             it."
        },
        "setFeature": {
          "Javadoc": "* This sets a feature on the SAX parser. See the SAX documentation for\n\t * more information. </p>\n\t * <p>\n\t * NOTE: SAXBuilder requires that some particular features of the SAX parser\n\t * be set up in certain ways for it to work properly. The list of such\n\t * features may change in the future. Therefore, the use of this method may\n\t * cause parsing to break, and even if it doesn't break anything today it\n\t * might break parsing in a future JDOM version, because what JDOM parsers\n\t * require may change over time. Use with caution.\n\t * </p>\n\t * JDOM uses {@link XMLReaderJDOMFactory} instances to provide XMLReader\n\t * instances. If you require special configuration on your XMLReader you\n\t * should consider extending or implementing an XMLReaderJDOMFactory in the\n\t * {@link org.jdom2.input.sax} package.\n\t * \n\t * @param name\n\t *        The feature name, which is a fully-qualified URI.\n\t * @param value\n\t *        The requested state of the feature (true or false)."
        },
        "setProperty": {
          "Javadoc": "* This sets a property on the SAX parser. See the SAX documentation for\n\t * more information.\n\t * <p>\n\t * NOTE: SAXBuilder requires that some particular properties of the SAX\n\t * parser be set up in certain ways for it to work properly. The list of\n\t * such properties may change in the future. Therefore, the use of this\n\t * method may cause parsing to break, and even if it doesn't break anything\n\t * today it might break parsing in a future JDOM version, because what JDOM\n\t * parsers require may change over time. Use with caution.\n\t * </p>\n\t * JDOM uses {@link XMLReaderJDOMFactory} instances to provide XMLReader\n\t * instances. If you require special configuration on your XMLReader you\n\t * should consider extending or implementing an XMLReaderJDOMFactory in the\n\t * {@link org.jdom2.input.sax} package.\n\t * \n\t * @param name\n\t *        The property name, which is a fully-qualified URI.\n\t * @param value\n\t *        The requested value for the property."
        },
        "buildEngine": {
          "Javadoc": "* This method builds a new and reusable {@link SAXEngine}.\n\t * Each time this method is called a new instance of a SAXEngine will be\n\t * returned.\n\t * <p>\n\t * This method is used internally by the various SAXBuilder.build(*) methods\n\t * (if any configuration has changed) but can also be used as a mechanism\n\t * for creating SAXEngines to be used in parsing pools or other optimised\n\t * structures.\n\t * \n\t * @return a {@link SAXEngine} representing the current state of the\n\t *         current SAXBuilder settings.\n\t * @throws JDOMException\n\t *         if there is any problem initialising the engine."
        },
        "createParser": {
          "Javadoc": "* Allow overriding classes access to the Parser before it is used in a\n\t * SAXBuilderEngine.\n\t * \n\t * @return a XMLReader parser.\n\t * @throws JDOMException\n\t *         if there is a problem"
        },
        "getEngine": {
          "Javadoc": "* This method retrieves (or builds) a SAXBuilderEngine that represents the\n\t * current SAXBuilder state.\n\t * \n\t * @return a {@link SAXBuilderEngine} representing the current state of the\n\t *         current SAXBuilder settings.\n\t * @throws JDOMException\n\t *         if there is any problem initializing the engine."
        },
        "configureParser": {
          "Javadoc": "* This configures the XMLReader to be used for reading the XML document.\n\t * <p>\n\t * The default implementation sets various options on the given XMLReader,\n\t * such as validation, DTD resolution, entity handlers, etc., according to\n\t * the options that were set (e.g. via <code>setEntityResolver</code>) and\n\t * set various SAX properties and features that are required for JDOM\n\t * internals. These features may change in future releases, so change this\n\t * behavior at your own risk.\n\t * </p>\n\t * \n\t * @param parser\n\t *        the XMLReader to configure.\n\t * @param contentHandler\n\t *        The SAXHandler to use for the XMLReader\n\t * @throws JDOMException\n\t *         if configuration fails."
        },
        "internalSetFeature": {
          "Javadoc": "* Tries to set a feature on the parser. If the feature cannot be set,\n\t * throws a JDOMException describing the problem."
        },
        "internalSetProperty": {
          "Javadoc": "* <p>\n\t * Tries to set a property on the parser. If the property cannot be set,\n\t * throws a JDOMException describing the problem.\n\t * </p>"
        },
        "build": {
          "Javadoc": "* <p>\n\t * This builds a document from the supplied URI. The URI is typically a file name, or a URL.\n\t * Do not use this method for parsing XML content that is in a Java String variable.\n\t * <p>\n\t * <ul>\n\t * <li><Strong>Right:</Strong> <code>....build(\"path/to/file.xml\");</code>\n\t * <li><Strong>Right:</Strong> <code>....build(\"http://my.example.com/xmlfile\");</code>\n\t * <li><Strong>Wrong:</Strong> <code>....build(\"&lt;root>data&lt/root>\");</code>\n\t * </ul>\n\t * </p>\n\t * If your XML content is in a Java String variable and you want to parse it, then use:<br/>\n\t * <code>    ....build(new StringReader(\"&lt;root>data&lt/root>\"));</code>\n\t * <p>\n\t * \n\t * @param systemId\n\t *        URI for the input\n\t * @return <code>Document</code> resultant Document object\n\t * @throws JDOMException\n\t *         when errors occur in parsing\n\t * @throws IOException\n\t *         when an I/O error prevents a document from being fully parsed"
        }
      }
    },
    "org.jdom2.input.stax.DefaultStAXFilter": {
      "Javadoc": "\n * This DefaultStAXFilter includes all content and prunes nothing.\n * <p>\n * Override this class to make adjustments to get the results you need.\n * \n * @see StAXFilter\n * \n * @author Rolf Lear\n "
    },
    "org.jdom2.input.stax.DTDParser": {
      "Javadoc": "\n * Parses out key information from a single String representing a DOCTYPE\n * declaration. StAX parsers supply a single string representing the DOCTYPE and\n * this needs to be processed to get items like the SystemID, etc. Additionally\n * it needs to be reformatted to create a standardised representation.\n * <p>\n * The assumption is that the DTD is valid.\n * <p>\n * We need to pull out 4 elements of data:\n * <ol>\n * <li>The root element name\n * <li>The SystemID (if available)\n * <li>The PublicID (if available)\n * <li>The internal subset (if available)\n * </ol>\n * \n * The internal-subset should be re-formatted to conform to the JDOM 'standard'\n * where each declaration starts on a new line indented with 2 spaces. This\n * 'standard' is defined by the way that JDOM formats the DTD declarations in the \n * SAX parse process, which fires individual events for the content in the DTD.\n * <p>\n * We can do this all with a well-structured regular expression, which is\n * actually simpler than trying to fish out all the components ourselves....\n * <p>\n * \n * @author Rolf Lear\n *\n ",
      "methods": {
        "populatePatterns": {
          "Javadoc": "* This builds a substitution map containing the raw patterns for\n\t * certain types of content we expect.\n\t * @return The populated map."
        },
        "buildPattern": {
          "Javadoc": "* This method substitutes the simple tokens in the meta-pattern with\n\t * the declared values in the map.\n\t * @param map The map containing substitution tokens/patterns\n\t * @param input The meta-pattern to do the substitutions on.\n\t * @return The substituted pattern"
        },
        "getGroup": {
          "Javadoc": "* Looks in any number of matched groups for a value. Returns the first set\n\t * value. The assumption is that, depending on the pattern matches, the\n\t * value could be in a few different locations.\n\t * @param mat The match that has succeeded\n\t * @param groups The groups to check for a value.\n\t * @return The first found value."
        },
        "isWhite": {
          "Javadoc": "* return true if the input character is one of the types recognized in the\n\t * DTD spec.\n\t * @param ch The char to check\n\t * @return true if it is a space, tab, newline, or carriage-return."
        },
        "formatInternal": {
          "Javadoc": "* Reformat an internal subset.... Each declaration starts on an indented\n\t * newline.\n\t * @param internal the input DocType declaration as found in a StAX Reader.\n\t * @return the formatted input."
        },
        "parse": {
          "Javadoc": "* Parse out a DOCTYPE declaration as supplied by the standard StAX\n\t * readers.\n\t * <p>\n\t * Using 'XML' terminology, this method assumes that the input is\n\t * both 'well-formed' and 'valid'. The assumptions that this class makes\n\t * ensure that the 'right thing' is done for valid content, but invalid\n\t * content may or may not fail with a JDOMException. The behaviour of this\n\t * method with invalid input is 'undefined'.\n\t * \n\t * @param input the input DOCTYPE string to parse. Must be valid.\n\t * @param factory The JDOM factory to use to build the JDOM DocType.\n\t * @return The input string as a DocType.\n\t * @throws JDOMException if the DocType is not generated."
        }
      }
    },
    "org.jdom2.input.stax.StAXFilter": {
      "Javadoc": "\n * In StAX Processing it is possible to read fragments of XML. JDOM supports\n * reading JDOM Content from StAX Readers in fragments. JDOM users can influence\n * the content that is processed by the return values in this interface.\n * <p>\n * Using the StAXStreamBuilder or StAXEventBuilder you can parse a List of\n * JDOM content by filtering that content with an instance of this filter.\n * <p>\n * There are two significant states in which methods in this interface will be\n * called:\n * <ul>\n * <li> We are not currently including any content, and we want to know whether\n *      the current StAX content should be included.\n * <li> We are currently inside an Element that this filter has indicated should\n *      be included, but perhaps you want to prune some content.\n * </ul>\n *  \n * @author Rolf Lear\n *\n ",
      "methods": {
        "includeDocType": {
          "Javadoc": "* The current event is a DocType event.\n\t * @return true if the DocType should become a JDOM Fragment."
        },
        "includeElement": {
          "Javadoc": "* The current event is an Element event.\n\t * <p>\n\t * If the return value of this call is true, then this Element will be \n\t * processed as a JDOM fragment. You may then get calls to the prune*\n\t * methods to determine whether child content of this Element should be\n\t * pruned.\n\t * \n\t * @param depth The depth of this content from the document root\n\t * \t\t\t(the root Element is at depth 0)\n\t * @param name The XML tag name of this Element\n\t * @param ns The Namespace of this Element\n\t * @return true if the Element should become a JDOM Fragment."
        },
        "includeComment": {
          "Javadoc": "* The current event is a Comment event.\n\t * <p>\n\t * A null return value will cause the Comment to be ignored, and a non-null\n\t * return value will become the Comment's text.\n\t * <p>\n\t * To include the comment as-is, do:\n\t * <br>\n\t * <pre>\n\t * public String includeComment(int depth, String comment) {\n\t *     return comment;\n\t * }\n\t * </pre>\n\t * @param depth The depth of this content from the document root\n\t * \t\t\t(the root Element is at depth 0)\n\t * @param comment The Comment value\n\t * @return null if you want to exclude this comment, or a non-null value\n\t *        which will become the new comment value."
        },
        "includeEntityRef": {
          "Javadoc": "* The current event is an EntityRef event.\n\t * <p>\n\t * @param depth The depth of this content from the document root\n\t * \t\t\t(the root Element is at depth 0)\n\t * @param name The EntityRef name\n\t * @return true if you want to include this EntityRef."
        },
        "includeCDATA": {
          "Javadoc": "* The current event is a CDATA event.\n\t * <p>\n\t * A null return value will cause the Comment to be ignored, and a non-null\n\t * return value will become the CDATA's text.\n\t * <p>\n\t * To include the CDATA as-is, do:\n\t * <br>\n\t * <pre>\n\t * public String includeCDATA(int depth, String text) {\n\t *     return text;\n\t * }\n\t * </pre>\n\t * @param depth The depth of this content from the document root\n\t * \t\t\t(the root Element is at depth 0)\n\t * @param text The CDATA text value\n\t * @return null if you want to exclude this CDATA, or a non-null value\n\t *        which will become the new CDATA text value."
        },
        "includeText": {
          "Javadoc": "* The current event is a TEXT event.\n\t * <p>\n\t * A null return value will cause the Comment to be ignored, and a non-null\n\t * return value will become the Text's text.\n\t * <p>\n\t * To include the Text as-is, do:\n\t * <br>\n\t * <pre>\n\t * public String includeText(int depth, String text) {\n\t *     return text;\n\t * }\n\t * </pre>\n\t * @param depth The depth of this content from the document root\n\t * \t\t\t(the root Element is at depth 0)\n\t * @param text The Text value\n\t * @return null if you want to exclude this Text, or a non-null value\n\t *        which will become the new Text value."
        },
        "includeProcessingInstruction": {
          "Javadoc": "* The current event is a ProcessingInstruction event.\n\t * <p>\n\t * @param depth The depth of this content from the document root\n\t * \t\t\t(the root Element is at depth 0)\n\t * @param target The ProcessingInstruction Target value\n\t * @return true if you want to include this ProcessingInstruction."
        },
        "pruneElement": {
          "Javadoc": "* An Element is being included, and this is a child Element event of the\n\t * included parent Element. Should this Child Element be pruned from the\n\t * parent fragment?\n\t * @param depth The depth of this content from the document root\n\t * \t\t\t(the root Element is at depth 0)\n\t * @param name The XML tag name of this child Element\n\t * @param ns The Namespace of this child Element\n\t * @return true if the child Element should be excluded."
        },
        "pruneComment": {
          "Javadoc": "* An Element is being included, and this is a child Comment event of the\n\t * included parent Element. Should this child Comment be pruned from the\n\t * parent fragment?\n\t * <p>\n\t * A non-null return value will become the Comment value. Return null to\n\t * skip the Comment.\n\t * <p>\n\t * To include the Comment as-is, do:\n\t * <br>\n\t * <pre>\n\t * public String pruneComment(int depth, String comment) {\n\t *     return comment;\n\t * }\n\t * </pre>\n\t * @param depth The depth of this content from the document root\n\t * \t\t\t(the root Element is at depth 0)\n\t * @param comment The Comment value\n\t * @return null if you want to exclude this Comment, or a non-null value\n\t *        which will become the new Comment value."
        },
        "pruneEntityRef": {
          "Javadoc": "* An Element is being included, and this is a child EntityRef event of the\n\t * included parent Element. Should this child EntityRef be pruned from the\n\t * parent fragment?\n\t * <p>\n\t * @param depth The depth of this content from the document root\n\t * \t\t\t(the root Element is at depth 0)\n\t * @param name The EntityRef name\n\t * @return true if you want to exclude this EntityRef."
        },
        "pruneCDATA": {
          "Javadoc": "* An Element is being included, and this is a child CDATA event of the\n\t * included parent Element. Should this child CDATA be pruned from the\n\t * parent fragment?\n\t * <p>\n\t * A non-null return value will become the CDATA text. Return null to skip\n\t * the CDATA.\n\t * <p>\n\t * To include the CDATA as-is, do:\n\t * <br>\n\t * <pre>\n\t * public String pruneCDATA(int depth, String text) {\n\t *     return text;\n\t * }\n\t * </pre>\n\t * @param depth The depth of this content from the document root\n\t * \t\t\t(the root Element is at depth 0)\n\t * @param text The CDATA text value\n\t * @return null if you want to exclude this CDATA, or a non-null value\n\t *        which will become the new CDATA text value."
        },
        "pruneText": {
          "Javadoc": "* An Element is being included, and this is a child Text event of the\n\t * included parent Element. Should this child Text be pruned from the\n\t * parent fragment?\n\t * <p>\n\t * A non-null return value will become the Text. Return null to skip\n\t * the Text.\n\t * <p>\n\t * To include the Text as-is, do:\n\t * <br>\n\t * <pre>\n\t * public String pruneText(int depth, String text) {\n\t *     return text;\n\t * }\n\t * </pre>\n\t * @param depth The depth of this content from the document root\n\t * \t\t\t(the root Element is at depth 0)\n\t * @param text The Text value\n\t * @return null if you want to exclude this Text, or a non-null value\n\t *        which will become the new Text value."
        },
        "pruneProcessingInstruction": {
          "Javadoc": "* An Element is being included, and this is a child ProcessingInstruction\n\t * event of the included parent Element. Should this ProcessingInstruction\n\t * be pruned from the parent fragment?\n\t * <p>\n\t * @param depth The depth of this content from the document root\n\t * \t\t\t(the root Element is at depth 0)\n\t * @param target The ProcessingInstruction Target value\n\t * @return true if you want to exclude this ProcessingInstruction."
        }
      }
    },
    "org.jdom2.input.StAXEventBuilder": {
      "Javadoc": "\n * Builds a JDOM Document from a StAX-based XMLEventReader.\n * <p>\n * XMLEventReaders are pre-configured and as a result JDOM is not able to\n * alter whether the input is validated, or whether the Events have escaped\n * entities or not. These (and other) characteristics are configurable by\n * setting the correct features and properties on the XMLInputFactory when it\n * is used to create the XMLStreamReader.\n * <p>\n * Useful configuration to set, or know about is:\n * <ul>\n * <li>StAX Events seldom differentiate between Text and CDATA content. You\n * will likely want to configure your StAX factory (XMLInputFactory) with\n * <code>http://java.sun.com/xml/stream/properties/report-cdata-event</code>\n * for the default Java StAX implementation, or the equivalent property for your\n * StAX engine.\n * <li>The remaining XMLInputFactory settings are likely to work fine at their\n * default values.\n * <li>StAX is not likely to be your best option if you want a validating\n * parser, at least not with the default (built-in Java implementation in Java6 \n * which does not support it). Consider a SAX parser.\n * </ul>\n * <p>\n * From a JDOM perspective XMLStreamReaders are more efficient than \n * XMLEventReaders. Where possible use an XMLStreamReader.\n * <p>\n * If you happen to be looking at the source code, pay careful attention to the\n * imports so you know what type of instance is being processed, whether it is\n * a StAX class, or a JDOM class, because there are name conflicts.\n * \n * @author Rolf Lear\n *\n ",
      "methods": {
        "process": {
          "Javadoc": "* Create a Document from an XMLEventReader\n\t * @param factory the {@link JDOMFactory} to use\n\t * @param stream the XMLEventReader to read from\n\t * @return the parsed Document\n\t * @throws JDOMException if there is any issue\n\t * \t\t\t\t(XMLStreamExceptions are wrapped)."
        },
        "getFactory": {
          "Javadoc": "* Returns the current {@link org.jdom2.JDOMFactory} in use.\n\t * @return the factory in use"
        },
        "setFactory": {
          "Javadoc": "* This sets a custom JDOMFactory for the builder.  Use this to build\n\t * the tree with your own subclasses of the JDOM classes.\n\t *\n\t * @param factory <code>JDOMFactory</code> to use"
        },
        "build": {
          "Javadoc": "* This builds a document from the supplied\n\t * XMLEventReader.\n\t * <p>\n\t * The JDOMContent will be built by the current JDOMFactory.\n\t *\n\t * @param events <code>XMLEventReader</code> to read from\n\t * @return <code>Document</code> resultant Document object\n\t * @throws JDOMException when errors occur in parsing"
        }
      }
    },
    "org.jdom2.input.StAXStreamBuilder": {
      "Javadoc": "\n * Builds a JDOM Document from a StAX-based XMLStreamReader.\n * <p>\n * XMLStreamReaders are pre-configured and as a result JDOM is not able to\n * alter whether the input is validated, or whether the Stream has escaped\n * entities or not. These (and other) characteristics are configurable by\n * setting the correct features and properties on the XMLInputFactory when it\n * is used to create the XMLStreamReader.\n * <p>\n * Useful configuration to set, or know about is:\n * <ul>\n * <li>StAX streams seldom differentiate between Text and CDATA content. You\n * will likely want to configure your StAX factory (XMLInputFactory) with\n * <code>http://java.sun.com/xml/stream/properties/report-cdata-event</code>\n * for the default Java StAX implementation, or the equivalent property for your\n * StAX engine.\n * <li>The remaining XMLInputFactory settings are likely to work fine at their\n * default values.\n * <li>StAX is not likely to be your best option if you want a validating\n * parser, at least not with the default (built-in Java implementation in Java6 \n * which does not support it). Consider a SAX parser.\n * </ul>\n * <p>\n * From a JDOM perspective XMLStreamReaders are more efficient than \n * XMLEventReaders. Where possible use an XMLStreamReader.\n * <p>\n * If you happen to be looking at the source code, pay careful attention to the\n * imports so you know what type of instance is being processed, whether it is\n * a StAX class, or a JDOM class, because there are name conflicts.\n * \n * @author Rolf Lear\n *\n ",
      "methods": {
        "process": {
          "Javadoc": "* Create a Document from an XMLStreamReader\n\t * @param factory The {@link JDOMFactory} to use\n\t * @param stream The XMLStreamReader to read from\n\t * @return the parsed Document\n\t * @throws JDOMException if there is any issue\n\t * \t\t\t\t(XMLStreamExceptions are wrapped)."
        },
        "processFragment": {
          "Javadoc": "* Create a Content from an XMLStreamReader\n\t * The stream is advanced to the event after the current event (or to the\n\t * event after the matching END_ELEMENT for an Element fragment).\n\t * @param factory The {@link JDOMFactory} to use\n\t * @param stream The XMLStreamReader to read from\n\t * @return the parsed Document\n\t * @throws JDOMException if there is any issue\n\t * \t\t\t\t(XMLStreamExceptions are wrapped)."
        },
        "getFactory": {
          "Javadoc": "* Returns the current {@link org.jdom2.JDOMFactory} in use.\n\t * @return the factory in use"
        },
        "setFactory": {
          "Javadoc": "* This sets a custom JDOMFactory for the builder.  Use this to build\n\t * the tree with your own subclasses of the JDOM classes.\n\t *\n\t * @param factory <code>JDOMFactory</code> to use"
        },
        "build": {
          "Javadoc": "* This builds a document from the supplied\n\t * XMLStreamReader.\n\t * <p>\n\t * The JDOMContent will be built by the current JDOMFactory.\n\t *\n\t * @param reader <code>XMLStreamReader</code> to read from\n\t * @return <code>Document</code> resultant Document object\n\t * @throws JDOMException when errors occur in parsing"
        },
        "buildFragments": {
          "Javadoc": "* Read the entire XMLStreamReader and from it build a list of Content that\n\t * conforms to the rules in the supplied StAXFilter.\n\t * @param reader The XMLStreamReader to parse\n\t * @param filter The Filter to use for the Content\n\t * @return a List of Content that were identified by the supplied filter\n\t * @throws JDOMException if there was a parsing problem."
        },
        "fragment": {
          "Javadoc": "* Read the current XML Fragment from the XMLStreamReader.\n\t * The XMLStreamReader must be at some 'content' state, it cannot be\n\t * at START_DOCUMENT, for example.\n\t * @param reader The XMLStreamReader to read the next fragment from\n\t * @return The JDOM fragment at the current position in the reader\n\t * @throws JDOMException if there is an issue with the state of the\n\t * XMLStreamReader or some other issue with the processing."
        }
      }
    },
    "org.jdom2.internal.ArrayCopy": {
      "Javadoc": "\n * The copyOf methods on java.util.Arrays are introduced in Java6. Need an\n * alternative to support Java5.\n * \n * @author Rolf Lear\n *\n ",
      "methods": {
        "copyOf": {
          "Javadoc": "* Arrays.copyOf(...) is a Java6 thing. This is a replacement.\n\t * @param source the source array.\n\t * @param len the length of the new array copy.\n\t * @return a new array that has the same elements as the source."
        },
        "copyOfRange": {
          "Javadoc": "* Arrays.copyOf(...) is a Java6 thing. This is a replacement.\n\t * @param <E> The generic type of the array we are copying.\n\t * @param source the source array.\n\t * @param from the start point of the copy (inclusive).\n\t * @param to the end point of the copy (exclusive).\n\t * @return a new array that has the same elements as the source."
        }
      }
    },
    "org.jdom2.internal.ReflectionConstructor": {
      "Javadoc": "\n * Utility class that handles constructing a class using reflection, and a\n * no-argument 'default' constructor.\n * \n * @author Rolf Lear\n *\n ",
      "methods": {
        "construct": {
          "Javadoc": "* Construct a new instance of the named class, and ensure it is cast\n\t * to the type specified as the targetclass.\n\t * @param <E> The generic type of the returned value.\n\t * @param classname The class name of the instance to create.\n\t * @param targetclass The return type of the created instance\n\t * @return an instantiated class\n\t * @throws IllegalArgumentException if there is a problem locating the class instance.\n\t * @throws IllegalStateException if there is a problem instantiating a class instance."
        }
      }
    },
    "org.jdom2.internal.SystemProperty": {
      "Javadoc": "\n * System.getProperty(...) requires security permissions in Applets, and some\n * other cases and this class contains static methods that allow the security\n * exceptions to fail silently. \n * \n * @author Rolf Lear\n *\n ",
      "methods": {
        "get": {
          "Javadoc": "* Query the System properties for a particular property. If the property\n\t * is not set, or not accessible, it returns the def value.\n\t * @param property The property to get\n\t * @param def The value to return if the property is not accessible or not set.\n\t * @return the appropriate property value."
        }
      }
    },
    "org.jdom2.JDOMConstants": {
      "Javadoc": "\n * A collection of constants that may be useful to JDOM users.\n * <p>\n * JDOM attempts to make knowing these 'magic' constants unnecessary, but it is\n * not always possible. In an attempt to make it easier though, common constants\n * are defined here. This is not a comprehensive list of all the constants that\n * may be useful when processing XML, but it should cover most of those occasions\n * where JDOM does not automatically do the 'right thing'.\n * <p>\n * Many of these constants are already referenced inside the JDOM code.\n * \n * @author Rolf Lear\n *\n "
    },
    "org.jdom2.JDOMException": {
      "Javadoc": "\n * The top level 'checked' exception that JDOM classes can throw. JDOM does\n * throw a number of unchecked exceptions, but all the checked exceptions are\n * descendants of this class.\n *\n * @author  Brett McLaughlin\n * @author  Jason Hunter\n "
    },
    "org.jdom2.JDOMFactory": {
      "Javadoc": "\n * An interface to be used by builders when constructing JDOM objects. The\n * <code>DefaultJDOMFactory</code> creates the standard top-level JDOM classes\n * (Element, Document, Comment, etc). Another implementation of this factory\n * could be used to create custom classes.\n *\n * @author  Ken Rune Holland\n * @author  Phil Nelson\n * @author  Bradley S. Huffman\n * @author  Rolf Lear\n ",
      "methods": {
        "attribute": {
          "Javadoc": "* This will create a new <code>Attribute</code> with the\n\t * specified (local) name, value and type, and does not place\n\t * the attribute in a <code>{@link org.jdom2.Namespace}</code>.\n\t * <p>\n\t * <b>Note</b>: This actually explicitly puts the\n\t * <code>Attribute</code> in the \"empty\" <code>Namespace</code>\n\t * (<code>{@link org.jdom2.Namespace#NO_NAMESPACE}</code>).\n\t * </p>\n\t *\n\t * @param name <code>String</code> name of <code>Attribute</code>.\n\t * @param value <code>String</code> value for new attribute.\n\t * @param type <code>AttributeType</code> type for new attribute.\n\t * @return the created Attribute instance"
        },
        "cdata": {
          "Javadoc": "* This creates the CDATA with the supplied text.\n\t *\n\t * @param line The line on which this content begins. \n\t * @param col  The column on the line at which this content begins.\n\t * @param str <code>String</code> content of CDATA.\n\t * @return the created CDATA instance\n\t * @since JDOM2"
        },
        "text": {
          "Javadoc": "* This creates the Text with the supplied text.\n\t *\n\t * @param str <code>String</code> content of Text.\n\t * @return the created Text instance"
        },
        "comment": {
          "Javadoc": "* This creates the comment with the supplied text.\n\t *\n\t * @param line The line on which this content begins. \n\t * @param col  The column on the line at which this content begins.\n\t * @param text <code>String</code> content of comment.\n\t * @return the created Comment instance\n\t * @since JDOM2"
        },
        "docType": {
          "Javadoc": "* This will create the <code>DocType</code> with\n\t * the specified element name\n\t *\n\t * @param line The line on which this content begins. \n\t * @param col  The column on the line at which this content begins.\n\t * @param elementName <code>String</code> name of\n\t *        element being constrained.\n\t * @return the created DocType instance\n\t * @since JDOM2"
        },
        "document": {
          "Javadoc": "* This will create a new <code>Document</code>,\n\t * with the supplied <code>{@link org.jdom2.Element}</code>\n\t * as the root element, and no <code>{@link org.jdom2.DocType}</code>\n\t * declaration.\n\t *\n\t * @param rootElement <code>Element</code> for document root\n\t * @return the created Document instance"
        },
        "element": {
          "Javadoc": "* This will create a new <code>Element</code> with\n\t * the supplied (local) name, and specifies the prefix and URI\n\t * of the <code>{@link org.jdom2.Namespace}</code> the <code>Element</code>\n\t * should be in.\n\t *\n\t * @param line The line on which this content begins. \n\t * @param col  The column on the line at which this content begins.\n\t * @param name <code>String</code> name of element.\n\t * @param prefix the NamespacePrefic to use for this Element\n\t * @param uri <code>String</code> URI for <code>Namespace</code> element\n\t *        should be in.\n\t * @return the created Element instance\n\t * @since JDOM2"
        },
        "processingInstruction": {
          "Javadoc": "* This will create a new <code>ProcessingInstruction</code>\n\t * with the specified target and no data.\n\t *\n\t * @param line The line on which this content begins. \n\t * @param col  The column on the line at which this content begins.\n\t * @param target <code>String</code> target of PI.\n\t * @return the created ProcessingInstruction instance\n\t * @since JDOM2"
        },
        "entityRef": {
          "Javadoc": "* This will create a new <code>EntityRef</code>\n\t * with the supplied name and system ID.\n\t * \n\t * @param line The line on which this content begins. \n\t * @param col  The column on the line at which this content begins.\n\t * @param name <code>String</code> name of element.\n\t * @param systemID <code>String</code> system ID of element.\n\t * @return the created EntityRef instance\n\t * @since JDOM2"
        },
        "addContent": {
          "Javadoc": "* This will add the specified content to the specified parent instance\n\t * @param parent The {@link Parent} to add the content to.\n\t * @param content The {@link Content} to add"
        },
        "setAttribute": {
          "Javadoc": "* Sets a specific Attribute on an Element\n\t * @param element The {@link Element} to set the Attribute on\n\t * @param a The {@link Attribute} to set"
        },
        "addNamespaceDeclaration": {
          "Javadoc": "* Adds a namespace declaration to an Element\n\t * @param element The {@link Element} to add the Namespace to\n\t * @param additional The {@link Namespace} to add."
        },
        "setRoot": {
          "Javadoc": "* Sets the 'root' Element for a Document.\n\t * @param doc The {@link Document} to set the Root Element of.\n\t * @param root The {@link Element} to set as the root."
        }
      }
    },
    "org.jdom2.located.Located": {
      "Javadoc": "\n * Implementations of this class know about their location (line and column).\n * <p>\n * While it would seem intuitive that this represents the location where the\n * content starts, in fact, if the data is populated by a SAX parser the line\n * and column values represent the <strong>end</strong> of the SAX\n * <strong>event</strong>.\n * <p>\n * SAX parsers may vary, but it typically means the\n * character after the last character for Text and CDATA values, the character\n * after EntityRef, Comment, and ProcessingInstruction data, and the character\n * after the opening tag for Element content. For DocType content, it appears\n * that Xerces is inconsistent in the location, with the location being set at\n * what appears to be the start of the internal subset data (if any).\n * <p>\n * Finally, remember that the column value counts characters, and thus, if you\n * have tab-indented values, the tab counts as a single character (regardless of\n * how much it indents).\n * \n * @author Rolf Lear\n *\n ",
      "methods": {
        "getLine": {
          "Javadoc": "* Get the line number\n\t * @return the line number"
        },
        "getColumn": {
          "Javadoc": "* Get the column (character on the line).\n\t * @return the column"
        },
        "setLine": {
          "Javadoc": "* Set the line number\n\t * @param line the line."
        },
        "setColumn": {
          "Javadoc": "* Set the column (character on the line).\n\t * @param col The column"
        }
      }
    },
    "org.jdom2.located.LocatedCDATA": {
      "Javadoc": "\n * An XML CDATA section. Represents character-based content within an XML\n * document that should be output within special CDATA tags. Semantically it's\n * identical to a simple {@link Text} object, but output behavior is different.\n * CDATA makes no guarantees about the underlying textual representation of\n * character data, but does expose that data as a Java String.\n *\n * @author  Rolf Lear\n "
    },
    "org.jdom2.located.LocatedComment": {
      "Javadoc": "\n * An XML comment. Methods allow the user to get and set the text of the\n * comment.\n *\n * @author  Rolf Lear\n "
    },
    "org.jdom2.located.LocatedDocType": {
      "Javadoc": "\n * An XML DOCTYPE declaration.  Method allow the user to get and set the\n * root element name, public id, and system id.\n *\n * @author Rolf Lear\n "
    },
    "org.jdom2.located.LocatedElement": {
      "Javadoc": "\n * This Element specialization contains the location information as parsed.\n * \n * @author Rolf Lear\n *\n "
    },
    "org.jdom2.located.LocatedEntityRef": {
      "Javadoc": "\n * An XML entity reference. Methods allow the user to manage its name, public\n * id, and system id.\n *\n * @author  Rolf Lear\n "
    },
    "org.jdom2.located.LocatedJDOMFactory": {
      "Javadoc": "\n * All Content instances (Element, Comment, CDATA, DocType, Text, EntityRef,\n * and ProcessingInstruction) will implement {@link Located}, and will\n * have the values set appropriately.\n * <p>\n * You can set an instance of this LocatedJDOMFactory as the factory for a\n * SAXBuilder, and the JDOM document produced will have the SAX Location data\n * embedded. Note though, that SAX Location data indicates the position of the\n * <strong>end</strong> of the SAX Event. \n * \n * @author Rolf Lear\n *\n "
    },
    "org.jdom2.located.LocatedProcessingInstruction": {
      "Javadoc": "\n * An XML processing instruction. Methods allow the user to obtain the target of\n * the PI as well as its data. The data can always be accessed as a String or,\n * if the data appears akin to an attribute list, can be retrieved as name/value\n * pairs.\n *\n * @author  Rolf Lear\n "
    },
    "org.jdom2.located.LocatedText": {
      "Javadoc": "\n * An XML character sequence. Provides a modular, parentable method of\n * representing text. Text makes no guarantees about the underlying textual\n * representation of character data, but does expose that data as a Java String.\n *\n * @author  Rolf Lear\n "
    },
    "org.jdom2.Namespace": {
      "Javadoc": "\n * An XML namespace representation, as well as a factory for creating XML\n * namespace objects. All methods on Namespace (including\n * {@link #getNamespace(String)} and {@link #getNamespace(String, String)})\n * are thread-safe.\n * \n * <p>\n * See {@link NamespaceAware} for additional notes on how Namespaces are\n * 'in-scope' in JDOM content, and how those in-scope Namespaces are accessed.\n *\n * @see NamespaceAware\n * @author  Brett McLaughlin\n * @author  Elliotte Rusty Harold\n * @author  Jason Hunter\n * @author  Wesley Biggs\n * @author  Rolf Lear\n ",
      "methods": {
        "getNamespace": {
          "Javadoc": "* This will retrieve (if in existence) or create (if not) a \n\t * <code>Namespace</code> for the supplied URI, and make it usable \n\t * as a default namespace, as no prefix is supplied.\n\t * This method is thread-safe.\n\t *\n\t * @param uri <code>String</code> URI of new <code>Namespace</code>.\n\t * @return <code>Namespace</code> - ready to use namespace."
        },
        "getPrefix": {
          "Javadoc": "* This returns the prefix mapped to this <code>Namespace</code>.\n\t *\n\t * @return <code>String</code> - prefix for this <code>Namespace</code>."
        },
        "getURI": {
          "Javadoc": "* This returns the namespace URI for this <code>Namespace</code>.\n\t *\n\t * @return <code>String</code> - URI for this <code>Namespace</code>."
        },
        "equals": {
          "Javadoc": "* This tests for equality - Two <code>Namespaces</code>\n\t * are equal if and only if their URIs are byte-for-byte equals.\n\t *\n\t * @param ob <code>Object</code> to compare to this <code>Namespace</code>.\n\t * @return <code>boolean</code> - whether the supplied object is equal to\n\t *         this <code>Namespace</code>."
        },
        "toString": {
          "Javadoc": "* This returns a <code>String</code> representation of this \n\t * <code>Namespace</code>, suitable for use in debugging.\n\t *\n\t * @return <code>String</code> - information about this instance."
        },
        "hashCode": {
          "Javadoc": "* This returns the hash code for the <code>Namespace</code> that conforms\n\t * to the 'equals()' contract.\n\t * <p>\n\t * If two namespaces have the same URI, they are equal and have the same\n\t * hash code, even if they have different prefixes.\n\t *\n\t * @return <code>int</code> - hash code for this <code>Namespace</code>."
        },
        "writeReplace": {
          "Javadoc": "* Serializes Namespace by using a proxy serialization instance.\n\t * @serialData The proxy deals with the protocol.\n\t * @return the Namespace proxy instance."
        },
        "readResolve": {
          "Javadoc": "* Because Namespace is serialized by proxy, the reading of direct Namespace\n\t * instances is illegal and prohibited.\n\t * @return nothing.\n\t * @throws InvalidObjectException always"
        }
      }
    },
    "org.jdom2.NamespaceSerializationProxy": {
      "Javadoc": ""
    },
    "org.jdom2.NamespaceAware": {
      "Javadoc": "\n * Classes implementing this interface are all sensitive to their\n * {@link Namespace} context. All the core JDOM classes are NamespaceAware\n * ({@link Parent} and subtypes, {@link Content} and subtypes, and\n * {@link Attribute}). You can use the methods that this interface provides\n * to query the Namespace context.\n * <p>\n * JDOM2 introduces a consistency in reporting Namespace context. XML standards\n * do not dictate any conditions on Namespace reporting or ordering, but\n * consistency is valuable for user-friendliness. As a result JDOM2 imposes a\n * useful order on the Namespace context for XML content.\n * <p>\n * The order for Namespace reporting is:\n * <ol>\n * <li>If the item 'has' a Namespace (Element, Attribute) then that Namespace is\n * reported.\n * <li>The remaining Namespaces are reported in alphabetical order by prefix.\n * </ol>\n * <p>\n * The XML namespace (bound to the prefix \"xml\" - see \n * {@link Namespace#XML_NAMESPACE} ) is always in every scope. It is always\n * introduced in {@link Document}, and in all other NamespaceAware instances it\n * is introduced if that content is detached.\n * <p>\n * See the individualised documentation for each implementing type for\n * additional specific details. The following section is a description of how\n * Namespaces are managed in the Element class.\n * <p>\n * <h2>The Element Namespace Scope</h2>\n * The 'default' Namespace is a source of confusion, but it is simply the\n * Namespace which is in-scope for an Element that has no Namespace prefix\n * (prefix is \"\" but it could have any Namespace URI). There will always be\n * exactly one Namespace that is in-scope for an element that has no prefix.\n * <p>\n * All Elements are in a Namespace. Elements will be in \n * {@link Namespace#NO_NAMESPACE} unless a different Namespace was supplied as\n * part of the Element Constructor, or later modified by the\n * {@link Element#setNamespace(Namespace)} method.\n * <p>\n * In addition to the Element's Namespace, there could be other Namespaces that\n * are 'in scope' for the Element. The set of Namespaces that are in scope for\n * an Element is the union of five sets:\n * <table>\n *   <tr>\n *     <th valign=\"top\">XML</th>\n *     <td>\n *       There is always exactly one member of this set, \n *       {@link Namespace#XML_NAMESPACE}.\n *       <br>\n *       This set cannot be changed.\n *     </td>\n *   </tr>\n *   <tr>\n *     <th valign=\"top\">Element</th>\n *     <td>\n *       There is always exactly one member of this set, and it can be retrieved\n *       or set with the methods {@link Element#getNamespace()} and\n *       {@link Element#setNamespace(Namespace)} respectively.\n *     </td>\n *   </tr>\n *   <tr>\n *     <th valign=\"top\">Attribute</th>\n *     <td>\n *       This is the set of distinct Namespaces that are used on Attributes. You\n *       can modify the set by adding and removing Attributes to the Element.\n *       <p>\n *       <b>NOTE:</b>\n *       The {@link Namespace#NO_NAMESPACE Namespace.NO_NAMESPACE} Namespace is always the\n *       <i>default</i> Namespace for attributes (the Namespace that has no\n *       prefix). Thus there may be a special case with this Namespace, because\n *       if there is a different <i>default</i> Namespace for the Element, then\n *       the Namespace.NO_NAMESPACE Namespace is not part of the Element's in-scope\n *       Namespace set (the Element cannot have two Namespaces in scope with the\n *       same prefix - \"\").\n *     </td>\n *   </tr>\n *   <tr>\n *     <th valign=\"top\">Additional</th>\n *     <td>\n *       This set is maintained by the two methods {@link Element#addNamespaceDeclaration(Namespace)}\n *       and {@link Element#removeNamespaceDeclaration(Namespace)}. You can get the full set\n *       of additional Namespaces with {@link Element#getAdditionalNamespaces()}\n *     </td>\n *   </tr>\n *   <tr>\n *     <th valign=\"top\">Inherited</th>\n *     <td>\n *       This last set is somewhat dynamic because only those Namespaces on the\n *       parent Element which are not re-defined by this Element will be \n *       inherited. A Namespace is redefined by setting a new Namespace with the\n *       same prefix, but a different URI. If you set a Namespace on the Element\n *       (or add a Namespace declaration or set an Attribute) with the same\n *       prefix as another Namespace that would have been otherwise inherited,\n *       then that other Namespace will no longer be inherited.\n *     </td>\n *   </tr>\n * </table>\n *   \n * <p>\n * Since you cannot change the Namespace.XML_NAMESPACE, and the 'inherited' Namespace set\n * is dynamic, the remaining Namespace sets are the most interesting from a JDOM\n * perspective. JDOM validates all modifications that affect the Namespaces in\n * scope for an Element. An IllegalAddException will be thrown if you attempt to\n * add a new Namespace to the in-scope set if a different Namespace with the \n * same prefix is already part of one of these three sets (Element, Attribute,\n * or Additional).\n *\n * \n * @author Rolf Lear\n * @since JDOM2\n ",
      "methods": {
        "getNamespacesInScope": {
          "Javadoc": "* Obtain a list of all namespaces that are in scope for the current\n\t * content.\n\t * <p>\n\t * The contents of this list will always be the combination of\n\t * getNamespacesIntroduced() and getNamespacesInherited().\n\t * <p>\n\t * See {@link NamespaceAware} documentation for details on what the order of the\n\t * Namespaces will be in the returned list.\n\t * \n\t * @return a read-only list of Namespaces."
        },
        "getNamespacesIntroduced": {
          "Javadoc": "* Obtain a list of all namespaces that are introduced to the XML tree by\n\t * this node. Only Elements and Attributes can introduce namespaces, so all\n\t * other Content types will return an empty list.\n\t * <p>\n\t * The contents of this list will always be a subset (but in the same order)\n\t * of getNamespacesInScope(), and will never intersect\n\t * getNamspacesInherited()\n\t * \n\t * @return a read-only list of Namespaces."
        },
        "getNamespacesInherited": {
          "Javadoc": "* Obtain a list of all namespaces that are in scope for this content, but\n\t * were not introduced by this content.\n\t * <p>\n\t * The contents of this list will always be a subset (but in the same order)\n\t * of getNamespacesInScope(), and will never intersect\n\t * getNamspacesIntroduced()\n\t * \n\t * @return a read-only list of Namespaces."
        }
      }
    },
    "org.jdom2.output.DOMOutputter": {
      "Javadoc": "\n * Outputs a JDOM {@link org.jdom2.Document org.jdom2.Document} as a DOM\n * {@link org.w3c.dom.Document org.w3c.dom.Document}. Also provides methods to\n * output other types of JDOM Content in the equivalent DOM nodes.\n * <p>\n * There are two versions of most functions, one that creates an independent DOM\n * node using the DOMAdapter to create a new org.w3c.dom.Document. The other\n * version creates the new DOM Nodes using the supplied org.w3c.dom.Document\n * instance.\n * \n * @author Brett McLaughlin\n * @author Jason Hunter\n * @author Matthew Merlo\n * @author Dan Schaffer\n * @author Yusuf Goolamabbas\n * @author Bradley S. Huffman\n * @author Rolf lear\n ",
      "methods": {
        "getDOMAdapter": {
          "Javadoc": "* Get the DOMAdapter currently set for this DOMOutputter.\n\t * \n\t * @return the current DOMAdapter.\n\t * @since JDOM2"
        },
        "setDOMAdapter": {
          "Javadoc": "* Set the DOMAdapter currently set for this DOMOutputter.\n\t * \n\t * @param adapter\n\t *        the new DOMAdapter to use (null implies the default).\n\t * @since JDOM2"
        },
        "getFormat": {
          "Javadoc": "* Get the Format instance currently used by this DOMOutputter.\n\t * \n\t * @return the current Format instance\n\t * @since JDOM2"
        },
        "setFormat": {
          "Javadoc": "* Set a new Format instance for this DOMOutputter\n\t * \n\t * @param format\n\t *        the new Format instance to use (null implies the default)\n\t * @since JDOM2"
        },
        "getDOMOutputProcessor": {
          "Javadoc": "* Get the current DOMOutputProcessor\n\t * \n\t * @return the current DOMOutputProcessor\n\t * @since JDOM2"
        },
        "setDOMOutputProcessor": {
          "Javadoc": "* Set a new DOMOutputProcessor for this DOMOutputter.\n\t * \n\t * @param processor\n\t *        the new processor to set (null implies the default)\n\t * @since JDOM2"
        },
        "setForceNamespaceAware": {
          "Javadoc": "* Controls how NO_NAMESPACE nodes are handled. If true the outputter always\n\t * creates a namespace aware DOM.\n\t * \n\t * @param flag\n\t *        true to force NamespaceAware\n\t * @deprecated All DOMOutputters are now always NamespaceAware."
        },
        "getForceNamespaceAware": {
          "Javadoc": "* Returns whether DOMs will be constructed with namespaces even when the\n\t * source document has elements all in the empty namespace.\n\t * \n\t * @return the forceNamespaceAware flag value\n\t * @deprecated All DOMOutputters are always NamesapceAware. Always true."
        },
        "output": {
          "Javadoc": "* This converts the list of JDOM <code>Content</code> in to a list of DOM\n\t * Nodes, returning the DOM version. The DOM Node will be linked to an\n\t * independent DOM Document instance supplied by the current DOMAdapter\n\t * \n\t * @param basedoc\n\t *        The DOM Document to use for creating DOM Nodes.\n\t * @param list\n\t *        of JDOM Content to output.\n\t * @return a List of <code>org.w3c.dom.Node</code>\n\t * @throws JDOMException\n\t *         if output failed.\n\t * @since JDOM2"
        }
      }
    },
    "org.jdom2.output.DefaultDOMOutputProcessor": {
      "Javadoc": "\n\t * Create a final/concrete instance of the AbstractDOMOutputProcessor.\n\t * Making it final improves performance.\n\t * \n\t * @author Rolf Lear\n\t "
    },
    "org.jdom2.output.EscapeStrategy": {
      "Javadoc": "\n * Logic to determine which characters should be formatted as character\n * entities.\n *\n * @author Alex Rosen\n * @author Bradley S. Huffman\n * @author Jason Hunter\n ",
      "methods": {
        "shouldEscape": {
          "Javadoc": "* Test whether the supplied character should be formatted literally\n\t * or as a character entity.\n\t * @param ch The char to test to determine whether it should be escaped.\n\t * @return true if ch should be escaped."
        }
      }
    },
    "org.jdom2.output.Format": {
      "Javadoc": "\n * Class to encapsulate XMLOutputter format options.\n * Typically users adapt the standard format configurations obtained by\n * {@link #getRawFormat} (no whitespace changes),\n * {@link #getPrettyFormat} (whitespace beautification), and\n * {@link #getCompactFormat} (whitespace normalization).\n * <p>\n * Several modes are available to effect the way textual content is printed.\n * See the documentation for {@link TextMode} for details.\n * <p>\n * <b>Note about Line Separator:</b>\n * <p>\n * By default JDOM will always use the CRNL sequence \"\\r\\n\" for output. This\n * can be changed in a number of different ways. See the {@link LineSeparator}\n * enumeration for more information.\n * <p>\n * <b>Note about XML Character Escaping:</b>\n * <p>\n * JDOM will escape characters in the output based on the EscapeStrategy that\n * is specified by this Format. The Format will by default use a sensible\n * EscapeStrategy that is based on the character encoding of the output. If\n * the default escape mechanism is not producing the correct results you can\n * change the EscapeStrategy on the format to suit your own needs.  \n * \n *\n * @see LineSeparator\n *\n * @author Jason Hunter\n * @author Rolf Lear\n ",
      "methods": {
        "getRawFormat": {
          "Javadoc": "* Returns a new Format object that performs no whitespace changes, uses\n\t * the UTF-8 encoding, doesn't expand empty elements, includes the\n\t * declaration and encoding, and uses the default entity escape strategy.\n\t * Tweaks can be made to the returned Format instance without affecting\n\t * other instances.\n\n\t * @return                     a Format with no whitespace changes"
        },
        "getPrettyFormat": {
          "Javadoc": "* Returns a new Format object that performs whitespace beautification with\n\t * 2-space indents, uses the UTF-8 encoding, doesn't expand empty elements,\n\t * includes the declaration and encoding, and uses the default entity\n\t * escape strategy.\n\t * Tweaks can be made to the returned Format instance without affecting\n\t * other instances.\n\t *\n\t * @return                     a Format with whitespace beautification"
        },
        "getCompactFormat": {
          "Javadoc": "* Returns a new Format object that performs whitespace normalization, uses\n\t * the UTF-8 encoding, doesn't expand empty elements, includes the\n\t * declaration and encoding, and uses the default entity escape strategy.\n\t * Tweaks can be made to the returned Format instance without affecting\n\t * other instances.\n\t *\n\t * @return                     a Format with whitespace normalization"
        },
        "compact": {
          "Javadoc": "* Use the XML Specification definition of whitespace to compact the\n\t * input value. The value is trimmed, and any internal XML whitespace\n\t * is replaced with a single ' ' space.\n\t * @param str The value to compact.\n\t * @return The compacted value\n\t * @since JDOM2"
        },
        "trimRight": {
          "Javadoc": "* Use the XML Specification definition of whitespace to Right-trim the\n\t * input value.\n\t * @param str The value to trim.\n\t * @return The value right-trimmed\n\t * @since JDOM2"
        },
        "trimLeft": {
          "Javadoc": "* Use the XML Specification definition of whitespace to Left-trim the\n\t * input value.\n\t * @param str The value to trim.\n\t * @return The value left-trimmed\n\t * @since JDOM2"
        },
        "trimBoth": {
          "Javadoc": "* Use the XML Specification definition of whitespace to trim the\n\t * input value.\n\t * @param str The value to trim.\n\t * @return The value trimmed\n\t * @since JDOM2"
        },
        "escapeAttribute": {
          "Javadoc": "* This will take the three pre-defined entities in XML 1.0 ('&lt;', '&gt;',\n\t * and '&amp;' - used specifically in XML elements) as well as CR/NL, tabs,\n\t * and Quote characters which require escaping inside Attribute values and\n\t * converts their character representation to the appropriate entity\n\t * reference suitable for XML attribute content. Further, some special\n\t * characters (e.g. characters that are not valid in the current encoding)\n\t * are converted to escaped representations.\n\t * <p>\n\t * @param strategy \n\t *        The EscapeStrategy to query.\n\t * @param value\n\t *        <code>String</code> Attribute value to escape.\n\t * @return The value appropriately escaped.\n\t * @throws IllegalDataException\n\t *         if an entity can not be escaped"
        },
        "escapeText": {
          "Javadoc": "* This will take the three pre-defined entities in XML 1.0 ('&lt;', '&gt;',\n\t * and '&amp;' - used specifically in XML elements) and convert their\n\t * character representation to the appropriate entity reference, suitable\n\t * for XML element content. Further, some special characters (e.g.\n\t * characters that are not valid in the current encoding) are converted to\n\t * escaped representations. If the eol parameter is not null, then any\n\t * internal newlines will be replaced with the specified eol sequence.\n\t * \n\t * @param strategy\n\t *        The EscapeStrategy\n\t * @param eol\n\t *        The End-Of-Line sequence to be used (may be null).\n\t * @param value\n\t *        The String to escape\n\t * @return The input value escaped.\n\t * @throws IllegalDataException\n\t *         if an entity can not be escaped\n\t * @since JDOM2"
        },
        "setEscapeStrategy": {
          "Javadoc": "* Sets the {@link EscapeStrategy} to use for character escaping.\n\t *\n\t * @param strategy the EscapeStrategy to use\n\t * @return a pointer to this Format for chaining"
        },
        "getEscapeStrategy": {
          "Javadoc": "* Returns the current escape strategy\n\t *\n\t * @return the current escape strategy"
        },
        "setLineSeparator": {
          "Javadoc": "* This will set the newline separator sequence.\n\t * <p>\n\t * This method differes from {@link #setLineSeparator(String)} slightly in\n\t * that, to disable end-of-line processing you should call:\n\t * <pre>\n\t * Format.setLinewSeparator(LineSeparator.NONE);\n\t * </pre>\n\t * \n\t * @see #setLineSeparator(String) for comprehensive notes.\n\t *\n\t * @param separator {@link LineSeparator} line separator to us\n\t * @return a pointer to this Format for chaining\n\t * @since JDOM2"
        },
        "getLineSeparator": {
          "Javadoc": "* Returns the current line separator.\n\t *\n\t * @return the current line separator"
        },
        "setOmitEncoding": {
          "Javadoc": "* This will set whether the XML declaration\n\t * (<code>&lt;&#063;xml version=\"1&#046;0\"\n\t * encoding=\"UTF-8\"&#063;&gt;</code>)\n\t * includes the encoding of the document. It is common to omit\n\t * this in uses such as WML and other wireless device protocols.\n\t *\n\t * @param omitEncoding <code>boolean</code> indicating whether or not\n\t *        the XML declaration should indicate the document encoding.\n\t * @return a pointer to this Format for chaining"
        },
        "getOmitEncoding": {
          "Javadoc": "* Returns whether the XML declaration encoding will be omitted.\n\t *\n\t * @return whether the XML declaration encoding will be omitted"
        },
        "setOmitDeclaration": {
          "Javadoc": "* This will set whether the XML declaration\n\t * (<code>&lt;&#063;xml version=\"1&#046;0\"&#063;&gt;</code>)\n\t * will be omitted or not. It is common to omit this in uses such\n\t * as SOAP and XML-RPC calls.\n\t *\n\t * @param omitDeclaration <code>boolean</code> indicating whether or not\n\t *        the XML declaration should be omitted.\n\t * @return a pointer to this Format for chaining"
        },
        "getOmitDeclaration": {
          "Javadoc": "* Returns whether the XML declaration will be omitted.\n\t *\n\t * @return whether the XML declaration will be omitted"
        },
        "setExpandEmptyElements": {
          "Javadoc": "* This will set whether empty elements are expanded from\n\t * <code>&lt;tagName/&gt;</code> to\n\t * <code>&lt;tagName&gt;&lt;/tagName&gt;</code>.\n\t *\n\t * @param expandEmptyElements <code>boolean</code> indicating whether or not\n\t *        empty elements should be expanded.\n\t * @return a pointer to this Format for chaining"
        },
        "getExpandEmptyElements": {
          "Javadoc": "* Returns whether empty elements are expanded.\n\t *\n\t * @return whether empty elements are expanded"
        },
        "setIgnoreTrAXEscapingPIs": {
          "Javadoc": "* This will set whether JAXP TrAX processing instructions for\n\t * disabling/enabling output escaping are ignored.  Disabling\n\t * output escaping allows using XML text as element content and\n\t * outputing it verbatim, i&#46;e&#46; as element children would be.\n\t * <p>\n\t * When processed, these processing instructions are removed from\n\t * the generated XML text and control whether the element text\n\t * content is output verbatim or with escaping of the pre-defined\n\t * entities in XML 1.0.  The text to be output verbatim shall be\n\t * surrounded by the\n\t * <code>&lt;?javax.xml.transform.disable-output-escaping ?&gt;</code>\n\t * and <code>&lt;?javax.xml.transform.enable-output-escaping ?&gt;</code>\n\t * PIs.</p>\n\t * <p>\n\t * When ignored, the processing instructions are present in the\n\t * generated XML text and the pre-defined entities in XML 1.0 are\n\t * escaped.\n\t * <p>\n\t * Default: <code>false</code>.</p>\n\t *\n\t * @param ignoreTrAXEscapingPIs <code>boolean</code> indicating\n\t *        whether or not TrAX ouput escaping PIs are ignored.\n\t *\n\t * @see javax.xml.transform.Result#PI_ENABLE_OUTPUT_ESCAPING\n\t * @see javax.xml.transform.Result#PI_DISABLE_OUTPUT_ESCAPING"
        },
        "getIgnoreTrAXEscapingPIs": {
          "Javadoc": "* Returns whether JAXP TrAX processing instructions for\n\t * disabling/enabling output escaping are ignored.\n\t *\n\t * @return whether or not TrAX ouput escaping PIs are ignored."
        },
        "setTextMode": {
          "Javadoc": "* This sets the text output style.  Options are available as static\n\t * {@link TextMode} instances.  The default is {@link TextMode#PRESERVE}.\n\t * \n\t * @param mode The TextMode to set.\n\t * @return a pointer to this Format for chaining"
        },
        "getTextMode": {
          "Javadoc": "* Returns the current text output style.\n\t *\n\t * @return the current text output style"
        },
        "setIndent": {
          "Javadoc": "* This will set the indent <code>String</code> to use; this\n\t * is usually a <code>String</code> of empty spaces. If you pass\n\t * the empty string (\"\"), then no indentation will happen but newlines\n\t * will still be generated.  Passing null will result in no indentation\n\t * and no newlines generated.  Default: none (null)\n\t *\n\t * @param indent <code>String</code> to use for indentation.\n\t * @return a pointer to this Format for chaining"
        },
        "getIndent": {
          "Javadoc": "* Returns the indent string in use.\n\t *\n\t * @return the indent string in use"
        },
        "setEncoding": {
          "Javadoc": "* Sets the output encoding.  The name should be an accepted XML\n\t * encoding.\n\t *\n\t * @param encoding the encoding format.  Use XML-style names like\n\t *                 \"UTF-8\" or \"ISO-8859-1\" or \"US-ASCII\"\n\t * @return a pointer to this Format for chaining"
        },
        "getEncoding": {
          "Javadoc": "* Returns the configured output encoding.\n\t *\n\t * @return the output encoding"
        },
        "isSpecifiedAttributesOnly": {
          "Javadoc": "* Will Attributes defaulted from the DTD or XMLSchema\n\t * be output\n\t * @return true if the defaulted Attributes will be output"
        },
        "setSpecifiedAttributesOnly": {
          "Javadoc": "* Set whether only those Attributes specified in the input XML should \n\t * be output. Other Attributes (those defaulted or 'fixed' in the DTD\n\t * or XMLSchema) should be ignored.\n\t * @param specifiedAttributesOnly true if the defaulted\n\t * Attributes should be ignored, false if they should be output"
        }
      }
    },
    "org.jdom2.output.EscapeStrategyUTF": {
      "Javadoc": "\n\t * An EscapeStrategy suitable for UTF-8 an UTF-16. We want the class to\n\t * have its own name.\n\t "
    },
    "org.jdom2.output.EscapeStrategy8Bits": {
      "Javadoc": "\n\t * An EscapeStrategy suitable for 8-bit charsets. We want the class to have\n\t * its own name.\n\t "
    },
    "org.jdom2.output.EscapeStrategy7Bits": {
      "Javadoc": "\n\t * An EscapeStrategy suitable for 7-bit charsets. We want the class to\n\t * have its own name.\n\t "
    },
    "org.jdom2.output.DefaultCharsetEscapeStrategy": {
      "Javadoc": "\n\t * Handles Charsets.\n\t "
    },
    "org.jdom2.output.JDOMLocator": {
      "Javadoc": "\n * An implementation of the SAX {@link Locator} interface that\n * exposes the JDOM node being processed by SAXOutputter.\n * <p>\n * In JDOM2 this class is demoted to an interface. The information was never\n * accurate anyway, and as an interface a specific Outputter instance can\n * instead do 'the right thing' with the locator, if needed.\n * <p>\n * This change breaks a possible compatibility with anyone who happened to treat\n * the JDOMLocator to be 'settable'. This used to extend LocatorImpl class which\n * had setter methods for the ColumnNumber, Line, PublicID, SystemID \n *\n * @author Laurent Bihanic\n * @author Rolf Lear\n *\n ",
      "methods": {
        "getNode": {
          "Javadoc": "* Returns the JDOM node being processed by SAXOutputter.\n\t *\n\t * @return the JDOM node being processed by SAXOutputter."
        }
      }
    },
    "org.jdom2.output.SAXOutputter": {
      "Javadoc": "\n * Outputs a JDOM document as a stream of SAX2 events.\n * <p>\n * Most ContentHandler callbacks are supported. BOTH\n * <code>ignorableWhitespace()</code> and <code>skippedEntity()</code> have not\n * been implemented. The <code>{@link JDOMLocator}</code> class returned by\n * <code>{@link #getLocator}</code> exposes the current node being operated\n * upon.\n * <p>\n * At this time, it is not possible to access notations and unparsed entity\n * references in a DTD from JDOM. Therefore, <code>DTDHandler</code> callbacks\n * have not been implemented yet.\n * <p>\n * The <code>ErrorHandler</code> callbacks have not been implemented, since\n * these are supposed to be invoked when the document is parsed and at this\n * point the document exists in memory and is known to have no errors.\n * </p>\n * \n * @author Brett McLaughlin\n * @author Jason Hunter\n * @author Fred Trimble\n * @author Bradley S. Huffman\n ",
      "methods": {
        "setContentHandler": {
          "Javadoc": "* This will set the <code>ContentHandler</code>.\n\t * \n\t * @param contentHandler\n\t *        contains <code>ContentHandler</code> callback methods."
        },
        "getContentHandler": {
          "Javadoc": "* Returns the registered <code>ContentHandler</code>.\n\t * \n\t * @return the current <code>ContentHandler</code> or <code>null</code> if\n\t *         none was registered."
        },
        "setErrorHandler": {
          "Javadoc": "* This will set the <code>ErrorHandler</code>.\n\t * \n\t * @param errorHandler\n\t *        contains <code>ErrorHandler</code> callback methods."
        },
        "getErrorHandler": {
          "Javadoc": "* Return the registered <code>ErrorHandler</code>.\n\t * \n\t * @return the current <code>ErrorHandler</code> or <code>null</code> if\n\t *         none was registered."
        },
        "setDTDHandler": {
          "Javadoc": "* This will set the <code>DTDHandler</code>.\n\t * \n\t * @param dtdHandler\n\t *        contains <code>DTDHandler</code> callback methods."
        },
        "getDTDHandler": {
          "Javadoc": "* Return the registered <code>DTDHandler</code>.\n\t * \n\t * @return the current <code>DTDHandler</code> or <code>null</code> if none\n\t *         was registered."
        },
        "setEntityResolver": {
          "Javadoc": "* This will set the <code>EntityResolver</code>.\n\t * \n\t * @param entityResolver\n\t *        contains EntityResolver callback methods."
        },
        "getEntityResolver": {
          "Javadoc": "* Return the registered <code>EntityResolver</code>.\n\t * \n\t * @return the current <code>EntityResolver</code> or <code>null</code> if\n\t *         none was registered."
        },
        "setLexicalHandler": {
          "Javadoc": "* This will set the <code>LexicalHandler</code>.\n\t * \n\t * @param lexicalHandler\n\t *        contains lexical callback methods."
        },
        "getLexicalHandler": {
          "Javadoc": "* Return the registered <code>LexicalHandler</code>.\n\t * \n\t * @return the current <code>LexicalHandler</code> or <code>null</code> if\n\t *         none was registered."
        },
        "setDeclHandler": {
          "Javadoc": "* This will set the <code>DeclHandler</code>.\n\t * \n\t * @param declHandler\n\t *        contains declaration callback methods."
        },
        "getDeclHandler": {
          "Javadoc": "* Return the registered <code>DeclHandler</code>.\n\t * \n\t * @return the current <code>DeclHandler</code> or <code>null</code> if none\n\t *         was registered."
        },
        "getReportNamespaceDeclarations": {
          "Javadoc": "* Returns whether attribute namespace declarations shall be reported as\n\t * \"xmlns\" attributes.\n\t * \n\t * @return whether attribute namespace declarations shall be reported as\n\t *         \"xmlns\" attributes."
        },
        "setReportNamespaceDeclarations": {
          "Javadoc": "* This will define whether attribute namespace declarations shall be\n\t * reported as \"xmlns\" attributes. This flag defaults to <code>false</code>\n\t * and behaves as the \"namespace-prefixes\" SAX core feature.\n\t * \n\t * @param declareNamespaces\n\t *        whether attribute namespace declarations shall be reported as\n\t *        \"xmlns\" attributes."
        },
        "getReportDTDEvents": {
          "Javadoc": "* Returns whether DTD events will be reported.\n\t * \n\t * @return whether DTD events will be reported"
        },
        "setReportDTDEvents": {
          "Javadoc": "* This will define whether to report DTD events to SAX DeclHandlers and\n\t * LexicalHandlers if these handlers are registered and the document to\n\t * output includes a DocType declaration.\n\t * \n\t * @param reportDtdEvents\n\t *        whether to notify DTD events."
        },
        "setFeature": {
          "Javadoc": "* This will set the state of a SAX feature.\n\t * <p>\n\t * All XMLReaders are required to support setting to true and to false.\n\t * </p>\n\t * <p>\n\t * SAXOutputter currently supports the following SAX core features:\n\t * <dl>\n\t * <dt><code>http://xml.org/sax/features/namespaces</code></dt>\n\t * <dd><strong>description:</strong> <code>true</code> indicates namespace\n\t * URIs and unprefixed local names for element and attribute names will be\n\t * available</dd>\n\t * <dd><strong>access:</strong> read/write, but always <code>true</code>!</dd>\n\t * <dt><code>http://xml.org/sax/features/namespace-prefixes</code></dt>\n\t * <dd><strong>description:</strong> <code>true</code> indicates XML 1.0\n\t * names (with prefixes) and attributes (including xmlns* attributes) will\n\t * be available</dd>\n\t * <dd><strong>access:</strong> read/write</dd>\n\t * <dt><code>http://xml.org/sax/features/validation</code></dt>\n\t * <dd><strong>description:</strong> controls whether SAXOutputter is\n\t * reporting DTD-related events; if <code>true</code>, the DocType internal\n\t * subset will be parsed to fire DTD events</dd>\n\t * <dd><strong>access:</strong> read/write, defaults to <code>true</code></dd>\n\t * </dl>\n\t * </p>\n\t * \n\t * @param name\n\t *        <code>String</code> the feature name, which is a fully-qualified\n\t *        URI.\n\t * @param value\n\t *        <code>boolean</code> the requested state of the feature (true or\n\t *        false).\n\t * @throws SAXNotRecognizedException\n\t *         when SAXOutputter does not recognize the feature name.\n\t * @throws SAXNotSupportedException\n\t *         when SAXOutputter recognizes the feature name but cannot set the\n\t *         requested value."
        },
        "getFeature": {
          "Javadoc": "* This will look up the value of a SAX feature.\n\t * \n\t * @param name\n\t *        <code>String</code> the feature name, which is a fully-qualified\n\t *        URI.\n\t * @return <code>boolean</code> the current state of the feature (true or\n\t *         false).\n\t * @throws SAXNotRecognizedException\n\t *         when SAXOutputter does not recognize the feature name.\n\t * @throws SAXNotSupportedException\n\t *         when SAXOutputter recognizes the feature name but determine its\n\t *         value at this time."
        },
        "setProperty": {
          "Javadoc": "* This will set the value of a SAX property. This method is also the\n\t * standard mechanism for setting extended handlers.\n\t * <p>\n\t * SAXOutputter currently supports the following SAX properties:\n\t * <dl>\n\t * <dt><code>http://xml.org/sax/properties/lexical-handler</code></dt>\n\t * <dd><strong>data type:</strong>\n\t * <code>org.xml.sax.ext.LexicalHandler</code></dd>\n\t * <dd><strong>description:</strong> An optional extension handler for\n\t * lexical events like comments.</dd>\n\t * <dd><strong>access:</strong> read/write</dd>\n\t * <dt><code>http://xml.org/sax/properties/declaration-handler</code></dt>\n\t * <dd><strong>data type:</strong> <code>org.xml.sax.ext.DeclHandler</code></dd>\n\t * <dd><strong>description:</strong> An optional extension handler for\n\t * DTD-related events other than notations and unparsed entities.</dd>\n\t * <dd><strong>access:</strong> read/write</dd>\n\t * </dl>\n\t * </p>\n\t * \n\t * @param name\n\t *        <code>String</code> the property name, which is a fully-qualified\n\t *        URI.\n\t * @param value\n\t *        <code>Object</code> the requested value for the property.\n\t * @throws SAXNotRecognizedException\n\t *         when SAXOutputter does not recognize the property name.\n\t * @throws SAXNotSupportedException\n\t *         when SAXOutputter recognizes the property name but cannot set the\n\t *         requested value."
        },
        "getProperty": {
          "Javadoc": "* This will look up the value of a SAX property.\n\t * \n\t * @param name\n\t *        <code>String</code> the property name, which is a fully-qualified\n\t *        URI.\n\t * @return <code>Object</code> the current value of the property.\n\t * @throws SAXNotRecognizedException\n\t *         when SAXOutputter does not recognize the property name.\n\t * @throws SAXNotSupportedException\n\t *         when SAXOutputter recognizes the property name but cannot\n\t *         determine its value at this time."
        },
        "getSAXOutputProcessor": {
          "Javadoc": "* Get the current {@link SAXOutputProcessor} being used for output.\n\t * \n\t * @return The current SAXOutputProcessor"
        },
        "setSAXOutputProcessor": {
          "Javadoc": "* Set the current {@link SAXOutputProcessor} to be used for output.\n\t * \n\t * @param processor\n\t *        the new SAXOutputProcessor"
        },
        "getFormat": {
          "Javadoc": "* Get the current {@link Format} being used for output\n\t * \n\t * @return the current Format"
        },
        "setFormat": {
          "Javadoc": "* Set the current {@link Format} to be used for output.\n\t * \n\t * @param format\n\t *        the new Format"
        },
        "output": {
          "Javadoc": "* This will output a single JDOM element as a document, firing off the SAX\n\t * events that have been registered.\n\t * \n\t * @param node\n\t *        the <code>Element</code> node to output.\n\t * @throws JDOMException\n\t *         if any error occurred."
        },
        "outputFragment": {
          "Javadoc": "* This will output a single JDOM nodes as a fragment of an XML document,\n\t * firing off the SAX events that have been registered.\n\t * <p>\n\t * <strong>Warning</strong>: This method does not call the\n\t * {@link ContentHandler#setDocumentLocator},\n\t * {@link ContentHandler#startDocument} and\n\t * {@link ContentHandler#endDocument} callbacks on the\n\t * {@link #setContentHandler ContentHandler}. The user shall invoke these\n\t * methods directly prior/after outputting the document fragments.\n\t * </p>\n\t * \n\t * @param node\n\t *        the <code>Content</code> node to output.\n\t * @throws JDOMException\n\t *         if any error occurred.\n\t * @see #outputFragment(java.util.List)"
        },
        "handleError": {
          "Javadoc": "* <p>\n\t * Notifies the registered {@link ErrorHandler SAX error handler}\n\t * (if any) of an input processing error. The error handler can\n\t * choose to absorb the error and let the processing continue.\n\t * </p>\n\t *\n\t * @param exception <code>JDOMException</code> containing the\n\t *                  error information; will be wrapped in a\n\t *                  {@link SAXParseException} when reported to\n\t *                  the SAX error handler.\n\t *\n\t * @throws JDOMException if no error handler has been registered\n\t *                       or if the error handler fired a\n\t *                       {@link SAXException}."
        },
        "getLocator": {
          "Javadoc": "* Returns null.\n\t * \n\t * @return null\n\t * @deprecated there is no way to get a meaningful document Locator outside\n\t *             of an active output process, and the contents of the locator\n\t *             are meaningless outside of an active output process anyway."
        }
      }
    },
    "org.jdom2.output.DefaultSAXOutputProcessor": {
      "Javadoc": ""
    },
    "org.jdom2.output.StAXEventOutputter": {
      "Javadoc": "",
      "methods": {
        "setFormat": {
          "Javadoc": "* Sets the new format logic for the StAXStreamOutputter. Note the Format object is\n\t * cloned internally before use.\n\t * \n\t * @see #getFormat()\n\t * @param newFormat\n\t *        the format to use for subsequent output"
        },
        "getFormat": {
          "Javadoc": "* Returns the current format in use by the StAXStreamOutputter. Note the Format\n\t * object returned is <b>not</b> a clone of the one used internally, thus,\n\t * an StAXStreamOutputter instance is able to have it's Format changed by changing\n\t * the settings on the Format instance returned by this method.\n\t * \n\t * @return the current Format instance used by this StAXStreamOutputter."
        },
        "getStAXStream": {
          "Javadoc": "* Returns the current XMLOutputProcessor instance in use by the\n\t * StAXStreamOutputter.\n\t * \n\t * @return the current XMLOutputProcessor instance."
        },
        "setStAXEventProcessor": {
          "Javadoc": "* Sets a new XMLOutputProcessor instance for this StAXStreamOutputter. Note the\n\t * processor object is expected to be thread-safe.\n\t * \n\t * @param processor\n\t *        the new XMLOutputProcesor to use for output"
        },
        "getEventFactory": {
          "Javadoc": "* @return the current XMLEventFactory used by this StAXEventOutputter"
        },
        "setEventFactory": {
          "Javadoc": "* @param myEventFactory the XMLEventFactory to use for subsequent output."
        },
        "output": {
          "Javadoc": "* Print out an <code>{@link EntityRef}</code>.\n\t * \n\t * @param entity\n\t *        <code>EntityRef</code> to output.\n\t * @param out\n\t *        <code>XMLEventConsumer</code> to use.\n\t * @throws XMLStreamException\n\t *         - if there's any problem writing.\n\t * @throws NullPointerException\n\t *         if the specified content is null."
        },
        "outputElementContent": {
          "Javadoc": "* This will handle printing out an <code>{@link\n\t * Element}</code>'s content only, not including its tag, and attributes.\n\t * This can be useful for printing the content of an element that contains\n\t * HTML, like \"&lt;description&gt;JDOM is\n\t * &lt;b&gt;fun&gt;!&lt;/description&gt;\".\n\t * \n\t * @param element\n\t *        <code>Element</code> to output.\n\t * @param out\n\t *        <code>XMLEventConsumer</code> to use.\n\t * @throws XMLStreamException\n\t *         - if there's any problem writing.\n\t * @throws NullPointerException\n\t *         if the specified content is null."
        },
        "clone": {
          "Javadoc": "* Returns a cloned copy of this StAXStreamOutputter."
        },
        "toString": {
          "Javadoc": "* Return a string listing of the settings for this StAXStreamOutputter instance.\n\t * \n\t * @return a string listing the settings for this StAXStreamOutputter instance"
        }
      }
    },
    "org.jdom2.output.DefaultStAXEventProcessor": {
      "Javadoc": "\n\t * Create a final and static instance of the AbstractStAXEventProcessor The\n\t * final part is important because it improves performance.\n\t * <p>\n\t * The JDOM user can change the actual XMLOutputProcessor with the\n\t * {@link StAXEventOutputter#setStAXEventProcessor(StAXEventProcessor)} method.\n\t * \n\t * @author rolf\n\t "
    },
    "org.jdom2.output.StAXStreamOutputter": {
      "Javadoc": "",
      "methods": {
        "setFormat": {
          "Javadoc": "* Sets the new format logic for the StAXStreamOutputter. Note the Format object is\n\t * cloned internally before use.\n\t * \n\t * @see #getFormat()\n\t * @param newFormat\n\t *        the format to use for subsequent output"
        },
        "getFormat": {
          "Javadoc": "* Returns the current format in use by the StAXStreamOutputter. Note the Format\n\t * object returned is <b>not</b> a clone of the one used internally, thus,\n\t * an StAXStreamOutputter instance is able to have it's Format changed by changing\n\t * the settings on the Format instance returned by this method.\n\t * \n\t * @return the current Format instance used by this StAXStreamOutputter."
        },
        "getStAXStream": {
          "Javadoc": "* Returns the current XMLOutputProcessor instance in use by the\n\t * StAXStreamOutputter.\n\t * \n\t * @return the current XMLOutputProcessor instance."
        },
        "setStAXStreamProcessor": {
          "Javadoc": "* Sets a new XMLOutputProcessor instance for this StAXStreamOutputter. Note the\n\t * processor object is expected to be thread-safe.\n\t * \n\t * @param processor\n\t *        the new XMLOutputProcesor to use for output"
        },
        "output": {
          "Javadoc": "* Print out an <code>{@link EntityRef}</code>.\n\t * \n\t * @param entity\n\t *        <code>EntityRef</code> to output.\n\t * @param out\n\t *        <code>XMLStreamWriter</code> to use.\n\t * @throws XMLStreamException\n\t *         - if there's any problem writing.\n\t * @throws NullPointerException\n\t *         if the specified content is null."
        },
        "outputElementContent": {
          "Javadoc": "* This will handle printing out an <code>{@link\n\t * Element}</code>'s content only, not including its tag, and attributes.\n\t * This can be useful for printing the content of an element that contains\n\t * HTML, like \"&lt;description&gt;JDOM is\n\t * &lt;b&gt;fun&gt;!&lt;/description&gt;\".\n\t * \n\t * @param element\n\t *        <code>Element</code> to output.\n\t * @param out\n\t *        <code>XMLStreamWriter</code> to use.\n\t * @throws XMLStreamException\n\t *         - if there's any problem writing.\n\t * @throws NullPointerException\n\t *         if the specified content is null."
        },
        "clone": {
          "Javadoc": "* Returns a cloned copy of this StAXStreamOutputter."
        },
        "toString": {
          "Javadoc": "* Return a string listing of the settings for this StAXStreamOutputter instance.\n\t * \n\t * @return a string listing the settings for this StAXStreamOutputter instance"
        }
      }
    },
    "org.jdom2.output.DefaultStAXStreamProcessor": {
      "Javadoc": "\n\t * Create a final and static instance of the AbstractStAXStreamProcessor The\n\t * final part is important because it improves performance.\n\t * <p>\n\t * The JDOM user can change the actual XMLOutputProcessor with the\n\t * {@link StAXStreamOutputter#setStAXStreamProcessor(StAXStreamProcessor)} method.\n\t * \n\t * @author rolf\n\t "
    },
    "org.jdom2.output.support.AbstractDOMOutputProcessor": {
      "Javadoc": "\n * This class provides a concrete implementation of {@link DOMOutputProcessor}\n * for supporting the {@link DOMOutputter}.\n * <p>\n * <h2>Overview</h2>\n * <p>\n * This class is marked abstract even though all methods are fully implemented.\n * The <code>process*(...)</code> methods are public because they match the\n * DOMOutputProcessor interface but the remaining methods are all protected.\n * <p>\n * People who want to create a custom DOMOutputProcessor for DOMOutputter\n * are able to extend this class and modify any functionality they want. Before\n * sub-classing this you should first check to see if the {@link Format} class\n * can get you the results you want.\n * <p>\n * <b><i>Subclasses of this should have reentrant methods.</i></b> This is\n * easiest to accomplish simply by not allowing any instance fields. If your\n * sub-class has an instance field/variable, then it's probably broken.\n * <p>\n * <h2>The Stacks</h2>\n * <p>\n * One significant feature of this implementation is that it creates and\n * maintains both a {@link NamespaceStack} and {@link FormatStack} that are\n * managed in the\n * {@link #printElement(FormatStack, NamespaceStack, org.w3c.dom.Document, Element)}\n * method. The stacks are pushed and popped in that method only. They\n * significantly improve the performance and readability of the code.\n * <p>\n * The NamespaceStack is only sent through to the\n * {@link #printElement(FormatStack, NamespaceStack, org.w3c.dom.Document, Element)}\n * and\n * {@link #printContent(FormatStack, NamespaceStack, org.w3c.dom.Document, org.w3c.dom.Node, Walker)}\n * methods, but the FormatStack is pushed through to all print* Methods.\n * <p>\n * <h2>Content Processing</h2>\n * <p>\n * This class delegates the formatting of the content to the Walker classes\n * and you can create your own custom walker by overriding the\n * {@link #buildWalker(FormatStack, List, boolean)} method.\n * \n * @see DOMOutputter\n * @see DOMOutputProcessor\n * @since JDOM2\n * @author Rolf Lear\n ",
      "methods": {
        "getXmlnsTagFor": {
          "Javadoc": "* This will handle adding any <code>{@link Namespace}</code> attributes to\n\t * the DOM tree.\n\t * \n\t * @param ns\n\t *        <code>Namespace</code> to add definition of"
        },
        "printDocument": {
          "Javadoc": "* This will handle printing of a {@link Document}.\n\t * \n\t * @param fstack\n\t *        the FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param basedoc\n\t *        The org.w3c.dom.Document for creating DOM Nodes\n\t * @param doc\n\t *        <code>Document</code> to write.\n\t * @return The input JDOM document converted to a DOM document."
        },
        "printProcessingInstruction": {
          "Javadoc": "* This will handle printing of a {@link ProcessingInstruction}.\n\t * \n\t * @param fstack\n\t *        the FormatStack\n\t * @param basedoc\n\t *        The org.w3c.dom.Document for creating DOM Nodes\n\t * @param pi\n\t *        <code>ProcessingInstruction</code> to write.\n\t * @return The input JDOM ProcessingInstruction converted to a DOM\n\t *         ProcessingInstruction."
        },
        "printComment": {
          "Javadoc": "* This will handle printing of a {@link Comment}.\n\t * \n\t * @param fstack\n\t *        the FormatStack\n\t * @param basedoc\n\t *        The org.w3c.dom.Document for creating DOM Nodes\n\t * @param comment\n\t *        <code>Comment</code> to write.\n\t * @return The input JDOM Comment converted to a DOM Comment"
        },
        "printEntityRef": {
          "Javadoc": "* This will handle printing of an {@link EntityRef}.\n\t * \n\t * @param fstack\n\t *        the FormatStack\n\t * @param basedoc\n\t *        The org.w3c.dom.Document for creating DOM Nodes\n\t * @param entity\n\t *        <code>EntotyRef</code> to write.\n\t * @return The input JDOM EntityRef converted to a DOM EntityReference"
        },
        "printCDATA": {
          "Javadoc": "* This will handle printing of a {@link CDATA}.\n\t * \n\t * @param fstack\n\t *        the FormatStack\n\t * @param basedoc\n\t *        The org.w3c.dom.Document for creating DOM Nodes\n\t * @param cdata\n\t *        <code>CDATA</code> to write.\n\t * @return The input JDOM CDATA converted to a DOM CDATASection"
        },
        "printText": {
          "Javadoc": "* This will handle printing of a {@link Text}.\n\t * \n\t * @param fstack\n\t *        the FormatStack\n\t * @param basedoc\n\t *        The org.w3c.dom.Document for creating DOM Nodes\n\t * @param text\n\t *        <code>Text</code> to write.\n\t * @return The input JDOM Text converted to a DOM Text"
        },
        "printAttribute": {
          "Javadoc": "* This will handle printing of a {@link Attribute}.\n\t * \n\t * @param fstack\n\t *        the FormatStack\n\t * @param basedoc\n\t *        The org.w3c.dom.Document for creating DOM Nodes\n\t * @param attribute\n\t *        <code>Attribute</code> to write.\n\t * @return The input JDOM Attribute converted to a DOM Attr"
        },
        "printElement": {
          "Javadoc": "* This will handle printing of an {@link Element}.\n\t * <p>\n\t * This method arranges for outputting the Element infrastructure including\n\t * Namespace Declarations and Attributes.\n\t * <p>\n\t * The actual formatting of the content is managed by the Walker created for\n\t * the Element's content.\n\t * <p>\n\t * \n\t * @param fstack\n\t *        the FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param basedoc\n\t *        The org.w3c.dom.Document for creating DOM Nodes\n\t * @param element\n\t *        <code>Element</code> to write.\n\t * @return The input JDOM Element converted to a DOM Element"
        },
        "printContent": {
          "Javadoc": "* This will handle printing of a List of {@link Content}. Uses the Walker\n\t * to ensure formatting.\n\t * \n\t * @param fstack\n\t *        the FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param basedoc\n\t *        The org.w3c.dom.Document for creating DOM Nodes\n\t * @param target\n\t *        the DOM node this content should be appended to.\n\t * @param walker\n\t *        <code>List</code> of <code>Content</code> to write."
        },
        "helperContentDispatcher": {
          "Javadoc": "* This method contains code which is reused in a number of places. It\n\t * simply determines what content is passed in, and dispatches it to the\n\t * correct print* method.\n\t * \n\t * @param fstack\n\t *        The current FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param basedoc\n\t *        The org.w3c.dom.Document for creating DOM Nodes\n\t * @param content\n\t *        The content to dispatch\n\t * @return the input JDOM Content converted to a DOM Node."
        }
      }
    },
    "org.jdom2.output.support.AbstractFormattedWalker": {
      "Javadoc": "\n * This Walker implementation walks a list of Content in a Formatted form of\n * some sort.\n * <p>\n * The JDOM content can be loosely categorised in to 'Text-like' content\n * (consisting of Text, CDATA, and EntityRef), and everything else. This\n * distinction is significant for for this class and it's sub-classes.\n * <p>\n * There will be text manipulation, and some (but not necessarily \n * all) Text-like content will be returned as text() instead of next().\n * <p>\n * The trick in this class is that it deals with the regular content, and\n * delegates the Text-like content to the sub-classes.\n * <p>\n * Subclasses are tasked with analysing chunks of Text-like content in the\n * {@link #analyzeMultiText(MultiText, int, int)}  method. The subclasses are\n * responsible for adding the relevant text content to the suppliedMultiText\n * instance in such a way as to result in the correct format.\n * <p>\n * The Subclass needs to concern itself with only the text portion because this\n * abstract class will ensure the Text-like content is appropriately indented.\n * \n * @author Rolf Lear\n ",
      "methods": {
        "analyzeMultiText": {
          "Javadoc": "* Add the content at the specified indices to the provided MultiText.\n\t * @param mtext the MultiText to append to.\n\t * @param offset The first Text-like content to add to the MultiText\n\t * @param len The number of Text-like content items to add."
        },
        "get": {
          "Javadoc": "* Get the content at a position in the input content. Useful for subclasses\n\t * in their {@link #analyzeMultiText(MultiText, int, int)} calls.\n\t * @param index the index to get the content at.\n\t * @return the content at the index."
        },
        "buildMultiText": {
          "Javadoc": "* This method was changed in 2.0.5\n\t * It now is only called when building the content of the variable pendingmt\n\t * This is important, because only pendingmt can be referenced when analyzing\n\t * the MultiText content.\n\t * @param first\n\t * @return The updated MultiText containing the correct sequence of Text-like content"
        }
      }
    },
    "org.jdom2.output.support.MultiText": {
      "Javadoc": "\n\t * Collect together the items that constitute formatted Text-like content.\n\t * \n\t * @author Rolf Lear\n\t *\n\t ",
      "methods": {
        "ensurespace": {
          "Javadoc": "* Ensure we have space for at least one more text-like item."
        },
        "closeText": {
          "Javadoc": "* Handle the case where we have been accumulating true text content,\n\t\t * and the next item is not more text.\n\t\t * @param postspace true if the last char in the text should be a space"
        },
        "appendText": {
          "Javadoc": "* Append some text to the text-like sequence that will be treated as\n\t\t * plain XML text (PCDATA). If the last content added to this text-like\n\t\t * sequence then this new text will be appended directly to the previous\n\t\t * text.\n\t\t * \n\t\t * @param trim How to prepare the Text content\n\t\t * @param text The actual Text content."
        },
        "appendCDATA": {
          "Javadoc": "* Append some text to the text-like sequence that will be treated as\n\t\t * CDATA.\n\t\t * @param trim How to prepare the CDATA content\n\t\t * @param text The actual CDATA content."
        },
        "forceAppend": {
          "Javadoc": "* Simple method that ensures the text is processed, regardless of\n\t\t * content, and is never escaped.\n\t\t * @param text"
        },
        "appendRaw": {
          "Javadoc": "* Add some JDOM Content (typically an EntityRef) that will be treated\n\t\t * as part of the Text-like sequence.\n\t\t * @param c the content to add."
        },
        "done": {
          "Javadoc": "* Indicate that there is no further content to be added to the\n\t\t * text-like sequence."
        }
      }
    },
    "org.jdom2.output.support.AbstractOutputProcessor": {
      "Javadoc": "\n * Methods common/useful for all Outputter processors.\n * \n * @since JDOM2\n * @author Rolf Lear\n ",
      "methods": {
        "buildWalker": {
          "Javadoc": "* Create a walker to process Content List values.\n\t * <p>\n\t * If you require a custom walker to process content in a specific way\n\t * then you probably want to override this method to build the walker you\n\t * want.\n\t * \n\t * @param fstack The current FormatStack for the walker (this should not be \n\t * \t\tmodified by the Walker).\n\t * @param content The list of content to walk.\n\t * @param escape If you want the Text values to be XMLEscaped then supply\n\t *      a non-null EscapeStrategy to use.\n\t * @return the created walker."
        }
      }
    },
    "org.jdom2.output.support.AbstractSAXOutputProcessor": {
      "Javadoc": "\n * Outputs a JDOM document as a stream of SAX2 events.\n * <p>\n * Most ContentHandler callbacks are supported. Neither\n * <code>ignorableWhitespace()</code> nor <code>skippedEntity()</code> have been\n * implemented.\n * <p>\n * At this time, it is not possible to access notations and unparsed entity\n * references in a DTD from JDOM. Therefore, full <code>DTDHandler</code>\n * call-backs have not been implemented yet.\n * <p>\n * The <code>ErrorHandler</code> call-backs have not been implemented, since\n * these are supposed to be invoked when the document is parsed and at this\n * point the document exists in memory and is known to have no errors.\n * </p>\n * The SAX2 API does not support whitespace formatting outside the root element.\n * As a consequence any Formatting options that would normally affect the\n * structures outside the root element will be ignored.\n * \n * @author Brett McLaughlin\n * @author Jason Hunter\n * @author Fred Trimble\n * @author Bradley S. Huffman\n * @author Rolf Lear\n ",
      "methods": {
        "printDocument": {
          "Javadoc": "* This will handle printing of a {@link Document}.\n\t * \n\t * @param out\n\t *        <code>SAXTarget</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param document\n\t *        <code>Document</code> to write.\n\t * @throws SAXException\n\t *         if the destination SAXTarget fails"
        },
        "printDocType": {
          "Javadoc": "* This will handle printing of a {@link DocType}.\n\t * \n\t * @param out\n\t *        <code>SAXTarget</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param docType\n\t *        <code>DocType</code> to write.\n\t * @throws SAXException\n\t *         if the destination SAXTarget fails"
        },
        "printProcessingInstruction": {
          "Javadoc": "* This will handle printing of a {@link ProcessingInstruction}.\n\t * \n\t * @param out\n\t *        <code>SAXTarget</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param pi\n\t *        <code>ProcessingInstruction</code> to write.\n\t * @throws SAXException\n\t *         if the destination SAXTarget fails"
        },
        "printComment": {
          "Javadoc": "* This will handle printing of a {@link Comment}.\n\t * \n\t * @param out\n\t *        <code>SAXTarget</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param comment\n\t *        <code>Comment</code> to write.\n\t * @throws SAXException\n\t *         if the destination SAXTarget fails"
        },
        "printEntityRef": {
          "Javadoc": "* This will handle printing of an {@link EntityRef}.\n\t * \n\t * @param out\n\t *        <code>SAXTarget</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param entity\n\t *        <code>EntotyRef</code> to write.\n\t * @throws SAXException\n\t *         if the destination SAXTarget fails"
        },
        "printCDATA": {
          "Javadoc": "* This will handle printing of a {@link CDATA}.\n\t * \n\t * @param out\n\t *        <code>SAXTarget</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param cdata\n\t *        <code>CDATA</code> to write.\n\t * @throws SAXException\n\t *         if the destination SAXTarget fails"
        },
        "printText": {
          "Javadoc": "* This will handle printing of a {@link Text}.\n\t * \n\t * @param out\n\t *        <code>SAXTarget</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param text\n\t *        <code>Text</code> to write.\n\t * @throws SAXException\n\t *         if the destination SAXTarget fails"
        },
        "printElement": {
          "Javadoc": "* This will handle printing of an {@link Element}.\n\t * <p>\n\t * This method arranges for outputting the Element infrastructure including\n\t * Namespace Declarations and Attributes.\n\t * \n\t * @param out\n\t *        <code>SAXTarget</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param element\n\t *        <code>Element</code> to write.\n\t * @throws SAXException\n\t *         if the destination SAXTarget fails"
        },
        "printContent": {
          "Javadoc": "* This will handle printing of a List of {@link Content}.\n\t * <p>\n\t * It relies on the appropriate Walker to get the formatting right.\n\t * \n\t * @param out\n\t *        <code>SAXTarget</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param walker\n\t *        <code>Waker</code> of <code>Content</code> to write.\n\t * @throws SAXException\n\t *         if the destination SAXTarget fails"
        },
        "getAttributeTypeName": {
          "Javadoc": "* <p>\n\t * Returns the SAX 2.0 attribute type string from the type of a JDOM\n\t * Attribute.\n\t * </p>\n\t * \n\t * @param type\n\t *        <code>int</code> the type of the JDOM attribute.\n\t * @return <code>String</code> the SAX 2.0 attribute type string.\n\t * @see org.jdom2.Attribute#getAttributeType\n\t * @see org.xml.sax.Attributes#getType"
        },
        "createParser": {
          "Javadoc": "* <p>\n\t * Creates a SAX XMLReader.\n\t * </p>\n\t * \n\t * @return <code>XMLReader</code> a SAX2 parser.\n\t * @throws Exception\n\t *         if no parser can be created."
        },
        "createDTDParser": {
          "Javadoc": "* <p>\n\t * This will create a SAX XMLReader capable of parsing a DTD and configure\n\t * it so that the DTD parsing events are routed to the handlers registered\n\t * onto this SAXOutputter.\n\t * </p>\n\t * \n\t * @return <code>XMLReader</code> a SAX2 parser.\n\t * @throws JDOMException\n\t *         if no parser can be created."
        }
      }
    },
    "org.jdom2.output.support.AbstractStAXEventProcessor": {
      "Javadoc": "\n * This class provides a concrete implementation of {@link StAXEventProcessor}\n * for supporting the {@link StAXEventOutputter}.\n * <p>\n * <h2>Overview</h2>\n * <p>\n * This class is marked abstract even though all methods are fully implemented.\n * The <code>process*(...)</code> methods are public because they match the\n * StAXEventProcessor interface but the remaining methods are all protected.\n * <p>\n * People who want to create a custom StAXEventProcessor for StAXEventOutputter are\n * able to extend this class and modify any functionality they want. Before\n * sub-classing this you should first check to see if the {@link Format} class\n * can get you the results you want.\n * <p>\n * <b><i>Subclasses of this should have reentrant methods.</i></b> This is\n * easiest to accomplish simply by not allowing any instance fields. If your\n * sub-class has an instance field/variable, then it's probably broken.\n * <p>\n * <h2>The Stacks</h2>\n * <p>\n * One significant feature of this implementation is that it creates and\n * maintains both a {@link NamespaceStack} and {@link FormatStack} that are\n * managed in the\n * {@link #printElement(XMLEventConsumer, FormatStack, NamespaceStack, XMLEventFactory, Element)} method.\n * The stacks are pushed and popped in that method only. They significantly\n * improve the performance and readability of the code.\n * <p>\n * The NamespaceStack is only sent through to the\n * {@link #printElement(XMLEventConsumer, FormatStack, NamespaceStack, XMLEventFactory, Element)} and\n * {@link #printContent(XMLEventConsumer, FormatStack, NamespaceStack, XMLEventFactory, Walker)} methods, but\n * the FormatStack is pushed through to all print* Methods.\n * \n * @see StAXEventOutputter\n * @see StAXEventProcessor\n * @since JDOM2\n * @author Rolf Lear\n ",
      "methods": {
        "printDocument": {
          "Javadoc": "* This will handle printing of a {@link Document}.\n\t * \n\t * @param out\n\t *        <code>XMLEventConsumer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param eventfactory\n\t * \t\t  The XMLEventFactory for creating XMLEvents \n\t * @param doc\n\t *        <code>Document</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLEventConsumer fails"
        },
        "printDocType": {
          "Javadoc": "* This will handle printing of a {@link DocType}.\n\t * \n\t * @param out\n\t *        <code>XMLEventConsumer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param eventfactory\n\t * \t\t  The XMLEventFactory for creating XMLEvents \n\t * @param docType\n\t *        <code>DocType</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLEventConsumer fails"
        },
        "printProcessingInstruction": {
          "Javadoc": "* This will handle printing of a {@link ProcessingInstruction}.\n\t * \n\t * @param out\n\t *        <code>XMLEventConsumer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param eventfactory\n\t * \t\t  The XMLEventFactory for creating XMLEvents \n\t * @param pi\n\t *        <code>ProcessingInstruction</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLEventConsumer fails"
        },
        "printComment": {
          "Javadoc": "* This will handle printing of a {@link Comment}.\n\t * \n\t * @param out\n\t *        <code>XMLEventConsumer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param eventfactory\n\t * \t\t  The XMLEventFactory for creating XMLEvents \n\t * @param comment\n\t *        <code>Comment</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLEventConsumer fails"
        },
        "printEntityRef": {
          "Javadoc": "* This will handle printing of an {@link EntityRef}.\n\t * \n\t * @param out\n\t *        <code>XMLEventConsumer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param eventfactory\n\t * \t\t  The XMLEventFactory for creating XMLEvents \n\t * @param entity\n\t *        <code>EntotyRef</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLEventConsumer fails"
        },
        "printCDATA": {
          "Javadoc": "* This will handle printing of a {@link CDATA}.\n\t * \n\t * @param out\n\t *        <code>XMLEventConsumer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param eventfactory\n\t * \t\t  The XMLEventFactory for creating XMLEvents \n\t * @param cdata\n\t *        <code>CDATA</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLEventConsumer fails"
        },
        "printText": {
          "Javadoc": "* This will handle printing of a {@link Text}.\n\t * \n\t * @param out\n\t *        <code>XMLEventConsumer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param eventfactory\n\t * \t\t  The XMLEventFactory for creating XMLEvents \n\t * @param text\n\t *        <code>Text</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLEventConsumer fails"
        },
        "printElement": {
          "Javadoc": "* This will handle printing of an {@link Element}.\n\t * <p>\n\t * This method arranges for outputting the Element infrastructure including\n\t * Namespace Declarations and Attributes.\n\t * <p>\n\t * \n\t * @param out\n\t *        <code>XMLEventConsumer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param eventfactory\n\t * \t\t  The XMLEventFactory for creating XMLEvents \n\t * @param element\n\t *        <code>Element</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLEventConsumer fails"
        },
        "printContent": {
          "Javadoc": "* This will handle printing of a List of {@link Content}.\n\t * <p>\n\t * \n\t * @param out\n\t *        <code>XMLEventConsumer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param eventfactory\n\t * \t\t  The XMLEventFactory for creating XMLEvents \n\t * @param walker\n\t *        <code>Walker</code> of <code>Content</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLEventConsumer fails"
        }
      }
    },
    "org.jdom2.output.support.NSIterator": {
      "Javadoc": ""
    },
    "org.jdom2.output.support.AttIterator": {
      "Javadoc": ""
    },
    "org.jdom2.output.support.AbstractStAXStreamProcessor": {
      "Javadoc": "\n * This class provides a concrete implementation of {@link StAXStreamProcessor}\n * for supporting the {@link StAXStreamOutputter}.\n * <p>\n * <h2>Overview</h2>\n * <p>\n * This class is marked abstract even though all methods are fully implemented.\n * The <code>process*(...)</code> methods are public because they match the\n * StAXStreamProcessor interface but the remaining methods are all protected.\n * <p>\n * People who want to create a custom StAXStreamProcessor for StAXStreamOutputter are\n * able to extend this class and modify any functionality they want. Before\n * sub-classing this you should first check to see if the {@link Format} class\n * can get you the results you want.\n * <p>\n * <b><i>Subclasses of this should have reentrant methods.</i></b> This is\n * easiest to accomplish simply by not allowing any instance fields. If your\n * sub-class has an instance field/variable, then it's probably broken.\n * <p>\n * <h2>The Stacks</h2>\n * <p>\n * One significant feature of this implementation is that it creates and\n * maintains both a {@link NamespaceStack} and {@link FormatStack} that are\n * managed in the\n * {@link #printElement(XMLStreamWriter, FormatStack, NamespaceStack, Element)} method.\n * The stacks are pushed and popped in that method only. They significantly\n * improve the performance and readability of the code.\n * <p>\n * The NamespaceStack is only sent through to the\n * {@link #printElement(XMLStreamWriter, FormatStack, NamespaceStack, Element)} and\n * {@link #printContent(XMLStreamWriter, FormatStack, NamespaceStack, Walker)} methods, but\n * the FormatStack is pushed through to all print* Methods.\n * <p>\n * \n * @see StAXStreamOutputter\n * @see StAXStreamProcessor\n * @since JDOM2\n * @author Rolf Lear\n ",
      "methods": {
        "printDocument": {
          "Javadoc": "* This will handle printing of a {@link Document}.\n\t * \n\t * @param out\n\t *        <code>XMLStreamWriter</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param doc\n\t *        <code>Document</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLStreamWriter fails"
        },
        "printDocType": {
          "Javadoc": "* This will handle printing of a {@link DocType}.\n\t * \n\t * @param out\n\t *        <code>XMLStreamWriter</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param docType\n\t *        <code>DocType</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLStreamWriter fails"
        },
        "printProcessingInstruction": {
          "Javadoc": "* This will handle printing of a {@link ProcessingInstruction}.\n\t * \n\t * @param out\n\t *        <code>XMLStreamWriter</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param pi\n\t *        <code>ProcessingInstruction</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLStreamWriter fails"
        },
        "printComment": {
          "Javadoc": "* This will handle printing of a {@link Comment}.\n\t * \n\t * @param out\n\t *        <code>XMLStreamWriter</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param comment\n\t *        <code>Comment</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLStreamWriter fails"
        },
        "printEntityRef": {
          "Javadoc": "* This will handle printing of an {@link EntityRef}.\n\t * \n\t * @param out\n\t *        <code>XMLStreamWriter</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param entity\n\t *        <code>EntotyRef</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLStreamWriter fails"
        },
        "printCDATA": {
          "Javadoc": "* This will handle printing of a {@link CDATA}.\n\t * \n\t * @param out\n\t *        <code>XMLStreamWriter</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param cdata\n\t *        <code>CDATA</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLStreamWriter fails"
        },
        "printText": {
          "Javadoc": "* This will handle printing of a {@link Text}.\n\t * \n\t * @param out\n\t *        <code>XMLStreamWriter</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param text\n\t *        <code>Text</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLStreamWriter fails"
        },
        "printElement": {
          "Javadoc": "* This will handle printing of an {@link Element}.\n\t * \n\t * @param out\n\t *        <code>XMLStreamWriter</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param element\n\t *        <code>Element</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLStreamWriter fails"
        },
        "printContent": {
          "Javadoc": "* This will handle printing of a List of {@link Content}.\n\t * <p>\n\t * \n\t * @param out\n\t *        <code>XMLStreamWriter</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param walker\n\t *        <code>Walker</code> of <code>Content</code> to write.\n\t * @throws XMLStreamException\n\t *         if the destination XMLStreamWriter fails"
        },
        "printNamespace": {
          "Javadoc": "* This will handle printing of any needed <code>{@link Namespace}</code>\n\t * declarations.\n\t * \n\t * @param out\n\t *        <code>XMLStreamWriter</code> to use.\n\t * @param fstack\n\t *        The current FormatStack\n\t * @param ns\n\t *        <code>Namespace</code> to print definition of\n\t * @throws XMLStreamException\n\t *         if the output fails"
        },
        "printAttribute": {
          "Javadoc": "* This will handle printing of an <code>{@link Attribute}</code>.\n\t * \n\t * @param out\n\t *        <code>XMLStreamWriter</code> to use.\n\t * @param fstack\n\t *        The current FormatStack\n\t * @param attribute\n\t *        <code>Attribute</code> to output\n\t * @throws XMLStreamException\n\t *         if the output fails"
        }
      }
    },
    "org.jdom2.output.support.AbstractXMLOutputProcessor": {
      "Javadoc": "\n * This class provides a concrete implementation of {@link XMLOutputProcessor}\n * for supporting the {@link XMLOutputter}.\n * <p>\n * <h2>Overview</h2>\n * <p>\n * This class is marked abstract even though all methods are fully implemented.\n * The <code>process*(...)</code> methods are public because they match the\n * XMLOutputProcessor interface but the remaining methods are all protected.\n * <p>\n * People who want to create a custom XMLOutputProcessor for XMLOutputter are\n * able to extend this class and modify any functionality they want. Before\n * sub-classing this you should first check to see if the {@link Format} class\n * can get you the results you want.\n * <p>\n * <b><i>Subclasses of this should have reentrant methods.</i></b> This is\n * easiest to accomplish simply by not allowing any instance fields. If your\n * sub-class has an instance field/variable, then it's probably broken.\n * <p>\n * <h2>The Stacks</h2>\n * <p>\n * One significant feature of this implementation is that it creates and\n * maintains both a {@link NamespaceStack} and {@link FormatStack} that are\n * managed in the\n * {@link #printElement(Writer, FormatStack, NamespaceStack, Element)} method.\n * The stacks are pushed and popped in that method only. They significantly\n * improve the performance and readability of the code.\n * <p>\n * The NamespaceStack is only sent through to the\n * {@link #printElement(Writer, FormatStack, NamespaceStack, Element)} and\n * {@link #printContent(Writer, FormatStack, NamespaceStack, Walker)} methods,\n * but the FormatStack is pushed through to all print* Methods.\n * <p>\n * <h2>Text Processing</h2>\n * <p>\n * In XML the concept of 'Text' can be loosely defined as anything that can be\n * found between an Element's start and end tags, excluding Comments and\n * Processing Instructions. When considered from a JDOM perspective, this means\n * {@link Text}, {@link CDATA} and {@link EntityRef} content. This will be\n * referred to as 'Text-like content'\n * <p>\n * XMLOutputter delegates the management and formatting of Content to a\n * Walker instance. See {@link Walker} and its various implementations for\n * details on how the Element content is processed.\n * <p>\n * Because the Walker interface specifies that Text/CDATA content may be\n * returned as either Text/CDATA instances or as formatted String values\n * this class sometimes uses printCDATA(...) and printText(...), and sometimes\n * uses the more direct {@link #textCDATA(Writer, String)} or\n * {@link #textRaw(Writer, String)} as\n * appropriate. In other words, subclasses should probably override these second\n * methods instead of the print methods.\n * <p>\n * <h2>Non-Text Content</h2>\n * <p>\n * Non-text content is processed via the respective print* methods. The usage\n * should be logical based on the method name.\n * <p>\n * The general observations are:\n * <ul>\n * <li>printElement - maintains the Stacks, prints the element open tags, with\n * attributes and namespaces. It checks to see whether the Element is text-only,\n * or has non-text content. If it is text-only there is no indent/newline\n * handling and it delegates to the correct text-type print method, otherwise it\n * delegates to printContent.\n * <li>printContent is called to output all lists of Content. It assumes that\n * all whitespace indentation/newlines are appropriate before it is called, but\n * it will ensure that padding is appropriate between the items in the list.\n * </ul>\n * <p>\n * <h2>Final Notes</h2> No methods actually write to the destination Writer\n * except the <code>write(...)</code> methods. Thus, all other methods do their\n * respective processing and delegate the actual destination output to the\n * {@link #write(Writer, char)} or {@link #write(Writer, String)} methods.\n * <p>\n * All Text-like content (printCDATA, printText, and printEntityRef) will\n * ultimately be output through the the text* methods (and no other content).\n * <p>\n *\n * @see XMLOutputter\n * @see XMLOutputProcessor\n * @since JDOM2\n * @author Rolf Lear\n ",
      "methods": {
        "write": {
          "Javadoc": "* Write a single character to the output Writer.\n\t * \n\t * @param out\n\t *        The Writer to write to.\n\t * @param c\n\t *        The char to write.\n\t * @throws IOException\n\t *         if the Writer fails."
        },
        "attributeEscapedEntitiesFilter": {
          "Javadoc": "* This will take the three pre-defined entities in XML 1.0 ('&lt;', '&gt;',\n\t * and '&amp;' - used specifically in XML elements) as well as CR/NL and\n\t * Quote characters which require escaping inside Attribute values and\n\t * convert their character representation to the appropriate entity\n\t * reference suitable for XML attribute content. Further, some special\n\t * characters (e.g. characters that are not valid in the current encoding)\n\t * are converted to escaped representations.\n\t * <p>\n\t * <b>Note:</b> If {@link FormatStack#getEscapeOutput()} is false then no\n\t * escaping will happen.\n\t * \n\t * @param out\n\t *        The destination Writer\n\t * @param fstack\n\t *        The {@link FormatStack}\n\t * @param value\n\t *        <code>String</code> Attribute value to escape.\n\t * @throws IOException\n\t *         if the destination Writer fails.\n\t * @throws IllegalDataException\n\t *         if an entity can not be escaped"
        },
        "textRaw": {
          "Javadoc": "* Convenience method that simply passes the input char to\n\t * {@link #write(Writer, char)}. This could be useful for subclasses to hook\n\t * in to. All text-type output will come through this or the\n\t * {@link #textRaw(Writer, String)} method.\n\t * \n\t * @param out\n\t *        the destination Writer.\n\t * @param ch\n\t *        the char to write.\n\t * @throws IOException\n\t *         if the Writer fails."
        },
        "textEntityRef": {
          "Javadoc": "* Write an {@link EntityRef} to the destination.\n\t * \n\t * @param out\n\t *        the destination Writer.\n\t * @param name\n\t *        the EntityRef's name.\n\t * @throws IOException\n\t *         if the Writer fails."
        },
        "textCDATA": {
          "Javadoc": "* Write a {@link CDATA} to the destination\n\t * @param out the destination Writer\n\t * @param text the CDATA text\n\t * @throws IOException if the Writer fails."
        },
        "printDocument": {
          "Javadoc": "* This will handle printing of a {@link Document}.\n\t * \n\t * @param out\n\t *        <code>Writer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param doc\n\t *        <code>Document</code> to write.\n\t * @throws IOException\n\t *         if the destination Writer fails"
        },
        "printDeclaration": {
          "Javadoc": "* This will handle printing of the XML declaration. Assumes XML version 1.0\n\t * since we don't directly know.\n\t * \n\t * @param out\n\t *        <code>Writer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @throws IOException\n\t *         if the destination Writer fails"
        },
        "printDocType": {
          "Javadoc": "* This will handle printing of a {@link DocType}.\n\t * \n\t * @param out\n\t *        <code>Writer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param docType\n\t *        <code>DocType</code> to write.\n\t * @throws IOException\n\t *         if the destination Writer fails"
        },
        "printProcessingInstruction": {
          "Javadoc": "* This will handle printing of a {@link ProcessingInstruction}.\n\t * \n\t * @param out\n\t *        <code>Writer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param pi\n\t *        <code>ProcessingInstruction</code> to write.\n\t * @throws IOException\n\t *         if the destination Writer fails"
        },
        "printComment": {
          "Javadoc": "* This will handle printing of a {@link Comment}.\n\t * \n\t * @param out\n\t *        <code>Writer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param comment\n\t *        <code>Comment</code> to write.\n\t * @throws IOException\n\t *         if the destination Writer fails"
        },
        "printEntityRef": {
          "Javadoc": "* This will handle printing of an {@link EntityRef}.\n\t * \n\t * @param out\n\t *        <code>Writer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param entity\n\t *        <code>EntotyRef</code> to write.\n\t * @throws IOException\n\t *         if the destination Writer fails"
        },
        "printCDATA": {
          "Javadoc": "* This will handle printing of a {@link CDATA}.\n\t * \n\t * @param out\n\t *        <code>Writer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param cdata\n\t *        <code>CDATA</code> to write.\n\t * @throws IOException\n\t *         if the destination Writer fails"
        },
        "printText": {
          "Javadoc": "* This will handle printing of a {@link Text}.\n\t * \n\t * @param out\n\t *        <code>Writer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param text\n\t *        <code>Text</code> to write.\n\t * @throws IOException\n\t *         if the destination Writer fails"
        },
        "printElement": {
          "Javadoc": "* This will handle printing of an {@link Element}.\n\t * <p>\n\t * This method arranges for outputting the Element infrastructure including\n\t * Namespace Declarations and Attributes.\n\t * \n\t * @param out\n\t *        <code>Writer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param element\n\t *        <code>Element</code> to write.\n\t * @throws IOException\n\t *         if the destination Writer fails"
        },
        "printContent": {
          "Javadoc": "* This will handle printing of a List of {@link Content}.\n\t * <p>\n\t * The list of Content is basically processed as one of three types of\n\t * content\n\t * <ol>\n\t * <li>Consecutive text-type (Text, CDATA, and EntityRef) content\n\t * <li>Stand-alone text-type content\n\t * <li>Non-text-type content.\n\t * </ol>\n\t * Although the code looks complex, the theory is conceptually simple:\n\t * <ol>\n\t * <li>identify one of the three types (consecutive, stand-alone, non-text)\n\t * <li>do indent if any is specified.\n\t * <li>send the type to the respective print* handler (e.g.\n\t * {@link #printCDATA(Writer, FormatStack, CDATA)}, or\n\t * {@link #printComment(Writer, FormatStack, Comment)},\n\t * <li>do a newline if one is specified.\n\t * <li>loop back to 1. until there's no more content to process.\n\t * </ol>\n\t * \n\t * @param out\n\t *        <code>Writer</code> to use.\n\t * @param fstack\n\t *        the FormatStack\n\t * @param nstack\n\t *        the NamespaceStack\n\t * @param walker\n\t *        {@link Walker} of <code>Content</code> to write.\n\t * @throws IOException\n\t *         if the destination Writer fails"
        },
        "printNamespace": {
          "Javadoc": "* This will handle printing of any needed <code>{@link Namespace}</code>\n\t * declarations.\n\t * \n\t * @param out\n\t *        <code>Writer</code> to use.\n\t * @param fstack\n\t *        The current FormatStack\n\t * @param ns\n\t *        <code>Namespace</code> to print definition of\n\t * @throws IOException\n\t *         if the output fails"
        },
        "printAttribute": {
          "Javadoc": "* This will handle printing of an <code>{@link Attribute}</code>.\n\t * \n\t * @param out\n\t *        <code>Writer</code> to use.\n\t * @param fstack\n\t *        The current FormatStack\n\t * @param attribute\n\t *        <code>Attribute</code> to output\n\t * @throws IOException\n\t *         if the output fails"
        }
      }
    },
    "org.jdom2.output.support.DOMOutputProcessor": {
      "Javadoc": "\n * This interface provides a base support for the {@link DOMOutputter}.\n * <p>\n * People who want to create a custom DOMOutputProcessor for DOMOutputter are\n * able to implement this interface with the following notes and restrictions:\n * <ol>\n * <li>The DOMOutputter will call one, and only one of the\n * <code>process(Format,*)</code> methods each time the DOMOutputter is\n * requested to output some JDOM content. It is thus safe to assume that a\n * <code>process(Format,*)</code> method can set up any infrastructure needed to\n * process the content, and that the DOMOutputter will not re-call that method,\n * or some other <code>process(Format,*)</code> method for the same output\n * sequence.\n * <li>The process methods should be thread-safe and reentrant: The same\n * <code>process(Format,*)</code> method may (will) be called concurrently from\n * different threads.\n * </ol>\n * <p>\n * The {@link AbstractDOMOutputProcessor} class is a full implementation of this\n * interface and is fully customisable. People who want a custom DOMOutputter\n * are encouraged to extend the AbstractDOMOutputProcessor rather than do a full\n * re-implementation of this interface.\n * \n * @see DOMOutputter\n * @see AbstractDOMOutputProcessor\n * @since JDOM2\n * @author Rolf Lear\n ",
      "methods": {
        "process": {
          "Javadoc": "* This will convert the <code>{@link Attribute}</code> using the given DOM\n\t * Document to create the resulting DOM Attr.\n\t * \n\t * @param basedoc\n\t *        The DOM document to use for the conversion\n\t * @param format\n\t *        <code>Format</code> instance specifying output style\n\t * @param attribute\n\t *        <code>Attribute</code> to format.\n\t * @return The input JDOM Attribute converted to a DOM Attr"
        }
      }
    },
    "org.jdom2.output.support.FormatStack": {
      "Javadoc": "\n * FormatStack implements a mechanism where the formatting details can be\n * changed mid-tree, but then get reverted when that tree segment is\n * complete.\n * <p>\n * This class is intended as a working-class for in the various outputter\n * implementations. It is inly public so that people extending the\n * Abstract*Processor classes can take advantage of it's functionality.\n * <p>\n * The value this class adds is:\n * <ul>\n * <li>Fast - \n * </ul>\n * \n * @since JDOM2\n * @author Rolf Lear\n ",
      "methods": {
        "resetReusableIndents": {
          "Javadoc": "* If the indent strategy changes part way through a stack, we need to\n\t * clear the previously calculated reusable 'lower' levels of the stack."
        },
        "getIndent": {
          "Javadoc": "* @return the original {@link Format#getIndent()}, may be null"
        },
        "getLineSeparator": {
          "Javadoc": "* @return the original {@link Format#getLineSeparator()}"
        },
        "getEncoding": {
          "Javadoc": "* @return the original {@link Format#getEncoding()}"
        },
        "isOmitDeclaration": {
          "Javadoc": "* @return the original {@link Format#getOmitDeclaration()}"
        },
        "isSpecifiedAttributesOnly": {
          "Javadoc": "* Indicate whether only those Attributes specified in the XML\n\t * should be output.\n\t * @return true if only the specified Attributes should be output,\n\t *      false if those Attributes defaulted from the DTD or XML schema\n\t *      should be output too."
        },
        "isOmitEncoding": {
          "Javadoc": "* @return the original {@link Format#getOmitEncoding()}"
        },
        "isExpandEmptyElements": {
          "Javadoc": "* @return the original {@link Format#getExpandEmptyElements()}"
        },
        "getEscapeStrategy": {
          "Javadoc": "* @return the original {@link Format#getEscapeStrategy()}"
        },
        "isIgnoreTrAXEscapingPIs": {
          "Javadoc": "* @return the current depth's {@link Format#getIgnoreTrAXEscapingPIs()}"
        },
        "setIgnoreTrAXEscapingPIs": {
          "Javadoc": "* Set the current depth's {@link Format#getIgnoreTrAXEscapingPIs()}\n\t * \n\t * @param ignoreTrAXEscapingPIs\n\t *        the boolean value to set."
        },
        "getEscapeOutput": {
          "Javadoc": "* The escapeOutput flag can be set or unset. When set, Element text and\n\t * Attribute values are 'escaped' so that the output is valid XML. When\n\t * unset, the Element text and Attribute values are not escaped.\n\t * \n\t * @return the current depth's escapeOutput flag."
        },
        "setEscapeOutput": {
          "Javadoc": "* The escapeOutput flag can be set or unset. When set, Element text and\n\t * Attribute values are 'escaped' so that the output is valid XML. When\n\t * unset, the Element text and Attribute values are not escaped.\n\t * \n\t * @param escape\n\t *        what to set the current level's escapeOutput flag to."
        },
        "getDefaultMode": {
          "Javadoc": "* @return the TextMode that was originally set for this stack before\n\t *         any modifications."
        },
        "getLevelIndent": {
          "Javadoc": "* @return the current depth's accumulated/maintained indent, may be null"
        },
        "getPadBetween": {
          "Javadoc": "* Get the end-of-line indenting sequence for before the first item in an\n\t * Element, as well as between subsequent items (but not after the last item)\n\t * @return the String EOL sequence followed by an indent. Null if it should \n\t * be ignored"
        },
        "getPadLast": {
          "Javadoc": "* Get the end-of-line indenting sequence for after the last item in an\n\t * Element\n\t * @return the String EOL sequence followed by an indent. Null if it should \n\t * be ignored"
        },
        "setLevelIndent": {
          "Javadoc": "* Override the current depth's accumulated line indent.\n\t * \n\t * @param indent\n\t *        the indent to set."
        },
        "getLevelEOL": {
          "Javadoc": "* @return the current depth's End-Of-Line sequence, may be null"
        },
        "setLevelEOL": {
          "Javadoc": "* Set the current depth's End-Of-Line sequence\n\t * \n\t * @param newline\n\t *        the new End-Of-Line sequence to set."
        },
        "getTextMode": {
          "Javadoc": "* @return the current depth's {@link Format#getTextMode()}"
        },
        "setTextMode": {
          "Javadoc": "* Change the current level's TextMode\n\t * \n\t * @param mode\n\t *        the new mode to set."
        },
        "push": {
          "Javadoc": "* Create a new depth level on the stack. The previous level's details\n\t * are copied to this level, and the accumulated indent (if any) is\n\t * indented further."
        },
        "pop": {
          "Javadoc": "* Move back a level on the stack."
        }
      }
    },
    "org.jdom2.output.support.SAXOutputProcessor": {
      "Javadoc": "\n * This interface provides a base support for the {@link SAXOutputter}.\n * <p>\n * People who want to create a custom SAXOutputProcessor for SAXOutputter are\n * able to implement this interface with the following notes and restrictions:\n * <ol>\n * <li>The SAXOutputter will call one, and only one of the\n * <code>process(SAXTarget,Format,*)</code> methods each time the SAXOutputter\n * is requested to output some JDOM content. It is thus safe to assume that a\n * <code>process(SAXTarget,Format,*)</code> method can set up any infrastructure\n * needed to process the content, and that the SAXOutputter will not re-call\n * that method, or some other <code>process(SAXTarget,Format,*)</code> method\n * for the same output sequence.\n * <li>The process methods should be thread-safe and reentrant: The same\n * <code>process(SAXTarget,Format,*)</code> method may (will) be called\n * concurrently from different threads.\n * </ol>\n * <p>\n * The {@link AbstractSAXOutputProcessor} class is a full implementation of this\n * interface and is fully customisable. People who want a custom SAXOutputter\n * are encouraged to extend the AbstractSAXOutputProcessor rather than do a full\n * re-implementation of this interface.\n * \n * @see SAXOutputter\n * @see AbstractSAXOutputProcessor\n * @since JDOM2\n * @author Rolf Lear\n ",
      "methods": {
        "process": {
          "Javadoc": "* Print out a <code>{@link EntityRef}</code>.\n\t * \n\t * @param out\n\t *        <code>SAXTarget</code> to use.\n\t * @param format\n\t *        <code>Format</code> instance specifying output style\n\t * @param entity\n\t *        <code>EntityRef</code> to output.\n\t * @throws JDOMException\n\t *         if there is an issue encountered during output.\n\t * @throws NullPointerException\n\t *         if the input content is null"
        },
        "processAsDocument": {
          "Javadoc": "* This will handle printing out a list of nodes thats encapsulated in\n\t * start/end Document SAX events. This can be useful for printing the\n\t * content of an element that contains HTML, like\n\t * \"&lt;description&gt;JDOM is &lt;b&gt;fun&gt;!&lt;/description&gt;\".\n\t * \n\t * @param out\n\t *        <code>SAXTarget</code> to use.\n\t * @param format\n\t *        <code>Format</code> instance specifying output style\n\t * @param list\n\t *        <code>List</code> of nodes.\n\t * @throws JDOMException\n\t *         if there is an issue encountered during output.\n\t * @throws NullPointerException\n\t *         if the input list is null or contains null members\n\t * @throws ClassCastException\n\t *         if any of the list members are not {@link Content}"
        }
      }
    },
    "org.jdom2.output.support.SAXTarget": {
      "Javadoc": "\n * The target for all SAX notifications in this OuputProcessor\n * \n * @author Rolf Lear\n ",
      "methods": {
        "getContentHandler": {
          "Javadoc": "* @return The target ContentHandler"
        },
        "getErrorHandler": {
          "Javadoc": "* @return The target ErrorHandler"
        },
        "getDTDHandler": {
          "Javadoc": "* @return The target DTDHandler"
        },
        "getEntityResolver": {
          "Javadoc": "* @return The target EntityResolver"
        },
        "getLexicalHandler": {
          "Javadoc": "* @return The target LexicalHandler"
        },
        "getDeclHandler": {
          "Javadoc": "* @return The target DeclHandler"
        },
        "isDeclareNamespaces": {
          "Javadoc": "* @return Whether to declare Namespaces"
        },
        "isReportDTDEvents": {
          "Javadoc": "* @return Whether to report DTD Events"
        },
        "getLocator": {
          "Javadoc": "* @return the Locator used for this Output"
        }
      }
    },
    "org.jdom2.output.support.SAXLocator": {
      "Javadoc": "\n\t * A locator specific to the SAXOutputter process.\n\t * @author Rolf Lear\n\t *\n\t ",
      "methods": {
        "setNode": {
          "Javadoc": "* Set the location on this SAXLocator\n\t\t * @param node The location to set."
        }
      }
    },
    "org.jdom2.output.support.StAXEventProcessor": {
      "Javadoc": "\n * This interface provides a base support for the {@link XMLOutputter}.\n * <p>\n * People who want to create a custom XMLOutputProcessor for XMLOutputter are\n * able to implement this interface with the following notes and restrictions:\n * <ol>\n * <li>The XMLOutputter will call one, and only one of the <code>process(XMLEventConsumer,Format,*)</code> methods each\n * time the XMLOutputter is requested to output some JDOM content. It is thus\n * safe to assume that a <code>process(XMLEventConsumer,Format,*)</code> method can set up any\n * infrastructure needed to process the content, and that the XMLOutputter will\n * not re-call that method, or some other <code>process(XMLEventConsumer,Format,*)</code> method for the same output\n * sequence.\n * <li>The process methods should be thread-safe and reentrant: The same\n * <code>process(XMLEventConsumer,Format,*)</code> method may (will) be called concurrently from different threads.\n * </ol>\n * <p>\n * The {@link AbstractXMLOutputProcessor} class is a full implementation of this\n * interface and is fully customisable. People who want a custom XMLOutputter\n * are encouraged to extend the AbstractXMLOutputProcessor rather than do a full\n * re-implementation of this interface.\n * \n * @see XMLOutputter\n * @see AbstractXMLOutputProcessor\n * @since JDOM2\n * @author Rolf Lear\n ",
      "methods": {
        "process": {
          "Javadoc": "* Print out a <code>{@link EntityRef}</code>.\n\t * \n\t * @param out\n\t *        <code>XMLEventConsumer</code> to use.\n\t * @param format\n\t *        <code>Format</code> instance specifying output style\n\t * @param eventfactory\n\t * \t\t  <code>XMLEventFactory</code> for creating XMLEvent instances.\n\t * @param entity\n\t *        <code>EntityRef</code> to output.\n\t * @throws XMLStreamException\n\t *         if there's any problem writing.\n\t * @throws NullPointerException\n\t *         if the input content is null"
        }
      }
    },
    "org.jdom2.output.support.StAXStreamProcessor": {
      "Javadoc": "\n * This interface provides a base support for the {@link XMLOutputter}.\n * <p>\n * People who want to create a custom XMLOutputProcessor for XMLOutputter are\n * able to implement this interface with the following notes and restrictions:\n * <ol>\n * <li>The XMLOutputter will call one, and only one of the <code>process(XMLStreamWriter,Format,*)</code> methods each\n * time the XMLOutputter is requested to output some JDOM content. It is thus\n * safe to assume that a <code>process(XMLStreamWriter,Format,*)</code> method can set up any\n * infrastructure needed to process the content, and that the XMLOutputter will\n * not re-call that method, or some other <code>process(XMLStreamWriter,Format,*)</code> method for the same output\n * sequence.\n * <li>The process methods should be thread-safe and reentrant: The same\n * <code>process(XMLStreamWriter,Format,*)</code> method may (will) be called concurrently from different threads.\n * </ol>\n * <p>\n * The {@link AbstractXMLOutputProcessor} class is a full implementation of this\n * interface and is fully customisable. People who want a custom XMLOutputter\n * are encouraged to extend the AbstractXMLOutputProcessor rather than do a full\n * re-implementation of this interface.\n * \n * @see XMLOutputter\n * @see AbstractXMLOutputProcessor\n * @since JDOM2\n * @author Rolf Lear\n ",
      "methods": {
        "process": {
          "Javadoc": "* Print out a <code>{@link EntityRef}</code>.\n\t * \n\t * @param out\n\t *        <code>XMLStreamWriter</code> to use.\n\t * @param format\n\t *        <code>Format</code> instance specifying output style\n\t * @param entity\n\t *        <code>EntityRef</code> to output.\n\t * @throws XMLStreamException\n\t *         if there's any problem writing.\n\t * @throws NullPointerException\n\t *         if the input content is null"
        }
      }
    },
    "org.jdom2.output.support.Walker": {
      "Javadoc": "\n * A model for walking the (potentially formatted) content of an Element.\n * <p>\n * Implementations of this class restructure the content to a particular format\n * and expose the restructured content in this 'Walker' which is a loose\n * equivalent to an iterator.\n * <p>\n * The next() method will return a Content instance (perhaps null) if there\n * is more content. If the returned content is null, then there will be some\n * formatted characters available in the text() method. These characters may\n * need to be represented as CDATA (check the isCDATA() method).\n * <p>\n * Not all CDATA and Text nodes need to be reformatted, and as a result they\n * may be returned as their original CDATA or Text instances instead of using\n * the formatted text() / isCDATA() mechanism.\n * <p>\n * The 'Rules' for the walkers are that no padding is done before the\n * first content step, and no padding is done after the last content step (but\n * the first/last content items may be trimmed to the correct format).\n * Any required padding will be done in plain text (not CDATA) content.\n * Consecutive CDATA sections may be separated by whitespace text for example. \n * \n * @author Rolf Lear\n *\n ",
      "methods": {
        "isAllText": {
          "Javadoc": "* If all the content in this walker is empty, or if whatever content\n\t * is available is Text-like.\n\t * <p>\n\t * Text-like content is considered to be {@link Text}, {@link CDATA},\n\t * {@link EntityRef}, or any (potentially mixed) sequence of these types,\n\t * but no other types.\n\t * \n\t * @return true if there is no content, or all content is Text"
        },
        "isAllWhitespace": {
          "Javadoc": "* If all the content is Text-like ({@link #isAllText()} returns true), and\n\t * additionally that any content is either Text or CDATA, and that the\n\t * values of these Text/CDATA members are all XML Whitespace.\n\t * @return true"
        },
        "hasNext": {
          "Javadoc": "* Behaves similarly to to a regular Iterator\n\t * \n\t * @return true if there is more content to be processed"
        },
        "next": {
          "Javadoc": "* Similar to an Iterator, but null return values need special treatment.\n\t * \n\t * @return the next content to be processed, perhaps null if the next\n\t * content is re-formatted text of some sort (Text / CDATA).\n\t * @throws NoSuchElementException if there is no further content."
        },
        "text": {
          "Javadoc": "* If the previous call to next() returned null, then this will return the\n\t * required text to be processed. Check to see whether this text is CDATA\n\t * by calling the isCDATA() method.\n\t * @return The current text value (null if the previous invocation of next()\n\t * returned a non-null value).\n\t * @throws IllegalStateException if there was not previous call to next()"
        },
        "isCDATA": {
          "Javadoc": "* If the previous next() method returned null, then this will indicate\n\t * whether the current text() value is CDATA or regular Text.\n\t * @return true if the current text() is valid, and is CDATA.\n\t * @throws IllegalStateException if there was not previous call to next()"
        }
      }
    },
    "org.jdom2.output.support.WalkerNORMALIZE": {
      "Javadoc": "\n * This Walker implementation will produce trimmed text content.\n * \n * @author Rolf Lear\n *\n "
    },
    "org.jdom2.output.support.WalkerPRESERVE": {
      "Javadoc": "\n * This Walker implementation walks a list of Content in it's original RAW\n * format. There is no text manipulation, and all content will be returned as\n * the input type. In other words, next() will never be null, and text() will\n * always be null.\n * \n * @author Rolf Lear\n *\n "
    },
    "org.jdom2.output.support.WalkerTRIM": {
      "Javadoc": "\n * This Walker implementation will produce trimmed text content.\n * \n * @author Rolf Lear\n *\n "
    },
    "org.jdom2.output.support.WalkerTRIM_FULL_WHITE": {
      "Javadoc": "\n * This Walker implementation will produce trimmed text content.\n * \n * @author Rolf Lear\n *\n "
    },
    "org.jdom2.output.support.XMLOutputProcessor": {
      "Javadoc": "\n * This interface provides a base support for the {@link XMLOutputter}.\n * <p>\n * People who want to create a custom XMLOutputProcessor for XMLOutputter are\n * able to implement this interface with the following notes and restrictions:\n * <ol>\n * <li>The XMLOutputter will call one, and only one of the <code>process(Writer,Format,*)</code> methods each\n * time the XMLOutputter is requested to output some JDOM content. It is thus\n * safe to assume that a <code>process(Writer,Format,*)</code> method can set up any\n * infrastructure needed to process the content, and that the XMLOutputter will\n * not re-call that method, or some other <code>process(Writer,Format,*)</code> method for the same output\n * sequence.\n * <li>The process methods should be thread-safe and reentrant: The same\n * <code>process(Writer,Format,*)</code> method may (will) be called concurrently from different threads.\n * </ol>\n * <p>\n * The {@link AbstractXMLOutputProcessor} class is a full implementation of this\n * interface and is fully customisable. People who want a custom XMLOutputter\n * are encouraged to extend the AbstractXMLOutputProcessor rather than do a full\n * re-implementation of this interface.\n * \n * @see XMLOutputter\n * @see AbstractXMLOutputProcessor\n * @since JDOM2\n * @author Rolf Lear\n ",
      "methods": {
        "process": {
          "Javadoc": "* Print out a <code>{@link EntityRef}</code>.\n\t * \n\t * @param out\n\t *        <code>Writer</code> to use.\n\t * @param format\n\t *        <code>Format</code> instance specifying output style\n\t * @param entity\n\t *        <code>EntityRef</code> to output.\n\t * @throws IOException\n\t *         if there's any problem writing.\n\t * @throws NullPointerException\n\t *         if the input content is null"
        }
      }
    },
    "org.jdom2.output.XMLOutputter": {
      "Javadoc": "",
      "methods": {
        "makeWriter": {
          "Javadoc": "* Get an OutputStreamWriter, use specified encoding.\n\t * \n\t * @param out\n\t *        The OutputStream to wrap in the writer\n\t * @param format\n\t *        The format is used to obtain the Character Encoding.\n\t * @return An Writer (Buffered) that delegates to the specified output steam\n\t * @throws java.io.UnsupportedEncodingException"
        },
        "setFormat": {
          "Javadoc": "* Sets the new format logic for the XMLOutputter. Note the Format object is\n\t * cloned internally before use.\n\t * \n\t * @see #getFormat()\n\t * @param newFormat\n\t *        the format to use for subsequent output"
        },
        "getFormat": {
          "Javadoc": "* Returns the current format in use by the XMLOutputter. Note the Format\n\t * object returned is <b>not</b> a clone of the one used internally, thus,\n\t * an XMLOutputter instance is able to have it's Format changed by changing\n\t * the settings on the Format instance returned by this method.\n\t * \n\t * @return the current Format instance used by this XMLOutputter."
        },
        "getXMLOutputProcessor": {
          "Javadoc": "* Returns the current XMLOutputProcessor instance in use by the\n\t * XMLOutputter.\n\t * \n\t * @return the current XMLOutputProcessor instance."
        },
        "setXMLOutputProcessor": {
          "Javadoc": "* Sets a new XMLOutputProcessor instance for this XMLOutputter. Note the\n\t * processor object is expected to be thread-safe.\n\t * \n\t * @param processor\n\t *        the new XMLOutputProcesor to use for output"
        },
        "output": {
          "Javadoc": "* Print out an <code>{@link EntityRef}</code>.\n\t * \n\t * @param entity\n\t *        <code>EntityRef</code> to output.\n\t * @param out\n\t *        <code>Writer</code> to use.\n\t * @throws IOException\n\t *         - if there's any problem writing.\n\t * @throws NullPointerException\n\t *         if the specified content is null."
        },
        "outputElementContent": {
          "Javadoc": "* This will handle printing out an <code>{@link\n\t * Element}</code>'s content only, not including its tag, and attributes.\n\t * This can be useful for printing the content of an element that contains\n\t * HTML, like \"&lt;description&gt;JDOM is\n\t * &lt;b&gt;fun&gt;!&lt;/description&gt;\".\n\t * \n\t * @param element\n\t *        <code>Element</code> to output.\n\t * @param out\n\t *        <code>Writer</code> to use.\n\t * @throws IOException\n\t *         - if there's any problem writing.\n\t * @throws NullPointerException\n\t *         if the specified content is null."
        },
        "outputString": {
          "Javadoc": "* Return a string representing an {@link EntityRef}.\n\t * <p>\n\t * <b>Warning</b>: a String is Unicode, which may not match the outputter's\n\t * specified encoding.\n\t * \n\t * @param entity\n\t *        <code>EntityRef</code> to format.\n\t * @return the input content formatted as an XML String.\n\t * @throws NullPointerException\n\t *         if the specified content is null."
        },
        "outputElementContentString": {
          "Javadoc": "* This will handle printing out an <code>{@link\n\t * Element}</code>'s content only, not including its tag, and attributes.\n\t * This can be useful for printing the content of an element that contains\n\t * HTML, like \"&lt;description&gt;JDOM is\n\t * &lt;b&gt;fun&gt;!&lt;/description&gt;\".\n\t * <p>\n\t * <b>Warning</b>: a String is Unicode, which may not match the outputter's\n\t * specified encoding.\n\t * \n\t * @param element\n\t *        <code>Element</code> to output.\n\t * @return the input content formatted as an XML String.\n\t * @throws NullPointerException\n\t *         if the specified content is null."
        },
        "escapeAttributeEntities": {
          "Javadoc": "* Escape any characters in the input string in such a way that the returned\n\t * value is valid as output in an XML Attribute value.\n\t * \n\t * @param str\n\t *        the input String to escape\n\t * @return the escaped version of the input String"
        },
        "escapeElementEntities": {
          "Javadoc": "* Escape any characters in the input string in such a way that the returned\n\t * value is valid as output in an XML Element text.\n\t * \n\t * @param str\n\t *        the input String to escape\n\t * @return the escaped version of the input String"
        },
        "clone": {
          "Javadoc": "* Returns a cloned copy of this XMLOutputter."
        },
        "toString": {
          "Javadoc": "* Return a string listing of the settings for this XMLOutputter instance.\n\t * \n\t * @return a string listing the settings for this XMLOutputter instance"
        }
      }
    },
    "org.jdom2.output.DefaultXMLProcessor": {
      "Javadoc": "\n\t * Create a final and static instance of the AbstractXMLOutputProcessor The\n\t * final part is important because it improves performance.\n\t * <p>\n\t * The JDOM user can change the actual XMLOutputProcessor with the\n\t * {@link XMLOutputter#setXMLOutputProcessor(XMLOutputProcessor)} method.\n\t * \n\t * @author rolf\n\t ",
      "methods": {
        "escapeAttributeEntities": {
          "Javadoc": "* A helper method to implement backward-compatibility with JDOM1\n\t\t * \n\t\t * @see XMLOutputter#escapeAttributeEntities(String)\n\t\t * @param str\n\t\t *        The String to output.\n\t\t * @param format\n\t\t *        The format details to use.\n\t\t * @return The input String escaped as an attribute value."
        },
        "escapeElementEntities": {
          "Javadoc": "* A helper method to implement backward-compatibility with JDOM1\n\t\t * \n\t\t * @see XMLOutputter#escapeElementEntities(String)\n\t\t * @param str\n\t\t *        The String to output.\n\t\t * @param format\n\t\t *        The format details to use.\n\t\t * @return The input String escaped as an element text value."
        }
      }
    },
    "org.jdom2.Parent": {
      "Javadoc": "\n * Interface for JDOM objects which are allowed to contain\n * {@link Content} content - {@link Element} and {@link Document}. \n *\n * @see org.jdom2.Content\n * @see org.jdom2.Document\n * @see org.jdom2.Element\n *\n * @author Bradley S. Huffman\n * @author Jason Hunter\n * @author Rolf Lear\n ",
      "methods": {
        "getContentSize": {
          "Javadoc": "* Returns the number of children in this parent's content list.\n\t * Children may be any {@link Content} type.\n\t *\n\t * @return number of children"
        },
        "indexOf": {
          "Javadoc": "* Returns the index of the supplied child in the content list,\n\t * or -1 if not a child of this parent.\n\t *\n\t * @param child  child to search for\n\t * @return       index of child, or -1 if not found"
        },
        "cloneContent": {
          "Javadoc": "* Returns a list containing detached clones of this parent's content list.\n\t *\n\t * @return list of cloned child content"
        },
        "getContent": {
          "Javadoc": "* Returns as a {@link java.util.List} the content of\n\t * this parent that matches the supplied filter. The returned list is\n\t * <b>\"live\"</b> and in document order. Any modifications to it affect\n\t * the element's actual contents. Modifications are checked for\n\t * conformance to XML 1.0 rules.\n\t * <p>\n\t * Sequential traversal through the List is best done with an Iterator\n\t * since the underlying implement of {@link java.util.List#size} may\n\t * require walking the entire list and indexed lookups may require\n\t * starting at the beginning each time.\n\t * @param <E> The Generic type of the returned content (the Filter's type)\n\t *\n\t * @param  filter filter to apply\n\t * @return a list of the content of the parent matching the filter\n\t * @throws IllegalStateException if parent is a Document\n\t *         and the root element is not set"
        },
        "removeContent": {
          "Javadoc": "* Removes and returns the child at the given\n\t * index, or returns null if there's no such child.\n\t *\n\t * @param index index of child to remove\n\t * @return detached child at given index or null if no\n\t * @throws IndexOutOfBoundsException if index is negative or beyond\n\t *             the current number of children"
        },
        "clone": {
          "Javadoc": "* Obtain a deep, unattached copy of this parent and it's children.\n\t *\n\t * @return a deep copy of this parent and it's children."
        },
        "getDescendants": {
          "Javadoc": "* Returns an {@link java.util.Iterator} that walks over all descendants\n\t * in document order applying the Filter to return only content that\n\t * match the filter rule.  With filters you can match only Elements,\n\t * only Comments, Elements or Comments, only Elements with a given name\n\t * and/or prefix, and so on.\n\t * <p>\n\t * Note that this method returns an IteratorIterable instance, which means\n\t * that you can use it either as an Iterator, or an Iterable, allowing both:\n\t * <p>\n\t * <pre>\n\t *   for (Iterator<Element> it = parent.getDescendants(Filters.element());\n\t *           it.hasNext();) {\n\t *       Element e = it.next();\n\t *       ....\n\t *   }\n\t * </pre>\n\t * and\n\t * <pre>\n\t *   for (Element e : parent.getDescendants(Filters.element())) {\n\t *       ....\n\t *   }\n\t * </pre>\n\t * The Iterator version is most useful if you need to do list modification\n\t * on the iterator (using remove()), and for compatibility with JDOM 1.x\n\t * \n\t * @param <E> The generic type of the returned descendant data\n\t * @param filter filter to select which descendants to see\n\t * @return an iterator to walk descendants that match a filter"
        },
        "getParent": {
          "Javadoc": "* Return this parent's parent, or null if this parent is currently\n\t * not attached to another parent. This is the same method as in Content but\n\t * also added to Parent to allow more easy up-the-tree walking.\n\t *\n\t * @return this parent's parent or null if none"
        },
        "getDocument": {
          "Javadoc": "* Return this parent's owning document or null if the branch containing\n\t * this parent is currently not attached to a document.\n\t *\n\t * @return this child's owning document or null if none"
        },
        "canContainContent": {
          "Javadoc": "* Test whether this Parent instance can contain the specified content\n\t * at the specified position.\n\t * @param content The content to be checked\n\t * @param index The location where the content would be put.\n\t * @param replace true if the intention is to replace the content already at\n\t * \t\t\t\tthe index.\n\t * @throws IllegalAddException if there is a problem with the content"
        },
        "addContent": {
          "Javadoc": "* Inserts the content in a collection into the content list\n\t * at the given index.  In event of an exception the original content\n\t * will be unchanged and the objects in the supplied collection will be\n\t * unaltered.\n\t *\n\t * @param index location for adding the collection\n\t * @param c  collection to insert\n\t * @return            the parent on which the method was called\n\t * @throws IndexOutOfBoundsException if index is negative or beyond\n\t *         the current number of children\n\t * @throws IllegalAddException if any item in the collection\n\t *         already has a parent or is of an illegal type."
        }
      }
    },
    "org.jdom2.ProcessingInstruction": {
      "Javadoc": "",
      "methods": {
        "setTarget": {
          "Javadoc": "* This will set the target for the PI.\n\t *\n\t * @param newTarget <code>String</code> new target of PI.\n\t * @return <code>ProcessingInstruction</code> - this PI modified."
        },
        "getValue": {
          "Javadoc": "* Returns the XPath 1.0 string value of this element, which is the\n\t * data of this PI.\n\t *\n\t * @return the data of this PI"
        },
        "getTarget": {
          "Javadoc": "* This will retrieve the target of the PI.\n\t *\n\t * @return <code>String</code> - target of PI."
        },
        "getData": {
          "Javadoc": "* This will return the raw data from all instructions.\n\t *\n\t * @return <code>String</code> - data of PI."
        },
        "getPseudoAttributeNames": {
          "Javadoc": "* This will return a <code>List</code> containing the names of the\n\t * \"attribute\" style pieces of name/value pairs in this PI's data.\n\t *\n\t * @return <code>List</code> - the <code>List</code> containing the\n\t *         \"attribute\" names."
        },
        "setData": {
          "Javadoc": "* This will set the name/value pairs within the passed\n\t * <code>Map</code> as the pairs for the data of\n\t * this PI.  The keys should be the pair name\n\t * and the values should be the pair values.\n\t *\n\t * @param data new map data to use\n\t * @return <code>ProcessingInstruction</code> - modified PI."
        },
        "getPseudoAttributeValue": {
          "Javadoc": "* This will return the value for a specific\n\t * name/value pair on the PI.  If no such pair is\n\t * found for this PI, null is returned.\n\t *\n\t * @param name <code>String</code> name of name/value pair\n\t *             to lookup value for.\n\t * @return <code>String</code> - value of name/value pair."
        },
        "setPseudoAttribute": {
          "Javadoc": "* This will set a pseudo attribute with the given name and value.\n\t * If the PI data is not already in a pseudo-attribute format, this will\n\t * replace the existing data.\n\t *\n\t * @param name <code>String</code> name of pair.\n\t * @param value <code>String</code> value for pair.\n\t * @return <code>ProcessingInstruction</code> this PI modified."
        },
        "removePseudoAttribute": {
          "Javadoc": "* This will remove the pseudo attribute with the specified name.\n\t *\n\t * @param name name of pseudo attribute to remove\n\t * @return <code>boolean</code> - whether the requested\n\t *         instruction was removed."
        },
        "toString": {
          "Javadoc": "* This returns a <code>String</code> representation of the\n\t * <code>ProcessingInstruction</code>, suitable for debugging. If the XML\n\t * representation of the <code>ProcessingInstruction</code> is desired,\n\t * {@link org.jdom2.output.XMLOutputter#outputString(ProcessingInstruction)}\n\t * should be used.\n\t *\n\t * @return <code>String</code> - information about the\n\t *         <code>ProcessingInstruction</code>"
        },
        "parseData": {
          "Javadoc": "* This will parse and load the instructions for the PI.\n\t * This is separated to allow it to occur once and then be reused."
        },
        "extractQuotedString": {
          "Javadoc": "* This is a helper routine, only used by parseData, to extract a\n\t * quoted String from the input parameter, rawData. A quoted string\n\t * can use either single or double quotes, but they must match up.\n\t * A singly quoted string can contain an unbalanced amount of double\n\t * quotes, or vice versa. For example, the String \"JDOM's the best\"\n\t * is legal as is 'JDOM\"s the best'.\n\t *\n\t * @param rawData the input string from which a quoted string is to\n\t *                be extracted.\n\t * @return the first quoted string encountered in the input data. If\n\t *         no quoted string is found, then the empty string, \"\", is\n\t *         returned.\n\t * @see #parseData"
        }
      }
    },
    "org.jdom2.SlimJDOMFactory": {
      "Javadoc": "\n * This JDOMFactory instance reduces the amount of memory used by JDOM content.\n * It does this by reusing String instances instead of using new (but equals())\n * instances. It uses the {@link StringBin} class to provide a String cache.\n * \n * @see StringBin\n * @author Rolf Lear\n *\n ",
      "methods": {
        "clearCache": {
          "Javadoc": "* Reset any Cached String instance data from this SlimJDOMFaxctory cache."
        }
      }
    },
    "org.jdom2.StringBin": {
      "Javadoc": "\n * This is a mechanism for storing and reusing unique instances of Strings.\n * The idea is that in XML the tag names, attribute names, and other String\n * content is often repeated a lot. Each repeat is typically done as a new\n * String instance. This class makes it possible to substantially reduce memory\n * usage by reusing String instances instead of keeping the new ones.\n * <p>\n * This class is not the same as String.intern() because String.intern() uses\n * the PermGen memory space (very limited in size), whereas this uses the heap.\n * <p>\n * The primary goal of this class is to be as memory efficient as possible. This\n * has the interesting side effect of reducing the amount of time spent in\n * garbage-collection cycles. While this does increase the amount of time to\n * process a String, it means that subsequent String values can be 'recycled'\n * fast, and, ideally, never need to leave the 'eden space' in the memory model\n * which in turn means that the duplicate strings do not even hit the GC\n * overhead. It is easy to measure that this process takes longer than simply\n * keeping the duplicate String values, but it is much harder to measure the\n * decreased cost of GC. It would be somewhat fair to say that the memory\n * benefit is substantial, and the cost of allocation is offset by the savings\n * in garbage collection. This trade-off is dependent on the amount of duplicate\n * data you have. In XML where there are lots of repeating patterns of element\n * and attribute names this can add up pretty fast.\n * <p>\n * This class is not thread-safe.\n * \n * @author Rolf Lear\n *\n ",
      "methods": {
        "locate": {
          "Javadoc": "* This code effectively does a binary search for a value.\n\t * The order of the data in a bucket is increasing-by-hashcode, and then\n\t * for values with the same hashcode, it is increasing by alphabetical. \n\t * @param hash\n\t * @param value\n\t * @param bucket\n\t * @param length\n\t * @return"
        },
        "reuse": {
          "Javadoc": "* Get a String instance that is equal to the input value. This may or may\n\t * not be the same instance as the input value. Null input values will\n\t * reuse() as null.\n\t * @param value The value to check.\n\t * @return a String that is equals() to the input value, or null if the\n\t * input was null"
        },
        "rehash": {
          "Javadoc": "* Store the existing values in a new and larger set of buckets.\n\t * This reduces the number of values in each bucket, which improves insert\n\t * time.\n\t * <p>\n\t * The data is stored in hashCode() order, and then alphabetically for\n\t * those instances where two String values have the same hashCode().\n\t * <p>\n\t * The bucketing hash key is calculated in a specific way that guarantees\n\t * that when we rehash there values in a bucket will be divided between\n\t * a new set of buckets, and no other source bucket will ever add values\n\t * to a bucket that we are dividing our bucket to.\n\t * <p> \n\t * The combination of the bucket hash key, and the bucket ordering means\n\t * that during a rehash we never have to insert values in to the middle of\n\t * the bucket."
        },
        "compact": {
          "Javadoc": "* Compact a Java String to its smallest char[] backing array.\n\t * Java often reuses the char[] array that backs String classes. If you have\n\t * one String value and substring it, or some other methods, then instead of\n\t * creating a new char[] array it reuses the original one. This can lead to \n\t * small String values being backed by very large arrays. We do not want to\n\t * be caching these large arrays... just the smallest.\n\t * @param input The String to compact\n\t * @return a Compacted version of the String."
        },
        "size": {
          "Javadoc": "* Number of registered Strings\n\t * @return the number of registered String values."
        }
      }
    },
    "org.jdom2.Text": {
      "Javadoc": "\n * An XML character sequence. Provides a modular, parentable method of\n * representing text. Text makes no guarantees about the underlying textual\n * representation of character data, but does expose that data as a Java String.\n *\n * @author  Brett McLaughlin\n * @author  Jason Hunter\n * @author  Bradley S. Huffman\n ",
      "methods": {
        "getText": {
          "Javadoc": "* This returns the value of this <code>Text</code> node as a Java\n\t * <code>String</code>.\n\t *\n\t * @return <code>String</code> - character content of this node."
        },
        "getTextTrim": {
          "Javadoc": "* This returns the textual content with all surrounding whitespace\n\t * removed.  If only whitespace exists, the empty string is returned.\n\t *\n\t * @return trimmed text content or empty string"
        },
        "getTextNormalize": {
          "Javadoc": "* This returns the textual content with all surrounding whitespace\n\t * removed and internal whitespace normalized to a single space.  If\n\t * only whitespace exists, the empty string is returned.\n\t *\n\t * @return normalized text content or empty string"
        },
        "normalizeString": {
          "Javadoc": "* This returns a new string with all surrounding whitespace\n\t * removed and internal whitespace normalized to a single space.  If\n\t * only whitespace exists, the empty string is returned.\n\t * <p>\n\t * Per XML 1.0 Production 3 whitespace includes: #x20, #x9, #xD, #xA\n\t * </p>\n\t *\n\t * @param str string to be normalized.\n\t * @return normalized string or empty string"
        },
        "setText": {
          "Javadoc": "* This will set the value of this <code>Text</code> node.\n\t *\n\t * @param str value for node's content.\n\t * @return the object on which the method was invoked\n\t * @throws IllegalDataException if <code>str</code> contains an\n\t *         illegal character such as a vertical tab (as determined\n\t *         by {@link org.jdom2.Verifier#checkCharacterData})"
        },
        "append": {
          "Javadoc": "* This will append the content of another <code>Text</code> node\n\t * to this node.\n\t *\n\t * @param text Text node to append."
        },
        "getValue": {
          "Javadoc": "* Returns the XPath 1.0 string value of this element, which is the\n\t * text itself.\n\t *\n\t * @return the text"
        },
        "toString": {
          "Javadoc": "* This returns a <code>String</code> representation of the\n\t * <code>Text</code> node, suitable for debugging. If the XML\n\t * representation of the <code>Text</code> node is desired,\n\t * either <code>{@link #getText}</code> or\n\t * {@link org.jdom2.output.XMLOutputter#outputString(Text)}</code>\n\t * should be used.\n\t *\n\t * @return <code>String</code> - information about this node."
        }
      }
    },
    "org.jdom2.transform.JDOMResult": {
      "Javadoc": "\n * A holder for an XSL Transformation result, generally a list of nodes\n * although it can be a JDOM Document also. As stated by the XSLT 1.0\n * specification, the result tree generated by an XSL transformation is not\n * required to be a well-formed XML document. The result tree may have \"any\n * sequence of nodes as children that would be possible for an\n * element node\".\n * <p>\n * The following example shows how to apply an XSL Transformation\n * to a JDOM document and get the transformation result in the form\n * of a list of JDOM nodes:\n * <pre><code>\n *   public static List transform(Document doc, String stylesheet)\n *                                        throws JDOMException {\n *     try {\n *       Transformer transformer = TransformerFactory.newInstance()\n *                             .newTransformer(new StreamSource(stylesheet));\n *       JDOMSource in = new JDOMSource(doc);\n *       JDOMResult out = new JDOMResult();\n *       transformer.transform(in, out);\n *       return out.getResult();\n *     }\n *     catch (TransformerException e) {\n *       throw new JDOMException(\"XSLT Transformation failed\", e);\n *     }\n *   }\n * </code></pre>\n *\n * @see      org.jdom2.transform.JDOMSource\n *\n * @author  Laurent Bihanic\n * @author  Jason Hunter\n ",
      "methods": {
        "setResult": {
          "Javadoc": "* Sets the object(s) produced as result of an XSL Transformation.\n\t * <p>\n\t * <strong>Note</strong>: This method shall be used by the\n\t * {@link javax.xml.transform.Transformer} implementations that\n\t * natively support JDOM to directly set the transformation\n\t * result rather than considering this object as a\n\t * {@link SAXResult}.  Applications should <i>not</i> use this\n\t * method.</p>\n\t *\n\t * @param  result   the result of a transformation as a\n\t *                  {@link java.util.List list} of JDOM nodes\n\t *                  (Elements, Texts, Comments, PIs...).\n\t *\n\t * @see    #getResult"
        },
        "getResult": {
          "Javadoc": "* Returns the result of an XSL Transformation as a list of JDOM\n\t * nodes.\n\t * <p>\n\t * If the result of the transformation is a JDOM document,\n\t * this method converts it into a list of JDOM nodes; any\n\t * subsequent call to {@link #getDocument} will return\n\t * <code>null</code>.</p>\n\t *\n\t * @return the transformation result as a (possibly empty) list of\n\t *         JDOM nodes (Elements, Texts, Comments, PIs...)."
        },
        "setDocument": {
          "Javadoc": "* Sets the document produced as result of an XSL Transformation.\n\t * <p>\n\t * <strong>Note</strong>: This method shall be used by the\n\t * {@link javax.xml.transform.Transformer} implementations that\n\t * natively support JDOM to directly set the transformation\n\t * result rather than considering this object as a\n\t * {@link SAXResult}.  Applications should <i>not</i> use this\n\t * method.</p>\n\t *\n\t * @param  document   the JDOM document result of a transformation.\n\t *\n\t * @see    #setResult\n\t * @see    #getDocument"
        },
        "getDocument": {
          "Javadoc": "* Returns the result of an XSL Transformation as a JDOM document.\n\t * <p>\n\t * If the result of the transformation is a list of nodes,\n\t * this method attempts to convert it into a JDOM document. If\n\t * successful, any subsequent call to {@link #getResult} will\n\t * return an empty list.</p>\n\t * <p>\n\t * <strong>Warning</strong>: The XSLT 1.0 specification states that\n\t * the output of an XSL transformation is not a well-formed XML\n\t * document but a list of nodes. Applications should thus use\n\t * {@link #getResult} instead of this method or at least expect\n\t * <code>null</code> documents to be returned.\n\t *\n\t * @return the transformation result as a JDOM document or\n\t *         <code>null</code> if the result of the transformation\n\t *         can not be converted into a well-formed document.\n\t *\n\t * @see    #getResult"
        },
        "setFactory": {
          "Javadoc": "* Sets a custom JDOMFactory to use when building the\n\t * transformation result. Use a custom factory to build the tree\n\t * with your own subclasses of the JDOM classes.\n\t *\n\t * @param  factory   the custom <code>JDOMFactory</code> to use or\n\t *                   <code>null</code> to use the default JDOM\n\t *                   classes.\n\t *\n\t * @see    #getFactory"
        },
        "getFactory": {
          "Javadoc": "* Returns the custom JDOMFactory used to build the transformation\n\t * result.\n\t *\n\t * @return the custom <code>JDOMFactory</code> used to build the\n\t *         transformation result or <code>null</code> if the\n\t *         default JDOM classes are being used.\n\t *\n\t * @see    #setFactory"
        },
        "retrieveResult": {
          "Javadoc": "* Checks whether a transformation result has been set and, if not,\n\t * retrieves the result tree being built by the document builder."
        },
        "setHandler": {
          "Javadoc": "* Sets the target to be a SAX2 ContentHandler.\n\t *\n\t * @param handler Must be a non-null ContentHandler reference."
        },
        "setLexicalHandler": {
          "Javadoc": "* Sets the SAX2 LexicalHandler for the output.\n\t * <p>\n\t * This is needed to handle XML comments and the like.  If the\n\t * lexical handler is not set, an attempt should be made by the\n\t * transformer to cast the ContentHandler to a LexicalHandler.</p>\n\t *\n\t * @param handler A non-null LexicalHandler for\n\t *                handling lexical parse events."
        }
      }
    },
    "org.jdom2.transform.FragmentHandler": {
      "Javadoc": "",
      "methods": {
        "getResult": {
          "Javadoc": "* Returns the result of an XSL Transformation.\n\t\t *\n\t\t * @return the transformation result as a (possibly empty) list of\n\t\t *         JDOM nodes (Elements, Texts, Comments, PIs...)."
        },
        "getDetachedContent": {
          "Javadoc": "* Returns the content of a JDOM Element detached from it.\n\t\t *\n\t\t * @param  elt   the element to get the content from.\n\t\t *\n\t\t * @return a (possibly empty) list of JDOM nodes, detached from\n\t\t *         their parent."
        }
      }
    },
    "org.jdom2.transform.DocumentBuilder": {
      "Javadoc": "",
      "methods": {
        "getResult": {
          "Javadoc": "* Returns the result of an XSL Transformation.\n\t\t *\n\t\t * @return the transformation result as a (possibly empty) list of\n\t\t *         JDOM nodes (Elements, Texts, Comments, PIs...) or\n\t\t *         <code>null</code> if no new transformation occurred\n\t\t *         since the result of the previous one was returned."
        },
        "startDocument": {
          "Javadoc": "* <i>[SAX ContentHandler interface support]</i> Processes a\n\t\t * start of document event.\n\t\t * <p>\n\t\t * This implementation creates a new JDOM document builder and\n\t\t * marks the current result as \"under construction\".</p>\n\t\t *\n\t\t * @throws SAXException   if any error occurred while creating\n\t\t *                        the document builder."
        },
        "startElement": {
          "Javadoc": "* <i>[SAX ContentHandler interface support]</i> Receives\n\t\t * notification of the beginning of an element.\n\t\t * <p>\n\t\t * This implementation ensures that startDocument() has been\n\t\t * called prior processing an element.\n\t\t *\n\t\t * @param  nsURI       the Namespace URI, or the empty string if\n\t\t *                     the element has no Namespace URI or if\n\t\t *                     Namespace processing is not being performed.\n\t\t * @param  localName   the local name (without prefix), or the\n\t\t *                     empty string if Namespace processing is\n\t\t *                     not being performed.\n\t\t * @param  qName       the qualified name (with prefix), or the\n\t\t *                     empty string if qualified names are not\n\t\t *                     available.\n\t\t * @param  atts        The attributes attached to the element.  If\n\t\t *                     there are no attributes, it shall be an\n\t\t *                     empty Attributes object.\n\t\t *\n\t\t * @throws SAXException   if any error occurred while creating\n\t\t *                        the document builder."
        },
        "startPrefixMapping": {
          "Javadoc": "* <i>[SAX ContentHandler interface support]</i> Begins the\n\t\t * scope of a prefix-URI Namespace mapping."
        },
        "characters": {
          "Javadoc": "* <i>[SAX ContentHandler interface support]</i> Receives\n\t\t * notification of character data."
        },
        "ignorableWhitespace": {
          "Javadoc": "* <i>[SAX ContentHandler interface support]</i> Receives\n\t\t * notification of ignorable whitespace in element content."
        },
        "processingInstruction": {
          "Javadoc": "* <i>[SAX ContentHandler interface support]</i> Receives\n\t\t * notification of a processing instruction."
        },
        "skippedEntity": {
          "Javadoc": "* <i>[SAX ContentHandler interface support]</i> Receives\n\t\t * notification of a skipped entity."
        },
        "startDTD": {
          "Javadoc": "* <i>[SAX LexicalHandler interface support]</i> Reports the\n\t\t * start of DTD declarations, if any.\n\t\t *\n\t\t * @param  name       the document type name.\n\t\t * @param  publicId   the declared public identifier for the\n\t\t *                    external DTD subset, or <code>null</code>\n\t\t *                    if none was declared.\n\t\t * @param  systemId   the declared system identifier for the\n\t\t *                    external DTD subset, or <code>null</code>\n\t\t *                    if none was declared.\n\t\t *\n\t\t * @throws SAXException   The application may raise an exception."
        },
        "endDTD": {
          "Javadoc": "* <i>[SAX LexicalHandler interface support]</i> Reports the end\n\t\t * of DTD declarations.\n\t\t *\n\t\t * @throws SAXException   The application may raise an exception."
        },
        "startEntity": {
          "Javadoc": "* <i>[SAX LexicalHandler interface support]</i> Reports the\n\t\t * beginning of some internal and external XML entities.\n\t\t *\n\t\t * @param  name   the name of the entity.  If it is a parameter\n\t\t *                entity, the name will begin with '%', and if it\n\t\t *                is the external DTD subset, it will be \"[dtd]\".\n\t\t *\n\t\t * @throws SAXException   The application may raise an exception."
        },
        "endEntity": {
          "Javadoc": "* <i>[SAX LexicalHandler interface support]</i> Reports the end\n\t\t * of an entity.\n\t\t *\n\t\t * @param  name   the name of the entity that is ending.\n\t\t *\n\t\t * @throws SAXException   The application may raise an exception."
        },
        "startCDATA": {
          "Javadoc": "* <i>[SAX LexicalHandler interface support]</i> Reports the\n\t\t * start of a CDATA section.\n\t\t *\n\t\t * @throws SAXException   The application may raise an exception."
        },
        "endCDATA": {
          "Javadoc": "* <i>[SAX LexicalHandler interface support]</i> Reports the end\n\t\t * of a CDATA section.\n\t\t *\n\t\t * @throws SAXException   The application may raise an exception."
        },
        "comment": {
          "Javadoc": "* <i>[SAX LexicalHandler interface support]</i> Reports an XML\n\t\t * comment anywhere in the document.\n\t\t *\n\t\t * @param  ch     an array holding the characters in the comment.\n\t\t * @param  start  the starting position in the array.\n\t\t * @param  length the number of characters to use from the array.\n\t\t *\n\t\t * @throws SAXException   The application may raise an exception."
        }
      }
    },
    "org.jdom2.transform.JDOMSource": {
      "Javadoc": "\n * A holder for an XML Transformation source: a Document, Element, or list of\n * nodes.\n * <p>\n * The is provides input to a\n * {@link javax.xml.transform.Transformer JAXP TrAX Transformer}.\n * <p>\n * The following example shows how to apply an XSL Transformation\n * to a JDOM document and get the transformation result in the form\n * of a list of JDOM nodes:\n * <pre><code>\n *   public static List transform(Document doc, String stylesheet)\n *                                        throws JDOMException {\n *     try {\n *       Transformer transformer = TransformerFactory.newInstance()\n *                             .newTransformer(new StreamSource(stylesheet));\n *       JDOMSource in = new JDOMSource(doc);\n *       JDOMResult out = new JDOMResult();\n *       transformer.transform(in, out);\n *       return out.getResult();\n *     }\n *     catch (TransformerException e) {\n *       throw new JDOMException(\"XSLT Transformation failed\", e);\n *     }\n *   }\n * </code></pre>\n *\n * @see org.jdom2.transform.JDOMResult\n *\n * @author Laurent Bihanic\n * @author Jason Hunter\n ",
      "methods": {
        "setDocument": {
          "Javadoc": "* Sets the source document used by this TrAX source.\n\t *\n\t * @param  source   the JDOM document to use as source for the\n\t *                  transformations\n\t *\n\t * @throws IllegalArgumentException   if <code>source</code> is\n\t *                                    <code>null</code>.\n\t *\n\t * @see    #getDocument"
        },
        "getDocument": {
          "Javadoc": "* Returns the source document used by this TrAX source.\n\t *\n\t * @return the source document used by this TrAX source or\n\t *         <code>null</code> if the source is a node list.\n\t *\n\t * @see    #setDocument"
        },
        "setNodes": {
          "Javadoc": "* Sets the source node list used by this TrAX source.\n\t *\n\t * @param  source   the JDOM nodes to use as source for the\n\t *                  transformations\n\t *\n\t * @throws IllegalArgumentException   if <code>source</code> is\n\t *                                    <code>null</code>.\n\t *\n\t * @see    #getNodes"
        },
        "getNodes": {
          "Javadoc": "* Returns the source node list used by this TrAX source.\n\t *\n\t * @return the source node list used by this TrAX source or\n\t *         <code>null</code> if the source is a JDOM document.\n\t *\n\t * @see    #setDocument"
        },
        "setInputSource": {
          "Javadoc": "* Sets the SAX InputSource to be used for the Source.\n\t * <p>\n\t * As this implementation only supports JDOM document as data\n\t * source, this method always throws an\n\t * {@link UnsupportedOperationException}.\n\t * </p>\n\t *\n\t * @param  inputSource   a valid InputSource reference.\n\t *\n\t * @throws UnsupportedOperationException   always!"
        },
        "setXMLReader": {
          "Javadoc": "* Set the XMLReader to be used for the Source.\n\t * <p>\n\t * As this implementation only supports JDOM document as data\n\t * source, this method throws an\n\t * {@link UnsupportedOperationException} if the provided reader\n\t * object does not implement the SAX {@link XMLFilter}\n\t * interface.  Otherwise, the JDOM document reader will be\n\t * attached as parent of the filter chain.</p>\n\t *\n\t * @param  reader   a valid XMLReader or XMLFilter reference.\n\t *\n\t * @throws UnsupportedOperationException   if <code>reader</code>\n\t *                                         is not a SAX\n\t *                                         {@link XMLFilter}.\n\t * @see    #getXMLReader"
        },
        "getXMLReader": {
          "Javadoc": "* Returns the XMLReader to be used for the Source.\n\t * <p>\n\t * This implementation returns a specific XMLReader reading\n\t * the XML data from the source JDOM document.\n\t * </p>\n\t *\n\t * @return an XMLReader reading the XML data from the source\n\t *         JDOM document."
        },
        "buildDocumentReader": {
          "Javadoc": "* Build an XMLReader to be used for the source. This will\n\t * create a new instance of DocumentReader with an \n\t * EntityResolver instance if available.\n\t * \n\t * @return XMLReader reading the XML data from the source\n\t * \t\tJDOM document with an optional EntityResolver"
        }
      }
    },
    "org.jdom2.transform.JDOMInputSource": {
      "Javadoc": "\n\t * A subclass of the SAX InputSource interface that wraps a JDOM\n\t * Document.\n\t * <p>\n\t * This class is nested in JDOMSource as it is not intented to\n\t * be used independently of its friend: DocumentReader.\n\t * </p>\n\t *\n\t * @see    org.jdom2.Document\n\t ",
      "methods": {
        "getSource": {
          "Javadoc": "* Returns the source.\n\t\t *\n\t\t * @return the source as a JDOM document or a list of JDOM nodes."
        },
        "setCharacterStream": {
          "Javadoc": "* Sets the character stream for this input source.\n\t\t * <p>\n\t\t * This implementation always throws an\n\t\t * {@link UnsupportedOperationException} as the only source\n\t\t * stream supported is the source JDOM document.\n\t\t * </p>\n\t\t *\n\t\t * @param  characterStream   a character stream containing\n\t\t *                           an XML document.\n\t\t *\n\t\t * @throws UnsupportedOperationException  always!"
        },
        "getCharacterStream": {
          "Javadoc": "* Gets the character stream for this input source.\n\t\t * <p>\n\t\t * Note that this method is only provided to make this\n\t\t * InputSource implementation acceptable by any XML\n\t\t * parser.  As it generates an in-memory string representation\n\t\t * of the JDOM document, it is quite inefficient from both\n\t\t * speed and memory consumption points of view.\n\t\t * </p>\n\t\t *\n\t\t * @return a Reader to a string representation of the\n\t\t *         source JDOM document."
        },
        "setByteStream": {
          "Javadoc": "* Sets the byte stream for this input source.\n\t\t * <p>\n\t\t * This implementation always throws an\n\t\t * {@link UnsupportedOperationException} as the only source\n\t\t * stream supported is the source JDOM document.\n\t\t * </p>\n\t\t *\n\t\t * @param  byteStream   a byte stream containing\n\t\t *                           an XML document.\n\t\t *\n\t\t * @throws UnsupportedOperationException  always!"
        }
      }
    },
    "org.jdom2.transform.DocumentReader": {
      "Javadoc": "\n\t * An implementation of the SAX2 XMLReader interface that presents\n\t * a SAX view of a JDOM Document.  The actual generation of the\n\t * SAX events is delegated to JDOM's SAXOutputter.\n\t *\n\t * @see    org.jdom2.Document\n\t * @see    org.jdom2.output.SAXOutputter\n\t ",
      "methods": {
        "parse": {
          "Javadoc": "* Parses an XML document.\n\t\t * <p>\n\t\t * The methods accepts only <code>JDOMInputSource</code>s\n\t\t * instances as input sources.\n\t\t * </p>\n\t\t *\n\t\t * @param  input   the input source for the top-level of the\n\t\t *                  XML document.\n\t\t *\n\t\t * @throws SAXException               any SAX exception,\n\t\t *                                    possibly wrapping\n\t\t *                                    another exception.\n\t\t * @throws SAXNotSupportedException   if the input source does\n\t\t *                                    not wrap a JDOM document."
        }
      }
    },
    "org.jdom2.transform.XSLTransformer": {
      "Javadoc": "\n * A convenience class to handle simple transformations. The JAXP TrAX classes\n * have more bells and whistles and can be used with {@link JDOMSource} and\n * {@link JDOMResult} for advanced uses. This class handles the common case and\n * presents a simple interface.  XSLTransformer is thread safe and may be\n * used from multiple threads.\n *\n * <pre><code>\n * XSLTransformer transformer = new XSLTransformer(\"file.xsl\");\n *\n * Document x2 = transformer.transform(x);  // x is a Document\n * Document y2 = transformer.transform(y);  // y is a Document\n * </code></pre>\n *\n *  JDOM relies on TrAX to perform the transformation.\n *  The <code>javax.xml.transform.TransformerFactory</code> Java system property\n *  determines which XSLT engine TrAX uses. Its value should be\n *  the fully qualified name of the implementation of the abstract\n *  <code>javax.xml.transform.TransformerFactory</code> class.\n *  Values of this property for popular XSLT processors include:\n *  </p>\n *  <ul><li>Saxon 6.x: <code>com.icl.saxon.TransformerFactoryImpl</code></li>\n *  <li>Saxon 7.x: <code>net.sf.saxon.TransformerFactoryImpl</code></li>\n *  <li>Xalan: <code>org.apache.xalan.processor.TransformerFactoryImpl</code></li>\n *  <li>jd.xslt: <code>jd.xml.xslt.trax.TransformerFactoryImpl</code></li>\n *  <li>Oracle: <code>oracle.xml.jaxp.JXSAXTransformerFactory</code></li>\n *  </ul>\n *  <p>\n *   This property can be set in all the usual ways a Java system property\n *   can be set. TrAX picks from them in this order:</p>\n *   <ol>\n *   <li> Invoking <code>System.setProperty( \"javax.xml.transform.TransformerFactory\",\n *     \"<i><code>classname</code></i>\")</code></li>\n *   <li>The value specified at the command line using the\n *      <tt>-Djavax.xml.transform.TransformerFactory=<i><code>classname</code></i></tt>\n *      option to the <b>java</b> interpreter</li>\n *    <li>The class named in the  <code>lib/jaxp.properties</code> properties file\n *         in the JRE directory, in a line like this one:\n *      <pre>javax.xml.parsers.DocumentBuilderFactory=<i><code>classname</code></i></pre></li>\n *    <li>The class named in the\n *   <code>META-INF/services/javax.xml.transform.TransformerFactory</code> file\n *   in the JAR archives available to the runtime</li>\n *   <li>Finally, if all of the above options fail,\n *    a default implementation is chosen. In Sun's JDK 1.4, this is\n *       Xalan 2.2d10. </li>\n *    </ol>\n\n * @author  Jason Hunter\n * @author  Elliotte Rusty Harold\n ",
      "methods": {
        "transform": {
          "Javadoc": "* Transforms the given document to an output document.\n\t *\n\t * @param  inputDoc            input document\n\t * @param  resolver\t\t\t   entity resolver for the input document\n\t * @return                     transformed output document\n\t * @throws XSLTransformException       if there's a problem in the transformation"
        },
        "setFactory": {
          "Javadoc": "* Sets a custom JDOMFactory to use when building the\n\t * transformation result. Use a custom factory to build the tree\n\t * with your own subclasses of the JDOM classes.\n\t *\n\t * @param  factory   the custom <code>JDOMFactory</code> to use or\n\t *                   <code>null</code> to use the default JDOM\n\t *                   classes.\n\t *\n\t * @see    #getFactory"
        },
        "getFactory": {
          "Javadoc": "* Returns the custom JDOMFactory used to build the transformation\n\t * result.\n\t *\n\t * @return the custom <code>JDOMFactory</code> used to build the\n\t *         transformation result or <code>null</code> if the\n\t *         default JDOM classes are being used.\n\t *\n\t * @see    #setFactory"
        }
      }
    },
    "org.jdom2.transform.XSLTransformException": {
      "Javadoc": "\n * Thrown when an XSL stylesheet fails to compile or an XSL transform fails\n *\n * @author  Jason Hunter\n "
    },
    "org.jdom2.UncheckedJDOMFactory": {
      "Javadoc": "\n * Special factory for building documents without any content or structure\n * checking.  This should only be used when you are 100% positive that the\n * input is absolutely correct.  This factory can speed builds, but any\n * problems in the input will be uncaught until later when they could cause\n * infinite loops, malformed XML, or worse.  Use with extreme caution.\n * \n * @author Various Authors - history is not complete\n "
    },
    "org.jdom2.util.IteratorIterable": {
      "Javadoc": "\n * An interface that represents both a <code>java.util.Iterator</code>\n * and a <code>java.lang.Iterable</code>.\n * <p>\n * JDOM 1.x has a number of methods that return an Iterator. These methods\n * would (in some conditions) be better represented as an Iterable. To maintain\n * compatibility, and to extend the functionality of these methods in JDOM2,\n * they have been altered to return an instance of this interface.\n * \n * @author Rolf Lear\n *\n * @param <T> The generic type of the values returned by this interface\n "
    },
    "org.jdom2.util.NamespaceStack": {
      "Javadoc": "\n * A high-performance stack for processing those Namespaces that are introduced\n * or are in-scope at a point in an Element hierarchy.\n * <p>\n * This stack implements the 'Namespace Rules' which XML uses, where a Namespace\n * 'redefines' an existing Namespace if they share the same prefix. This class\n * is intended to provide a high-performance mechanism for calculating the\n * Namespace scope for an Element, and identifying what Namespaces an Element\n * introduces in to the scope. This is not a validation tool.\n * <p>\n * This class implements Iterable which means it can be used in the context\n * of a for-each type loop:\n * <br>\n * <code><pre>\n *   NamespaceStack namespacestack = new NamespaceStack();\n *   for (Namespace ns : namespacestack) {\n *      ...\n *   }\n * </pre></code>\n * The Iteration in the above example will return those Namespaces which are\n * in-scope for the current level of the stack. The Namespace order will follow\n * the JDOM 'standard'. The first namespace will be the Element's Namespace. The\n * subsequent Namespaces will be the other in-scope namespaces in alphabetical\n * order by the Namespace prefix.\n * <p>\n * NamespaceStack does not validate the push()/pop() cycles. It does not ensure\n * that the pop() is for the same element that was previously pushed. Further,\n * it does not check to make sure that the pushed() Element is the natural child\n * of the previously pushed() Element.\n * \n * @author Rolf Lear\n *\n ",
      "methods": {
        "binarySearch": {
          "Javadoc": "* Lots of reasons for having our own binarySearch.\n\t * <ul>\n\t * <li> We can make it specific for Namespaces (using == search).\n\t * <li> There is a bug in IBM's AIX JVM in all Java's prior to (including):\n\t *      IBM J9 VM (build 2.4, J2RE 1.6.0 IBM J9 2.4 AIX ppc-32\n\t *              jvmap3260-20081105_25433 (JIT enabled, AOT enabled))\n\t *      where it returns '-1' for all instances where 'from == to' instead\n\t *      of returning '-from -1'. See\n\t *      <a href=\"http://www.ibm.com/developerworks/forums/thread.jspa?threadID=351575&tstart=0\">\n\t *      this description</a> for how it is broken, and pre-checking to make\n\t *      sure that <code>left &lt; right</code> for each test is a pain.\n\t * <li> Ahh, actually, we will never encounter the bug, because we always\n\t *      have a larger-than-1 scope array.... see comment inside code...\n\t * <li> It's not that complicated, really.\n\t * </ul>\n\t * @param data The Namespaces to search.\n\t * @param left The left side of the range to search <b>INCLUSIVE</b>\n\t * @param right The right side of the range to search <b>EXCLUSIVE</b>\n\t * @param key The Namespace to search for.\n\t * @return the 'insertion point' - the following is copied from the Java\n\t * \t\t\tJavadoc for Arrays.binarySearch()\n\t * \t\t<br><i>\n\t *      index of the search key, if it is contained in the array; otherwise,\n\t *      <code> (-(insertion point) - 1) </code>. The insertion point is\n\t *      defined as the point at which the key would be inserted into the\n\t *      array: the index of the first element greater than the key, or\n\t *      a.length if all elements in the array are less than the specified\n\t *      key. Note that this guarantees that the return value will be >= 0\n\t *      if and only if the key is found.\n\t *      </i>"
        },
        "checkNamespace": {
          "Javadoc": "* Inspect the <i>scope</i> array to see whether the <i>namespace</i>\n\t * Namespace is 'new' or not. If it is 'new' then it is added to the\n\t * <i>store</i> List.\n\t * @param store Where to add the <i>namespace</i> if it is 'new'\n\t * @param namespace The Namespace to check\n\t * @param scope The array of Namespaces that are currently in-scope.\n\t * @return The revised version of 'in-scope' if the scope has changed. If\n\t *         there is no modification then the same input scope will be returned."
        },
        "push": {
          "Javadoc": "* Create a new in-scope level for the Stack based on an Attribute.\n\t * \n\t * @param att The attribute to contribute to the namespace scope."
        },
        "pop": {
          "Javadoc": "* Restore stack to the level prior to the current one. The various Iterator\n\t * methods will thus return the data at the previous level."
        },
        "addedForward": {
          "Javadoc": "* Return an Iterable containing all the Namespaces introduced to the\n\t * current-level's scope.\n\t * @see #push(Element) for the details on the data order.\n\t * @return A read-only Iterable containing added Namespaces (may be empty);"
        },
        "addedReverse": {
          "Javadoc": "* Return an Iterable containing all the Namespaces introduced to the\n\t * current-level's scope but in reverse order to {@link #addedForward()}.\n\t * @see #push(Element) for the details on the data order.\n\t * @return A read-only Iterable containing added Namespaces (may be empty);"
        },
        "iterator": {
          "Javadoc": "* Get all the Namespaces in-scope at the current level of the stack.\n\t * @see #push(Element) for the details on the data order.\n\t * @return A read-only Iterator containing added Namespaces (may be empty);"
        },
        "getScope": {
          "Javadoc": "* Return a new array instance representing the current scope.\n\t * Modifying the returned array will not affect this scope.\n\t * @return a copy of the current scope."
        },
        "isInScope": {
          "Javadoc": "* Inspect the current scope and return true if the specified namespace is\n\t * in scope.\n\t * @param ns The Namespace to check\n\t * @return true if the current scope contains that Namespace."
        }
      }
    },
    "org.jdom2.util.ForwardWalker": {
      "Javadoc": "\n\t * Simple read-only iterator that walks an array of Namespace.\n\t * \n\t * @author rolf\n\t *\n\t "
    },
    "org.jdom2.util.BackwardWalker": {
      "Javadoc": "\n\t * Simple read-only iterator that walks an array of Namespace in reverse.\n\t * \n\t * @author rolf\n\t *\n\t "
    },
    "org.jdom2.util.NamespaceIterable": {
      "Javadoc": "\n\t * Simple Iterable instance that produces either Forward or Backward\n\t * read-only iterators of the Namespaces\n\t * \n\t * @author rolf\n\t *\n\t "
    },
    "org.jdom2.util.EmptyIterable": {
      "Javadoc": "\n\t * Convenience class that makes very fast work for an empty Namespace array.\n\t * It doubles up as both Iterator and Interable.\n\t * @author rolf\n\t "
    },
    "org.jdom2.Verifier": {
      "Javadoc": "\n * A utility class to handle well-formedness checks on names, data, and other\n * verification tasks for JDOM. The class is final and may not be subclassed.\n *\n * @author  Brett McLaughlin\n * @author  Elliotte Rusty Harold\n * @author  Jason Hunter\n * @author  Bradley S. Huffman\n * @author  Rolf Lear\n * @author  Wilfried Middleton\n ",
      "methods": {
        "buildBitFlags": {
          "Javadoc": "* Convert the two compressed arrays in to th CHARFLAGS array.\n\t * @return the CHARFLAGS array."
        },
        "checkElementName": {
          "Javadoc": "* This will check the supplied name to see if it is legal for use as\n\t * a JDOM <code>{@link Element}</code> name.\n\t *\n\t * @param name <code>String</code> name to check.\n\t * @return <code>String</code> reason name is illegal, or\n\t *         <code>null</code> if name is OK."
        },
        "checkAttributeName": {
          "Javadoc": "* This will check the supplied name to see if it is legal for use as\n\t * a JDOM <code>{@link Attribute}</code> name.\n\t *\n\t * @param name <code>String</code> name to check.\n\t * @return <code>String</code> reason name is illegal, or\n\t *         <code>null</code> if name is OK."
        },
        "checkCharacterData": {
          "Javadoc": "* This will check the supplied string to see if it only contains\n\t * characters allowed by the XML 1.0 specification. The C0 controls\n\t * (e.g. null, vertical tab, form-feed, etc.) are specifically excluded\n\t * except for carriage return, line-feed, and the horizontal tab.\n\t * Surrogates are also excluded. \n\t * <p>\n\t * This method is useful for checking element content and attribute\n\t * values. Note that characters \n\t * like \" and &lt; are allowed in attribute values and element content. \n\t * They will simply be escaped as &quot; or &lt; \n\t * when the value is serialized. \n\t * </p>\n\t *\n\t * @param text <code>String</code> value to check.\n\t * @return <code>String</code> reason name is illegal, or\n\t *         <code>null</code> if name is OK."
        },
        "checkCDATASection": {
          "Javadoc": "* This will check the supplied data to see if it is legal for use as\n\t * JDOM <code>{@link CDATA}</code>.\n\t *\n\t * @param data <code>String</code> data to check.\n\t * @return <code>String</code> reason data is illegal, or\n\t *         <code>null</code> is name is OK."
        },
        "checkNamespacePrefix": {
          "Javadoc": "* This will check the supplied name to see if it is legal for use as\n\t * a JDOM <code>{@link Namespace}</code> prefix.\n\t *\n\t * @param prefix <code>String</code> prefix to check.\n\t * @return <code>String</code> reason name is illegal, or\n\t *         <code>null</code> if name is OK."
        },
        "checkNamespaceURI": {
          "Javadoc": "* This will check the supplied name to see if it is legal for use as\n\t * a JDOM <code>{@link Namespace}</code> URI.\n\t * <p>\n\t * This is a 'light' test of URI's designed to filter out only the worst\n\t * illegal URIs. It tests only to ensure the first character is valid. A\n\t * comprehensive URI validation process would be impractical.\n\t *\n\t * @param uri <code>String</code> URI to check.\n\t * @return <code>String</code> reason name is illegal, or\n\t *         <code>null</code> if name is OK."
        },
        "checkNamespaceCollision": {
          "Javadoc": "* Check if a <code>{@link Namespace}</code> collides with any namespace\n\t * from a list of objects.\n\t *\n\t * @param namespace <code>Namespace</code> to check.\n\t * @param list <code>List</code> to check against.\n\t * @param ignoreatt Ignore a specific Attribute (if it exists) when\n\t *        calculating any collisions (used when replacing one attribute\n\t *        with another).\n\t * @return <code>String</code> reason for collision, or\n\t *         <code>null</code> if no collision."
        },
        "checkProcessingInstructionTarget": {
          "Javadoc": "* This will check the supplied data to see if it is legal for use as\n\t * a JDOM <code>{@link ProcessingInstruction}</code> target.\n\t *\n\t * @param target <code>String</code> target to check.\n\t * @return <code>String</code> reason target is illegal, or\n\t *         <code>null</code> if target is OK."
        },
        "checkProcessingInstructionData": {
          "Javadoc": "* This will check the supplied data to see if it is legal for use as\n\t * <code>{@link ProcessingInstruction}</code> data. Besides checking that\n\t * all the characters are allowed in XML, this also checks\n\t * that the data does not contain the PI end-string \"?&gt;\".\n\t *\n\t * @param data <code>String</code> data to check.\n\t * @return <code>String</code> reason data is illegal, or\n\t *         <code>null</code> if data is OK."
        },
        "checkCommentData": {
          "Javadoc": "* This will check the supplied data to see if it is legal for use as\n\t * JDOM <code>{@link Comment}</code> data.\n\t *\n\t * @param data <code>String</code> data to check.\n\t * @return <code>String</code> reason data is illegal, or\n\t *         <code>null</code> if data is OK."
        },
        "decodeSurrogatePair": {
          "Javadoc": "* This is a utility function to decode a non-BMP \n\t * UTF-16 surrogate pair.\n\t * @param high high 16 bits\n\t * @param low low 16 bits\n\t * @return decoded character"
        },
        "isXMLPublicIDCharacter": {
          "Javadoc": "* This will check the supplied data to see if it is legal for use as\n\t * PublicID (in a {@link DocType} or {@link EntityRef}).\n\t * \n\t * @param c the character to validate\n\t * @return <code>String</code> reason <i>c</i> is illegal, or\n\t *         <code>null</code> if <i>c</i> is OK."
        },
        "checkPublicID": {
          "Javadoc": "* This will ensure that the data for a public identifier\n\t * is legal.\n\t *\n\t * @param publicID <code>String</code> public ID to check.\n\t * @return <code>String</code> reason public ID is illegal, or\n\t *         <code>null</code> if public ID is OK."
        },
        "checkSystemLiteral": {
          "Javadoc": "* This will ensure that the data for a system literal\n\t * is legal.\n\t *\n\t * @param systemLiteral <code>String</code> system literal to check.\n\t * @return <code>String</code> reason system literal is illegal, or\n\t *         <code>null</code> if system literal is OK."
        },
        "checkXMLName": {
          "Javadoc": "* This is a utility function for sharing the base process of checking\n\t * any XML name.\n\t *\n\t * @param name <code>String</code> to check for XML name compliance.\n\t * @return <code>String</code> reason the name is illegal, or\n\t *         <code>null</code> if OK."
        },
        "checkURI": {
          "Javadoc": "* <p>\n\t * Checks a string to see if it is a legal RFC 2396 URI.\n\t * Both absolute and relative URIs are supported.\n\t * </p>\n\t *\n\t * @param uri <code>String</code> to check.\n\t * @return <code>String</code> reason the URI is illegal, or\n\t *         <code>null</code> if OK."
        },
        "isHexDigit": {
          "Javadoc": "* <p>\n\t * This is a utility function for determining whether a specified\n\t * Unicode character is a hexadecimal digit as defined in RFC 2396;\n\t * that is, one of the ASCII characters 0-9, a-f, or A-F.\n\t * </p>\n\t *\n\t * @param c  to check for hex digit.\n\t * @return true if it's allowed, false otherwise."
        },
        "isHighSurrogate": {
          "Javadoc": "* This is a function for determining whether the\n\t * specified character is the high 16 bits in a \n\t * UTF-16 surrogate pair.\n\t * @param ch character to check\n\t * @return true if the character is a high surrogate, false otherwise"
        },
        "isLowSurrogate": {
          "Javadoc": "* This is a function for determining whether the \n\t * specified character is the low 16 bits in a \n\t * UTF-16 surrogate pair.\n\t * @param ch character to check\n\t * @return true if the character is a low surrogate, false otherwise."
        },
        "isURICharacter": {
          "Javadoc": "* <p>\n\t * This is a utility function for determining whether\n\t * a specified Unicode character is legal in URI references\n\t * as determined by RFC 2396.\n\t * </p>\n\t *\n\t * @param c <code>char</code> to check for URI reference compliance.\n\t * @return true if it's allowed, false otherwise."
        },
        "isXMLCharacter": {
          "Javadoc": "* This is a utility function for determining whether a specified \n\t * character is a character according to production 2 of the \n\t * XML 1.0 specification.\n\t *\n\t * @param c <code>char</code> to check for XML compliance\n\t * @return <code>boolean</code> true if it's a character, \n\t *                                false otherwise"
        },
        "isXMLNameCharacter": {
          "Javadoc": "* This is a utility function for determining whether a specified \n\t * character is a name character according to production 4 of the \n\t * XML 1.0 specification.\n\t *\n\t * @param c <code>char</code> to check for XML name compliance.\n\t * @return <code>boolean</code> true if it's a name character, \n\t *                                false otherwise."
        },
        "isXMLNameStartCharacter": {
          "Javadoc": "* This is a utility function for determining whether a specified \n\t * character is a legal name start character according to production 5\n\t * of the XML 1.0 specification. This production does allow names\n\t * to begin with colons which the Namespaces in XML Recommendation\n\t * disallows. \n\t *\n\t * @param c <code>char</code> to check for XML name start compliance.\n\t * @return <code>boolean</code> true if it's a name start character, \n\t *                                false otherwise."
        },
        "isXMLLetterOrDigit": {
          "Javadoc": "* This is a utility function for determining whether a specified \n\t * character is a letter or digit according to productions 84 and 88\n\t * of the XML 1.0 specification.\n\t *\n\t * @param c <code>char</code> to check.\n\t * @return <code>boolean</code> true if it's letter or digit, \n\t *                                false otherwise."
        },
        "isXMLLetter": {
          "Javadoc": "* This is a utility function for determining whether a specified character\n\t * is a letter according to production 84 of the XML 1.0 specification.\n\t *\n\t * @param c <code>char</code> to check for XML name compliance.\n\t * @return <code>String</code> true if it's a letter, false otherwise."
        },
        "isXMLCombiningChar": {
          "Javadoc": "* This is a utility function for determining whether a specified character\n\t * is a combining character according to production 87\n\t * of the XML 1.0 specification.\n\t *\n\t * @param c <code>char</code> to check.\n\t * @return <code>boolean</code> true if it's a combining character,\n\t *         false otherwise."
        },
        "isXMLExtender": {
          "Javadoc": "* This is a utility function for determining whether a specified \n\t * character is an extender according to production 88 of the XML 1.0\n\t * specification.\n\t *\n\t * @param c <code>char</code> to check.\n\t * @return <code>String</code> true if it's an extender, false otherwise."
        },
        "isXMLDigit": {
          "Javadoc": "* This is a utility function for determining whether a specified \n\t * Unicode character\n\t * is a digit according to production 88 of the XML 1.0 specification.\n\t *\n\t * @param c <code>char</code> to check for XML digit compliance\n\t * @return <code>boolean</code> true if it's a digit, false otherwise"
        },
        "isXMLWhitespace": {
          "Javadoc": "* This is a utility function for determining whether a specified \n\t * Unicode character is a whitespace character according to production 3\n\t * of the XML 1.0 specification.\n\t *\n\t * @param c <code>char</code> to check for XML whitespace compliance\n\t * @return <code>boolean</code> true if it's a whitespace, false otherwise"
        },
        "isAllXMLWhitespace": {
          "Javadoc": "* This is a utility function for determining whether a specified \n\t * String is a whitespace character according to production 3\n\t * of the XML 1.0 specification.\n\t * <p>\n\t * This method delegates the individual calls for each character to\n\t * {@link #isXMLWhitespace(char)}.\n\t * \n\t * @param value\n\t *        The value to inspect\n\t * @return true if all characters in the input value are all whitespace\n\t *        (or the string is the empty-string).\n\t * @since JDOM2"
        }
      }
    },
    "org.jdom2.xpath.jaxen.JaxenCompiled": {
      "Javadoc": "\n * Jaxen specific code for XPath management.\n * \n * @author Rolf Lear\n * @param <T>\n *        The generic type of returned data.\n ",
      "methods": {
        "unWrapNS": {
          "Javadoc": "* Same story, need to be able to strip NamespaceContainer instances from\n\t * Namespace content.\n\t * \n\t * @param o\n\t *        A result object which could potentially be a NamespaceContainer\n\t * @return The input parameter unless it is a NamespaceContainer in which\n\t *         case return the wrapped Namespace"
        },
        "unWrap": {
          "Javadoc": "* Same story, need to be able to replace NamespaceContainer instances with\n\t * Namespace content.\n\t * \n\t * @param results\n\t *        A list potentially containing NamespaceContainer instances\n\t * @return The parameter list with NamespaceContainer instances replaced by\n\t *         the wrapped Namespace instances."
        }
      }
    },
    "org.jdom2.xpath.jaxen.JaxenXPathFactory": {
      "Javadoc": "\n * This simple Factory creates XPath instances tailored to the Jaxen library.\n * \n * @author Rolf Lear\n *\n "
    },
    "org.jdom2.xpath.jaxen.JDOM2Navigator": {
      "Javadoc": "\n * Simply extend the core Navigator to make it all final.\n * \n * @author Rolf Lear\n *\n "
    },
    "org.jdom2.xpath.jaxen.JDOMCoreNavigator": {
      "Javadoc": ""
    },
    "org.jdom2.xpath.jaxen.JDOMNavigator": {
      "Javadoc": ""
    },
    "org.jdom2.xpath.jaxen.JDOMXPath": {
      "Javadoc": "\n * A concrete XPath implementation for Jaxen. This class must be public because\n * the main JDOM XPath class needs to access the class, and the constructor.\n * \n *        The generic type of the returned values from this XPath instance.\n * @author Laurent Bihanic\n * @deprecated replaced by compiled version.\n ",
      "methods": {
        "unWrapNS": {
          "Javadoc": "* Same story, need to be able to strip NamespaceContainer instances from\n\t * Namespace content.\n\t * \n\t * @param o\n\t *        A result object which could potentially be a NamespaceContainer\n\t * @return The input parameter unless it is a NamespaceContainer in which\n\t *         case return the wrapped Namespace"
        },
        "unWrap": {
          "Javadoc": "* Same story, need to be able to replace NamespaceContainer instances with\n\t * Namespace content.\n\t * \n\t * @param results\n\t *        A list potentially containing NamespaceContainer instances\n\t * @return The parameter list with NamespaceContainer instances replaced by\n\t *         the wrapped Namespace instances."
        },
        "selectNodes": {
          "Javadoc": "* Evaluates the wrapped XPath expression and returns the list of selected\n\t * items.\n\t * \n\t * @param context\n\t *        the node to use as context for evaluating the XPath expression.\n\t * @return the list of selected items, which may be of types: {@link Element}\n\t *         , {@link Attribute}, {@link Text}, {@link CDATA}, {@link Comment}\n\t *         , {@link ProcessingInstruction}, Boolean, Double, or String.\n\t * @throws JDOMException\n\t *         if the evaluation of the XPath expression on the specified\n\t *         context failed."
        },
        "selectSingleNode": {
          "Javadoc": "* Evaluates the wrapped XPath expression and returns the first entry in the\n\t * list of selected nodes (or atomics).\n\t * \n\t * @param context\n\t *        the node to use as context for evaluating the XPath expression.\n\t * @return the first selected item, which may be of types: {@link Element},\n\t *         {@link Attribute}, {@link Text}, {@link CDATA}, {@link Comment},\n\t *         {@link ProcessingInstruction}, Boolean, Double, String, or\n\t *         <code>null</code> if no item was selected.\n\t * @throws JDOMException\n\t *         if the evaluation of the XPath expression on the specified\n\t *         context failed."
        },
        "valueOf": {
          "Javadoc": "* Returns the string value of the first node selected by applying the\n\t * wrapped XPath expression to the given context.\n\t * \n\t * @param context\n\t *        the element to use as context for evaluating the XPath expression.\n\t * @return the string value of the first node selected by applying the\n\t *         wrapped XPath expression to the given context.\n\t * @throws JDOMException\n\t *         if the XPath expression is invalid or its evaluation on the\n\t *         specified context failed."
        },
        "numberValueOf": {
          "Javadoc": "* Returns the number value of the first item selected by applying the\n\t * wrapped XPath expression to the given context.\n\t * \n\t * @param context\n\t *        the element to use as context for evaluating the XPath expression.\n\t * @return the number value of the first item selected by applying the\n\t *         wrapped XPath expression to the given context, <code>null</code>\n\t *         if no node was selected or the special value\n\t *         {@link java.lang.Double#NaN} (Not-a-Number) if the selected value\n\t *         can not be converted into a number value.\n\t * @throws JDOMException\n\t *         if the XPath expression is invalid or its evaluation on the\n\t *         specified context failed."
        },
        "setVariable": {
          "Javadoc": "* Defines an XPath variable and sets its value.\n\t * \n\t * @param name\n\t *        the variable name.\n\t * @param value\n\t *        the variable value.\n\t * @throws IllegalArgumentException\n\t *         if <code>name</code> is not a valid XPath variable name or if the\n\t *         value type is not supported by the underlying implementation"
        },
        "addNamespace": {
          "Javadoc": "* Adds a namespace definition to the list of namespaces known of this XPath\n\t * expression.\n\t * <p>\n\t * <strong>Note</strong>: In XPath, there is no such thing as a 'default\n\t * namespace'. The empty prefix <b>always</b> resolves to the empty\n\t * namespace URI.\n\t * </p>\n\t * \n\t * @param namespace\n\t *        the namespace."
        },
        "getXPath": {
          "Javadoc": "* Returns the wrapped XPath expression as a string.\n\t * \n\t * @return the wrapped XPath expression as a string."
        },
        "setXPath": {
          "Javadoc": "* Compiles and sets the XPath expression wrapped by this object.\n\t * \n\t * @param expr\n\t *        the XPath expression to wrap.\n\t * @throws JDOMException\n\t *         if the XPath expression is invalid."
        }
      }
    },
    "org.jdom2.xpath.jaxen.NamespaceContainer": {
      "Javadoc": "\n * XPath requires that the namespace nodes are linked to an Element.\n * JDOM does not have such a relationship, so we improvise.\n * Jaxen uses the identity equals ( == ) when comparing\n * one 'node' to another, so we have to make sure that within the context of\n * Jaxen we always return the same instances of NamespaceContainer each time.\n * Further, for jaxen the instance of a Namespace for one Node cannot be the\n * same instance of the same Namespace on a different Node...\n * <p>\n * This all also means that all Jaxen interaction is done with NamespaceContainer\n * and not the JDOM Namespace, which in turn means that when Jaxen returns\n * a NamespaceContainer node, it has to be unwrapped to a simple Namespace.\n * \n * @author rolf\n *\n "
    },
    "org.jdom2.xpath.util.AbstractXPathCompiled": {
      "Javadoc": "\n * A mostly-implemented XPathExpression that only needs two methods to be\n * implemented in order to satisfy the complete API. Subclasses of this\n * <strong>MUST</strong> correctly override the clone() method which in turn\n * should call <code>super.clone();</code>\n * \n * @param <T>\n *        The generic type of the returned values.\n * @author Rolf Lear\n ",
      "methods": {
        "getPrefixForURI": {
          "Javadoc": "* Utility method to find a Namespace that has a given URI, and return the prefix.\n\t * @param uri the URI to search for\n\t * @param nsa the array of namespaces to search through\n\t * @return the prefix of the namespace"
        },
        "clone": {
          "Javadoc": "* Subclasses of this AbstractXPathCompile class must call super.clone() in\n\t * their clone methods!\n\t * <p>\n\t * This would be a sample clone method from a subclass:\n\t * \n\t * \n\t * <code><pre>\n\t * \t\tpublic XPathExpression&lt;T&gt; clone() {\n\t * \t\t\t{@literal @}SuppressWarnings(\"unchecked\")\n\t * \t\t\tfinal MyXPathCompiled&lt;T&gt; ret = (MyXPathCompiled&lt;T&gt;)super.clone();\n\t * \t\t\t// change any fields that need to be cloned.\n\t * \t\t\t....\n\t * \t\t\treturn ret;\n\t * \t\t}\n\t * </pre></code>\n\t * \n\t * Here's the documentation from {@link XPathExpression#clone()}\n\t * <p>\n\t * {@inheritDoc}"
        },
        "getVariables": {
          "Javadoc": "* utility method that allows descendant classes to access the variables\n\t * that were set on this expression, in a format that can be used in a constructor (qname/value).\n\t * @return the variables set on this instance."
        },
        "evaluateFirst": {
          "Javadoc": "*"
        },
        "evaluateRawAll": {
          "Javadoc": "* This is the raw expression evaluator to be implemented by the back-end\n\t * XPath library.\n\t * \n\t * @param context\n\t *        The context against which to evaluate the query\n\t * @return A list of XPath results."
        },
        "evaluateRawFirst": {
          "Javadoc": "* This is the raw expression evaluator to be implemented by the back-end\n\t * XPath library. When this method is processed the implementing library is\n\t * free to stop processing when the result that would be the first result is\n\t * retrieved.\n\t * <p>\n\t * Only the first value in the result will be processed (if any).\n\t * \n\t * @param context\n\t *        The context against which to evaluate the query\n\t * @return The first item in the XPath results, or null if there are no\n\t *         results."
        }
      }
    },
    "org.jdom2.xpath.util.NamespaceComparator": {
      "Javadoc": ""
    },
    "org.jdom2.xpath.util.XPathDiagnosticImpl": {
      "Javadoc": "\n * A diagnostic implementation useful for diagnosing problems in XPath results.\n * <p>\n * This class tries to make all the data available as part of the internal\n * structure which may assist people who are stepping-through the code from \n * a debugging environment.\n * \n * @author Rolf Lear\n *\n * @param <T> The generic type of the results from the {@link XPathExpression}\n "
    },
    "org.jdom2.xpath.XPath": {
      "Javadoc": "\n * A utility class for performing XPath calls on JDOM nodes, with a factory\n * interface for obtaining a first XPath instance. Users operate against this\n * class while XPath vendors can plug-in implementations underneath.  Users\n * can choose an implementation using either {@link #setXPathClass} or\n * the system property \"org.jdom2.xpath.class\".\n *\n * @author  Laurent Bihanic\n * @deprecated Use XPathFactory/XPathExpression/XPathBuilder instead.\n ",
      "methods": {
        "newInstance": {
          "Javadoc": "* Creates a new XPath wrapper object, compiling the specified\n\t * XPath expression.\n\t *\n\t * @param  path   the XPath expression to wrap.\n\t * @return an XPath instance representing the input path\n\t *\n\t * @throws JDOMException   if the XPath expression is invalid."
        },
        "setXPathClass": {
          "Javadoc": "* Sets the concrete XPath subclass to use when allocating XPath\n\t * instances.\n\t *\n\t * @param  aClass   the concrete subclass of XPath.\n\t *\n\t * @throws IllegalArgumentException   if <code>aClass</code> is\n\t *                                    <code>null</code>.\n\t * @throws JDOMException              if <code>aClass</code> is\n\t *                                    not a concrete subclass\n\t *                                    of XPath."
        },
        "selectNodes": {
          "Javadoc": "* Evaluates an XPath expression and returns the list of selected\n\t * items.\n\t * <p>\n\t * <strong>Note</strong>: This method should not be used when the\n\t * same XPath expression needs to be applied several times (on the\n\t * same or different contexts) as it requires the expression to be\n\t * compiled before being evaluated.  In such cases,\n\t * {@link #newInstance allocating} an XPath wrapper instance and\n\t * {@link #selectNodes(java.lang.Object) evaluating} it several\n\t * times is way more efficient.\n\t * </p>\n\t *\n\t * @param  context   the node to use as context for evaluating\n\t *                   the XPath expression.\n\t * @param  path      the XPath expression to evaluate.\n\t *\n\t * @return the list of selected items, which may be of types: {@link Element},\n\t *         {@link Attribute}, {@link Text}, {@link CDATA},\n\t *         {@link Comment}, {@link ProcessingInstruction}, Boolean,\n\t *         Double, or String.\n\t *\n\t * @throws JDOMException   if the XPath expression is invalid or\n\t *                         its evaluation on the specified context\n\t *                         failed."
        },
        "selectSingleNode": {
          "Javadoc": "* Evaluates the wrapped XPath expression and returns the first\n\t * entry in the list of selected nodes (or atomics).\n\t * <p>\n\t * <strong>Note</strong>: This method should not be used when the\n\t * same XPath expression needs to be applied several times (on the\n\t * same or different contexts) as it requires the expression to be\n\t * compiled before being evaluated.  In such cases,\n\t * {@link #newInstance allocating} an XPath wrapper instance and\n\t * {@link #selectSingleNode(java.lang.Object) evaluating} it\n\t * several times is way more efficient.\n\t * </p>\n\t *\n\t * @param  context   the element to use as context for evaluating\n\t *                   the XPath expression.\n\t * @param  path      the XPath expression to evaluate.\n\t *\n\t * @return the first selected item, which may be of types: {@link Element},\n\t *         {@link Attribute}, {@link Text}, {@link CDATA},\n\t *         {@link Comment}, {@link ProcessingInstruction}, Boolean,\n\t *         Double, String, or <code>null</code> if no item was selected.\n\t *\n\t * @throws JDOMException   if the XPath expression is invalid or\n\t *                         its evaluation on the specified context\n\t *                         failed."
        },
        "valueOf": {
          "Javadoc": "* Returns the string value of the first node selected by applying\n\t * the wrapped XPath expression to the given context.\n\t *\n\t * @param  context   the element to use as context for evaluating\n\t *                   the XPath expression.\n\t *\n\t * @return the string value of the first node selected by applying\n\t *         the wrapped XPath expression to the given context.\n\t *\n\t * @throws JDOMException   if the XPath expression is invalid or\n\t *                         its evaluation on the specified context\n\t *                         failed."
        },
        "numberValueOf": {
          "Javadoc": "* Returns the number value of the first node selected by applying\n\t * the wrapped XPath expression to the given context.\n\t *\n\t * @param  context   the element to use as context for evaluating\n\t *                   the XPath expression.\n\t *\n\t * @return the number value of the first node selected by applying\n\t *         the wrapped XPath expression to the given context,\n\t *         <code>null</code> if no node was selected or the\n\t *         special value {@link java.lang.Double#NaN}\n\t *         (Not-a-Number) if the selected value can not be\n\t *         converted into a number value.\n\t *\n\t * @throws JDOMException   if the XPath expression is invalid or\n\t *                         its evaluation on the specified context\n\t *                         failed."
        },
        "setVariable": {
          "Javadoc": "* Defines an XPath variable and sets its value.\n\t *\n\t * @param  name    the variable name.\n\t * @param  value   the variable value.\n\t *\n\t * @throws IllegalArgumentException   if <code>name</code> is not\n\t *                                    a valid XPath variable name\n\t *                                    or if the value type is not\n\t *                                    supported by the underlying\n\t *                                    implementation"
        },
        "addNamespace": {
          "Javadoc": "* Adds a namespace definition (prefix and URI) to the list of\n\t * namespaces known of this XPath expression.\n\t * <p>\n\t * <strong>Note</strong>: In XPath, there is no such thing as a\n\t * 'default namespace'.  The empty prefix <b>always</b> resolves\n\t * to the empty namespace URI.</p>\n\t *\n\t * @param  prefix   the namespace prefix.\n\t * @param  uri      the namespace URI.\n\t *\n\t * @throws IllegalNameException   if the prefix or uri are null or\n\t *                                empty strings or if they contain\n\t *                                illegal characters."
        },
        "getXPath": {
          "Javadoc": "* Returns the wrapped XPath expression as a string.\n\t *\n\t * @return the wrapped XPath expression as a string."
        },
        "writeReplace": {
          "Javadoc": "* <i>[Serialization support]</i> Returns the alternative object\n\t * to write to the stream when serializing this object.  This\n\t * method returns an instance of a dedicated nested class to\n\t * serialize XPath expressions independently of the concrete\n\t * implementation being used.\n\t * <p>\n\t * <strong>Note</strong>: Subclasses are not allowed to override\n\t * this method to ensure valid serialization of all\n\t * implementations.</p>\n\t *\n\t * @return an XPathString instance configured with the wrapped\n\t *         XPath expression.\n\t *\n\t * @throws ObjectStreamException   never."
        }
      }
    },
    "org.jdom2.xpath.XPathString": {
      "Javadoc": "\n\t * The XPathString is dedicated to serialize instances of\n\t * XPath subclasses in a implementation-independent manner.\n\t * <p>\n\t * XPathString ensures that only string data are serialized.  Upon\n\t * deserialization, XPathString relies on XPath factory method to\n\t * to create instances of the concrete XPath wrapper currently\n\t * configured.</p>\n\t ",
      "methods": {
        "readResolve": {
          "Javadoc": "* <i>[Serialization support]</i> Resolves the read XPathString\n\t\t * objects into XPath implementations.\n\t\t *\n\t\t * @return an instance of a concrete implementation of\n\t\t *         XPath.\n\t\t *\n\t\t * @throws ObjectStreamException   if no XPath could be built\n\t\t *                                 from the read object."
        }
      }
    },
    "org.jdom2.xpath.XPathBuilder": {
      "Javadoc": "\n * A helper class for creating {@link XPathExpression} instances without having\n * to manage your own Namespace and Variable contexts.\n * \n * @author Rolf Lear\n * @param <T>\n *        The generic type of the returned results.\n ",
      "methods": {
        "setVariable": {
          "Javadoc": "* Define or redefine an XPath expression variable value. In XPath, variable\n\t * names can be in a namespace, and thus the variable name is in a QName\n\t * form: prefix:name\n\t * <p>\n\t * Variables without a prefix are in the \"\" Namespace.\n\t * <p>\n\t * Variables can have a null value. The {@link XPathExpression} can change\n\t * the variable value before the expression is evaluated, and, some XPath\n\t * libraries support a null variable value. See\n\t * {@link XPathExpression#setVariable(String, Namespace, Object)}.\n\t * <p>\n\t * In order to validate that a Variable is unique you have to know the\n\t * namespace associated with the prefix. This class is designed to make it\n\t * possible to make the namespace associations after the variables have been\n\t * added. As a result it is not possible to validate the uniqueness of a\n\t * variable name until the {@link #compileWith(XPathFactory)} method is\n\t * called.\n\t * <p>\n\t * As a consequence of the above, this class assumes that each unique prefix\n\t * is for a unique Namespace URI (thus calling this method with different\n\t * QNames is assumed to be setting different variables). This may lead to an\n\t * IllegalArgumentException when the {@link #compileWith(XPathFactory)}\n\t * method is called.\n\t * <p>\n\t * This method does not validate the format of the variable name either, it\n\t * instead postpones the validation until the expression is compiled. As a\n\t * result you may encounter IllegalArgumentExceptions at compile time if the\n\t * variable names are not valid XPath QNames (\"name\" or \"prefix:name\").\n\t * \n\t * @param qname\n\t *        The variable name to define.\n\t * @param value\n\t *        The variable value to set.\n\t * @return true if this variable was defined, false if it was previously\n\t *         defined and has now been redefined.\n\t * @throws NullPointerException\n\t *         if the name is null."
        },
        "setNamespace": {
          "Javadoc": "* Define a Namespace to be available for the XPath expression.\n\t * \n\t * @param namespace\n\t *        The namespace to define.\n\t * @return true if this Namespace prefix was newly defined, false if the\n\t *         prefix was previously defined and has now been redefined.\n\t * @throws NullPointerException\n\t *         if the namespace is null."
        },
        "setNamespaces": {
          "Javadoc": "* Add a number of namespaces to this XPathBuilder\n\t * \n\t * @param namespaces\n\t *        The namespaces to set.\n\t * @return true if any of the Namespace prefixes are new to the XPathBuilder\n\t * @throws NullPointerException\n\t *         if the namespace collection, or any of its members are null."
        },
        "getVariable": {
          "Javadoc": "* Get the variable value associated with the given name. See\n\t * {@link #setVariable(String, Object)} for notes on how the Namespaces need\n\t * to be established before an authoritative reference to a variable can be\n\t * made. As a result, this method uses the simple variable QName name to\n\t * reference the variable.\n\t * \n\t * @param qname\n\t *        The variable name to get the vaiable value for.\n\t * @return the variable value, or null if the variable was not defined.\n\t * @throws NullPointerException\n\t *         if the qname is null."
        },
        "getNamespace": {
          "Javadoc": "* Get the Namespace associated with the given prefix.\n\t * \n\t * @param prefix\n\t *        The Namespace prefix to get the Namespace for.\n\t * @return the Namespace with that prefix, or null if that prefix was never\n\t *         defined."
        },
        "getFilter": {
          "Javadoc": "* Get the Filter instance used for coercion.\n\t * \n\t * @return the coercion Filter."
        },
        "getExpression": {
          "Javadoc": "* Get the XPath expression.\n\t * \n\t * @return the XPath expression."
        },
        "compileWith": {
          "Javadoc": "* Compile an XPathExpression using the details currently stored in the\n\t * XPathBuilder.\n\t * \n\t * @param factory\n\t *        The XPath factory to use for compiling.\n\t * @return The compiled XPath expression\n\t * @throws IllegalArgumentException\n\t *         if the expression cannot be compiled."
        }
      }
    },
    "org.jdom2.xpath.XPathDiagnostic": {
      "Javadoc": "\n * Class representing the results of an XPath query allowing JDOM users to trace\n * whether an item returned from an XPath query is subsequently filtered by the\n * coercion filter attached to the {@link XPathExpression};\n * \n * @author Rolf Lear\n * @param <T>\n *        The generic type of the results retruend by the expression.\n ",
      "methods": {
        "getContext": {
          "Javadoc": "* @return The context object against which the XPath query was evaluated."
        },
        "getXPathExpression": {
          "Javadoc": "* @return the {@link XPathExpression} instance that generated this\n\t *         diagnostic."
        },
        "getResult": {
          "Javadoc": "* Returns the results as they would be returned by the regular evaluate\n\t * process (read-only).\n\t * \n\t * @return the regular evaluated results."
        },
        "getFilteredResults": {
          "Javadoc": "* Returns the XPath results which are not returned by the regular evaluate\n\t * process.\n\t * \n\t * @return those results which were returned by the XPath query but were\n\t *         filtered out by the JDOM Filter."
        },
        "getRawResults": {
          "Javadoc": "* Returns the XPath results before any were filtered.\n\t * \n\t * @return those results which were returned by the XPath query before any\n\t *         filtering."
        },
        "isFirstOnly": {
          "Javadoc": "* Indicate whether the query was evaluated as a first-only evaluation.\n\t * XPath libraries are allowed to stop processing the results after the\n\t * first result is retrieved if first-only processing is set.\n\t * \n\t * @return true if the evaluation was a first-only evaluation."
        }
      }
    },
    "org.jdom2.xpath.XPathExpression": {
      "Javadoc": "\n * XPathExpression is a representation of a compiled XPath query and any\n * Namespace or variable references the query may require.\n * <p>\n * Once an XPathExpression is created, the values associated with variable names\n * can be changed. But new variables may not be added.\n * <p>\n * <p>\n * XPathExpression is not thread-safe. XPath libraries allow variable values to\n * change between calls to their query routines, but require that the variable\n * value is constant for the duration of any particular evaluation. It is easier\n * to simply have separate XPathExpression instances in each thread than it is\n * to manage the synchronization of a single instance. XPathExpression thus\n * supports Cloneable to easily create another XPathExpression instance. It is\n * the responsibility of the JDOM caller to ensure appropriate synchronisation\n * of the XPathExpression if it is accessed from multiple threads.\n * \n * @author Rolf Lear\n * @param <T>\n *        The generic type of the results of the XPath query after being\n *        processed by the JDOM {@code Filter<T>}\n ",
      "methods": {
        "clone": {
          "Javadoc": "* Create a new instance of this XPathExpression that duplicates this\n\t * instance.\n\t * <p>\n\t * The 'cloned' instance will have the same XPath query, namespace\n\t * declarations, and variables. Changing a value associated with a variable\n\t * on the cloned instance will not change this instance's values, and it is\n\t * safe to run the evaluate methods on the cloned copy at the same time as\n\t * this copy.\n\t * \n\t * @return a new XPathExpression instance that shares the same core details\n\t *         as this."
        },
        "getExpression": {
          "Javadoc": "* Get the XPath expression\n\t * \n\t * @return the string representation of the XPath expression"
        },
        "getNamespace": {
          "Javadoc": "* Get the Namespace associated with a given prefix.\n\t * \n\t * @param prefix\n\t *        The prefix to select the Namespace URI for.\n\t * @return the URI of the specified Namespace prefix\n\t * @throws IllegalArgumentException\n\t *         if that prefix is not defined."
        },
        "getNamespaces": {
          "Javadoc": "* Get the Namespaces that were used to compile this XPathExpression.\n\t * \n\t * @return a potentially empty array of Namespaces (never null)."
        },
        "setVariable": {
          "Javadoc": "* Change the defined value for a variable to some new value. You may not\n\t * use this method to add new variables to the compiled XPath, you can only\n\t * change existing variable values.\n\t * <p>\n\t * The value of the variable may be null. Some XPath libraries support a\n\t * null value, and if the library that this expression is for does not\n\t * support a null value it should be translated to something meaningful for\n\t * that library, typically the empty string.\n\t * <p>\n\t * qname must consist of an optional namespace prefix and colon, followed\n\t * by a mandatory variable localname. If the prefix is not specified, then\n\t * the Namespace is assumed to be the {@link Namespace#NO_NAMESPACE}. If\n\t * the prefix is specified, it must match with one of the declared\n\t * Namespaces for this XPathExpression\n\t * \n\t * @param qname\n\t *        The variable qname to change.\n\t * @param value\n\t *        The new value to set.\n\t * @return The value of the variable prior to this change.\n\t * @throws NullPointerException\n\t *         if qname is null\n\t * @throws IllegalArgumentException\n\t *         if name is not already a variable."
        },
        "getVariable": {
          "Javadoc": "* Get the variable value associated to the given variable qname.\n\t * <p>\n\t * qname must consist of an optional namespace prefix and colon, followed\n\t * by a mandatory variable localname. If the prefix is not specified, then\n\t * the Namespace is assumed to be the {@link Namespace#NO_NAMESPACE}. If\n\t * the prefix is specified, it must match with one of the declared\n\t * Namespaces for this XPathExpression\n\t * \n\t * @param qname\n\t *        the variable qname to retrieve the value for.\n\t * @return the value associated to a Variable name.\n\t * @throws NullPointerException\n\t *         if qname is null\n\t * @throws IllegalArgumentException\n\t *         if that variable name is not defined."
        },
        "getFilter": {
          "Javadoc": "* Get the {@code Filter<T>} used to coerce the raw XPath results in to\n\t *         the correct Generic type.\n\t * @return the {@code Filter<T>} used to coerce the raw XPath results in to\n\t *         the correct Generic type."
        },
        "evaluate": {
          "Javadoc": "* Process the compiled XPathExpression against the specified context.\n\t * <p>\n\t * In the JDOM2 XPath API the results of the raw XPath query are processed\n\t * by the attached {@code Filter<T>} instance to coerce the results in to\n\t * the correct generic type for this XPathExpression. The Filter process may\n\t * cause some XPath results to be removed from the final results. You may\n\t * instead want to call the {@link #diagnose(Object, boolean)} method to\n\t * have access to both the raw XPath results as well as the filtered and\n\t * generically typed results.\n\t * \n\t * @param context\n\t *        The context against which to process the query.\n\t * @return a list of the XPath results.\n\t * @throws NullPointerException\n\t *         if the context is null\n\t * @throws IllegalStateException\n\t *         if the expression is not runnable or if the context node is not\n\t *         appropriate for the expression."
        },
        "evaluateFirst": {
          "Javadoc": "* Return the first value in the XPath query result set type-cast to the\n\t * return type of this XPathExpression.\n\t * <p>\n\t * The concept of the 'first' result is applied before any JDOM Filter is\n\t * applied. Thus, if the underlying XPath query has some results, the first\n\t * result is sent through the filter. If it matches it is returned, if it\n\t * does not match, then null is returned (even if some subsequent result\n\t * underlying XPath result would pass the filter).\n\t * <p>\n\t * This allows the XPath implementation to optimise the evaluateFirst method\n\t * by potentially using 'short-circuit' conditions in the evaluation.\n\t * <p>\n\t * \n\t * @param context\n\t *        The context against which to evaluate the expression. This will\n\t *        typically be a Document, Element, or some other JDOM object.\n\t * @return The first XPath result (if there is any) coerced to the generic\n\t *         type of this XPathExpression, or null if it cannot be coerced.\n\t * @throws NullPointerException\n\t *         if the context is null\n\t * @throws IllegalStateException\n\t *         if the expression is not runnable or if the context node is not\n\t *         appropriate for the expression."
        },
        "diagnose": {
          "Javadoc": "* Evaluate the XPath query against the supplied context, but return\n\t * additional data which may be useful for diagnosing problems with XPath\n\t * queries.\n\t * \n\t * @param context\n\t *        The context against which to run the query.\n\t * @param firstonly\n\t *        Indicate whether the XPath expression can be terminated after the\n\t *        first successful result value.\n\t * @return an {@link XPathDiagnostic} instance.\n\t * @throws NullPointerException\n\t *         if the context is null\n\t * @throws IllegalStateException\n\t *         if the expression is not runnable or if the context node is not\n\t *         appropriate for the expression."
        }
      }
    },
    "org.jdom2.xpath.XPathFactory": {
      "Javadoc": "\n * XPathFactory allows JDOM users to configure which XPath implementation to use\n * when evaluating XPath expressions.\n * <p>\n * JDOM does not extend the core Java XPath API (javax.xml.xpath.XPath). Instead\n * it creates a new API that is more JDOM and Java friendly leading to neater\n * and more understandable code (in a JDOM context).\n * <p>\n * A JDOM XPathFactory instance is able to create JDOM XPathExpression instances\n * that can be used to evaluate XPath expressions against JDOM Content.\n * <p>\n * The XPathFactory allows either default or custom XPathFactory instances to be\n * created. If you use the {@link #newInstance(String)} method then an\n * XPathFactory of that specific type will be created. If you use the\n * {@link #instance()} method then a default XPathFactory instance will be\n * returned.\n * <p>\n * Instances of XPathFactory are specified to be thread-safe. You can reuse an\n * XPathFactory in multiple threads. Instances of XPathExpression are\n * <strong>NOT</strong> thread-safe.\n * \n * @since JDOM2\n * @author Rolf Lear\n ",
      "methods": {
        "instance": {
          "Javadoc": "* Obtain an instance of an XPathFactory using the default mechanisms to\n\t * determine what XPathFactory implementation to use.\n\t * <p>\n\t * The exact same XPathFactory instance will be returned from each call.\n\t * <p>\n\t * The default mechanism will inspect the system property (only once)\n\t * {@link JDOMConstants#JDOM2_PROPERTY_XPATH_FACTORY} to determine what\n\t * class should be used for the XPathFactory. If that property is not set\n\t * then JDOM will use the {@link JaxenXPathFactory}.\n\t * \n\t * @return the default XPathFactory instance"
        },
        "newInstance": {
          "Javadoc": "* Create a new instance of an explicit XPathFactory. A new instance of the\n\t * specified XPathFactory is created each time. The target XPathFactory\n\t * needs to have a no-argument default constructor.\n\t * <p>\n\t * This method is a convenience mechanism only, and JDOM users are free to\n\t * create a custom XPathFactory instance and use a simple: <br>\n\t * <code>   XPathFactory fac = new MyXPathFactory(arg1, arg2, ...)</code>\n\t * \n\t * @param factoryclass\n\t *        The name of the XPathFactory class to create.\n\t * @return An XPathFactory of the specified class."
        },
        "compile": {
          "Javadoc": "* Create a XPathExpression&lt;Object&gt; instance from this factory.\n\t * \n\t * @param expression\n\t *        The XPath expression.\n\t * @return an XPathExpression&lt;Object&gt; instance.\n\t * @throws NullPointerException\n\t *         if the query or filter is null\n\t * @throws IllegalArgumentException\n\t *         if there is any reason that the XPath query cannot be compiled."
        }
      }
    },
    "org.jdom2.xpath.XPathHelper": {
      "Javadoc": "\n * Provides a set of utility methods to generate XPath expressions to select a\n * given node in a document. You can generate absolute XPath expressions to the\n * target node, or relative expressions from a specified start point. If you\n * request a relative expression, the start and target nodes must share some\n * common ancestry.\n * <p>\n * XPaths are required to be namespace-aware. Typically this is done by using\n * a namespace-prefixed query, with the actual namespace URI being set in the\n * context of the XPath expression. This is not possible to express using a\n * simple String return value. As a work-around, this method uses a potentially\n * slower, but more reliable, mechanism for ensuring the correct namespace\n * context is selected. The mechanism will appear like (for Elements):\n * <br>\n * <code>   .../*[local-name() = 'tag' and namespace-uri() = 'uri']</code>\n * <br>\n * Similarly, Attributes will have a syntax similar to:\n * <br>\n * <code>   .../@*[local-name() = 'attname' and namespace-uri() = 'uri'] </code>\n * <br>\n * This mechanism makes it possible to have a simple namespace context, and a\n * simple String value returned from the methods on this class.\n * <p>\n * This class does not provide ways to access document-level content. Nor does\n * it provide ways to access data relative to the Document level. Use absolute\n * methods to access data from the Document level.\n * <p>\n * The methods on this class assume that the Document is above the top-most\n * Element in the XML tree. The top-most Element is the one that does not have\n * a parent Element (although it may have a parent Document). As a result, you\n * can use Element data that is not attached to a JDOM Document.\n * <p>\n * Detatched Attributes, and detached non-Element content are not treated the\n * same. If you try to get an Absolute path to a detached Attribute or\n * non-Element Content you will get an IllegalArgumentException. On the other\n * hand it is legal to get the relative XPath for a detached node to itself (\n * but to some other node will cause an IllegalArgumentException because the\n * nodes do not share a common ancestor).  \n * <p>\n * <strong>Note</strong>: As this class has no knowledge of the document\n * content, the generated XPath expression rely on the document structure. Hence\n * any modification of the structure of the document may invalidate the\n * generated XPaths.\n * </p>\n * \n * @author Laurent Bihanic\n * @author Rolf Lear\n ",
      "methods": {
        "getPositionPath": {
          "Javadoc": "* Appends the specified path token to the provided buffer followed by the\n\t * position specification of the target node in its siblings list (if\n\t * needed).\n\t * \n\t * @param node\n\t *        the target node for the XPath expression.\n\t * @param siblings\n\t *        the siblings of the target node.\n\t * @param pathToken\n\t *        the path token identifying the target node.\n\t * @param buffer\n\t *        the buffer to which appending the XPath sub-expression or\n\t *        <code>null</code> if the method shall allocate a new buffer.\n\t * @return the XPath sub-expression to select the target node among its\n\t *         siblings."
        },
        "getSingleStep": {
          "Javadoc": "* Calculate a single stage of an XPath query.\n\t * \n\t * @param nsa\n\t *        The token to get the relative-to-parent XPath for\n\t * @param buffer\n\t *        The buffer to append the relative stage to\n\t * @return The same buffer as was input."
        },
        "getRelativeElementPath": {
          "Javadoc": "* Returns the path to the specified <code>to</code>Element from the\n\t * specified <code>from</code> Element. The from Element must have a common\n\t * ancestor Element with the to Element.\n\t * <p>\n\t * \n\t * @param from\n\t *        the Element the generated path shall select relative to.\n\t * @param to\n\t *        the Content the generated path shall select.\n\t * @param sb\n\t *        the StringBuilder to append the path to.\n\t * @return an XPath expression to select the specified node.\n\t * @throws IllegalArgumentException\n\t *         if the from and to Elements have no common ancestor."
        },
        "locate": {
          "Javadoc": "* Do an identity search in an array for a specific value.\n\t * \n\t * @param f\n\t *        The Element to search for.\n\t * @param tostack\n\t *        The list to search in.\n\t * @return the position of the f value in the tostack."
        },
        "getRelativePath": {
          "Javadoc": "* Returns the relative path from the given from Attribute to the specified\n\t * to Content as an XPath expression.\n\t * \n\t * @param from\n\t *        the Attribute from which the the generated path shall be applied.\n\t * @param to\n\t *        the Content the generated path shall select.\n\t * @return an XPath expression to select the specified node.\n\t * @throws IllegalArgumentException\n\t *         if <code>to</code> and <code>from</code> are not part of the same\n\t *         XML tree"
        },
        "getAbsolutePath": {
          "Javadoc": "* Returns the absolute path to the specified to Content.\n\t * \n\t * @param to\n\t *        the Content the generated path shall select.\n\t * @return an XPath expression to select the specified node.\n\t * @throws IllegalArgumentException\n\t *         if <code>to</code> is detached."
        }
      }
    }
  }
}