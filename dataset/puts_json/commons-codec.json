{
  "dataset": "commons-codec",
  "classes": {
    "org.apache.commons.codec.binary.Base16": {
      "Javadoc": "\n * Provides Base16 encoding and decoding.\n *\n * <p>\n * This class is thread-safe.\n * </p>\n * <p>\n * This implementation strictly follows RFC 4648, and as such unlike the {@link Base32} and {@link Base64} implementations, it does not ignore invalid alphabet\n * characters or whitespace, neither does it offer chunking or padding characters.\n * </p>\n * <p>\n * The only additional feature above those specified in RFC 4648 is support for working with a lower-case alphabet in addition to the default upper-case\n * alphabet.\n * </p>\n *\n * @see <a href=\"https://tools.ietf.org/html/rfc4648#section-8\">RFC 4648 - 8. Base 16 Encoding</a>\n *\n * @since 1.15\n ",
      "methods": {
        "isInAlphabet": {
          "Javadoc": "* Returns whether or not the {@code octet} is in the Base16 alphabet.\n     *\n     * @param octet The value to test.\n     *\n     * @return {@code true} if the value is defined in the Base16 alphabet {@code false} otherwise."
        },
        "validateTrailingCharacter": {
          "Javadoc": "* Validates whether decoding allows an entire final trailing character that cannot be used for a complete byte.\n     *\n     * @throws IllegalArgumentException if strict decoding is enabled"
        }
      }
    },
    "org.apache.commons.codec.binary.Base16InputStream": {
      "Javadoc": "\n * Provides Base16 encoding and decoding in a streaming fashion (unlimited size).\n * <p>\n * The default behavior of the Base16InputStream is to DECODE, whereas the default behavior of the\n * {@link Base16OutputStream} is to ENCODE, but this behavior can be overridden by using a different constructor.\n * </p>\n *\n * @since 1.15\n "
    },
    "org.apache.commons.codec.binary.Base16OutputStream": {
      "Javadoc": "\n * Provides Hex encoding and decoding in a streaming fashion (unlimited size).\n * <p>\n * The default behavior of the HexOutputStream is to ENCODE, whereas the default behavior of the\n * {@link Base16InputStream} is to DECODE. But this behavior can be overridden by using a different constructor.\n * </p>\n *\n * @since 1.15\n "
    },
    "org.apache.commons.codec.binary.Base32": {
      "Javadoc": "\n * Provides Base32 encoding and decoding as defined by <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>.\n *\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * </p>\n * <ul>\n * <li>Whether to use the \"base32hex\" variant instead of the default \"base32\"</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 8 will still essentially end up being multiples of 8 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * <p>\n * This class operates directly on byte streams, and not character streams.\n * </p>\n * <p>\n * This class is thread-safe.\n * </p>\n * <p>\n * You can configure instances with the {@link Builder}.\n * </p>\n * <pre>\n * Base32 base32 = Base32.builder()\n *   .setDecodingPolicy(DecodingPolicy.LENIENT) // default is lenient\n *   .setEncodeTable(customEncodeTable)\n *   .setLineLength(0)                          // default is none\n *   .setLineSeparator('\\r', '\\n')              // default is CR LF\n *   .setPadding('=')                           // default is =\n *   .get()\n * </pre>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>\n * @since 1.5\n ",
      "methods": {
        "builder": {
          "Javadoc": "* Creates a new Builder.\n     *\n     * @return a new Builder.\n     * @since 1.17.0"
        },
        "decode": {
          "Javadoc": "* <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once with the data to decode, and once with\n     * inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\" call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-Base32 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are silently ignored, but has implications\n     * for other bytes, too. This method subscribes to the garbage-in, garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Output is written to {@link org.apache.commons.codec.binary.BaseNCodec.Context#buffer Context#buffer} as 8-bit octets, using\n     * {@link org.apache.commons.codec.binary.BaseNCodec.Context#pos Context#pos} as the buffer position\n     * </p>\n     *\n     * @param input   byte[] array of ASCII data to Base32 decode.\n     * @param inPos   Position to start reading data from.\n     * @param inAvail Amount of bytes available from input for decoding.\n     * @param context the context to be used"
        },
        "encode": {
          "Javadoc": "* <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with the data to encode, and once with\n     * inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last remaining bytes (if not multiple of 5).\n     * </p>\n     *\n     * @param input   byte[] array of binary data to Base32 encode.\n     * @param inPos   Position to start reading data from.\n     * @param inAvail Amount of bytes available from input for encoding.\n     * @param context the context to be used"
        },
        "getLineSeparator": {
          "Javadoc": "* Gets the line separator (for testing only).\n     *\n     * @return the line separator."
        },
        "isInAlphabet": {
          "Javadoc": "* Returns whether or not the {@code octet} is in the Base32 alphabet.\n     *\n     * @param octet The value to test\n     * @return {@code true} if the value is defined in the Base32 alphabet {@code false} otherwise."
        },
        "validateCharacter": {
          "Javadoc": "* Validates whether decoding the final trailing character is possible in the context of the set of possible base 32 values.\n     * <p>\n     * The character is valid if the lower bits within the provided mask are zero. This is used to test the final trailing base-32 digit is zero in the bits\n     * that will be discarded.\n     * </p>\n     *\n     * @param emptyBitsMask The mask of the lower bits that should be empty\n     * @param context       the context to be used\n     *\n     * @throws IllegalArgumentException if the bits being checked contain any non-zero value"
        },
        "validateTrailingCharacters": {
          "Javadoc": "* Validates whether decoding allows final trailing characters that cannot be created during encoding.\n     *\n     * @throws IllegalArgumentException if strict decoding is enabled"
        }
      }
    },
    "org.apache.commons.codec.binary.Builder": {
      "Javadoc": "\n     * Builds {@link Base64} instances.\n     *\n     * @since 1.17.0\n     ",
      "methods": {
        "setUrlSafe": {
          "Javadoc": "* Sets the URL-safe encoding policy.\n         *\n         * @param urlSafe URL-safe encoding policy, null resets to the default.\n         * @return this."
        }
      }
    },
    "org.apache.commons.codec.binary.Base32InputStream": {
      "Javadoc": "\n * Provides Base32 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n * constructor.\n * <p>\n * The default behavior of the Base32InputStream is to DECODE, whereas the default behavior of the Base32OutputStream\n * is to ENCODE, but this behavior can be overridden by using a different constructor.\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * <p>\n * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a\n * valid encoding. These can be bits that are unused from the final character or entire characters. The default mode is\n * lenient decoding.\n * </p>\n * <ul>\n * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.\n * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid\n * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not\n * allowed.\n * </ul>\n * <p>\n * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches\n * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding\n * and alphabet as the encoder.\n * </p>\n * @see <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>\n * @since 1.5\n "
    },
    "org.apache.commons.codec.binary.Base32OutputStream": {
      "Javadoc": "\n * Provides Base32 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n * constructor.\n * <p>\n * The default behavior of the Base32OutputStream is to ENCODE, whereas the default behavior of the Base32InputStream\n * is to DECODE. But this behavior can be overridden by using a different constructor.\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * <p>\n * <b>Note:</b> It is mandatory to close the stream after the last byte has been written to it, otherwise the\n * final padding will be omitted and the resulting data will be incomplete/inconsistent.\n * </p>\n * <p>\n * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a\n * valid encoding. These can be bits that are unused from the final character or entire characters. The default mode is\n * lenient decoding.\n * </p>\n * <ul>\n * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.\n * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid\n * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not\n * allowed.\n * </ul>\n * <p>\n * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches\n * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding\n * and alphabet as the encoder.\n * </p>\n * @see <a href=\"http://www.ietf.org/rfc/rfc4648.txt\">RFC 4648</a>\n * @since 1.5\n "
    },
    "org.apache.commons.codec.binary.Base64": {
      "Javadoc": "\n * Provides Base64 encoding and decoding as defined by <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>.\n *\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * The class can be parameterized in the following manner with various constructors:\n * </p>\n * <ul>\n * <li>URL-safe mode: Default off.</li>\n * <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of\n * 4 in the encoded data.\n * <li>Line separator: Default is CRLF (\"\\r\\n\")</li>\n * </ul>\n * <p>\n * The URL-safe parameter is only applied to encode operations. Decoding seamlessly handles both modes.\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only\n * encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252,\n * UTF-8, etc).\n * </p>\n * <p>\n * This class is thread-safe.\n * </p>\n * <p>\n * You can configure instances with the {@link Builder}.\n * </p>\n * <pre>\n * Base64 base64 = Base64.builder()\n *   .setDecodingPolicy(DecodingPolicy.LENIENT) // default is lenient, null resets to default\n *   .setEncodeTable(customEncodeTable)         // default is built in, null resets to default\n *   .setLineLength(0)                          // default is none\n *   .setLineSeparator('\\r', '\\n')              // default is CR LF, null resets to default\n *   .setPadding('=')                           // default is =\n *   .setUrlSafe(false)                         // default is false\n *   .get()\n * </pre>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 1.0\n ",
      "methods": {
        "builder": {
          "Javadoc": "* Creates a new Builder.\n     *\n     * @return a new Builder.\n     * @since 1.17.0"
        },
        "decodeBase64": {
          "Javadoc": "* Decodes a Base64 String into octets.\n     * <p>\n     * <b>Note:</b> this method seamlessly handles data encoded in URL-safe or normal mode.\n     * </p>\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4"
        },
        "decodeInteger": {
          "Javadoc": "* Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\n     *\n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4"
        },
        "encodeBase64": {
          "Javadoc": "* Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if {@code true} this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if {@code true} this encoder will emit - and _ instead of the usual + and / characters.\n     *            <b>Note: no padding is added when encoding using the URL-safe alphabet.</b>\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4"
        },
        "encodeBase64Chunked": {
          "Javadoc": "* Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return Base64 characters chunked in 76 character blocks"
        },
        "encodeBase64String": {
          "Javadoc": "* Encodes binary data using the base64 algorithm but does not chunk the output.\n     *\n     * NOTE:  We changed the behavior of this method from multi-line chunking (commons-codec-1.4) to\n     * single-line non-chunking (commons-codec-1.5).\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4 (NOTE:  1.4 chunked the output, whereas 1.5 does not)."
        },
        "encodeBase64URLSafe": {
          "Javadoc": "* Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * <b>Note: no padding is added.</b>\n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4"
        },
        "encodeBase64URLSafeString": {
          "Javadoc": "* Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * <b>Note: no padding is added.</b>\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4"
        },
        "encodeInteger": {
          "Javadoc": "* Encodes to a byte64-encoded integer according to crypto standards such as W3C's XML-Signature.\n     *\n     * @param bigInteger\n     *            a BigInteger\n     * @return A byte array containing base64 character data\n     * @throws NullPointerException\n     *             if null is passed in\n     * @since 1.4"
        },
        "isArrayByteBase64": {
          "Javadoc": "* Tests a given byte array to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     *\n     * @param arrayOctet\n     *            byte array to test\n     * @return {@code true} if all bytes are valid characters in the Base64 alphabet or if the byte array is empty;\n     *         {@code false}, otherwise\n     * @deprecated 1.5 Use {@link #isBase64(byte[])}, will be removed in 2.0."
        },
        "isBase64": {
          "Javadoc": "* Tests a given String to see if it contains only valid characters within the Base64 alphabet. Currently the\n     * method treats whitespace as valid.\n     *\n     * @param base64\n     *            String to test\n     * @return {@code true} if all characters in the String are valid characters in the Base64 alphabet or if\n     *         the String is empty; {@code false}, otherwise\n     *  @since 1.5"
        },
        "toIntegerBytes": {
          "Javadoc": "* Returns a byte-array representation of a {@code BigInteger} without sign bit.\n     *\n     * @param bigInt\n     *            {@code BigInteger} to be converted\n     * @return a byte array representation of the BigInteger parameter"
        },
        "calculateDecodeTable": {
          "Javadoc": "* Calculates a decode table for a given encode table.\n     *\n     * @param encodeTable that is used to determine decode lookup table\n     * @return decodeTable"
        },
        "decode": {
          "Javadoc": "* <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * https://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param input\n     *            byte[] array of ASCII data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for decoding.\n     * @param context\n     *            the context to be used"
        },
        "encode": {
          "Javadoc": "* <p>\n     * Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with\n     * the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, to flush last\n     * remaining bytes (if not multiple of 3).\n     * </p>\n     * <p><b>Note: no padding is added when encoding using the URL-safe alphabet.</b></p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * https://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param in\n     *            byte[] array of binary data to base64 encode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     * @param context\n     *            the context to be used"
        },
        "getLineSeparator": {
          "Javadoc": "* Gets the line separator (for testing only).\n     *\n     * @return the line separator."
        },
        "isInAlphabet": {
          "Javadoc": "* Returns whether or not the {@code octet} is in the Base64 alphabet.\n     *\n     * @param octet\n     *            The value to test\n     * @return {@code true} if the value is defined in the Base64 alphabet {@code false} otherwise."
        },
        "isUrlSafe": {
          "Javadoc": "* Returns our current encode mode. True if we're URL-safe, false otherwise.\n     *\n     * @return true if we're in URL-safe mode, false otherwise.\n     * @since 1.4"
        },
        "validateCharacter": {
          "Javadoc": "* Validates whether decoding the final trailing character is possible in the context\n     * of the set of possible base 64 values.\n     * <p>\n     * The character is valid if the lower bits within the provided mask are zero. This\n     * is used to test the final trailing base-64 digit is zero in the bits that will be discarded.\n     * </p>\n     *\n     * @param emptyBitsMask The mask of the lower bits that should be empty\n     * @param context the context to be used\n     *\n     * @throws IllegalArgumentException if the bits being checked contain any non-zero value"
        },
        "validateTrailingCharacter": {
          "Javadoc": "* Validates whether decoding allows an entire final trailing character that cannot be\n     * used for a complete byte.\n     *\n     * @throws IllegalArgumentException if strict decoding is enabled"
        }
      }
    },
    "org.apache.commons.codec.binary.Base64InputStream": {
      "Javadoc": "\n * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n * constructor.\n * <p>\n * The default behavior of the Base64InputStream is to DECODE, whereas the default behavior of the Base64OutputStream\n * is to ENCODE, but this behavior can be overridden by using a different constructor.\n * </p>\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * <p>\n * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a\n * valid encoding. These can be bits that are unused from the final character or entire characters. The default mode is\n * lenient decoding.\n * </p>\n * <ul>\n * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.\n * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid\n * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not\n * allowed.\n * </ul>\n * <p>\n * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches\n * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding\n * and alphabet as the encoder.\n * </p>\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 1.4\n "
    },
    "org.apache.commons.codec.binary.Base64OutputStream": {
      "Javadoc": "\n * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength\n * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate\n * constructor.\n * <p>\n * The default behavior of the Base64OutputStream is to ENCODE, whereas the default behavior of the Base64InputStream\n * is to DECODE. But this behavior can be overridden by using a different constructor.\n * </p>\n * <p>\n * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose\n * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.\n * </p>\n * <p>\n * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode\n * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).\n * </p>\n * <p>\n * <b>Note:</b> It is mandatory to close the stream after the last byte has been written to it, otherwise the\n * final padding will be omitted and the resulting data will be incomplete/inconsistent.\n * </p>\n * <p>\n * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a\n * valid encoding. These can be bits that are unused from the final character or entire characters. The default mode is\n * lenient decoding.\n * </p>\n * <ul>\n * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.\n * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid\n * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not\n * allowed.\n * </ul>\n * <p>\n * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches\n * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding\n * and alphabet as the encoder.\n * </p>\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n * @since 1.4\n "
    },
    "org.apache.commons.codec.binary.BaseNCodec": {
      "Javadoc": "\n * Abstract superclass for Base-N encoders and decoders.\n *\n * <p>\n * This class is thread-safe.\n * </p>\n * <p>\n * You can set the decoding behavior when the input bytes contain leftover trailing bits that cannot be created by a\n * valid encoding. These can be bits that are unused from the final character or entire characters. The default mode is\n * lenient decoding.\n * </p>\n * <ul>\n * <li>Lenient: Any trailing bits are composed into 8-bit bytes where possible. The remainder are discarded.\n * <li>Strict: The decoding will raise an {@link IllegalArgumentException} if trailing bits are not part of a valid\n * encoding. Any unused bits from the final character must be zero. Impossible counts of entire final characters are not\n * allowed.\n * </ul>\n * <p>\n * When strict decoding is enabled it is expected that the decoded bytes will be re-encoded to a byte array that matches\n * the original, i.e. no changes occur on the final character. This requires that the input bytes use the same padding\n * and alphabet as the encoder.\n * </p>\n ",
      "methods": {
        "createPositiveCapacity": {
          "Javadoc": "* Create a positive capacity at least as large the minimum required capacity.\n     * If the minimum capacity is negative then this throws an OutOfMemoryError as no array\n     * can be allocated.\n     *\n     * @param minCapacity the minimum capacity\n     * @return the capacity\n     * @throws OutOfMemoryError if the {@code minCapacity} is negative"
        },
        "getChunkSeparator": {
          "Javadoc": "* Gets a copy of the chunk separator per RFC 2045 section 2.1.\n     *\n     * @return the chunk separator\n     * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n     * @since 1.15"
        },
        "isWhiteSpace": {
          "Javadoc": "* Checks if a byte value is whitespace or not.\n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     * @see Character#isWhitespace(int)\n     * @deprecated Use {@link Character#isWhitespace(int)}."
        },
        "resizeBuffer": {
          "Javadoc": "* Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.\n     * @param context the context to be used\n     * @param minCapacity the minimum required capacity\n     * @return the resized byte[] buffer\n     * @throws OutOfMemoryError if the {@code minCapacity} is negative"
        },
        "toLength": {
          "Javadoc": "* Gets the array length or 0 if null.\n     *\n     * @param array the array or null.\n     * @return the array length or 0 if null."
        },
        "available": {
          "Javadoc": "* Returns the amount of buffered data available for reading.\n     *\n     * @param context the context to be used\n     * @return The amount of buffered data available for reading."
        },
        "containsAlphabetOrPad": {
          "Javadoc": "* Tests a given byte array to see if it contains any characters within the alphabet or PAD.\n     *\n     * Intended for use in checking line-ending arrays\n     *\n     * @param arrayOctet\n     *            byte array to test\n     * @return {@code true} if any byte is a valid character in the alphabet or PAD; {@code false} otherwise"
        },
        "decode": {
          "Javadoc": "* Decodes a String containing characters in the Base-N alphabet.\n     *\n     * @param pArray\n     *            A String containing Base-N character data\n     * @return a byte array containing binary data"
        },
        "encode": {
          "Javadoc": "* Encodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].\n     *\n     * @param obj\n     *            Object to encode\n     * @return An object (of type byte[]) containing the Base-N encoded data which corresponds to the byte[] supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type byte[]"
        },
        "encodeAsString": {
          "Javadoc": "* Encodes a byte[] containing binary data, into a String containing characters in the appropriate alphabet.\n     * Uses UTF8 encoding.\n     * <p>\n     * This is a duplicate of {@link #encodeToString(byte[])}; it was merged during refactoring.\n     * </p>\n     *\n     * @param pArray a byte array containing binary data\n     * @return String containing only character data in the appropriate alphabet.\n     * @since 1.5"
        },
        "encodeToString": {
          "Javadoc": "* Encodes a byte[] containing binary data, into a String containing characters in the Base-N alphabet.\n     * Uses UTF8 encoding.\n     *\n     * @param pArray\n     *            a byte array containing binary data\n     * @return A String containing only Base-N character data"
        },
        "ensureBufferSize": {
          "Javadoc": "* Ensure that the buffer has room for {@code size} bytes\n     *\n     * @param size minimum spare space required\n     * @param context the context to be used\n     * @return the buffer"
        },
        "getCodecPolicy": {
          "Javadoc": "* Returns the decoding behavior policy.\n     *\n     * <p>\n     * The default is lenient. If the decoding policy is strict, then decoding will raise an\n     * {@link IllegalArgumentException} if trailing bits are not part of a valid encoding. Decoding will compose\n     * trailing bits into 8-bit bytes and discard the remainder.\n     * </p>\n     *\n     * @return true if using strict decoding\n     * @since 1.15"
        },
        "getDefaultBufferSize": {
          "Javadoc": "* Gets the default buffer size. Can be overridden.\n     *\n     * @return the default buffer size."
        },
        "getEncodedLength": {
          "Javadoc": "* Calculates the amount of space needed to encode the supplied array.\n     *\n     * @param pArray byte[] array which will later be encoded\n     *\n     * @return amount of space needed to encode the supplied array.\n     * Returns a long since a max-len array will require &gt; Integer.MAX_VALUE"
        },
        "hasData": {
          "Javadoc": "* Returns true if this object has buffered data for reading.\n     *\n     * @param context the context to be used\n     * @return true if there is data still available for reading."
        },
        "isInAlphabet": {
          "Javadoc": "* Tests a given String to see if it contains only valid characters within the alphabet.\n     * The method treats whitespace and PAD as valid.\n     *\n     * @param basen String to test\n     * @return {@code true} if all characters in the String are valid characters in the alphabet or if\n     *         the String is empty; {@code false}, otherwise\n     * @see #isInAlphabet(byte[], boolean)"
        },
        "isStrictDecoding": {
          "Javadoc": "* Returns true if decoding behavior is strict. Decoding will raise an {@link IllegalArgumentException} if trailing\n     * bits are not part of a valid encoding.\n     *\n     * <p>\n     * The default is false for lenient decoding. Decoding will compose trailing bits into 8-bit bytes and discard the\n     * remainder.\n     * </p>\n     *\n     * @return true if using strict decoding\n     * @since 1.15"
        },
        "readResults": {
          "Javadoc": "* Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail\n     * bytes. Returns how many bytes were actually extracted.\n     * <p>\n     * Package private for access from I/O streams.\n     * </p>\n     *\n     * @param b\n     *            byte[] array to extract the buffered data into.\n     * @param bPos\n     *            position in byte[] array to start extraction at.\n     * @param bAvail\n     *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).\n     * @param context\n     *            the context to be used\n     * @return The number of bytes successfully extracted into the provided byte[] array."
        }
      }
    },
    "org.apache.commons.codec.binary.AbstractBuilder": {
      "Javadoc": "\n     * Builds {@link Base64} instances.\n     *\n     * @param <T> the codec type to build.\n     * @param <B> the codec builder subtype.\n     * @since 1.17.0\n     ",
      "methods": {
        "setDecodingPolicy": {
          "Javadoc": "* Sets the decoding policy.\n         *\n         * @param decodingPolicy the decoding policy, null resets to the default.\n         * @return this."
        },
        "setEncodeTable": {
          "Javadoc": "* Sets the encode table.\n         *\n         * @param encodeTable the encode table, null resets to the default.\n         * @return this."
        },
        "setLineLength": {
          "Javadoc": "* Sets the line length.\n         *\n         * @param lineLength the line length, less than 0 resets to the default.\n         * @return this."
        },
        "setLineSeparator": {
          "Javadoc": "* Sets the line separator.\n         *\n         * @param lineSeparator the line separator, null resets to the default.\n         * @return this."
        },
        "setPadding": {
          "Javadoc": "* Sets the padding byte.\n         *\n         * @param padding the padding byte.\n         * @return this."
        }
      }
    },
    "org.apache.commons.codec.binary.Context": {
      "Javadoc": "\n     * Holds thread context so classes can be thread-safe.\n     *\n     * This class is not itself thread-safe; each thread must allocate its own copy.\n     ",
      "methods": {
        "toString": {
          "Javadoc": "* Returns a String useful for debugging (especially within a debugger.)\n         *\n         * @return a String useful for debugging."
        }
      }
    },
    "org.apache.commons.codec.binary.BaseNCodecInputStream": {
      "Javadoc": "\n * Abstract superclass for Base-N input streams.\n *\n * @since 1.5\n ",
      "methods": {
        "available": {
          "Javadoc": "* {@inheritDoc}\n     *\n     * @return {@code 0} if the {@link InputStream} has reached {@code EOF},\n     * {@code 1} otherwise\n     * @since 1.7"
        },
        "isStrictDecoding": {
          "Javadoc": "* Returns true if decoding behavior is strict. Decoding will raise an\n     * {@link IllegalArgumentException} if trailing bits are not part of a valid encoding.\n     *\n     * <p>\n     * The default is false for lenient encoding. Decoding will compose trailing bits\n     * into 8-bit bytes and discard the remainder.\n     * </p>\n     *\n     * @return true if using strict decoding\n     * @since 1.15"
        },
        "mark": {
          "Javadoc": "* Marks the current position in this input stream.\n     * <p>\n     * The {@link #mark} method of {@link BaseNCodecInputStream} does nothing.\n     * </p>\n     *\n     * @param readLimit the maximum limit of bytes that can be read before the mark position becomes invalid.\n     * @see #markSupported()\n     * @since 1.7"
        },
        "markSupported": {
          "Javadoc": "* {@inheritDoc}\n     *\n     * @return Always returns {@code false}"
        },
        "read": {
          "Javadoc": "* Attempts to read {@code len} bytes into the specified {@code b} array starting at {@code offset}\n     * from this InputStream.\n     *\n     * @param array\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     *\n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid"
        },
        "reset": {
          "Javadoc": "* Repositions this stream to the position at the time the mark method was last called on this input stream.\n     * <p>\n     * The {@link #reset} method of {@link BaseNCodecInputStream} does nothing except throw an {@link IOException}.\n     * </p>\n     *\n     * @throws IOException if this method is invoked\n     * @since 1.7"
        },
        "skip": {
          "Javadoc": "* {@inheritDoc}\n     *\n     * @throws IllegalArgumentException if the provided skip length is negative\n     * @since 1.7"
        }
      }
    },
    "org.apache.commons.codec.binary.BaseNCodecOutputStream": {
      "Javadoc": "\n * Abstract superclass for Base-N output streams.\n * <p>\n * To write the EOF marker without closing the stream, call {@link #eof()} or use an <a\n * href=\"https://commons.apache.org/proper/commons-io/\">Apache Commons IO</a> <a href=\n * \"https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/output/CloseShieldOutputStream.html\"\n * >CloseShieldOutputStream</a>.\n * </p>\n *\n * @since 1.5\n ",
      "methods": {
        "close": {
          "Javadoc": "* Closes this output stream and releases any system resources associated with the stream.\n     * <p>\n     * To write the EOF marker without closing the stream, call {@link #eof()} or use an\n     * <a href=\"https://commons.apache.org/proper/commons-io/\">Apache Commons IO</a> <a href=\n     * \"https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/output/CloseShieldOutputStream.html\"\n     * >CloseShieldOutputStream</a>.\n     * </p>\n     *\n     * @throws IOException\n     *             if an I/O error occurs."
        },
        "eof": {
          "Javadoc": "* Writes EOF.\n     *\n     * @since 1.11"
        },
        "flush": {
          "Javadoc": "* Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propagate is\n     * true, the wrapped stream will also be flushed.\n     *\n     * @param propagate\n     *            boolean flag to indicate whether the wrapped OutputStream should also be flushed.\n     * @throws IOException\n     *             if an I/O error occurs."
        },
        "isStrictDecoding": {
          "Javadoc": "* Returns true if decoding behavior is strict. Decoding will raise an\n     * {@link IllegalArgumentException} if trailing bits are not part of a valid encoding.\n     *\n     * <p>\n     * The default is false for lenient encoding. Decoding will compose trailing bits\n     * into 8-bit bytes and discard the remainder.\n     * </p>\n     *\n     * @return true if using strict decoding\n     * @since 1.15"
        },
        "write": {
          "Javadoc": "* Writes the specified {@code byte} to this output stream.\n     *\n     * @param i\n     *            source byte\n     * @throws IOException\n     *             if an I/O error occurs."
        }
      }
    },
    "org.apache.commons.codec.binary.BinaryCodec": {
      "Javadoc": "\n * Converts between byte arrays and strings of \"0\"s and \"1\"s.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * TODO: may want to add more bit vector functions like and/or/xor/nand\n * TODO: also might be good to generate boolean[] from byte[] et cetera.\n *\n * @since 1.3\n ",
      "methods": {
        "fromAscii": {
          "Javadoc": "* Decodes a char array where each char represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  each char represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a char in the char array argument"
        },
        "isEmpty": {
          "Javadoc": "* Returns {@code true} if the given array is {@code null} or empty (size 0.)\n     *\n     * @param array\n     *            the source array\n     * @return {@code true} if the given array is {@code null} or empty (size 0.)"
        },
        "toAsciiBytes": {
          "Javadoc": "* Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated\n     * char.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return an array of 0 and 1 character bytes for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])"
        },
        "toAsciiChars": {
          "Javadoc": "* Converts an array of raw binary data into an array of ASCII 0 and 1 characters.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return an array of 0 and 1 characters for each bit of the argument\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])"
        },
        "toAsciiString": {
          "Javadoc": "* Converts an array of raw binary data into a String of ASCII 0 and 1 characters.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return a String of 0 and 1 characters representing the binary data\n     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])"
        },
        "decode": {
          "Javadoc": "* Decodes a byte array where each byte represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  each byte represents an ASCII '0' or '1'\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     * @throws DecoderException\n     *                  if argument is not a byte[], char[] or String\n     * @see org.apache.commons.codec.Decoder#decode(Object)"
        },
        "encode": {
          "Javadoc": "* Converts an array of raw binary data into an array of ASCII 0 and 1 chars.\n     *\n     * @param raw\n     *                  the raw binary data to convert\n     * @return 0 and 1 ASCII character chars one for each bit of the argument\n     * @throws EncoderException\n     *                  if the argument is not a byte[]\n     * @see org.apache.commons.codec.Encoder#encode(Object)"
        },
        "toByteArray": {
          "Javadoc": "* Decodes a String where each char of the String represents an ASCII '0' or '1'.\n     *\n     * @param ascii\n     *                  String of '0' and '1' characters\n     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument\n     * @see org.apache.commons.codec.Decoder#decode(Object)"
        }
      }
    },
    "org.apache.commons.codec.binary.CharSequenceUtils": {
      "Javadoc": "\n * <p>\n * Operations on {@link CharSequence} that are {@code null} safe.\n * </p>\n * <p>\n * Copied from Apache Commons Lang r1586295 on April 10, 2014 (day of 3.3.2 release).\n * </p>\n *\n * @see CharSequence\n * @since 1.10\n ",
      "methods": {
        "regionMatches": {
          "Javadoc": "* Green implementation of regionMatches.\n     *\n     * <p>\n     * Note: This function differs from the current implementation in Apache Commons Lang\n     * where the input indices are not valid. It is only used within this package.\n     * </p>\n     *\n     * @param cs\n     *            the {@code CharSequence} to be processed\n     * @param ignoreCase\n     *            whether or not to be case-insensitive\n     * @param thisStart\n     *            the index to start on the {@code cs} CharSequence\n     * @param substring\n     *            the {@code CharSequence} to be looked for\n     * @param start\n     *            the index to start on the {@code substring} CharSequence\n     * @param length\n     *            character length of the region\n     * @return whether the region matched"
        }
      }
    },
    "org.apache.commons.codec.binary.Hex": {
      "Javadoc": "\n * Converts hexadecimal Strings. The Charset used for certain operation can be set, the default is set in\n * {@link #DEFAULT_CHARSET_NAME}\n *\n * This class is thread-safe.\n *\n * @since 1.1\n ",
      "methods": {
        "decodeHex": {
          "Javadoc": "* Converts a String representing hexadecimal values into an array of bytes of those same values. The returned array\n     * will be half the length of the passed String, as it takes two characters to represent any given byte. An\n     * exception is thrown if the passed String has an odd number of elements.\n     *\n     * @param data A String containing hexadecimal digits\n     * @return A byte array containing binary data decoded from the supplied char array.\n     * @throws DecoderException Thrown if an odd number of characters or illegal characters are supplied\n     * @since 1.11"
        },
        "encodeHex": {
          "Javadoc": "* Converts a byte buffer into an array of characters representing the hexadecimal values of each byte in order. The\n     * returned array will be double the length of the passed array, as it takes two characters to represent any given\n     * byte.\n     *\n     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method\n     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>\n     *\n     * @param byteBuffer a byte buffer to convert to hexadecimal characters\n     * @param toDigits   the output alphabet (must be at least 16 characters)\n     * @return A char[] containing the appropriate characters from the alphabet For best results, this should be either\n     *         upper- or lower-case hex.\n     * @since 1.11"
        },
        "encodeHexString": {
          "Javadoc": "* Converts a byte buffer into a String representing the hexadecimal values of each byte in order. The returned\n     * String will be double the length of the passed array, as it takes two characters to represent any given byte.\n     *\n     * <p>All bytes identified by {@link ByteBuffer#remaining()} will be used; after this method\n     * the value {@link ByteBuffer#remaining() remaining()} will be zero.</p>\n     *\n     * @param data        a byte buffer to convert to hexadecimal characters\n     * @param toLowerCase {@code true} converts to lowercase, {@code false} to uppercase\n     * @return A String containing lower-case hexadecimal characters\n     * @since 1.11"
        },
        "toAlphabet": {
          "Javadoc": "* Converts a boolean to an alphabet.\n     *\n     * @param toLowerCase true for lowercase, false for uppercase.\n     * @return an alphabet."
        },
        "toByteArray": {
          "Javadoc": "* Convert the byte buffer to a byte array. All bytes identified by\n     * {@link ByteBuffer#remaining()} will be used.\n     *\n     * @param byteBuffer the byte buffer\n     * @return the byte[]"
        },
        "toDigit": {
          "Javadoc": "* Converts a hexadecimal character to an integer.\n     *\n     * @param ch    A character to convert to an integer digit\n     * @param index The index of the character in the source\n     * @return An integer\n     * @throws DecoderException Thrown if ch is an illegal hexadecimal character"
        },
        "decode": {
          "Javadoc": "* Converts a String or an array of character bytes representing hexadecimal values into an array of bytes of those\n     * same values. The returned array will be half the length of the passed String or array, as it takes two characters\n     * to represent any given byte. An exception is thrown if the passed char array has an odd number of elements.\n     *\n     * @param object A String, ByteBuffer, byte[], or an array of character bytes containing hexadecimal digits\n     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).\n     * @throws DecoderException Thrown if an odd number of characters is supplied to this function or the object is not\n     *                          a String or char[]\n     * @see #decodeHex(char[])"
        },
        "encode": {
          "Javadoc": "* Converts a String or an array of bytes into an array of characters representing the hexadecimal values of each\n     * byte in order. The returned array will be double the length of the passed String or array, as it takes two\n     * characters to represent any given byte.\n     * <p>\n     * The conversion from hexadecimal characters to bytes to be encoded to performed with the charset named by\n     * {@link #getCharset()}.\n     * </p>\n     *\n     * @param object a String, ByteBuffer, or byte[] to convert to hexadecimal characters\n     * @return A char[] containing lower-case hexadecimal characters\n     * @throws EncoderException Thrown if the given object is not a String or byte[]\n     * @see #encodeHex(byte[])"
        },
        "getCharset": {
          "Javadoc": "* Gets the charset.\n     *\n     * @return the charset.\n     * @since 1.7"
        },
        "getCharsetName": {
          "Javadoc": "* Gets the charset name.\n     *\n     * @return the charset name.\n     * @since 1.4"
        },
        "toString": {
          "Javadoc": "* Returns a string representation of the object, which includes the charset name.\n     *\n     * @return a string representation of the object."
        }
      }
    },
    "org.apache.commons.codec.binary.StringUtils": {
      "Javadoc": "\n * Converts String to and from bytes using the encodings required by the Java specification. These encodings are\n * specified in standard {@link Charset}.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @see CharEncoding\n * @see Charset\n * @see StandardCharsets\n * @since 1.4\n ",
      "methods": {
        "equals": {
          "Javadoc": "* <p>\n     * Compares two CharSequences, returning {@code true} if they represent equal sequences of characters.\n     * </p>\n     *\n     * <p>\n     * {@code null}s are handled without exceptions. Two {@code null} references are considered to be equal.\n     * The comparison is case sensitive.\n     * </p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be {@code null}\n     * @param cs2\n     *            the second CharSequence, may be {@code null}\n     * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n     * @since 1.10"
        },
        "getByteBuffer": {
          "Javadoc": "* Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the {@code String}\n     * @return the encoded bytes"
        },
        "getByteBufferUtf8": {
          "Javadoc": "* Encodes the given string into a byte buffer using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @see Charset\n     * @see #getBytesUnchecked(String, String)\n     * @since 1.11"
        },
        "getBytes": {
          "Javadoc": "* Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the {@code String}\n     * @return the encoded bytes"
        },
        "getBytesIso8859_1": {
          "Javadoc": "* Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new\n     * byte array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#ISO_8859_1} is not initialized, which should never happen\n     *             since it is required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see Charset\n     * @see #getBytesUnchecked(String, String)"
        },
        "getBytesUnchecked": {
          "Javadoc": "* Encodes the given string into a sequence of bytes using the named charset, storing the result into a new byte\n     * array.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and rethrows it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#getBytes(String)"
        },
        "getBytesUsAscii": {
          "Javadoc": "* Encodes the given string into a sequence of bytes using the US-ASCII charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see Charset\n     * @see #getBytesUnchecked(String, String)"
        },
        "getBytesUtf16": {
          "Javadoc": "* Encodes the given string into a sequence of bytes using the UTF-16 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see Charset\n     * @see #getBytesUnchecked(String, String)"
        },
        "getBytesUtf16Be": {
          "Javadoc": "* Encodes the given string into a sequence of bytes using the UTF-16BE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see Charset\n     * @see #getBytesUnchecked(String, String)"
        },
        "getBytesUtf16Le": {
          "Javadoc": "* Encodes the given string into a sequence of bytes using the UTF-16LE charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see Charset\n     * @see #getBytesUnchecked(String, String)"
        },
        "getBytesUtf8": {
          "Javadoc": "* Encodes the given string into a sequence of bytes using the UTF-8 charset, storing the result into a new byte\n     * array.\n     *\n     * @param string\n     *            the String to encode, may be {@code null}\n     * @return encoded bytes, or {@code null} if the input string was {@code null}\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     * @see Charset\n     * @see #getBytesUnchecked(String, String)"
        },
        "newString": {
          "Javadoc": "* Constructs a new {@code String} by decoding the specified array of bytes using the given charset.\n     * <p>\n     * This method catches {@link UnsupportedEncodingException} and re-throws it as {@link IllegalStateException}, which\n     * should never happen for a required charset name. Use this method when the encoding is required to be in the JRE.\n     * </p>\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be {@code null}\n     * @param charsetName\n     *            The name of a required {@link java.nio.charset.Charset}\n     * @return A new {@code String} decoded from the specified array of bytes using the given charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws IllegalStateException\n     *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a\n     *             required charset name.\n     * @see CharEncoding\n     * @see String#String(byte[], String)"
        },
        "newStringIso8859_1": {
          "Javadoc": "* Constructs a new {@code String} by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be {@code null}\n     * @return A new {@code String} decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#ISO_8859_1} is not initialized, which should never happen\n     *             since it is required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException"
        },
        "newStringUsAscii": {
          "Javadoc": "* Constructs a new {@code String} by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new {@code String} decoded from the specified array of bytes using the US-ASCII charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException"
        },
        "newStringUtf16": {
          "Javadoc": "* Constructs a new {@code String} by decoding the specified array of bytes using the UTF-16 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new {@code String} decoded from the specified array of bytes using the UTF-16 charset\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_16} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException"
        },
        "newStringUtf16Be": {
          "Javadoc": "* Constructs a new {@code String} by decoding the specified array of bytes using the UTF-16BE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new {@code String} decoded from the specified array of bytes using the UTF-16BE charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_16BE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException"
        },
        "newStringUtf16Le": {
          "Javadoc": "* Constructs a new {@code String} by decoding the specified array of bytes using the UTF-16LE charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new {@code String} decoded from the specified array of bytes using the UTF-16LE charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_16LE} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException"
        },
        "newStringUtf8": {
          "Javadoc": "* Constructs a new {@code String} by decoding the specified array of bytes using the UTF-8 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new {@code String} decoded from the specified array of bytes using the UTF-8 charset,\n     *         or {@code null} if the input byte array was {@code null}.\n     * @throws NullPointerException\n     *             Thrown if {@link StandardCharsets#UTF_8} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException"
        }
      }
    },
    "org.apache.commons.codec.BinaryDecoder": {
      "Javadoc": "\n * Defines common decoding methods for byte array decoders.\n ",
      "methods": {
        "decode": {
          "Javadoc": "* Decodes a byte array and returns the results as a byte array.\n     *\n     * @param source\n     *            A byte array which has been encoded with the appropriate encoder\n     * @return a byte array that contains decoded content\n     * @throws DecoderException\n     *             A decoder exception is thrown if a Decoder encounters a failure condition during the decode process."
        }
      }
    },
    "org.apache.commons.codec.BinaryEncoder": {
      "Javadoc": "\n * Defines common encoding methods for byte array encoders.\n ",
      "methods": {
        "encode": {
          "Javadoc": "* Encodes a byte array and return the encoded data as a byte array.\n     *\n     * @param source\n     *            Data to be encoded\n     * @return A byte array containing the encoded data\n     * @throws EncoderException\n     *             thrown if the Encoder encounters a failure condition during the encoding process."
        }
      }
    },
    "org.apache.commons.codec.CharEncoding": {
      "Javadoc": "\n * Character encoding names required of every implementation of the Java platform.\n *\n * From the Java documentation for {@link Charset}:\n * <p>\n * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the\n * release documentation for your implementation to see if any other encodings are supported. Consult the release\n * documentation for your implementation to see if any other encodings are supported.</cite>\n * </p>\n *\n * <ul>\n * <li>{@code US-ASCII}<p>\n * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</p></li>\n * <li>{@code ISO-8859-1}<p>\n * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</p></li>\n * <li>{@code UTF-8}<p>\n * Eight-bit Unicode Transformation Format.</p></li>\n * <li>{@code UTF-16BE}<p>\n * Sixteen-bit Unicode Transformation Format, big-endian byte order.</p></li>\n * <li>{@code UTF-16LE}<p>\n * Sixteen-bit Unicode Transformation Format, little-endian byte order.</p></li>\n * <li>{@code UTF-16}<p>\n * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order\n * accepted on input, big-endian used on output.)</p></li>\n * </ul>\n *\n * This perhaps would best belong in the [lang] project. Even if a similar interface is defined in [lang], it is not\n * foreseen that [codec] would be made to depend on [lang].\n *\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @see Charset\n * @since 1.4\n "
    },
    "org.apache.commons.codec.Charsets": {
      "Javadoc": "\n * Charsets required of every implementation of the Java platform.\n *\n * From the Java documentation <a href=\"https://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard\n * charsets</a>:\n * <p>\n * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the\n * release documentation for your implementation to see if any other encodings are supported. Consult the release\n * documentation for your implementation to see if any other encodings are supported. </cite>\n * </p>\n *\n * <ul>\n * <li>{@code US-ASCII}<p>\n * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</p></li>\n * <li>{@code ISO-8859-1}<p>\n * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</p></li>\n * <li>{@code UTF-8}<p>\n * Eight-bit Unicode Transformation Format.</p></li>\n * <li>{@code UTF-16BE}<p>\n * Sixteen-bit Unicode Transformation Format, big-endian byte order.</p></li>\n * <li>{@code UTF-16LE}<p>\n * Sixteen-bit Unicode Transformation Format, little-endian byte order.</p></li>\n * <li>{@code UTF-16}<p>\n * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order\n * accepted on input, big-endian used on output.)</p></li>\n * </ul>\n *\n * This perhaps would best belong in the Commons Lang project. Even if a similar class is defined in Commons Lang, it is\n * not foreseen that Commons Codec would be made to depend on Commons Lang.\n *\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @see <a href=\"https://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n * @since 1.7\n ",
      "methods": {
        "toCharset": {
          "Javadoc": "* Returns a Charset for the named charset. If the name is null, return the default Charset.\n     *\n     * @param charset\n     *            The name of the requested charset, may be null.\n     * @return a Charset for the named charset\n     * @throws java.nio.charset.UnsupportedCharsetException\n     *             If the named charset is unavailable"
        }
      }
    },
    "org.apache.commons.codec.cli.Digest": {
      "Javadoc": "\n * A minimal command line to run digest over files, directories or a string.\n *\n * @see #main(String[])\n * @since 1.11\n ",
      "methods": {
        "main": {
          "Javadoc": "* Runs the digest algorithm in {@code args[0]} on the file in {@code args[1]}. If there is no {@code args[1]}, use\n     * standard input.\n     *\n     * <p>\n     * The algorithm can also be {@code ALL} or {@code *} to output one line for each known algorithm.\n     * </p>\n     *\n     * @param args\n     *            {@code args[0]} is one of {@link MessageDigestAlgorithms} name,\n     *            {@link MessageDigest} name, {@code ALL}, or {@code *}.\n     *            {@code args[1+]} is a FILE/DIRECTORY/String.\n     * @throws IOException if an error occurs"
        }
      }
    },
    "org.apache.commons.codec.Decoder": {
      "Javadoc": "\n * Provides the highest level of abstraction for Decoders.\n * <p>\n * This is the sister interface of {@link Encoder}. All Decoders implement this common generic interface.\n * Allows a user to pass a generic Object to any Decoder implementation in the codec package.\n * </p>\n * <p>\n * One of the two interfaces at the center of the codec package.\n * </p>\n ",
      "methods": {
        "decode": {
          "Javadoc": "* Decodes an \"encoded\" Object and returns a \"decoded\" Object. Note that the implementation of this interface will\n     * try to cast the Object parameter to the specific type expected by a particular Decoder implementation. If a\n     * {@link ClassCastException} occurs this decode method will throw a DecoderException.\n     *\n     * @param source\n     *            the object to decode\n     * @return a 'decoded\" object\n     * @throws DecoderException\n     *             a decoder exception can be thrown for any number of reasons. Some good candidates are that the\n     *             parameter passed to this method is null, a param cannot be cast to the appropriate type for a\n     *             specific encoder."
        }
      }
    },
    "org.apache.commons.codec.DecoderException": {
      "Javadoc": "\n * Thrown when there is a failure condition during the decoding process. This exception is thrown when a {@link Decoder}\n * encounters a decoding specific exception such as invalid data, or characters outside of the expected range.\n "
    },
    "org.apache.commons.codec.digest.B64": {
      "Javadoc": "\n * Base64-like method to convert binary bytes into ASCII chars.\n * <p>\n * TODO: Can Base64 be reused?\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n ",
      "methods": {
        "b64from24bit": {
          "Javadoc": "* Base64 like conversion of bytes to ASCII chars.\n     *\n     * @param b2\n     *            A byte from the result.\n     * @param b1\n     *            A byte from the result.\n     * @param b0\n     *            A byte from the result.\n     * @param outLen\n     *            The number of expected output chars.\n     * @param buffer\n     *            Where the output chars is appended to."
        },
        "getRandomSalt": {
          "Javadoc": "* Generates a string of random chars from the B64T set.\n     * <p>\n     * The salt is generated with the {@link Random} provided.\n     * </p>\n     *\n     * @param num Number of chars to generate.\n     * @param random an instance of {@link Random}.\n     * @return a random salt {@link String}."
        }
      }
    },
    "org.apache.commons.codec.digest.Blake3": {
      "Javadoc": "\n * Implements the Blake3 algorithm providing a {@linkplain #initHash() hash function} with extensible output (XOF), a\n * {@linkplain #initKeyedHash(byte[]) keyed hash function} (MAC, PRF), and a\n * {@linkplain #initKeyDerivationFunction(byte[]) key derivation function} (KDF). Blake3 has a 128-bit security level\n * and a default output length of 256 bits (32 bytes) which can extended up to 2<sup>64</sup> bytes.\n * <h2>Hashing</h2>\n * <p>Hash mode calculates the same output hash given the same input bytes and can be used as both a message digest and\n * and extensible output function.</p>\n * <pre>{@code\n *      Blake3 hasher = Blake3.initHash();\n *      hasher.update(\"Hello, world!\".getBytes(StandardCharsets.UTF_8));\n *      byte[] hash = new byte[32];\n *      hasher.doFinalize(hash);\n * }</pre>\n * <h2>Keyed Hashing</h2>\n * <p>Keyed hashes take a 32-byte secret key and calculates a message authentication code on some input bytes. These\n * also work as pseudo-random functions (PRFs) with extensible output similar to the extensible hash output. Note that\n * Blake3 keyed hashes have the same performance as plain hashes; the key is used in initialization in place of a\n * standard initialization vector used for plain hashing.</p>\n * <pre>{@code\n *      SecureRandom random = SecureRandom.getInstanceStrong();\n *      byte[] key = new byte[32];\n *      random.nextBytes(key);\n *      Blake3 hasher = Blake3.initKeyedHash(key);\n *      hasher.update(\"Hello, Alice!\".getBytes(StandardCharsets.UTF_8));\n *      byte[] mac = new byte[32];\n *      hasher.doFinalize(mac);\n * }</pre>\n * <h2>Key Derivation</h2>\n * <p>A specific hash mode for deriving session keys and other derived keys in a unique key derivation context\n * identified by some sequence of bytes. These context strings should be unique but do not need to be kept secret.\n * Additional input data is hashed for key material which can be finalized to derive subkeys.</p>\n * <pre>{@code\n *      String context = \"org.apache.commons.codec.digest.Blake3Example\";\n *      byte[] sharedSecret = ...;\n *      byte[] senderId = ...;\n *      byte[] recipientId = ...;\n *      Blake3 kdf = Blake3.initKeyDerivationFunction(context.getBytes(StandardCharsets.UTF_8));\n *      kdf.update(sharedSecret);\n *      kdf.update(senderId);\n *      kdf.update(recipientId);\n *      byte[] txKey = new byte[32];\n *      byte[] rxKey = new byte[32];\n *      kdf.doFinalize(txKey);\n *      kdf.doFinalize(rxKey);\n * }</pre>\n * <p>\n * Adapted from the ISC-licensed O(1) Cryptography library by Matt Sicker and ported from the reference public domain\n * implementation by Jack O'Connor.\n * </p>\n *\n * @see <a href=\"https://github.com/BLAKE3-team/BLAKE3\">BLAKE3 hash function</a>\n * @since 1.16\n ",
      "methods": {
        "g": {
          "Javadoc": "* The mixing function, G, which mixes either a column or a diagonal."
        },
        "hash": {
          "Javadoc": "* Calculates the Blake3 hash of the provided data.\n     *\n     * @param data source array to absorb data from\n     * @return 32-byte hash squeezed from the provided data\n     * @throws NullPointerException if data is null"
        },
        "initHash": {
          "Javadoc": "* Constructs a fresh Blake3 hash function. The instance returned functions as an arbitrary length message digest.\n     *\n     * @return fresh Blake3 instance in hashed mode"
        },
        "initKeyDerivationFunction": {
          "Javadoc": "* Constructs a fresh Blake3 key derivation function using the provided key derivation context byte string.\n     * The instance returned functions as a key-derivation function which can further absorb additional context data\n     * before squeezing derived key data.\n     *\n     * @param kdfContext a globally unique key-derivation context byte string to separate key derivation contexts from each other\n     * @return fresh Blake3 instance in key derivation mode\n     * @throws NullPointerException if kdfContext is null"
        },
        "initKeyedHash": {
          "Javadoc": "* Constructs a fresh Blake3 keyed hash function. The instance returned functions as a pseudorandom function (PRF) or as a\n     * message authentication code (MAC).\n     *\n     * @param key 32-byte secret key\n     * @return fresh Blake3 instance in keyed mode using the provided key\n     * @throws NullPointerException     if key is null\n     * @throws IllegalArgumentException if key is not 32 bytes"
        },
        "keyedHash": {
          "Javadoc": "* Calculates the Blake3 keyed hash (MAC) of the provided data.\n     *\n     * @param key  32-byte secret key\n     * @param data source array to absorb data from\n     * @return 32-byte mac squeezed from the provided data\n     * @throws NullPointerException if key or data are null"
        },
        "doFinalize": {
          "Javadoc": "* Squeezes and returns an arbitrary number of bytes dependent on the sequence of previously absorbed and squeezed bytes.\n     *\n     * @param nrBytes number of bytes to finalize\n     * @return requested number of finalized bytes\n     * @throws IllegalArgumentException if nrBytes is negative"
        },
        "reset": {
          "Javadoc": "* Resets this instance back to its initial state when it was first constructed.\n     * @return this"
        },
        "update": {
          "Javadoc": "* Updates this hash state using the provided bytes at an offset.\n     *\n     * @param in     source array to update data from\n     * @param offset where in the array to begin reading bytes\n     * @param length number of bytes to update\n     * @return this\n     * @throws NullPointerException      if in is null\n     * @throws IndexOutOfBoundsException if offset or length are negative or if offset + length is greater than the\n     *                                   length of the provided array"
        }
      }
    },
    "org.apache.commons.codec.digest.ChunkState": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.digest.EngineState": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.digest.Output": {
      "Javadoc": "\n     * Represents the state just prior to either producing an eight word chaining value or any number of output bytes\n     * when the ROOT flag is set.\n     "
    },
    "org.apache.commons.codec.digest.Crypt": {
      "Javadoc": "\n * GNU libc crypt(3) compatible hash method.\n * <p>\n * See {@link #crypt(String, String)} for further details.\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @since 1.7\n ",
      "methods": {
        "crypt": {
          "Javadoc": "* Encrypts a password in a crypt(3) compatible way.\n     * <p>\n     * The exact algorithm depends on the format of the salt string:\n     * </p>\n     * <ul>\n     * <li>SHA-512 salts start with {@code $6$} and are up to 16 chars long.\n     * <li>SHA-256 salts start with {@code $5$} and are up to 16 chars long\n     * <li>MD5 salts start with {@code $1$} and are up to 8 chars long\n     * <li>DES, the traditional UnixCrypt algorithm is used with only 2 chars\n     * <li>Only the first 8 chars of the passwords are used in the DES algorithm!\n     * </ul>\n     * <p>\n     * The magic strings {@code \"$apr1$\"} and {@code \"$2a$\"} are not recognized by this method as its output should be\n     * identical with that of the libc implementation.\n     * </p>\n     * <p>\n     * The rest of the salt string is drawn from the set {@code [a-zA-Z0-9./]} and is cut at the maximum length of if a\n     * {@code \"$\"} sign is encountered. It is therefore valid to enter a complete hash value as salt to e.g. verify a\n     * password with:\n     * </p>\n     * <pre>\n     * storedPwd.equals(crypt(enteredPwd, storedPwd))\n     * </pre>\n     * <p>\n     * The resulting string starts with the marker string ({@code $n$}), where n is the same as the input salt.\n     * The salt is then appended, followed by a {@code \"$\"} sign.\n     * This is followed by the actual hash value.\n     * For DES the string only contains the salt and actual hash.\n     * The total length is dependent on the algorithm used:\n     * </p>\n     * <ul>\n     * <li>SHA-512: 106 chars\n     * <li>SHA-256: 63 chars\n     * <li>MD5: 34 chars\n     * <li>DES: 13 chars\n     * </ul>\n     * <p>\n     * Example:\n     * </p>\n     * <pre>\n     *      crypt(\"secret\", \"$1$xxxx\") =&gt; \"$1$xxxx$aMkevjfEIpa35Bh3G4bAc.\"\n     *      crypt(\"secret\", \"xx\") =&gt; \"xxWAum7tHdIUw\"\n     * </pre>\n     * <p>\n     * This method comes in a variation that accepts a byte[] array to support input strings that are not encoded in\n     * UTF-8 but e.g. in ISO-8859-1 where equal characters result in different byte values.\n     * </p>\n     *\n     * @see \"The man page of the libc crypt (3) function.\"\n     * @param key\n     *            plaintext password as entered by the used\n     * @param salt\n     *            real salt value without prefix or \"rounds=\". The salt may be null, in which case a\n     *            salt is generated for you using {@link SecureRandom}\n     * @return hash value, i.e. encrypted password including the salt string\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught. *"
        }
      }
    },
    "org.apache.commons.codec.digest.DigestUtils": {
      "Javadoc": "\n * Operations to simplify common {@link java.security.MessageDigest} tasks. This class is immutable and thread-safe. However the MessageDigest instances it\n * creates generally won't be.\n * <p>\n * The {@link MessageDigestAlgorithms} class provides constants for standard digest algorithms that can be used with the {@link #getDigest(String)} method and\n * other methods that require the Digest algorithm name.\n * </p>\n * <p>\n * Note: the class has shorthand methods for all the algorithms present as standard in Java 6. This approach requires lots of methods for each algorithm, and\n * quickly becomes unwieldy. The following code works with all algorithms:\n * </p>\n *\n * <pre>\n * import static org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_224;\n * ...\n * byte [] digest = new DigestUtils(SHA_224).digest(dataToDigest);\n * String hdigest = new DigestUtils(SHA_224).digestAsHex(new File(\"pom.xml\"));\n * </pre>\n *\n * @see MessageDigestAlgorithms\n ",
      "methods": {
        "digest": {
          "Javadoc": "* Reads through a byte array and returns the digest for the data.\n     *\n     * @param data Data to digest treated as UTF-8 string\n     * @return the digest\n     * @since 1.11"
        },
        "getDigest": {
          "Javadoc": "* Gets a {@code MessageDigest} for the given {@code algorithm} or a default if there is a problem getting the algorithm.\n     *\n     * @param algorithm            the name of the algorithm requested. See\n     *                             <a href=\"https://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\" > Appendix A in the Java\n     *                             Cryptography Architecture Reference Guide</a> for information about standard algorithm names.\n     * @param defaultMessageDigest The default MessageDigest.\n     * @return A digest instance.\n     * @see MessageDigest#getInstance(String)\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught.\n     * @since 1.11"
        },
        "getMd2Digest": {
          "Javadoc": "* Gets an MD2 MessageDigest.\n     *\n     * @return An MD2 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD2 is a built-in algorithm\n     * @see MessageDigestAlgorithms#MD2\n     * @since 1.7"
        },
        "getMd5Digest": {
          "Javadoc": "* Gets an MD5 MessageDigest.\n     *\n     * @return An MD5 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because MD5 is a built-in algorithm\n     * @see MessageDigestAlgorithms#MD5"
        },
        "getMessageDigest": {
          "Javadoc": "* Returns the message digest instance.\n     *\n     * @return the message digest instance\n     * @since 1.11"
        },
        "getSha1Digest": {
          "Javadoc": "* Gets an SHA-1 digest.\n     *\n     * @return An SHA-1 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-1 is a built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_1\n     * @since 1.7"
        },
        "getSha256Digest": {
          "Javadoc": "* Gets an SHA-256 digest.\n     *\n     * @return An SHA-256 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-256 is a built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_256"
        },
        "getSha3_224Digest": {
          "Javadoc": "* Gets an SHA3-224 digest.\n     *\n     * @return An SHA3-224 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should not happen on Oracle Java 9 and greater.\n     * @see MessageDigestAlgorithms#SHA3_224\n     * @since 1.12"
        },
        "getSha3_256Digest": {
          "Javadoc": "* Returns an SHA3-256 digest.\n     *\n     * @return An SHA3-256 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should not happen on Oracle Java 9 and greater.\n     * @see MessageDigestAlgorithms#SHA3_256\n     * @since 1.12"
        },
        "getSha3_384Digest": {
          "Javadoc": "* Gets an SHA3-384 digest.\n     *\n     * @return An SHA3-384 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should not happen on Oracle Java 9 and greater.\n     * @see MessageDigestAlgorithms#SHA3_384\n     * @since 1.12"
        },
        "getSha3_512Digest": {
          "Javadoc": "* Gets an SHA3-512 digest.\n     *\n     * @return An SHA3-512 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should not happen on Oracle Java 9 and greater.\n     * @see MessageDigestAlgorithms#SHA3_512\n     * @since 1.12"
        },
        "getSha384Digest": {
          "Javadoc": "* Gets an SHA-384 digest.\n     *\n     * @return An SHA-384 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-384 is a built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_384"
        },
        "getSha512_224Digest": {
          "Javadoc": "* Gets an SHA-512/224 digest.\n     *\n     * @return An SHA-512/224 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught.\n     * @see MessageDigestAlgorithms#SHA_512_224"
        },
        "getSha512_256Digest": {
          "Javadoc": "* Gets an SHA-512/256 digest.\n     *\n     * @return An SHA-512/256 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught.\n     * @see MessageDigestAlgorithms#SHA_512_224"
        },
        "getSha512Digest": {
          "Javadoc": "* Gets an SHA-512 digest.\n     *\n     * @return An SHA-512 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught, which should never happen because SHA-512 is a built-in algorithm\n     * @see MessageDigestAlgorithms#SHA_512"
        },
        "getShaDigest": {
          "Javadoc": "* Gets an SHA-1 digest.\n     *\n     * @return An SHA-1 digest instance.\n     * @throws IllegalArgumentException when a {@link NoSuchAlgorithmException} is caught\n     * @deprecated (1.11) Use {@link #getSha1Digest()}"
        },
        "isAvailable": {
          "Javadoc": "* Test whether the algorithm is supported.\n     *\n     * @param messageDigestAlgorithm the algorithm name\n     * @return {@code true} if the algorithm can be found\n     * @since 1.11"
        },
        "md2": {
          "Javadoc": "* Calculates the MD2 digest and returns the value as a 16 element {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return MD2 digest\n     * @since 1.7"
        },
        "md2Hex": {
          "Javadoc": "* Calculates the MD2 digest and returns the value as a 32 character hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return MD2 digest as a hexadecimal string\n     * @since 1.7"
        },
        "md5": {
          "Javadoc": "* Calculates the MD5 digest and returns the value as a 16 element {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return MD5 digest"
        },
        "md5Hex": {
          "Javadoc": "* Calculates the MD5 digest and returns the value as a 32 character hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return MD5 digest as a hexadecimal string"
        },
        "sha": {
          "Javadoc": "* Calculates the SHA-1 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest\n     * @return SHA-1 digest\n     * @deprecated (1.11) Use {@link #sha1(String)}"
        },
        "sha1": {
          "Javadoc": "* Calculates the SHA-1 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-1 digest"
        },
        "sha1Hex": {
          "Javadoc": "* Calculates the SHA-1 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-1 digest as a hexadecimal string\n     * @since 1.7"
        },
        "sha256": {
          "Javadoc": "* Calculates the SHA-256 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-256 digest\n     * @since 1.4"
        },
        "sha256Hex": {
          "Javadoc": "* Calculates the SHA-256 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-256 digest as a hexadecimal string\n     * @since 1.4"
        },
        "sha3_224": {
          "Javadoc": "* Calculates the SHA3-224 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA3-224 digest\n     * @since 1.12"
        },
        "sha3_224Hex": {
          "Javadoc": "* Calculates the SHA3-224 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-224 digest as a hexadecimal string\n     * @since 1.12"
        },
        "sha3_256": {
          "Javadoc": "* Calculates the SHA3-256 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA3-256 digest\n     * @since 1.12"
        },
        "sha3_256Hex": {
          "Javadoc": "* Calculates the SHA3-256 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-256 digest as a hexadecimal string\n     * @since 1.12"
        },
        "sha3_384": {
          "Javadoc": "* Calculates the SHA3-384 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA3-384 digest\n     * @since 1.12"
        },
        "sha3_384Hex": {
          "Javadoc": "* Calculates the SHA3-384 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-384 digest as a hexadecimal string\n     * @since 1.12"
        },
        "sha3_512": {
          "Javadoc": "* Calculates the SHA3-512 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA3-512 digest\n     * @since 1.12"
        },
        "sha3_512Hex": {
          "Javadoc": "* Calculates the SHA3-512 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA3-512 digest as a hexadecimal string\n     * @since 1.12"
        },
        "sha384": {
          "Javadoc": "* Calculates the SHA-384 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-384 digest\n     * @since 1.4"
        },
        "sha384Hex": {
          "Javadoc": "* Calculates the SHA-384 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-384 digest as a hexadecimal string\n     * @since 1.4"
        },
        "sha512": {
          "Javadoc": "* Calculates the SHA-512 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-512 digest\n     * @since 1.4"
        },
        "sha512_224": {
          "Javadoc": "* Calculates the SHA-512/224 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-512/224 digest\n     * @since 1.14"
        },
        "sha512_224Hex": {
          "Javadoc": "* Calculates the SHA-512/224 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-512/224 digest as a hexadecimal string\n     * @since 1.14"
        },
        "sha512_256": {
          "Javadoc": "* Calculates the SHA-512/256 digest and returns the value as a {@code byte[]}.\n     *\n     * @param data Data to digest; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return SHA-512/224 digest\n     * @since 1.14"
        },
        "sha512_256Hex": {
          "Javadoc": "* Calculates the SHA-512/256 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-512/256 digest as a hexadecimal string\n     * @since 1.14"
        },
        "sha512Hex": {
          "Javadoc": "* Calculates the SHA-512 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-512 digest as a hexadecimal string\n     * @since 1.4"
        },
        "shaHex": {
          "Javadoc": "* Calculates the SHA-1 digest and returns the value as a hexadecimal string.\n     *\n     * @param data Data to digest\n     * @return SHA-1 digest as a hexadecimal string\n     * @deprecated (1.11) Use {@link #sha1Hex(String)}"
        },
        "updateDigest": {
          "Javadoc": "* Updates the given {@link MessageDigest} from a String (converted to bytes using UTF-8).\n     * <p>\n     * To update the digest using a different charset for the conversion, convert the String to a byte array using\n     * {@link String#getBytes(java.nio.charset.Charset)} and pass that to the {@link DigestUtils#updateDigest(MessageDigest, byte[])} method\n     *\n     * @param messageDigest the {@link MessageDigest} to update\n     * @param valueToDigest the value to update the {@link MessageDigest} with; converted to bytes using {@link StringUtils#getBytesUtf8(String)}\n     * @return the updated {@link MessageDigest}\n     * @since 1.7"
        },
        "digestAsHex": {
          "Javadoc": "* Reads through a byte array and returns the digest for the data.\n     *\n     * @param data Data to digest treated as UTF-8 string\n     * @return the digest as a hexadecimal string\n     * @since 1.11"
        }
      }
    },
    "org.apache.commons.codec.digest.HmacUtils": {
      "Javadoc": "\n * Simplifies common {@link javax.crypto.Mac} tasks. This class is immutable and thread-safe.\n * However the Mac may not be.\n * <p>\n * <strong>Note: Not all JCE implementations support all algorithms. If not supported, an IllegalArgumentException is\n * thrown.</strong>\n * </p>\n * <p>\n * Sample usage:\n * </p>\n * <pre>\n * import static HmacAlgorithms.*;\n * byte[] key = {1,2,3,4}; // don't use this actual key!\n * String valueToDigest = \"The quick brown fox jumps over the lazy dog\";\n * byte[] hmac = new HmacUtils(HMAC_SHA_224, key).hmac(valueToDigest);\n * // Mac re-use\n * HmacUtils hm1 = new HmacUtils(\"HmacAlgoName\", key); // use a valid name here!\n * String hexPom = hm1.hmacHex(new File(\"pom.xml\"));\n * String hexNot = hm1.hmacHex(new File(\"NOTICE.txt\"));\n * </pre>\n * @since 1.10\n ",
      "methods": {
        "getHmacMd5": {
          "Javadoc": "* Returns an initialized {@code Mac} for the HmacMD5 algorithm.\n     * <p>\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_MD5, byte[])}"
        },
        "getHmacSha1": {
          "Javadoc": "* Returns an initialized {@code Mac} for the HmacSHA1 algorithm.\n     * <p>\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_1, byte[])}"
        },
        "getHmacSha256": {
          "Javadoc": "* Returns an initialized {@code Mac} for the HmacSHA256 algorithm.\n     * <p>\n     * Every implementation of the Java platform is required to support this standard Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_256, byte[])}"
        },
        "getHmacSha384": {
          "Javadoc": "* Returns an initialized {@code Mac} for the HmacSHA384 algorithm.\n     * <p>\n     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_384, byte[])}"
        },
        "getHmacSha512": {
          "Javadoc": "* Returns an initialized {@code Mac} for the HmacSHA512 algorithm.\n     * <p>\n     * Every implementation of the Java platform is <em>not</em> required to support this Mac algorithm.\n     * </p>\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code getInitializedMac(HmacAlgorithms.HMAC_SHA_512, byte[])}"
        },
        "getInitializedMac": {
          "Javadoc": "* Returns an initialized {@code Mac} for the given {@code algorithm}.\n     *\n     * @param algorithm\n     *            the name of the algorithm requested. See\n     *            <a href= \"https://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA\"\n     *            >Appendix A in the Java Cryptography Architecture Reference Guide</a> for information about standard\n     *            algorithm names.\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @return A Mac instance initialized with the given key.\n     * @see Mac#getInstance(String)\n     * @see Mac#init(Key)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid."
        },
        "hmacMd5": {
          "Javadoc": "* Returns a HmacMD5 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacMD5 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, String).hmac(String)}"
        },
        "hmacMd5Hex": {
          "Javadoc": "* Returns a HmacMD5 Message Authentication Code (MAC) as a hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacMD5 MAC for the given key and value as a hexadecimal string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_MD5, String).hmacHex(String)}"
        },
        "hmacSha1": {
          "Javadoc": "* Returns a HmacSHA1 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA1 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, String).hmac(String)}"
        },
        "hmacSha1Hex": {
          "Javadoc": "* Returns a HmacSHA1 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA1 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_1, String).hmacHex(String)}"
        },
        "hmacSha256": {
          "Javadoc": "* Returns a HmacSHA256 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA256 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, String).hmac(String)}"
        },
        "hmacSha256Hex": {
          "Javadoc": "* Returns a HmacSHA256 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA256 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_256, String).hmacHex(String)}"
        },
        "hmacSha384": {
          "Javadoc": "* Returns a HmacSHA384 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA384 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, String).hmac(String)}"
        },
        "hmacSha384Hex": {
          "Javadoc": "* Returns a HmacSHA384 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA384 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_384, String).hmacHex(String)}"
        },
        "hmacSha512": {
          "Javadoc": "* Returns a HmacSHA512 Message Authentication Code (MAC) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA512 MAC for the given key and value\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, String).hmac(String)}"
        },
        "hmacSha512Hex": {
          "Javadoc": "* Returns a HmacSHA512 Message Authentication Code (MAC) as hexadecimal string (lowercase) for the given key and value.\n     *\n     * @param key\n     *            The key for the keyed digest (must not be null)\n     * @param valueToDigest\n     *            The value (data) which should to digest (maybe empty or null)\n     * @return HmacSHA512 MAC for the given key and value as hexadecimal string (lowercase)\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught or key is null or key is invalid.\n     * @deprecated (1.11) Use {@code new HmacUtils(HmacAlgorithms.HMAC_SHA_512, String).hmacHex(String)}"
        },
        "isAvailable": {
          "Javadoc": "* Returns whether this algorithm is available\n     *\n     * @param name the name to check\n     * @return whether this algorithm is available\n     * @since 1.11"
        },
        "updateHmac": {
          "Javadoc": "* Resets and then updates the given {@link Mac} with the value.\n     *\n     * @param mac\n     *            the initialized {@link Mac} to update\n     * @param valueToDigest\n     *            the value to update the {@link Mac} with (maybe null or empty)\n     * @return the updated {@link Mac}\n     * @throws IllegalStateException\n     *             if the Mac was not initialized"
        },
        "hmac": {
          "Javadoc": "* Returns the digest for the input data.\n     *\n     * @param valueToDigest the input to use, treated as UTF-8\n     * @return the digest as a byte[]\n     * @since 1.11"
        },
        "hmacHex": {
          "Javadoc": "* Returns the digest for the input data.\n     *\n     * @param valueToDigest the input to use, treated as UTF-8\n     * @return the digest as a hexadecimal String\n     * @since 1.11"
        }
      }
    },
    "org.apache.commons.codec.digest.Md5Crypt": {
      "Javadoc": "\n * The libc crypt() \"$1$\" and Apache \"$apr1$\" MD5-based hash algorithm.\n * <p>\n * Based on the public domain (\"beer-ware\") C implementation from Poul-Henning Kamp which was found at: <a\n * href=\"http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/libcrypt/crypt-md5.c?rev=1.1;content-type=text%2Fplain\">\n * crypt-md5.c @ freebsd.org</a>\n * </p>\n * <p>\n * Source:\n * </p>\n * <pre>\n * $FreeBSD: src/lib/libcrypt/crypt-md5.c,v 1.1 1999/01/21 13:50:09 brandon Exp $\n * </pre>\n * <p>\n * Conversion to Kotlin and from there to Java in 2012.\n * </p>\n * <p>\n * The C style comments are from the original C code, the ones with \"//\" from the port.\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @since 1.7\n ",
      "methods": {
        "apr1Crypt": {
          "Javadoc": "* Generates an Apache htpasswd compatible \"$apr1$\" MD5 based hash value.\n     * <p>\n     * The algorithm is identical to the crypt(3) \"$1$\" one but produces different outputs due to the different salt\n     * prefix.\n     * </p>\n     *\n     * @param keyBytes\n     *            plaintext string to hash. Each array element is set to {@code 0} before returning.\n     * @param salt\n     *            salt string including the prefix and optionally garbage at the end. The salt may be null, in which\n     *            case a salt is generated for you using {@link SecureRandom}.\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught."
        },
        "md5Crypt": {
          "Javadoc": "* Generates a libc6 crypt() \"$1$\" or Apache htpasswd \"$apr1$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} or {@link #apr1Crypt(String, String)} for details.\n     * </p>\n     *\n     * @param keyBytes\n     *            plaintext string to hash. Each array element is set to {@code 0} before returning.\n     * @param salt\n     *            real salt value without prefix or \"rounds=\". The salt may be null, in which case a salt\n     *            is generated for you using {@link SecureRandom}.\n     * @param prefix\n     *            salt prefix\n     * @param random\n     *            the instance of {@link Random} to use for generating the salt.\n     *            Consider using {@link SecureRandom} for more secure salts.\n     * @return the hash value\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     * @since 1.12"
        }
      }
    },
    "org.apache.commons.codec.digest.MessageDigestAlgorithms": {
      "Javadoc": "\n * Standard {@link MessageDigest} algorithm names from the <cite>Java Cryptography Architecture Standard Algorithm Name\n * Documentation</cite>.\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n * <ul>\n * <li>Java 8 and up: SHA-224.</li>\n * <li>Java 9 and up: SHA3-224, SHA3-256, SHA3-384, SHA3-512.</li>\n * </ul>\n *\n * @see <a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#MessageDigest\">\n *      Java 8 Cryptography Architecture Standard Algorithm Name Documentation</a>\n * @see <a href=\"https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#messagedigest-algorithms\">\n *      Java 11 Cryptography Architecture Standard Algorithm Name Documentation</a>\n * @see <a href=\"https://docs.oracle.com/en/java/javase/17/docs/specs/security/standard-names.html#messagedigest-algorithms\">\n *      Java 17 Cryptography Architecture Standard Algorithm Name Documentation</a>\n * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/specs/security/standard-names.html#messagedigest-algorithms\">\n *      Java 21 Cryptography Architecture Standard Algorithm Name Documentation</a>\n *\n * @see <a href=\"https://dx.doi.org/10.6028/NIST.FIPS.180-4\">FIPS PUB 180-4</a>\n * @see <a href=\"https://dx.doi.org/10.6028/NIST.FIPS.202\">FIPS PUB 202</a>\n * @since 1.7\n ",
      "methods": {
        "values": {
          "Javadoc": "* Gets all constant values defined in this class.\n     *\n     * @return all constant values defined in this class.\n     * @since 1.11"
        }
      }
    },
    "org.apache.commons.codec.digest.MurmurHash2": {
      "Javadoc": "\n * Implementation of the MurmurHash2 32-bit and 64-bit hash functions.\n *\n * <p>MurmurHash is a non-cryptographic hash function suitable for general\n * hash-based lookup. The name comes from two basic operations, multiply (MU)\n * and rotate (R), used in its inner loop. Unlike cryptographic hash functions,\n * it is not specifically designed to be difficult to reverse by an adversary,\n * making it unsuitable for cryptographic purposes.</p>\n *\n * <p>This contains a Java port of the 32-bit hash function {@code MurmurHash2}\n * and the 64-bit hash function {@code MurmurHash64A} from Austin Appleby's\n * original {@code c++} code in SMHasher.</p>\n *\n * <p>This is a re-implementation of the original C code plus some additional\n * features.</p>\n *\n * <p>This is public domain code with no copyrights. From home page of\n * <a href=\"https://github.com/aappleby/smhasher\">SMHasher</a>:</p>\n *\n * <blockquote>\n * \"All MurmurHash versions are public domain software, and the author\n * disclaims all copyright to their code.\"\n * </blockquote>\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/MurmurHash\">MurmurHash</a>\n * @see <a href=\"https://github.com/aappleby/smhasher/blob/master/src/MurmurHash2.cpp\">\n *   Original MurmurHash2 c++ code</a>\n * @since 1.13\n ",
      "methods": {
        "getLittleEndianInt": {
          "Javadoc": "* Gets the little-endian int from 4 bytes starting at the specified index.\n     *\n     * @param data The data\n     * @param index The index\n     * @return The little-endian int"
        },
        "getLittleEndianLong": {
          "Javadoc": "* Gets the little-endian long from 8 bytes starting at the specified index.\n     *\n     * @param data The data\n     * @param index The index\n     * @return The little-endian long"
        },
        "hash32": {
          "Javadoc": "* Generates a 32-bit hash from a substring with a default seed value.\n     * The string is converted to bytes using the default encoding.\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int seed = 0x9747b28c;\n     * byte[] bytes = text.substring(from, from + length).getBytes(StandardCharsets.UTF_8);\n     * int hash = MurmurHash2.hash32(bytes, bytes.length, seed);\n     * </pre>\n     *\n     * @param text The input string\n     * @param from The starting index\n     * @param length The length of the substring\n     * @return The 32-bit hash\n     * @see #hash32(byte[], int, int)"
        },
        "hash64": {
          "Javadoc": "* Generates a 64-bit hash from a substring with a default seed value.\n     * The string is converted to bytes using the default encoding.\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int seed = 0xe17a1465;\n     * byte[] bytes = text.substring(from, from + length).getBytes(StandardCharsets.UTF_8);\n     * int hash = MurmurHash2.hash64(bytes, bytes.length, seed);\n     * </pre>\n     *\n     * @param text The input string\n     * @param from The starting index\n     * @param length The length of the substring\n     * @return The 64-bit hash\n     * @see #hash64(byte[], int, int)"
        }
      }
    },
    "org.apache.commons.codec.digest.MurmurHash3": {
      "Javadoc": "\n * Implementation of the MurmurHash3 32-bit and 128-bit hash functions.\n *\n * <p>\n * MurmurHash is a non-cryptographic hash function suitable for general hash-based lookup. The name comes from two basic\n * operations, multiply (MU) and rotate (R), used in its inner loop. Unlike cryptographic hash functions, it is not\n * specifically designed to be difficult to reverse by an adversary, making it unsuitable for cryptographic purposes.\n * </p>\n *\n * <p>\n * This contains a Java port of the 32-bit hash function {@code MurmurHash3_x86_32} and the 128-bit hash function\n * {@code MurmurHash3_x64_128} from Austin Appleby's original {@code c++} code in SMHasher.\n * </p>\n *\n * <p>\n * This is public domain code with no copyrights. From home page of\n * <a href=\"https://github.com/aappleby/smhasher\">SMHasher</a>:\n * </p>\n *\n * <blockquote> \"All MurmurHash versions are public domain software, and the author disclaims all copyright to their\n * code.\" </blockquote>\n *\n * <p>\n * Original adaption from Apache Hive. That adaption contains a {@code hash64} method that is not part of the original\n * MurmurHash3 code. It is not recommended to use these methods. They will be removed in a future release. To obtain a\n * 64-bit hash use half of the bits from the {@code hash128x64} methods using the input data converted to bytes.\n * </p>\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/MurmurHash\">MurmurHash</a>\n * @see <a href=\"https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp\"> Original MurmurHash3 c++\n *      code</a>\n * @see <a href=\n *      \"https://github.com/apache/hive/blob/master/storage-api/src/java/org/apache/hive/common/util/Murmur3.java\">\n *      Apache Hive Murmer3</a>\n * @since 1.13\n ",
      "methods": {
        "fmix32": {
          "Javadoc": "* Performs the final avalanche mix step of the 32-bit hash function {@code MurmurHash3_x86_32}.\n     *\n     * @param hash The current hash\n     * @return The final hash"
        },
        "fmix64": {
          "Javadoc": "* Performs the final avalanche mix step of the 64-bit hash function {@code MurmurHash3_x64_128}.\n     *\n     * @param hash The current hash\n     * @return The final hash"
        },
        "getLittleEndianInt": {
          "Javadoc": "* Gets the little-endian int from 4 bytes starting at the specified index.\n     *\n     * @param data The data\n     * @param index The index\n     * @return The little-endian int"
        },
        "getLittleEndianLong": {
          "Javadoc": "* Gets the little-endian long from 8 bytes starting at the specified index.\n     *\n     * @param data The data\n     * @param index The index\n     * @return The little-endian long"
        },
        "hash128": {
          "Javadoc": "* Generates 128-bit hash from a string with a default seed.\n     * <p>\n     * Before 1.14 the string was converted using default encoding.\n     * Since 1.14 the string is converted to bytes using UTF-8 encoding.\n     * </p>\n     * <p>\n     * This is a helper method that will produce the same result as:\n     * </p>\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 104729;\n     * byte[] bytes = data.getBytes(StandardCharsets.UTF_8);\n     * int hash = MurmurHash3.hash128(bytes, offset, bytes.length, seed);\n     * </pre>\n     *\n     * <p>Note: The sign extension bug in {@link #hash128(byte[], int, int, int)} does not effect\n     * this result as the default seed is positive.</p>\n     *\n     * @param data The input String\n     * @return The 128-bit hash (2 longs)\n     * @see #hash128(byte[], int, int, int)\n     * @deprecated Use {@link #hash128x64(byte[])} using the bytes returned from\n     * {@link String#getBytes(java.nio.charset.Charset)}."
        },
        "hash128x64": {
          "Javadoc": "* Generates 128-bit hash from the byte array with the given offset, length and seed.\n     *\n     * <p>This is an implementation of the 128-bit hash function {@code MurmurHash3_x64_128}\n     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>\n     *\n     * @param data The input byte array\n     * @param offset The first element of array\n     * @param length The length of array\n     * @param seed The initial seed value\n     * @return The 128-bit hash (2 longs)\n     * @since 1.14"
        },
        "hash128x64Internal": {
          "Javadoc": "* Generates 128-bit hash from the byte array with the given offset, length and seed.\n     *\n     * <p>This is an implementation of the 128-bit hash function {@code MurmurHash3_x64_128}\n     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>\n     *\n     * @param data The input byte array\n     * @param offset The first element of array\n     * @param length The length of array\n     * @param seed The initial seed value\n     * @return The 128-bit hash (2 longs)"
        },
        "hash32": {
          "Javadoc": "* Generates 32-bit hash from a string with a default seed.\n     * <p>\n     * Before 1.14 the string was converted using default encoding.\n     * Since 1.14 the string is converted to bytes using UTF-8 encoding.\n     * </p>\n     * This is a helper method that will produce the same result as:\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 104729;\n     * byte[] bytes = data.getBytes(StandardCharsets.UTF_8);\n     * int hash = MurmurHash3.hash32(bytes, offset, bytes.length, seed);\n     * </pre>\n     *\n     * <p>This implementation contains a sign-extension bug in the finalization step of\n     * any bytes left over from dividing the length by 4. This manifests if any of these\n     * bytes are negative.</p>\n     *\n     * @param data The input string\n     * @return The 32-bit hash\n     * @see #hash32(byte[], int, int, int)\n     * @deprecated Use {@link #hash32x86(byte[], int, int, int)} with the bytes returned from\n     * {@link String#getBytes(java.nio.charset.Charset)}. This corrects the processing of trailing bytes."
        },
        "hash32x86": {
          "Javadoc": "* Generates 32-bit hash from the byte array with the given offset, length and seed.\n     *\n     * <p>This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}\n     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>\n     *\n     * @param data The input byte array\n     * @param offset The offset of data\n     * @param length The length of array\n     * @param seed The initial seed value\n     * @return The 32-bit hash\n     * @since 1.14"
        },
        "hash64": {
          "Javadoc": "* Generates 64-bit hash from a short with a default seed.\n     *\n     * <p><strong>This is not part of the original MurmurHash3 {@code c++} implementation.</strong></p>\n     *\n     * <p>This is a Murmur3-like 64-bit variant.\n     * The method does not produce the same result as either half of the hash bytes from\n     * {@linkplain #hash128x64(byte[])} with the same byte data from the {@code short}.\n     * This method will be removed in a future release.</p>\n     *\n     * <p>Note: The sign extension bug in {@link #hash64(byte[], int, int, int)} does not effect\n     * this result as the default seed is positive.</p>\n     *\n     * <p>This is a helper method that will produce the same result as:</p>\n     *\n     * <pre>\n     * int offset = 0;\n     * int seed = 104729;\n     * long hash = MurmurHash3.hash64(ByteBuffer.allocate(2)\n     *                                          .putShort(data)\n     *                                          .array(), offset, 2, seed);\n     * </pre>\n     *\n     * @param data The short to hash\n     * @return The 64-bit hash\n     * @see #hash64(byte[], int, int, int)\n     * @deprecated Not part of the MurmurHash3 implementation.\n     * Use half of the hash bytes from {@link #hash128x64(byte[])} with the bytes from the {@code short}."
        },
        "mix32": {
          "Javadoc": "* Performs the intermediate mix step of the 32-bit hash function {@code MurmurHash3_x86_32}.\n     *\n     * @param k The data to add to the hash\n     * @param hash The current hash\n     * @return The new hash"
        }
      }
    },
    "org.apache.commons.codec.digest.IncrementalHash32": {
      "Javadoc": "\n     * Generates 32-bit hash from input bytes. Bytes can be added incrementally and the new\n     * hash computed.\n     *\n     * <p>This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}\n     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>\n     *\n     * <p>This implementation contains a sign-extension bug in the finalization step of\n     * any bytes left over from dividing the length by 4. This manifests if any of these\n     * bytes are negative.</p>\n     *\n     * @deprecated Use IncrementalHash32x86. This corrects the processing of trailing bytes.\n     ",
      "methods": {
        "finalise": {
          "Javadoc": "* {@inheritDoc}\n         *\n         * <p>This implementation contains a sign-extension bug in the finalization step of\n         * any bytes left over from dividing the length by 4. This manifests if any of these\n         * bytes are negative.<p>\n         *\n         * @deprecated Use IncrementalHash32x86. This corrects the processing of trailing bytes."
        }
      }
    },
    "org.apache.commons.codec.digest.IncrementalHash32x86": {
      "Javadoc": "\n     * Generates 32-bit hash from input bytes. Bytes can be added incrementally and the new\n     * hash computed.\n     *\n     * <p>This is an implementation of the 32-bit hash function {@code MurmurHash3_x86_32}\n     * from Austin Appleby's original MurmurHash3 {@code c++} code in SMHasher.</p>\n     *\n     * @since 1.14\n     ",
      "methods": {
        "orBytes": {
          "Javadoc": "* Combines the bytes using an Or operation ({@code | } in a little-endian representation\n         * of a 32-bit integer; byte 1 will be the least significant byte, byte 4 the most\n         * significant.\n         *\n         * @param b1 The first byte\n         * @param b2 The second byte\n         * @param b3 The third byte\n         * @param b4 The fourth byte\n         * @return The 32-bit integer"
        },
        "add": {
          "Javadoc": "* Adds the byte array to the current incremental hash.\n         *\n         * @param data The input byte array\n         * @param offset The offset of data\n         * @param length The length of array"
        },
        "end": {
          "Javadoc": "* Generates the 32-bit hash value. Repeat calls to this method with no additional data\n         * will generate the same hash value.\n         *\n         * @return The 32-bit hash"
        },
        "finalise": {
          "Javadoc": "* Finalizes the running hash to the output 32-bit hash by processing remaining bytes\n         * and performing final mixing.\n         *\n         * @param hash The running hash\n         * @param unprocessedLength The number of unprocessed bytes in the tail data.\n         * @param unprocessed Up to 3 unprocessed bytes from input data.\n         * @param totalLen The total number of input bytes added since the start.\n         * @return The 32-bit hash"
        },
        "start": {
          "Javadoc": "* Starts a new incremental hash.\n         *\n         * @param seed The initial seed value"
        }
      }
    },
    "org.apache.commons.codec.digest.PureJavaCrc32": {
      "Javadoc": "\n * A pure-Java implementation of the CRC32 checksum that uses\n * the same polynomial as the built-in native CRC32.\n * <p>\n * This is to avoid the JNI overhead for certain uses of checksumming\n * where many small pieces of data are checksummed in succession.\n * </p>\n * <p>\n * The current version is ~10x to 1.8x as fast as Sun's native\n * java.util.zip.CRC32 in Java 1.6\n * </p>\n * <p>\n * Copied from Apache Hadoop 2.6.3.\n * The code agrees with the following file in the 2.6.3 tag:\n * https://gitbox.apache.org/repos/asf?p=hadoop.git;a=blob_plain;\n * f=hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/PureJavaCrc32.java;\n * hb=2120de588b92b9f22b1cc4188761d6a8c61aa778\n * </p>\n * <p>\n * This class is Not ThreadSafe\n * </p>\n *\n * @see java.util.zip.CRC32\n * @since 1.11\n "
    },
    "org.apache.commons.codec.digest.PureJavaCrc32C": {
      "Javadoc": "\n * A pure-Java implementation of the CRC32 checksum that uses the CRC32-C polynomial, the same polynomial used by iSCSI and implemented on many Intel chipsets\n * supporting SSE 4.2.\n *\n * <p>\n * Copied from Apache Hadoop 2.3.6: https://gitbox.apache.org/repos/asf?p=hadoop.git;a=blob_plain;\n * f=hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/PureJavaCrc32C.java; hb=2120de588b92b9f22b1cc4188761d6a8c61aa778\n * </p>\n * <p>\n * This class is Not ThreadSafe\n * </p>\n *\n * @since 1.11\n "
    },
    "org.apache.commons.codec.digest.Sha2Crypt": {
      "Javadoc": "\n * SHA2-based UNIX crypt implementation.\n * <p>\n * Based on the C implementation released into the Public Domain by Ulrich Drepper &lt;drepper@redhat.com&gt;\n * http://www.akkadia.org/drepper/SHA-crypt.txt\n * </p>\n * <p>\n * Conversion to Kotlin and from there to Java in 2012 by Christian Hammers &lt;ch@lathspell.de&gt; and likewise put\n * into the Public Domain.\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @since 1.7\n ",
      "methods": {
        "sha256Crypt": {
          "Javadoc": "* Generates a libc6 crypt() compatible \"$5$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     * </p>\n     * @param keyBytes\n     *            plaintext to hash. Each array element is set to {@code 0} before returning.\n     * @param salt\n     *            real salt value without prefix or \"rounds=\".\n     * @param random\n     *            the instance of {@link Random} to use for generating the salt.\n     *            Consider using {@link SecureRandom} for more secure salts.\n     * @return complete hash value including salt\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     * @since 1.12"
        },
        "sha2Crypt": {
          "Javadoc": "* Generates a libc6 crypt() compatible \"$5$\" or \"$6$\" SHA2 based hash value.\n     * <p>\n     * This is a nearly line by line conversion of the original C function. The numbered comments are from the algorithm\n     * description, the short C-style ones from the original C code and the ones with \"Remark\" from me.\n     * </p>\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     * </p>\n     *\n     * @param keyBytes\n     *            plaintext to hash. Each array element is set to {@code 0} before returning.\n     * @param salt\n     *            real salt value without prefix or \"rounds=\"; may not be null\n     * @param saltPrefix\n     *            either $5$ or $6$\n     * @param blocksize\n     *            a value that differs between $5$ and $6$\n     * @param algorithm\n     *            {@link MessageDigest} algorithm identifier string\n     * @return complete hash value including prefix and salt\n     * @throws IllegalArgumentException\n     *             if the given salt is {@code null} or does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link NoSuchAlgorithmException} is caught\n     * @see MessageDigestAlgorithms"
        },
        "sha512Crypt": {
          "Javadoc": "* Generates a libc6 crypt() compatible \"$6$\" hash value.\n     * <p>\n     * See {@link Crypt#crypt(String, String)} for details.\n     * </p>\n     * @param keyBytes\n     *            plaintext to hash. Each array element is set to {@code 0} before returning.\n     * @param salt\n     *            real salt value without prefix or \"rounds=\". The salt may be null, in which case a salt\n     *            is generated for you using {@link SecureRandom}.\n     * @param random\n     *            the instance of {@link Random} to use for generating the salt.\n     *            Consider using {@link SecureRandom} for more secure salts.\n     * @return complete hash value including salt\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern\n     * @throws IllegalArgumentException\n     *             when a {@link java.security.NoSuchAlgorithmException} is caught.\n     * @since 1.12"
        }
      }
    },
    "org.apache.commons.codec.digest.UnixCrypt": {
      "Javadoc": "\n * UNIX crypt(3) algorithm implementation.\n * <p>\n * This class only implements the traditional 56 bit DES based algorithm. Please use DigestUtils.crypt() for a method\n * that distinguishes between all the algorithms supported in the current glibc's crypt().\n * </p>\n * <p>\n * The Java implementation was taken from the JetSpeed Portal project (see\n * org.apache.jetspeed.services.security.ldap.UnixCrypt).\n * </p>\n * <p>\n * This class is slightly incompatible if the given salt contains characters that are not part of the allowed range\n * [a-zA-Z0-9./].\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @since 1.7\n ",
      "methods": {
        "crypt": {
          "Javadoc": "* Generates a crypt(3) compatible hash using the DES algorithm.\n     *\n     * @param original\n     *            plaintext password\n     * @param salt\n     *            a two character string drawn from [a-zA-Z0-9./]. The salt may be null, in which case a salt is\n     *            generated for you using {@link SecureRandom}.\n     * @return a 13 character string starting with the salt string\n     * @throws IllegalArgumentException\n     *             if the salt does not match the allowed pattern"
        }
      }
    },
    "org.apache.commons.codec.digest.XXHash32": {
      "Javadoc": "\n * Implementation of the xxHash32 hash algorithm.\n *\n * <p>\n * Copied from Commons Compress 1.14 <a href=\n * \"https://gitbox.apache.org/repos/asf?p=commons-compress.git;a=blob;f=src/main/java/org/apache/commons/compress/compressors/lz4/XXHash32.java;h=a406ffc197449be594d46f0d2712b2d4786a1e68;hb=HEAD\">https://gitbox.apache.org/repos/asf?p=commons-compress.git;a=blob;f=src/main/java/org/apache/commons/compress/compressors/lz4/XXHash32.java;h=a406ffc197449be594d46f0d2712b2d4786a1e68;hb=HEAD</a>\n * </p>\n * <p>\n * NotThreadSafe\n * </p>\n *\n * @see <a href=\"https://cyan4973.github.io/xxHash/\">xxHash</a>\n * @since 1.11\n ",
      "methods": {
        "getInt": {
          "Javadoc": "* Gets the little-endian int from 4 bytes starting at the specified index.\n     *\n     * @param buffer The data\n     * @param idx The index\n     * @return The little-endian int"
        }
      }
    },
    "org.apache.commons.codec.Encoder": {
      "Javadoc": "\n * Provides the highest level of abstraction for Encoders.\n * <p>\n * This is the sister interface of {@link Decoder}.  Every implementation of Encoder provides this\n * common generic interface which allows a user to pass a generic Object to any Encoder implementation\n * in the codec package.\n * </p>\n ",
      "methods": {
        "encode": {
          "Javadoc": "* Encodes an \"Object\" and returns the encoded content as an Object. The Objects here may just be\n     * {@code byte[]} or {@code String}s depending on the implementation used.\n     *\n     * @param source\n     *            An object to encode\n     * @return An \"encoded\" Object\n     * @throws EncoderException\n     *             An encoder exception is thrown if the encoder experiences a failure condition during the encoding\n     *             process."
        }
      }
    },
    "org.apache.commons.codec.EncoderException": {
      "Javadoc": "\n * Thrown when there is a failure condition during the encoding process. This exception is thrown when an\n * {@link Encoder} encounters an encoding specific exception such as invalid data, inability to calculate a checksum,\n * characters outside of the expected range.\n "
    },
    "org.apache.commons.codec.language.AbstractCaverphone": {
      "Javadoc": "\n * Encodes a string into a Caverphone value.\n *\n * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0\n * algorithm:\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Caverphone\">Wikipedia - Caverphone</a>\n * @since 1.5\n ",
      "methods": {
        "encode": {
          "Javadoc": "* Encodes an Object using the caverphone algorithm. This method is provided in order to satisfy the requirements of\n     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type {@link String}.\n     *\n     * @param source\n     *            Object to encode\n     * @return An object (or type {@link String}) containing the caverphone code which corresponds to the String\n     *         supplied.\n     * @throws EncoderException\n     *             if the parameter supplied is not of type {@link String}."
        },
        "isEncodeEqual": {
          "Javadoc": "* Tests if the encodings of two strings are equal.\n     *\n     * This method might be promoted to a new AbstractStringEncoder superclass.\n     *\n     * @param str1\n     *            First of two strings to compare\n     * @param str2\n     *            Second of two strings to compare\n     * @return {@code true} if the encodings of these strings are identical, {@code false} otherwise.\n     * @throws EncoderException\n     *             thrown if there is an error condition during the encoding process."
        }
      }
    },
    "org.apache.commons.codec.language.bm.BeiderMorseEncoder": {
      "Javadoc": "\n * Encodes strings into their Beider-Morse phonetic encoding.\n * <p>\n * Beider-Morse phonetic encodings are optimized for family names. However, they may be useful for a wide range of\n * words.\n * </p>\n * <p>\n * This encoder is intentionally mutable to allow dynamic configuration through bean properties. As such, it is mutable,\n * and may not be thread-safe. If you require a guaranteed thread-safe encoding then use {@link PhoneticEngine}\n * directly.\n * </p>\n * <h2>Encoding overview</h2>\n * <p>\n * Beider-Morse phonetic encodings is a multi-step process. Firstly, a table of rules is consulted to guess what\n * language the word comes from. For example, if it ends in \"{@code ault}\" then it infers that the word is French.\n * Next, the word is translated into a phonetic representation using a language-specific phonetics table. Some runs of\n * letters can be pronounced in multiple ways, and a single run of letters may be potentially broken up into phonemes at\n * different places, so this stage results in a set of possible language-specific phonetic representations. Lastly, this\n * language-specific phonetic representation is processed by a table of rules that re-writes it phonetically taking into\n * account systematic pronunciation differences between languages, to move it towards a pan-indo-european phonetic\n * representation. Again, sometimes there are multiple ways this could be done and sometimes things that can be\n * pronounced in several ways in the source language have only one way to represent them in this average phonetic\n * language, so the result is again a set of phonetic spellings.\n * </p>\n * <p>\n * Some names are treated as having multiple parts. This can be due to two things. Firstly, they may be hyphenated. In\n * this case, each individual hyphenated word is encoded, and then these are combined end-to-end for the final encoding.\n * Secondly, some names have standard prefixes, for example, \"{@code Mac/Mc}\" in Scottish (English) names. As\n * sometimes it is ambiguous whether the prefix is intended or is an accident of the spelling, the word is encoded once\n * with the prefix and once without it. The resulting encoding contains one and then the other result.\n * </p>\n * <h2>Encoding format</h2>\n * <p>\n * Individual phonetic spellings of an input word are represented in upper- and lower-case roman characters. Where there\n * are multiple possible phonetic representations, these are joined with a pipe ({@code |}) character. If multiple\n * hyphenated words where found, or if the word may contain a name prefix, each encoded word is placed in ellipses and\n * these blocks are then joined with hyphens. For example, \"{@code d'ortley}\" has a possible prefix. The form\n * without prefix encodes to \"{@code ortlaj|ortlej}\", while the form with prefix encodes to \"\n * {@code dortlaj|dortlej}\". Thus, the full, combined encoding is \"{@code (ortlaj|ortlej)-(dortlaj|dortlej)}\".\n * </p>\n * <p>\n * The encoded forms are often quite a bit longer than the input strings. This is because a single input may have many\n * potential phonetic interpretations. For example, \"{@code Renault}\" encodes to \"\n * {@code rYnDlt|rYnalt|rYnult|rinDlt|rinalt|rinult}\". The {@code APPROX} rules will tend to produce larger\n * encodings as they consider a wider range of possible, approximate phonetic interpretations of the original word.\n * Down-stream applications may wish to further process the encoding for indexing or lookup purposes, for example, by\n * splitting on pipe ({@code |}) and indexing under each of these alternatives.\n * </p>\n * <p>\n * <b>Note</b>: this version of the Beider-Morse encoding is equivalent with v3.4 of the reference implementation.\n * </p>\n * @see <a href=\"https://stevemorse.org/phonetics/bmpm.htm\">Beider-Morse Phonetic Matching</a>\n * @see <a href=\"https://stevemorse.org/phoneticinfo.htm\">Reference implementation</a>\n *\n * <p>\n * This class is Not ThreadSafe\n * </p>\n * @since 1.6\n ",
      "methods": {
        "getNameType": {
          "Javadoc": "* Gets the name type currently in operation.\n     *\n     * @return the NameType currently being used"
        },
        "getRuleType": {
          "Javadoc": "* Gets the rule type currently in operation.\n     *\n     * @return the RuleType currently being used"
        },
        "isConcat": {
          "Javadoc": "* Discovers if multiple possible encodings are concatenated.\n     *\n     * @return true if multiple encodings are concatenated, false if just the first one is returned"
        },
        "setConcat": {
          "Javadoc": "* Sets how multiple possible phonetic encodings are combined.\n     *\n     * @param concat\n     *            true if multiple encodings are to be combined with a '|', false if just the first one is\n     *            to be considered"
        },
        "setMaxPhonemes": {
          "Javadoc": "* Sets the number of maximum of phonemes that shall be considered by the engine.\n     *\n     * @param maxPhonemes\n     *            the maximum number of phonemes returned by the engine\n     * @since 1.7"
        },
        "setNameType": {
          "Javadoc": "* Sets the type of name. Use {@link NameType#GENERIC} unless you specifically want phonetic encodings\n     * optimized for Ashkenazi or Sephardic Jewish family names.\n     *\n     * @param nameType\n     *            the NameType in use"
        },
        "setRuleType": {
          "Javadoc": "* Sets the rule type to apply. This will widen or narrow the range of phonetic encodings considered.\n     *\n     * @param ruleType\n     *            {@link RuleType#APPROX} or {@link RuleType#EXACT} for approximate or exact phonetic matches"
        }
      }
    },
    "org.apache.commons.codec.language.bm.Lang": {
      "Javadoc": "\n * Language guessing utility.\n * <p>\n * This class encapsulates rules used to guess the possible languages that a word originates from. This is\n * done by reference to a whole series of rules distributed in resource files.\n * </p>\n * <p>\n * Instances of this class are typically managed through the static factory method instance().\n * Unless you are developing your own language guessing rules, you will not need to interact with this class directly.\n * </p>\n * <p>\n * This class is intended to be immutable and thread-safe.\n * </p>\n * <h2>Lang resources</h2>\n * <p>\n * Language guessing rules are typically loaded from resource files. These are UTF-8 encoded text files.\n * They are systematically named following the pattern:\n * </p>\n * <blockquote>org/apache/commons/codec/language/bm/lang.txt</blockquote>\n * <p>\n * The format of these resources is the following:\n * </p>\n * <ul>\n * <li><b>Rules:</b> whitespace separated strings.\n * There should be 3 columns to each row, and these will be interpreted as:\n * <ol>\n * <li>pattern: a regular expression.</li>\n * <li>languages: a '+'-separated list of languages.</li>\n * <li>acceptOnMatch: 'true' or 'false' indicating if a match rules in or rules out the language.</li>\n * </ol>\n * </li>\n * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text following on that line to be\n * discarded as a comment.</li>\n * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode.\n * This will skip all content until a line ending in '*' and '/' is found.</li>\n * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n * </ul>\n * <p>\n * Port of lang.php\n * </p>\n *\n * @since 1.6\n ",
      "methods": {
        "instance": {
          "Javadoc": "* Gets a Lang instance for one of the supported NameTypes.\n     *\n     * @param nameType\n     *            the NameType to look up\n     * @return a Lang encapsulating the language guessing rules for that name type"
        },
        "loadFromResource": {
          "Javadoc": "* Loads language rules from a resource.\n     * <p>\n     * In normal use, you will obtain instances of Lang through the {@link #instance(NameType)} method.\n     * You will only need to call this yourself if you are developing custom language mapping rules.\n     * </p>\n     *\n     * @param languageRulesResourceName\n     *            the fully-qualified resource name to load\n     * @param languages\n     *            the languages that these rules will support\n     * @return a Lang encapsulating the loaded language-guessing rules."
        },
        "guessLanguage": {
          "Javadoc": "* Guesses the language of a word.\n     *\n     * @param text\n     *            the word\n     * @return the language that the word originates from or {@link Languages#ANY} if there was no unique match"
        },
        "guessLanguages": {
          "Javadoc": "* Guesses the languages of a word.\n     *\n     * @param input\n     *            the word\n     * @return a Set of Strings of language names that are potential matches for the input word"
        }
      }
    },
    "org.apache.commons.codec.language.bm.LangRule": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.language.bm.Languages": {
      "Javadoc": "\n * Language codes.\n * <p>\n * Language codes are typically loaded from resource files. These are UTF-8\n * encoded text files. They are systematically named following the pattern:\n * </p>\n * <blockquote>org/apache/commons/codec/language/bm/${{@link NameType#getName()}\n * languages.txt</blockquote>\n * <p>\n * The format of these resources is the following:\n * </p>\n * <ul>\n * <li><b>Language:</b> a single string containing no whitespace</li>\n * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text\n * following on that line to be discarded as a comment.</li>\n * <li><b>Multi-line comments:</b> Any line starting with '/*' will start\n * multi-line commenting mode. This will skip all content until a line ending in\n * '*' and '/' is found.</li>\n * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n * </ul>\n * <p>\n * Ported from language.php\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @since 1.6\n "
    },
    "org.apache.commons.codec.language.bm.LanguageSet": {
      "Javadoc": "\n     * A set of languages.\n     "
    },
    "org.apache.commons.codec.language.bm.SomeLanguages": {
      "Javadoc": "\n     * Some languages, explicitly enumerated.\n     "
    },
    "org.apache.commons.codec.language.bm.PhoneticEngine": {
      "Javadoc": "\n * Converts words into potential phonetic representations.\n * <p>\n * This is a two-stage process. Firstly, the word is converted into a phonetic representation that takes\n * into account the likely source language. Next, this phonetic representation is converted into a\n * pan-European 'average' representation, allowing comparison between different versions of essentially\n * the same word from different languages.\n * </p>\n * <p>\n * This class is intentionally immutable and thread-safe.\n * If you wish to alter the settings for a PhoneticEngine, you\n * must make a new one with the updated settings.\n * </p>\n * <p>\n * Ported from phoneticengine.php\n * </p>\n *\n * @since 1.6\n ",
      "methods": {
        "join": {
          "Javadoc": "* Joins some strings with an internal separator.\n     *\n     * @param strings   Strings to join\n     * @param sep       String to separate them with\n     * @return a single String consisting of each element of {@code strings} interleaved by {@code sep}"
        },
        "applyFinalRules": {
          "Javadoc": "* Applies the final rules to convert from a language-specific phonetic representation to a\n     * language-independent representation.\n     *\n     * @param phonemeBuilder the current phonemes\n     * @param finalRules the final rules to apply\n     * @return the resulting phonemes"
        },
        "encode": {
          "Javadoc": "* Encodes an input string into an output phonetic representation, given a set of possible origin languages.\n     *\n     * @param input\n     *            String to phoneticise; a String with dashes or spaces separating each word\n     * @param languageSet\n     *            set of possible origin languages\n     * @return a phonetic representation of the input; a String containing '-'-separated phonetic representations of the\n     *         input"
        },
        "getLang": {
          "Javadoc": "* Gets the Lang language guessing rules being used.\n     *\n     * @return the Lang in use"
        },
        "getMaxPhonemes": {
          "Javadoc": "* Gets the maximum number of phonemes the engine will calculate for a given input.\n     *\n     * @return the maximum number of phonemes\n     * @since 1.7"
        },
        "getNameType": {
          "Javadoc": "* Gets the NameType being used.\n     *\n     * @return the NameType in use"
        },
        "getRuleType": {
          "Javadoc": "* Gets the RuleType being used.\n     *\n     * @return the RuleType in use"
        },
        "isConcat": {
          "Javadoc": "* Gets if multiple phonetic encodings are concatenated or if just the first one is kept.\n     *\n     * @return true if multiple phonetic encodings are returned, false if just the first is"
        }
      }
    },
    "org.apache.commons.codec.language.bm.PhonemeBuilder": {
      "Javadoc": "\n     * Utility for manipulating a set of phonemes as they are being built up. Not intended for use outside\n     * this package, and probably not outside the {@link PhoneticEngine} class.\n     *\n     * @since 1.6\n     ",
      "methods": {
        "empty": {
          "Javadoc": "* An empty builder where all phonemes must come from some set of languages. This will contain a single\n         * phoneme of zero characters. This can then be appended to. This should be the only way to create a new\n         * phoneme from scratch.\n         *\n         * @param languages the set of languages\n         * @return  a new, empty phoneme builder"
        },
        "append": {
          "Javadoc": "* Creates a new phoneme builder containing all phonemes in this one extended by {@code str}.\n         *\n         * @param str   the characters to append to the phonemes"
        },
        "apply": {
          "Javadoc": "* Applies the given phoneme expression to all phonemes in this phoneme builder.\n         * <p>\n         * This will lengthen phonemes that have compatible language sets to the expression, and drop those that are\n         * incompatible.\n         * </p>\n         *\n         * @param phonemeExpr   the expression to apply\n         * @param maxPhonemes   the maximum number of phonemes to build up"
        },
        "getPhonemes": {
          "Javadoc": "* Gets underlying phoneme set. Please don't mutate.\n         *\n         * @return  the phoneme set"
        },
        "makeString": {
          "Javadoc": "* Stringifies the phoneme set. This produces a single string of the strings of each phoneme,\n         * joined with a pipe. This is explicitly provided in place of toString as it is a potentially\n         * expensive operation, which should be avoided when debugging.\n         *\n         * @return  the stringified phoneme set"
        }
      }
    },
    "org.apache.commons.codec.language.bm.RulesApplication": {
      "Javadoc": "\n     * A function closure capturing the application of a list of rules to an input sequence at a particular offset.\n     * After invocation, the values {@code i} and {@code found} are updated. {@code i} points to the\n     * index of the next char in {@code input} that must be processed next (the input up to that index having been\n     * processed already), and {@code found} indicates if a matching rule was found or not. In the case where a\n     * matching rule was found, {@code phonemeBuilder} is replaced with a new builder containing the phonemes\n     * updated by the matching rule.\n     * <p>\n     * Although this class is not thread-safe (it has mutable unprotected fields), it is not shared between threads\n     * as it is constructed as needed by the calling methods.\n     * </p>\n     *\n     * @since 1.6\n     ",
      "methods": {
        "invoke": {
          "Javadoc": "* Invokes the rules. Loops over the rules list, stopping at the first one that has a matching context\n         * and pattern. Then applies this rule to the phoneme builder to produce updated phonemes. If there was no\n         * match, {@code i} is advanced one and the character is silently dropped from the phonetic spelling.\n         *\n         * @return {@code this}"
        }
      }
    },
    "org.apache.commons.codec.language.bm.ResourceConstants": {
      "Javadoc": "\n * Constants used to process resource files.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @since 1.6\n "
    },
    "org.apache.commons.codec.language.bm.Rule": {
      "Javadoc": "\n * A phoneme rule.\n * <p>\n * Rules have a pattern, left context, right context, output phoneme, set of languages for which they apply\n * and a logical flag indicating if all languages must be in play. A rule matches if:\n * </p>\n * <ul>\n * <li>the pattern matches at the current position</li>\n * <li>the string up until the beginning of the pattern matches the left context</li>\n * <li>the string from the end of the pattern matches the right context</li>\n * <li>logical is ALL and all languages are in scope; or</li>\n * <li>logical is any other value and at least one language is in scope</li>\n * </ul>\n * <p>\n * Rules are typically generated by parsing rules resources. In normal use, there will be no need for the user\n * to explicitly construct their own.\n * </p>\n * <p>\n * Rules are immutable and thread-safe.\n * </p>\n * <h2>Rules resources</h2>\n * <p>\n * Rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically\n * named following the pattern:\n * </p>\n * <blockquote>org/apache/commons/codec/language/bm/${NameType#getName}_${RuleType#getName}_${language}.txt</blockquote>\n * <p>\n * The format of these resources is the following:\n * </p>\n * <ul>\n * <li><b>Rules:</b> whitespace separated, double-quoted strings. There should be 4 columns to each row, and these\n * will be interpreted as:\n * <ol>\n * <li>pattern</li>\n * <li>left context</li>\n * <li>right context</li>\n * <li>phoneme</li>\n * </ol>\n * </li>\n * <li><b>End-of-line comments:</b> Any occurrence of '//' will cause all text following on that line to be discarded\n * as a comment.</li>\n * <li><b>Multi-line comments:</b> Any line starting with '/*' will start multi-line commenting mode. This will skip\n * all content until a line ending in '*' and '/' is found.</li>\n * <li><b>Blank lines:</b> All blank lines will be skipped.</li>\n * </ul>\n *\n * @since 1.6\n ",
      "methods": {
        "getInstance": {
          "Javadoc": "* Gets rules for a combination of name type, rule type and a single language.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param lang\n     *            the language to consider\n     * @return a list of Rules that apply"
        },
        "getInstanceMap": {
          "Javadoc": "* Gets rules for a combination of name type, rule type and a single language.\n     *\n     * @param nameType\n     *            the NameType to consider\n     * @param rt\n     *            the RuleType to consider\n     * @param lang\n     *            the language to consider\n     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern\n     * @since 1.9"
        },
        "pattern": {
          "Javadoc": "* Attempts to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.\n     *\n     * @param regex\n     *            the regular expression to compile\n     * @return an RPattern that will match this regex"
        },
        "getLContext": {
          "Javadoc": "* Gets the left context. This is a regular expression that must match to the left of the pattern.\n     *\n     * @return the left context Pattern"
        },
        "getPattern": {
          "Javadoc": "* Gets the pattern. This is a string-literal that must exactly match.\n     *\n     * @return the pattern"
        },
        "getPhoneme": {
          "Javadoc": "* Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.\n     *\n     * @return the phoneme"
        },
        "getRContext": {
          "Javadoc": "* Gets the right context. This is a regular expression that must match to the right of the pattern.\n     *\n     * @return the right context Pattern"
        },
        "patternAndContextMatches": {
          "Javadoc": "* Decides if the pattern and context match the input starting at a position. It is a match if the\n     * {@code lContext} matches {@code input} up to {@code i}, {@code pattern} matches at i and\n     * {@code rContext} matches from the end of the match of {@code pattern} to the end of {@code input}.\n     *\n     * @param input\n     *            the input String\n     * @param i\n     *            the int position within the input\n     * @return true if the pattern and left/right context match, false otherwise"
        }
      }
    },
    "org.apache.commons.codec.language.bm.Phoneme": {
      "Javadoc": "",
      "methods": {
        "join": {
          "Javadoc": "* Deprecated since 1.9.\n         *\n         * @param right the Phoneme to join\n         * @return a new Phoneme\n         * @deprecated since 1.9"
        },
        "mergeWithLanguage": {
          "Javadoc": "* Returns a new Phoneme with the same text but a union of its\n         * current language set and the given one.\n         *\n         * @param lang the language set to merge\n         * @return a new Phoneme"
        }
      }
    },
    "org.apache.commons.codec.language.bm.PhonemeExpr": {
      "Javadoc": "",
      "methods": {
        "size": {
          "Javadoc": "* Gets the expression size in phonemes.\n         *\n         * @return the expression size in phonemes.\n         * @since 1.17.0"
        }
      }
    },
    "org.apache.commons.codec.language.bm.PhonemeList": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.language.bm.RPattern": {
      "Javadoc": "\n     * A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.\n     "
    },
    "org.apache.commons.codec.language.Caverphone": {
      "Javadoc": "\n * Encodes a string into a Caverphone 2.0 value. Delegate to a {@link Caverphone2} instance.\n *\n * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0\n * algorithm:\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Caverphone\">Wikipedia - Caverphone</a>\n * @see <a href=\"https://caversham.otago.ac.nz/files/working/ctp150804.pdf\">Caverphone 2.0 specification</a>\n * @since 1.4\n * @deprecated 1.5 Replaced by {@link Caverphone2}, will be removed in 2.0.\n ",
      "methods": {
        "caverphone": {
          "Javadoc": "* Encodes the given String into a Caverphone value.\n     *\n     * @param source\n     *            String the source string\n     * @return A caverphone code for the given String"
        },
        "encode": {
          "Javadoc": "* Encodes a String using the Caverphone algorithm.\n     *\n     * @param str\n     *            String object to encode\n     * @return The caverphone code corresponding to the String supplied"
        },
        "isCaverphoneEqual": {
          "Javadoc": "* Tests if the caverphones of two strings are identical.\n     *\n     * @param str1\n     *            First of two strings to compare\n     * @param str2\n     *            Second of two strings to compare\n     * @return {@code true} if the caverphones of these strings are identical, {@code false} otherwise."
        }
      }
    },
    "org.apache.commons.codec.language.Caverphone1": {
      "Javadoc": "\n * Encodes a string into a Caverphone 1.0 value.\n *\n * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 1.0\n * algorithm:\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Caverphone\">Wikipedia - Caverphone</a>\n * @see <a href=\"https://caversham.otago.ac.nz/files/working/ctp060902.pdf\">Caverphone 1.0 specification</a>\n * @since 1.5\n *\n * <p>This class is immutable and thread-safe.</p>\n ",
      "methods": {
        "encode": {
          "Javadoc": "* Encodes the given String into a Caverphone value.\n     *\n     * @param source\n     *            String the source string\n     * @return A caverphone code for the given String"
        }
      }
    },
    "org.apache.commons.codec.language.Caverphone2": {
      "Javadoc": "\n * Encodes a string into a Caverphone 2.0 value.\n *\n * This is an algorithm created by the Caversham Project at the University of Otago. It implements the Caverphone 2.0\n * algorithm:\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Caverphone\">Wikipedia - Caverphone</a>\n * @see <a href=\"https://caversham.otago.ac.nz/files/working/ctp150804.pdf\">Caverphone 2.0 specification</a>\n * @since 1.5\n *\n * <p>This class is immutable and thread-safe.</p>\n ",
      "methods": {
        "encode": {
          "Javadoc": "* Encodes the given String into a Caverphone 2.0 value.\n     *\n     * @param source\n     *            String the source string\n     * @return A caverphone code for the given String"
        }
      }
    },
    "org.apache.commons.codec.language.ColognePhonetic": {
      "Javadoc": "\n * Encodes a string into a Cologne Phonetic value.\n * <p>\n * Implements the <a href=\"https://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik\">K&ouml;lner Phonetik</a> (Cologne\n * Phonetic) algorithm issued by Hans Joachim Postel in 1969.\n * </p>\n * <p>\n * The <i>K&ouml;lner Phonetik</i> is a phonetic algorithm which is optimized for the German language. It is related to\n * the well-known soundex algorithm.\n * </p>\n *\n * <h2>Algorithm</h2>\n *\n * <ul>\n *\n * <li>\n * <h3>Step 1:</h3>\n * After preprocessing (conversion to upper case, transcription of <a\n * href=\"https://en.wikipedia.org/wiki/Germanic_umlaut\">germanic umlauts</a>, removal of non alphabetical characters) the\n * letters of the supplied text are replaced by their phonetic code according to the following table.\n * <table border=\"1\">\n * <caption style=\"caption-side: bottom\"><small><i>(Source: <a\n * href=\"https://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik#Buchstabencodes\">Wikipedia (de): K&ouml;lner Phonetik --\n * Buchstabencodes</a>)</i></small></caption> <tbody>\n * <tr>\n * <th>Letter</th>\n * <th>Context</th>\n * <th>Code</th>\n * </tr>\n * <tr>\n * <td>A, E, I, J, O, U, Y</td>\n * <td></td>\n * <td>0</td>\n * </tr>\n * <tr>\n *\n * <td>H</td>\n * <td></td>\n * <td>-</td>\n * </tr>\n * <tr>\n * <td>B</td>\n * <td></td>\n * <td rowspan=\"2\">1</td>\n * </tr>\n * <tr>\n * <td>P</td>\n * <td>not before H</td>\n *\n * </tr>\n * <tr>\n * <td>D, T</td>\n * <td>not before C, S, Z</td>\n * <td>2</td>\n * </tr>\n * <tr>\n * <td>F, V, W</td>\n * <td></td>\n * <td rowspan=\"2\">3</td>\n * </tr>\n * <tr>\n *\n * <td>P</td>\n * <td>before H</td>\n * </tr>\n * <tr>\n * <td>G, K, Q</td>\n * <td></td>\n * <td rowspan=\"3\">4</td>\n * </tr>\n * <tr>\n * <td rowspan=\"2\">C</td>\n * <td>at onset before A, H, K, L, O, Q, R, U, X</td>\n *\n * </tr>\n * <tr>\n * <td>before A, H, K, O, Q, U, X except after S, Z</td>\n * </tr>\n * <tr>\n * <td>X</td>\n * <td>not after C, K, Q</td>\n * <td>48</td>\n * </tr>\n * <tr>\n * <td>L</td>\n * <td></td>\n *\n * <td>5</td>\n * </tr>\n * <tr>\n * <td>M, N</td>\n * <td></td>\n * <td>6</td>\n * </tr>\n * <tr>\n * <td>R</td>\n * <td></td>\n * <td>7</td>\n * </tr>\n *\n * <tr>\n * <td>S, Z</td>\n * <td></td>\n * <td rowspan=\"6\">8</td>\n * </tr>\n * <tr>\n * <td rowspan=\"3\">C</td>\n * <td>after S, Z</td>\n * </tr>\n * <tr>\n * <td>at onset except before A, H, K, L, O, Q, R, U, X</td>\n * </tr>\n *\n * <tr>\n * <td>not before A, H, K, O, Q, U, X</td>\n * </tr>\n * <tr>\n * <td>D, T</td>\n * <td>before C, S, Z</td>\n * </tr>\n * <tr>\n * <td>X</td>\n * <td>after C, K, Q</td>\n * </tr>\n * </tbody>\n * </table>\n *\n * <h4>Example:</h4>\n *\n * {@code \"M}&uuml;{@code ller-L}&uuml;<code>denscheidt\"\n * =&gt; \"MULLERLUDENSCHEIDT\" =&gt; \"6005507500206880022\"</code>\n *\n * </li>\n *\n * <li>\n * <h3>Step 2:</h3>\n * Collapse of all multiple consecutive code digits.\n * <h4>Example:</h4>\n * {@code \"6005507500206880022\" =&gt; \"6050750206802\"}</li>\n *\n * <li>\n * <h3>Step 3:</h3>\n * Removal of all codes \"0\" except at the beginning. This means that two or more identical consecutive digits can occur\n * if they occur after removing the \"0\" digits.\n *\n * <h4>Example:</h4>\n * {@code \"6050750206802\" =&gt; \"65752682\"}</li>\n *\n * </ul>\n *\n * <p>\n * This class is thread-safe.\n * </p>\n *\n * @see <a href=\"https://de.wikipedia.org/wiki/K%C3%B6lner_Phonetik\">Wikipedia (de): K&ouml;lner Phonetik (in German)</a>\n * @since 1.5\n ",
      "methods": {
        "colognePhonetic": {
          "Javadoc": "* <p>\n     * Implements the <i>K&ouml;lner Phonetik</i> algorithm.\n     * </p>\n     * <p>\n     * In contrast to the initial description of the algorithm, this implementation does the encoding in one pass.\n     * </p>\n     *\n     * @param text The source text to encode\n     * @return the corresponding encoding according to the <i>K&ouml;lner Phonetik</i> algorithm"
        },
        "isEncodeEqual": {
          "Javadoc": "* Compares the first encoded string to the second encoded string.\n     *\n     * @param text1 source text to encode before testing for equality.\n     * @param text2 source text to encode before testing for equality.\n     * @return {@code true} if the encoding the first string equals the encoding of the second string, {@code false}\n     *         otherwise"
        },
        "preprocess": {
          "Javadoc": "* Converts the string to upper case and replaces Germanic umlaut characters\n     * The following characters are mapped:\n     * <ul>\n     * <li>capital A, umlaut mark</li>\n     * <li>capital U, umlaut mark</li>\n     * <li>capital O, umlaut mark</li>\n     * <li>small sharp s, German</li>\n     * </ul>"
        }
      }
    },
    "org.apache.commons.codec.language.CologneBuffer": {
      "Javadoc": "\n     * This class is not thread-safe; the field {@link #length} is mutable.\n     * However, it is not shared between threads, as it is constructed on demand\n     * by the method {@link ColognePhonetic#colognePhonetic(String)}\n     "
    },
    "org.apache.commons.codec.language.CologneInputBuffer": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.language.CologneOutputBuffer": {
      "Javadoc": "",
      "methods": {
        "put": {
          "Javadoc": "* Stores the next code in the output buffer, keeping track of the previous code.\n         * '0' is only stored if it is the first entry.\n         * Ignored chars are never stored.\n         * If the code is the same as the last code (whether stored or not) it is not stored.\n         *\n         * @param code the code to store."
        }
      }
    },
    "org.apache.commons.codec.language.DaitchMokotoffSoundex": {
      "Javadoc": "\n * Encodes a string into a Daitch-Mokotoff Soundex value.\n * <p>\n * The Daitch-Mokotoff Soundex algorithm is a refinement of the Russel and American Soundex algorithms, yielding greater\n * accuracy in matching especially Slavish and Yiddish surnames with similar pronunciation but differences in spelling.\n * </p>\n * <p>\n * The main differences compared to the other soundex variants are:\n * </p>\n * <ul>\n * <li>coded names are 6 digits long\n * <li>the initial character of the name is coded\n * <li>rules to encoded multi-character n-grams\n * <li>multiple possible encodings for the same name (branching)\n * </ul>\n * <p>\n * This implementation supports branching, depending on the used method:\n * <ul>\n * <li>{@link #encode(String)} - branching disabled, only the first code will be returned\n * <li>{@link #soundex(String)} - branching enabled, all codes will be returned, separated by '|'\n * </ul>\n * <p>\n * Note: this implementation has additional branching rules compared to the original description of the algorithm. The\n * rules can be customized by overriding the default rules contained in the resource file\n * {@code org/apache/commons/codec/language/dmrules.txt}.\n * </p>\n * <p>\n * This class is thread-safe.\n * </p>\n *\n * @see Soundex\n * @see <a href=\"https://en.wikipedia.org/wiki/Daitch%E2%80%93Mokotoff_Soundex\"> Wikipedia - Daitch-Mokotoff Soundex</a>\n * @see <a href=\"http://www.avotaynu.com/soundex.htm\">Avotaynu - Soundexing and Genealogy</a>\n *\n * @since 1.10\n ",
      "methods": {
        "cleanup": {
          "Javadoc": "* Performs a cleanup of the input string before the actual soundex transformation.\n     * <p>\n     * Removes all whitespace characters and performs ASCII folding if enabled.\n     * </p>\n     *\n     * @param input\n     *            the input string to clean up\n     * @return a cleaned up string"
        },
        "encode": {
          "Javadoc": "* Encodes a String using the Daitch-Mokotoff soundex algorithm without branching.\n     *\n     * @see #soundex(String)\n     *\n     * @param source\n     *            A String object to encode\n     * @return A DM Soundex code corresponding to the String supplied\n     * @throws IllegalArgumentException\n     *             if a character is not mapped"
        },
        "soundex": {
          "Javadoc": "* Perform the actual DM Soundex algorithm on the input string.\n     *\n     * @param source\n     *            A String object to encode\n     * @param branching\n     *            If branching shall be performed\n     * @return A string array containing all DM Soundex codes corresponding to the String supplied depending on the\n     *         selected branching mode"
        }
      }
    },
    "org.apache.commons.codec.language.Branch": {
      "Javadoc": "\n     * Inner class representing a branch during DM soundex encoding.\n     ",
      "methods": {
        "createBranch": {
          "Javadoc": "* Creates a new branch, identical to this branch.\n         *\n         * @return a new, identical branch"
        },
        "finish": {
          "Javadoc": "* Finish this branch by appending '0's until the maximum code length has been reached."
        },
        "processNextReplacement": {
          "Javadoc": "* Process the next replacement to be added to this branch.\n         *\n         * @param replacement\n         *            the next replacement to append\n         * @param forceAppend\n         *            indicates if the default processing shall be overridden"
        }
      }
    },
    "org.apache.commons.codec.language.Rule": {
      "Javadoc": "\n     * Inner class for storing rules.\n     "
    },
    "org.apache.commons.codec.language.DoubleMetaphone": {
      "Javadoc": "\n * Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence\n * Philips</CITE>.\n * <p>\n * This class is conditionally thread-safe. The instance field for the maximum code length is mutable\n * {@link #setMaxCodeLen(int)} but is not volatile, and accesses are not synchronized. If an instance of the class is\n * shared between threads, the caller needs to ensure that suitable synchronization is used to ensure safe publication\n * of the value between threads, and must not invoke {@link #setMaxCodeLen(int)} after initial setup.\n * </p>\n *\n * @see <a href=\"https://drdobbs.com/the-double-metaphone-search-algorithm/184401251?pgno=2\">Dr. Dobbs Original Article</a>\n * @see <a href=\"https://en.wikipedia.org/wiki/Metaphone\">Wikipedia Metaphone</a>\n ",
      "methods": {
        "cleanInput": {
          "Javadoc": "* Cleans the input."
        },
        "conditionC0": {
          "Javadoc": "* Complex condition 0 for 'C'."
        },
        "conditionCH0": {
          "Javadoc": "* Complex condition 0 for 'CH'."
        },
        "conditionCH1": {
          "Javadoc": "* Complex condition 1 for 'CH'."
        },
        "conditionL0": {
          "Javadoc": "* Complex condition 0 for 'L'."
        },
        "conditionM0": {
          "Javadoc": "* Complex condition 0 for 'M'."
        },
        "doubleMetaphone": {
          "Javadoc": "* Encode a value with Double Metaphone, optionally using the alternate encoding.\n     *\n     * @param value String to encode\n     * @param alternate use alternate encode\n     * @return an encoded string"
        },
        "encode": {
          "Javadoc": "* Encode the value using DoubleMetaphone.\n     *\n     * @param value String to encode\n     * @return An encoded String"
        },
        "getMaxCodeLen": {
          "Javadoc": "* Returns the maxCodeLen.\n     * @return int"
        },
        "handleAEIOUY": {
          "Javadoc": "* Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases."
        },
        "handleC": {
          "Javadoc": "* Handles 'C' cases."
        },
        "handleCC": {
          "Javadoc": "* Handles 'CC' cases."
        },
        "handleCH": {
          "Javadoc": "* Handles 'CH' cases."
        },
        "handleD": {
          "Javadoc": "* Handles 'D' cases."
        },
        "handleG": {
          "Javadoc": "* Handles 'G' cases."
        },
        "handleGH": {
          "Javadoc": "* Handles 'GH' cases."
        },
        "handleH": {
          "Javadoc": "* Handles 'H' cases."
        },
        "handleJ": {
          "Javadoc": "* Handles 'J' cases."
        },
        "handleL": {
          "Javadoc": "* Handles 'L' cases."
        },
        "handleP": {
          "Javadoc": "* Handles 'P' cases."
        },
        "handleR": {
          "Javadoc": "* Handles 'R' cases."
        },
        "handleS": {
          "Javadoc": "* Handles 'S' cases."
        },
        "handleSC": {
          "Javadoc": "* Handles 'SC' cases."
        },
        "handleT": {
          "Javadoc": "* Handles 'T' cases."
        },
        "handleW": {
          "Javadoc": "* Handles 'W' cases."
        },
        "handleX": {
          "Javadoc": "* Handles 'X' cases."
        },
        "handleZ": {
          "Javadoc": "* Handles 'Z' cases."
        },
        "isDoubleMetaphoneEqual": {
          "Javadoc": "* Check if the Double Metaphone values of two {@code String} values\n     * are equal, optionally using the alternate value.\n     *\n     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.\n     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.\n     * @param alternate use the alternate value if {@code true}.\n     * @return {@code true} if the encoded {@code String}s are equal;\n     *          {@code false} otherwise."
        },
        "isSilentStart": {
          "Javadoc": "* Determines whether or not the value starts with a silent letter.  It will\n     * return {@code true} if the value starts with any of 'GN', 'KN',\n     * 'PN', 'WR' or 'PS'."
        },
        "isSlavoGermanic": {
          "Javadoc": "* Determines whether or not a value is of slavo-germanic origin. A value is\n     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'."
        },
        "isVowel": {
          "Javadoc": "* Determines whether or not a character is a vowel or not"
        },
        "setMaxCodeLen": {
          "Javadoc": "* Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set"
        }
      }
    },
    "org.apache.commons.codec.language.DoubleMetaphoneResult": {
      "Javadoc": "\n     * Inner class for storing results, since there is the optional alternate encoding.\n     "
    },
    "org.apache.commons.codec.language.MatchRatingApproachEncoder": {
      "Javadoc": "\n * Match Rating Approach Phonetic Algorithm Developed by <CITE>Western Airlines</CITE> in 1977.\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Match_rating_approach\">Wikipedia - Match Rating Approach</a>\n * @since 1.8\n ",
      "methods": {
        "cleanName": {
          "Javadoc": "* Cleans up a name: 1. Upper-cases everything 2. Removes some common punctuation 3. Removes accents 4. Removes any\n     * spaces.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            The name to be cleaned\n     * @return The cleaned name"
        },
        "encode": {
          "Javadoc": "* Encodes a String using the Match Rating Approach (MRA) algorithm.\n     *\n     * @param name\n     *            String object to encode\n     * @return The MRA code corresponding to the String supplied"
        },
        "getFirst3Last3": {
          "Javadoc": "* Gets the first and last 3 letters of a name (if &gt; 6 characters) Else just returns the name.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            The string to get the substrings from\n     * @return Annexed first and last 3 letters of input word."
        },
        "getMinRating": {
          "Javadoc": "* Obtains the min rating of the length sum of the 2 names. In essence the larger the sum length the smaller the\n     * min rating. Values strictly from documentation.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param sumLength\n     *            The length of 2 strings sent down\n     * @return The min rating value"
        },
        "isEncodeEquals": {
          "Javadoc": "* Determines if two names are homophonous via Match Rating Approach (MRA) algorithm. It should be noted that the\n     * strings are cleaned in the same way as {@link #encode(String)}.\n     *\n     * @param name1\n     *            First of the 2 strings (names) to compare\n     * @param name2\n     *            Second of the 2 names to compare\n     * @return {@code true} if the encodings are identical {@code false} otherwise."
        },
        "isVowel": {
          "Javadoc": "* Determines if a letter is a vowel.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param letter\n     *            The letter under investigation\n     * @return True if a vowel, else false"
        },
        "leftToRightThenRightToLeftProcessing": {
          "Javadoc": "* Processes the names from left to right (first) then right to left removing identical letters in same positions.\n     * Then subtracts the longer string that remains from 6 and returns this.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name1\n     *            name2\n     * @return the length as above"
        },
        "removeAccents": {
          "Javadoc": "* Removes accented letters and replaces with non-accented ASCII equivalent Case is preserved.\n     * http://www.codecodex.com/wiki/Remove_accent_from_letters_%28ex_.%C3%A9_to_e%29\n     *\n     * @param accentedWord\n     *            The word that may have accents in it.\n     * @return De-accented word"
        },
        "removeDoubleConsonants": {
          "Javadoc": "* Replaces any double consonant pair with the single letter equivalent.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            String to have double consonants removed\n     * @return Single consonant word"
        },
        "removeVowels": {
          "Javadoc": "* Deletes all vowels unless the vowel begins the word.\n     *\n     * <h2>API Usage</h2>\n     * <p>\n     * Consider this method private, it is package protected for unit testing only.\n     * </p>\n     *\n     * @param name\n     *            The name to have vowels removed\n     * @return De-voweled word"
        }
      }
    },
    "org.apache.commons.codec.language.Metaphone": {
      "Javadoc": "\n * Encodes a string into a Metaphone value.\n * <p>\n * Initial Java implementation by <CITE>William B. Brogden. December, 1997</CITE>.\n * Permission given by <CITE>wbrogden</CITE> for code to be used anywhere.\n * </p>\n * <p>\n * <CITE>Hanging on the Metaphone</CITE> by <CITE>Lawrence Philips</CITE> in <CITE>Computer Language of Dec. 1990,\n * p 39.</CITE>\n * </p>\n * <p>\n * Note, that this does not match the algorithm that ships with PHP, or the algorithm found in the Perl implementations:\n * </p>\n * <ul>\n * <li><a href=\"https://search.cpan.org/~mschwern/Text-Metaphone-1.96/Metaphone.pm\">Text:Metaphone-1.96</a>\n *  (broken link 4/30/2013) </li>\n * <li><a href=\"https://metacpan.org/source/MSCHWERN/Text-Metaphone-1.96//Metaphone.pm\">Text:Metaphone-1.96</a>\n *  (link checked 4/30/2013) </li>\n * </ul>\n * <p>\n * They have had undocumented changes from the originally published algorithm.\n * For more information, see <a href=\"https://issues.apache.org/jira/browse/CODEC-57\">CODEC-57</a>.\n * </p>\n * <p>\n * This class is conditionally thread-safe.\n * The instance field for maximum code length is mutable {@link #setMaxCodeLen(int)}\n * but is not volatile, and accesses are not synchronized.\n * If an instance of the class is shared between threads, the caller needs to ensure that suitable synchronization\n * is used to ensure safe publication of the value between threads, and must not invoke {@link #setMaxCodeLen(int)}\n * after initial setup.\n * </p>\n ",
      "methods": {
        "encode": {
          "Javadoc": "* Encodes a String using the Metaphone algorithm.\n     *\n     * @param str String object to encode\n     * @return The metaphone code corresponding to the String supplied"
        },
        "getMaxCodeLen": {
          "Javadoc": "* Returns the maxCodeLen.\n     * @return int"
        },
        "isMetaphoneEqual": {
          "Javadoc": "* Tests is the metaphones of two strings are identical.\n     *\n     * @param str1 First of two strings to compare\n     * @param str2 Second of two strings to compare\n     * @return {@code true} if the metaphones of these strings are identical,\n     *        {@code false} otherwise."
        },
        "metaphone": {
          "Javadoc": "* Find the metaphone value of a String. This is similar to the\n     * soundex algorithm, but better at finding similar sounding words.\n     * All input is converted to upper case.\n     * Limitations: Input format is expected to be a single ASCII word\n     * with only characters in the A - Z range, no punctuation or numbers.\n     *\n     * @param txt String to find the metaphone code for\n     * @return A metaphone code corresponding to the String supplied"
        },
        "setMaxCodeLen": {
          "Javadoc": "* Sets the maxCodeLen.\n     * @param maxCodeLen The maxCodeLen to set"
        }
      }
    },
    "org.apache.commons.codec.language.Nysiis": {
      "Javadoc": "\n * Encodes a string into a NYSIIS value. NYSIIS is an encoding used to relate similar names, but can also be used as a\n * general purpose scheme to find word with similar phonemes.\n * <p>\n * NYSIIS features an accuracy increase of 2.7% over the traditional Soundex algorithm.\n * </p>\n * <p>\n * Algorithm description:\n * </p>\n * <pre>\n * 1. Transcode first characters of name\n *   1a. MAC -&gt;   MCC\n *   1b. KN  -&gt;   NN\n *   1c. K   -&gt;   C\n *   1d. PH  -&gt;   FF\n *   1e. PF  -&gt;   FF\n *   1f. SCH -&gt;   SSS\n * 2. Transcode last characters of name\n *   2a. EE, IE          -&gt;   Y\n *   2b. DT,RT,RD,NT,ND  -&gt;   D\n * 3. First character of key = first character of name\n * 4. Transcode remaining characters by following these rules, incrementing by one character each time\n *   4a. EV  -&gt;   AF  else A,E,I,O,U -&gt; A\n *   4b. Q   -&gt;   G\n *   4c. Z   -&gt;   S\n *   4d. M   -&gt;   N\n *   4e. KN  -&gt;   N   else K -&gt; C\n *   4f. SCH -&gt;   SSS\n *   4g. PH  -&gt;   FF\n *   4h. H   -&gt;   If previous or next is non-vowel, previous\n *   4i. W   -&gt;   If previous is vowel, previous\n *   4j. Add current to key if current != last key character\n * 5. If last character is S, remove it\n * 6. If last characters are AY, replace with Y\n * 7. If last character is A, remove it\n * 8. Collapse all strings of repeated characters\n * 9. Add original first character of name as first character of key\n * </pre>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/NYSIIS\">NYSIIS on Wikipedia</a>\n * @see <a href=\"http://www.dropby.com/NYSIIS.html\">NYSIIS on dropby.com</a>\n * @see Soundex\n * @since 1.7\n ",
      "methods": {
        "isVowel": {
          "Javadoc": "* Tests if the given character is a vowel.\n     *\n     * @param c\n     *            the character to test\n     * @return {@code true} if the character is a vowel, {@code false} otherwise"
        },
        "transcodeRemaining": {
          "Javadoc": "* Transcodes the remaining parts of the String. The method operates on a sliding window, looking at 4 characters at\n     * a time: [i-1, i, i+1, i+2].\n     *\n     * @param prev\n     *            the previous character\n     * @param curr\n     *            the current character\n     * @param next\n     *            the next character\n     * @param aNext\n     *            the after next character\n     * @return a transcoded array of characters, starting from the current position"
        },
        "encode": {
          "Javadoc": "* Encodes a String using the NYSIIS algorithm.\n     *\n     * @param str\n     *            A String object to encode\n     * @return A Nysiis code corresponding to the String supplied\n     * @throws IllegalArgumentException\n     *            if a character is not mapped"
        },
        "isStrict": {
          "Javadoc": "* Indicates the strict mode for this {@link Nysiis} encoder.\n     *\n     * @return {@code true} if the encoder is configured for strict mode, {@code false} otherwise"
        },
        "nysiis": {
          "Javadoc": "* Retrieves the NYSIIS code for a given String object.\n     *\n     * @param str\n     *            String to encode using the NYSIIS algorithm\n     * @return A NYSIIS code for the String supplied"
        }
      }
    },
    "org.apache.commons.codec.language.RefinedSoundex": {
      "Javadoc": "\n * Encodes a string into a Refined Soundex value. A refined soundex code is\n * optimized for spell checking words. Soundex method originally developed by\n * <CITE>Margaret Odell</CITE> and <CITE>Robert Russell</CITE>.\n *\n * <p>This class is immutable and thread-safe.</p>\n ",
      "methods": {
        "difference": {
          "Javadoc": "* Returns the number of characters in the two encoded Strings that are the\n     * same. This return value ranges from 0 to the length of the shortest\n     * encoded String: 0 indicates little or no similarity, and 4 out of 4 (for\n     * example) indicates strong similarity or identical values. For refined\n     * Soundex, the return value can be greater than 4.\n     *\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the\n     *             same from 0 to the length of the shortest encoded String.\n     *\n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"https://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3"
        },
        "encode": {
          "Javadoc": "* Encodes a String using the refined soundex algorithm.\n     *\n     * @param str\n     *                  A String object to encode\n     * @return A Soundex code corresponding to the String supplied"
        },
        "getMappingCode": {
          "Javadoc": "* Returns the mapping code for a given character. The mapping codes are\n     * maintained in an internal char array named soundexMapping, and the\n     * default values of these mappings are US English.\n     *\n     * @param c\n     *                  char to get mapping for\n     * @return A character (really a numeral) to return for the given char"
        },
        "soundex": {
          "Javadoc": "* Retrieves the Refined Soundex code for a given String object.\n     *\n     * @param str\n     *                  String to encode using the Refined Soundex algorithm\n     * @return A soundex code for the String supplied"
        }
      }
    },
    "org.apache.commons.codec.language.Soundex": {
      "Javadoc": "\n * Encodes a string into a Soundex value. Soundex is an encoding used to relate similar names, but can also be used as a\n * general purpose scheme to find word with similar phonemes.\n *\n * <p>This class is thread-safe.\n * Although not strictly immutable, the mutable fields are not actually used.</p>\n ",
      "methods": {
        "difference": {
          "Javadoc": "* Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This\n     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or\n     * identical values.\n     *\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.\n     *\n     * @see SoundexUtils#difference(StringEncoder,String,String)\n     * @see <a href=\"https://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\"> MS\n     *          T-SQL DIFFERENCE</a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings\n     * @since 1.3"
        },
        "encode": {
          "Javadoc": "* Encodes a String using the soundex algorithm.\n     *\n     * @param str\n     *                  A String object to encode\n     * @return A Soundex code corresponding to the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped"
        },
        "getMaxLength": {
          "Javadoc": "* Returns the maxLength. Standard Soundex\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @return int"
        },
        "map": {
          "Javadoc": "* Maps the given upper-case character to its Soundex code.\n     *\n     * @param ch\n     *                  An upper-case character.\n     * @return A Soundex code.\n     * @throws IllegalArgumentException\n     *                  Thrown if {@code ch} is not mapped."
        },
        "setMaxLength": {
          "Javadoc": "* Sets the maxLength.\n     *\n     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.\n     * @param maxLength\n     *                  The maxLength to set"
        },
        "soundex": {
          "Javadoc": "* Retrieves the Soundex code for a given String object.\n     *\n     * @param str\n     *                  String to encode using the Soundex algorithm\n     * @return A soundex code for the String supplied\n     * @throws IllegalArgumentException\n     *                  if a character is not mapped"
        }
      }
    },
    "org.apache.commons.codec.language.SoundexUtils": {
      "Javadoc": "\n * Utility methods for {@link Soundex} and {@link RefinedSoundex} classes.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @since 1.3\n ",
      "methods": {
        "clean": {
          "Javadoc": "* Cleans up the input string before Soundex processing by only returning\n     * upper case letters.\n     *\n     * @param str\n     *                  The String to clean.\n     * @return A clean String."
        },
        "difference": {
          "Javadoc": "* Encodes the Strings and returns the number of characters in the two\n     * encoded Strings that are the same.\n     * <ul>\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n     * little or no similarity, and 4 indicates strong similarity or identical\n     * values.</li>\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\n     * </ul>\n     *\n     * @param encoder\n     *                  The encoder to use to encode the Strings.\n     * @param s1\n     *                  A String that will be encoded and compared.\n     * @param s2\n     *                  A String that will be encoded and compared.\n     * @return The number of characters in the two Soundex encoded Strings that\n     *             are the same.\n     *\n     * @see #differenceEncoded(String,String)\n     * @see <a href=\"https://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>\n     *\n     * @throws EncoderException\n     *                  if an error occurs encoding one of the strings"
        },
        "differenceEncoded": {
          "Javadoc": "* Returns the number of characters in the two Soundex encoded Strings that\n     * are the same.\n     * <ul>\n     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates\n     * little or no similarity, and 4 indicates strong similarity or identical\n     * values.</li>\n     * <li>For refined Soundex, the return value can be greater than 4.</li>\n     * </ul>\n     *\n     * @param es1\n     *                  An encoded String.\n     * @param es2\n     *                  An encoded String.\n     * @return The number of characters in the two Soundex encoded Strings that\n     *             are the same.\n     *\n     * @see <a href=\"https://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp\">\n     *          MS T-SQL DIFFERENCE</a>"
        },
        "isEmpty": {
          "Javadoc": "* <p>Checks if a CharSequence is empty (\"\") or null.</p>\n     *\n     * <pre>\n     * StringUtils.isEmpty(null)      = true\n     * StringUtils.isEmpty(\"\")        = true\n     * StringUtils.isEmpty(\" \")       = false\n     * StringUtils.isEmpty(\"bob\")     = false\n     * StringUtils.isEmpty(\"  bob  \") = false\n     * </pre>\n     *\n     * @param cs  the CharSequence to check, may be null\n     * @return {@code true} if the CharSequence is empty or null"
        }
      }
    },
    "org.apache.commons.codec.net.BCodec": {
      "Javadoc": "\n * Identical to the Base64 encoding defined by <a href=\"http://www.ietf.org/rfc/rfc1521.txt\">RFC 1521</a>\n * and allows a character set to be specified.\n * <p>\n * <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">RFC 1522</a> describes techniques to allow the encoding of non-ASCII\n * text in various portions of a RFC 822 [2] message header, in a manner which is unlikely to confuse existing message\n * handling software.\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">MIME (Multipurpose Internet Mail Extensions) Part Two: Message\n *          Header Extensions for Non-ASCII Text</a>\n *\n * @since 1.3\n ",
      "methods": {
        "decode": {
          "Javadoc": "* Decodes a Base64 string into its original form. Escaped characters are converted back to their original\n     * representation.\n     *\n     * @param value\n     *            Base64 string to convert into its original form\n     * @return original string\n     * @throws DecoderException\n     *             A decoder exception is thrown if a failure condition is encountered during the decode process."
        },
        "encode": {
          "Javadoc": "* Encodes a string into its Base64 form using the specified Charset. Unsafe characters are escaped.\n     *\n     * @param strSource\n     *            string to convert to Base64 form\n     * @param sourceCharset\n     *            the Charset for {@code value}\n     * @return Base64 string\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process."
        },
        "isStrictDecoding": {
          "Javadoc": "* Returns true if decoding behavior is strict. Decoding will raise a\n     * {@link DecoderException} if trailing bits are not part of a valid Base64 encoding.\n     *\n     * <p>The default is false for lenient encoding. Decoding will compose trailing bits\n     * into 8-bit bytes and discard the remainder.\n     *\n     * @return true if using strict decoding\n     * @since 1.15"
        }
      }
    },
    "org.apache.commons.codec.net.PercentCodec": {
      "Javadoc": "\n * Implements the Percent-Encoding scheme, as described in HTTP 1.1 specification. For extensibility, an array of\n * special US-ASCII characters can be specified in order to perform proper URI encoding for the different parts\n * of the URI.\n * <p>\n * This class is immutable. It is also thread-safe besides using BitSet which is not thread-safe, but its public\n * interface only call the access\n * </p>\n *\n * @see <a href=\"https://tools.ietf.org/html/rfc3986#section-2.1\">Percent-Encoding</a>\n * @since 1.12\n ",
      "methods": {
        "decode": {
          "Javadoc": "* Decodes a byte[] Object, whose bytes are encoded with Percent-Encoding.\n     *\n     * @param obj the object to decode\n     * @return the decoding result byte[] as Object\n     * @throws DecoderException if the object is not a byte array"
        },
        "encode": {
          "Javadoc": "* Encodes an object into using the Percent-Encoding. Only byte[] objects are accepted.\n     *\n     * @param obj the object to encode\n     * @return the encoding result byte[] as Object\n     * @throws EncoderException if the object is not a byte array"
        },
        "insertAlwaysEncodeChar": {
          "Javadoc": "* Inserts a single character into a BitSet and maintains the min and max of the characters of the\n     * {@code BitSet alwaysEncodeChars} in order to avoid look-ups when a byte is out of this range.\n     *\n     * @param b the byte that is candidate for min and max limit"
        },
        "insertAlwaysEncodeChars": {
          "Javadoc": "* Inserts the byte array into a BitSet for faster lookup.\n     *\n     * @param alwaysEncodeCharsArray"
        }
      }
    },
    "org.apache.commons.codec.net.QCodec": {
      "Javadoc": "\n * Similar to the Quoted-Printable content-transfer-encoding defined in\n * <a href=\"http://www.ietf.org/rfc/rfc1521.txt\">RFC 1521</a> and designed to allow text containing mostly ASCII\n * characters to be decipherable on an ASCII terminal without decoding.\n * <p>\n * <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">RFC 1522</a> describes techniques to allow the encoding of non-ASCII\n * text in various portions of a RFC 822 [2] message header, in a manner which is unlikely to confuse existing message\n * handling software.\n * </p>\n * <p>\n * This class is conditionally thread-safe.\n * The instance field for encoding blanks is mutable {@link #setEncodeBlanks(boolean)}\n * but is not volatile, and accesses are not synchronized.\n * If an instance of the class is shared between threads, the caller needs to ensure that suitable synchronization\n * is used to ensure safe publication of the value between threads, and must not invoke\n * {@link #setEncodeBlanks(boolean)} after initial setup.\n * </p>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">MIME (Multipurpose Internet Mail Extensions) Part Two: Message\n *          Header Extensions for Non-ASCII Text</a>\n *\n * @since 1.3\n ",
      "methods": {
        "decode": {
          "Javadoc": "* Decodes a quoted-printable string into its original form. Escaped characters are converted back to their original\n     * representation.\n     *\n     * @param str\n     *            quoted-printable string to convert into its original form\n     * @return original string\n     * @throws DecoderException\n     *             A decoder exception is thrown if a failure condition is encountered during the decode process."
        },
        "encode": {
          "Javadoc": "* Encodes a string into its quoted-printable form using the specified Charset. Unsafe characters are escaped.\n     *\n     * @param sourceStr\n     *            string to convert to quoted-printable form\n     * @param sourceCharset\n     *            the Charset for sourceStr\n     * @return quoted-printable string\n     * @throws EncoderException\n     *             thrown if a failure condition is encountered during the encoding process."
        },
        "isEncodeBlanks": {
          "Javadoc": "* Tests if optional transformation of SPACE characters is to be used\n     *\n     * @return {@code true} if SPACE characters are to be transformed, {@code false} otherwise"
        },
        "setEncodeBlanks": {
          "Javadoc": "* Defines whether optional transformation of SPACE characters is to be used\n     *\n     * @param b\n     *            {@code true} if SPACE characters are to be transformed, {@code false} otherwise"
        }
      }
    },
    "org.apache.commons.codec.net.QuotedPrintableCodec": {
      "Javadoc": "\n * Codec for the Quoted-Printable section of <a href=\"http://www.ietf.org/rfc/rfc1521.txt\">RFC 1521</a>.\n * <p>\n * The Quoted-Printable encoding is intended to represent data that largely consists of octets that correspond to\n * printable characters in the ASCII character set. It encodes the data in such a way that the resulting octets are\n * unlikely to be modified by mail transport. If the data being encoded are mostly ASCII text, the encoded form of the\n * data remains largely recognizable by humans. A body which is entirely ASCII may also be encoded in Quoted-Printable\n * to ensure the integrity of the data should the message pass through a character- translating, and/or line-wrapping\n * gateway.\n * </p>\n * <p>\n * Note:\n * </p>\n * <p>\n * Depending on the selected {@code strict} parameter, this class will implement a different set of rules of the\n * quoted-printable spec:\n * </p>\n * <ul>\n *   <li>{@code strict=false}: only rules #1 and #2 are implemented</li>\n *   <li>{@code strict=true}: all rules #1 through #5 are implemented</li>\n * </ul>\n * <p>\n * Originally, this class only supported the non-strict mode, but the codec in this partial form could already be used\n * for certain applications that do not require quoted-printable line formatting (rules #3, #4, #5), for instance\n * Q codec. The strict mode has been added in 1.10.\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc1521.txt\">RFC 1521 MIME (Multipurpose Internet Mail Extensions) Part One:\n *          Mechanisms for Specifying and Describing the Format of Internet Message Bodies </a>\n *\n * @since 1.3\n ",
      "methods": {
        "decodeQuotedPrintable": {
          "Javadoc": "* Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     * <p>\n     * This function fully implements the quoted-printable encoding specification (rule #1 through rule #5) as\n     * defined in RFC 1521.\n     * </p>\n     *\n     * @param bytes\n     *            array of quoted-printable characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if quoted-printable decoding is unsuccessful"
        },
        "encodeByte": {
          "Javadoc": "* Encodes a byte in the buffer.\n     *\n     * @param b\n     *            byte to write\n     * @param encode\n     *            indicates whether the octet shall be encoded\n     * @param buffer\n     *            the buffer to write to\n     * @return the number of bytes that have been written to the buffer"
        },
        "encodeQuotedPrintable": {
          "Javadoc": "* Encodes byte into its quoted-printable representation.\n     *\n     * @param b\n     *            byte to encode\n     * @param buffer\n     *            the buffer to write to\n     * @return The number of bytes written to the {@code buffer}"
        },
        "getUnsignedOctet": {
          "Javadoc": "* Gets the byte at position {@code index} of the byte array and\n     * make sure it is unsigned.\n     *\n     * @param index\n     *            position in the array\n     * @param bytes\n     *            the byte array\n     * @return the unsigned octet at position {@code index} from the array"
        },
        "isWhitespace": {
          "Javadoc": "* Checks whether the given byte is whitespace.\n     *\n     * @param b\n     *            byte to be checked\n     * @return {@code true} if the byte is either a space or tab character"
        },
        "decode": {
          "Javadoc": "* Decodes a quoted-printable string into its original form using the specified string Charset. Escaped characters\n     * are converted back to their original representation.\n     *\n     * @param sourceStr\n     *            quoted-printable string to convert into its original form\n     * @param sourceCharset\n     *            the original string Charset\n     * @return original string\n     * @throws DecoderException\n     *             Thrown if quoted-printable decoding is unsuccessful\n     * @throws UnsupportedEncodingException\n     *             Thrown if Charset is not supported"
        },
        "encode": {
          "Javadoc": "* Encodes a string into its quoted-printable form using the specified Charset. Unsafe characters are escaped.\n     * <p>\n     * Depending on the selection of the {@code strict} parameter, this function either implements the full ruleset\n     * or only a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in\n     * RFC 1521 and is suitable for encoding binary data and unformatted text.\n     * </p>\n     *\n     * @param sourceStr\n     *            string to convert to quoted-printable form\n     * @param sourceCharset\n     *            the Charset for sourceStr\n     * @return quoted-printable string\n     * @throws UnsupportedEncodingException\n     *             Thrown if the Charset is not supported"
        },
        "getCharset": {
          "Javadoc": "* Gets the default Charset name used for string decoding and encoding.\n     *\n     * @return the default Charset name\n     * @since 1.7"
        },
        "getDefaultCharset": {
          "Javadoc": "* Gets the default Charset name used for string decoding and encoding.\n     *\n     * @return the default Charset name"
        }
      }
    },
    "org.apache.commons.codec.net.RFC1522Codec": {
      "Javadoc": "\n * Implements methods common to all codecs defined in RFC 1522.\n * <p>\n * <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">RFC 1522</a> describes techniques to allow the\n * encoding of non-ASCII text in various portions of a RFC 822 [2] message header, in a manner which\n * is unlikely to confuse existing message handling software.\n * </p>\n * <p>\n * This class is immutable and thread-safe.\n * </p>\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc1522.txt\">MIME (Multipurpose Internet Mail Extensions) Part Two:\n *          Message Header Extensions for Non-ASCII Text</a>\n * @since 1.3\n ",
      "methods": {
        "decodeText": {
          "Javadoc": "* Applies an RFC 1522 compliant decoding scheme to the given string of text.\n     * <p>\n     * This method processes the \"encoded-word\" header common to all the RFC 1522 codecs and then invokes\n     * {@link #doDecoding(byte[])}  method of a concrete class to perform the specific decoding.\n     * </p>\n     *\n     * @param text\n     *            a string to decode\n     * @return A new decoded String or {@code null} if the input is {@code null}.\n     * @throws DecoderException\n     *             thrown if there is an error condition during the decoding process.\n     * @throws UnsupportedEncodingException\n     *             thrown if charset specified in the \"encoded-word\" header is not supported"
        },
        "doDecoding": {
          "Javadoc": "* Decodes an array of bytes using the defined encoding scheme.\n     *\n     * @param bytes\n     *            Data to be decoded\n     * @return a byte array that contains decoded data\n     * @throws DecoderException\n     *             A decoder exception is thrown if a Decoder encounters a failure condition during the decode process."
        },
        "doEncoding": {
          "Javadoc": "* Encodes an array of bytes using the defined encoding scheme.\n     *\n     * @param bytes\n     *            Data to be encoded\n     * @return A byte array containing the encoded data\n     * @throws EncoderException\n     *             thrown if the Encoder encounters a failure condition during the encoding process."
        },
        "encodeText": {
          "Javadoc": "* Applies an RFC 1522 compliant encoding scheme to the given string of text with the given charset.\n     * <p>\n     * This method constructs the \"encoded-word\" header common to all the RFC 1522 codecs and then invokes\n     * {@link #doEncoding(byte[])}  method of a concrete class to perform the specific encoding.\n     * </p>\n     *\n     * @param text\n     *            a string to encode\n     * @param charsetName\n     *            the charset to use\n     * @return RFC 1522 compliant \"encoded-word\"\n     * @throws EncoderException\n     *             thrown if there is an error condition during the Encoding process.\n     * @throws UnsupportedCharsetException\n     *             if charset is not available\n     * @see Charset"
        },
        "getCharset": {
          "Javadoc": "* Gets the default Charset name used for string decoding and encoding.\n     *\n     * @return the default Charset name\n     * @since 1.7"
        },
        "getDefaultCharset": {
          "Javadoc": "* Gets the default Charset name used for string decoding and encoding.\n     *\n     * @return the default Charset name"
        },
        "getEncoding": {
          "Javadoc": "* Returns the codec name (referred to as encoding in the RFC 1522).\n     *\n     * @return name of the codec."
        }
      }
    },
    "org.apache.commons.codec.net.URLCodec": {
      "Javadoc": "\n * Implements the 'www-form-urlencoded' encoding scheme, also misleadingly known as URL encoding.\n * <p>\n * This codec is meant to be a replacement for standard Java classes {@link java.net.URLEncoder} and\n * {@link java.net.URLDecoder} on older Java platforms, as these classes in Java versions below\n * 1.4 rely on the platform's default charset encoding.\n * </p>\n * <p>\n * This class is thread-safe as of 1.11\n * </p>\n *\n * @see <a href=\"http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1\">Chapter 17.13.4 Form content types</a>\n *           of the <a href=\"http://www.w3.org/TR/html4/\">HTML 4.01 Specification</a>\n *\n * @since 1.2\n ",
      "methods": {
        "decodeUrl": {
          "Javadoc": "* Decodes an array of URL safe 7-bit characters into an array of original bytes. Escaped characters are converted\n     * back to their original representation.\n     *\n     * @param bytes\n     *            array of URL safe characters\n     * @return array of original bytes\n     * @throws DecoderException\n     *             Thrown if URL decoding is unsuccessful"
        },
        "encodeUrl": {
          "Javadoc": "* Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.\n     *\n     * @param urlsafe\n     *            bitset of characters deemed URL safe\n     * @param bytes\n     *            array of bytes to convert to URL safe characters\n     * @return array of bytes containing URL safe characters"
        },
        "decode": {
          "Javadoc": "* Decodes a URL safe string into its original form using the specified encoding. Escaped characters are converted\n     * back to their original representation.\n     *\n     * @param str\n     *            URL safe string to convert into its original form\n     * @param charsetName\n     *            the original string charset\n     * @return original string\n     * @throws DecoderException\n     *             Thrown if URL decoding is unsuccessful\n     * @throws UnsupportedEncodingException\n     *             Thrown if charset is not supported"
        },
        "encode": {
          "Javadoc": "* Encodes a string into its URL safe form using the specified string charset. Unsafe characters are escaped.\n     *\n     * @param str\n     *            string to convert to a URL safe form\n     * @param charsetName\n     *            the charset for str\n     * @return URL safe string\n     * @throws UnsupportedEncodingException\n     *             Thrown if charset is not supported"
        },
        "getDefaultCharset": {
          "Javadoc": "* The default charset used for string decoding and encoding.\n     *\n     * @return the default string charset."
        },
        "getEncoding": {
          "Javadoc": "* The {@code String} encoding used for decoding and encoding.\n     *\n     * @return Returns the encoding.\n     *\n     * @deprecated Use {@link #getDefaultCharset()}, will be removed in 2.0."
        }
      }
    },
    "org.apache.commons.codec.net.Utils": {
      "Javadoc": "\n * Utility methods for this package.\n *\n * <p>This class is immutable and thread-safe.</p>\n *\n * @since 1.4\n ",
      "methods": {
        "digit16": {
          "Javadoc": "* Returns the numeric value of the character {@code b} in radix 16.\n     *\n     * @param b\n     *            The byte to be converted.\n     * @return The numeric value represented by the character in radix 16.\n     *\n     * @throws DecoderException\n     *             Thrown when the byte is not valid per {@link Character#digit(char,int)}"
        },
        "hexDigit": {
          "Javadoc": "* Returns the upper case hexadecimal digit of the lower 4 bits of the int.\n     *\n     * @param b the input int\n     * @return the upper case hexadecimal digit of the lower 4 bits of the int."
        }
      }
    },
    "org.apache.commons.codec.Resources": {
      "Javadoc": "\n * Consider this class package private. Helps load resources.\n *\n * @since 1.12\n ",
      "methods": {
        "getInputStream": {
          "Javadoc": "* Opens the given named resource from the given class.\n     *\n     * @param name The resource name.\n     * @return An input stream."
        }
      }
    },
    "org.apache.commons.codec.StringDecoder": {
      "Javadoc": "\n * Defines common decoding methods for String decoders.\n ",
      "methods": {
        "decode": {
          "Javadoc": "* Decodes a String and returns a String.\n     *\n     * @param source\n     *            the String to decode\n     * @return the encoded String\n     * @throws DecoderException\n     *             thrown if there is an error condition during the Encoding process."
        }
      }
    },
    "org.apache.commons.codec.StringEncoder": {
      "Javadoc": "\n * Defines common encoding methods for String encoders.\n ",
      "methods": {
        "encode": {
          "Javadoc": "* Encodes a String and returns a String.\n     *\n     * @param source\n     *            the String to encode\n     * @return the encoded String\n     * @throws EncoderException\n     *             thrown if there is an error condition during the encoding process."
        }
      }
    },
    "org.apache.commons.codec.StringEncoderComparator": {
      "Javadoc": "\n * Compares Strings using a {@link StringEncoder}. This comparator is used to sort Strings by an encoding scheme such as\n * Soundex, Metaphone, etc. This class can come in handy if one need to sort Strings by an encoded form of a name such\n * as Soundex.\n *\n * <p>This class is immutable and thread-safe.</p>\n ",
      "methods": {
        "compare": {
          "Javadoc": "* Compares two strings based not on the strings themselves, but on an encoding of the two strings using the\n     * StringEncoder this Comparator was created with.\n     *\n     * If an {@link EncoderException} is encountered, return {@code 0}.\n     *\n     * @param o1\n     *            the object to compare\n     * @param o2\n     *            the object to compare to\n     * @return the Comparable.compareTo() return code or 0 if an encoding error was caught.\n     * @see Comparable"
        }
      }
    },
    "org.apache.commons.codec.AbstractStringEncoderTest": {
      "Javadoc": "\n "
    },
    "org.apache.commons.codec.binary.AllocateDirectHexTest": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.binary.Base16InputStreamTest": {
      "Javadoc": "\n ",
      "methods": {
        "testAvailable": {
          "Javadoc": "* Tests skipping past the end of a stream.\n     *\n     * @throws IOException for some failure scenarios."
        },
        "testBase16EmptyInputStream": {
          "Javadoc": "* Tests the Base16InputStream implementation against empty input.\n     *\n     * @throws IOException for some failure scenarios."
        },
        "testBase16InputStreamByChunk": {
          "Javadoc": "* Tests the Base16InputStream implementation.\n     *\n     * @throws IOException for some failure scenarios."
        },
        "testBase16InputStreamByteByByte": {
          "Javadoc": "* Tests the Base16InputStream implementation.\n     *\n     * @throws IOException for some failure scenarios."
        },
        "testByChunk": {
          "Javadoc": "* Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base16InputStream wraps itself in encode and decode mode over and over again.\n     *\n     * @param encoded   Base16 encoded data\n     * @param decoded   the data from above, but decoded\n     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet\n     * @throws IOException Usually signifies a bug in the Base16 commons-codec implementation."
        },
        "testByteByByte": {
          "Javadoc": "* Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base16InputStream wraps itself in encode and decode mode over and over again.\n     *\n     * @param encoded   Base16 encoded data\n     * @param decoded   the data from above, but decoded\n     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet\n     * @throws IOException Usually signifies a bug in the Base16 commons-codec implementation."
        },
        "testMarkSupported": {
          "Javadoc": "* Tests markSupported.\n     *\n     * @throws IOException for some failure scenarios."
        },
        "testRead0": {
          "Javadoc": "* Tests read returning 0\n     *\n     * @throws IOException for some failure scenarios."
        },
        "testReadNull": {
          "Javadoc": "* Tests read with null.\n     *\n     * @throws IOException for some failure scenarios."
        },
        "testReadOutOfBounds": {
          "Javadoc": "* Tests read throwing IndexOutOfBoundsException\n     *\n     * @throws IOException for some failure scenarios."
        },
        "testSkipBig": {
          "Javadoc": "* Tests skipping number of characters larger than the internal buffer.\n     *\n     * @throws IOException for some failure scenarios."
        },
        "testSkipNone": {
          "Javadoc": "* Tests skipping as a noop\n     *\n     * @throws IOException for some failure scenarios."
        },
        "testSkipPastEnd": {
          "Javadoc": "* Tests skipping past the end of a stream.\n     *\n     * @throws IOException for some failure scenarios."
        },
        "testSkipToEnd": {
          "Javadoc": "* Tests skipping to the end of a stream.\n     *\n     * @throws IOException for some failure scenarios."
        },
        "testSkipWrongArgument": {
          "Javadoc": "* Tests if negative arguments to skip are handled correctly.\n     *\n     * @throws IOException for some failure scenarios."
        }
      }
    },
    "org.apache.commons.codec.binary.Base16OutputStreamTest": {
      "Javadoc": "\n ",
      "methods": {
        "testBase16EmptyOutputStream": {
          "Javadoc": "* Test the Base16OutputStream implementation against empty input.\n     *\n     * @throws IOException for some failure scenarios.."
        },
        "testBase16OutputStreamByChunk": {
          "Javadoc": "* Test the Base16OutputStream implementation\n     *\n     * @throws IOException for some failure scenarios."
        },
        "testBase16OutputStreamByteByByte": {
          "Javadoc": "* Test the Base16OutputStream implementation\n     *\n     * @throws IOException for some failure scenarios."
        },
        "testByChunk": {
          "Javadoc": "* Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base16OutputStream wraps itself in encode and decode\n     * mode over and over again.\n     *\n     * @param encoded base16 encoded data\n     * @param decoded the data from above, but decoded\n     * @param lowerCase if {@code true} then use a lower-case Base16 alphabet\n     * @throws IOException Usually signifies a bug in the Base16 commons-codec implementation."
        },
        "testByteByByte": {
          "Javadoc": "* Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base16OutputStream wraps itself in encode and decode\n     * mode over and over again.\n     *\n     * @param encoded base16 encoded data\n     * @param decoded the data from above, but decoded\n     * @throws IOException Usually signifies a bug in the Base16 commons-codec implementation."
        },
        "testWriteOutOfBounds": {
          "Javadoc": "* Tests Base16OutputStream.write for expected IndexOutOfBoundsException conditions.\n     *\n     * @throws IOException for some failure scenarios."
        },
        "testWriteToNullCoverage": {
          "Javadoc": "* Tests Base16OutputStream.write(null).\n     *\n     * @throws IOException for some failure scenarios."
        }
      }
    },
    "org.apache.commons.codec.binary.Base16Test": {
      "Javadoc": "\n * Test cases for Base16 class.\n ",
      "methods": {
        "getRandom": {
          "Javadoc": "* @return Returns the random."
        },
        "testBase16": {
          "Javadoc": "* Test the Base16 implementation"
        },
        "testCodec68": {
          "Javadoc": "* isBase16 throws RuntimeException on some non-Base16 bytes"
        },
        "testEmptyBase16": {
          "Javadoc": "* Test encode and decode of empty byte array."
        }
      }
    },
    "org.apache.commons.codec.binary.Base16TestData": {
      "Javadoc": "\n * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between\n * Commons-Codec and OpenSSL.\n "
    },
    "org.apache.commons.codec.binary.Base32InputStreamTest": {
      "Javadoc": "",
      "methods": {
        "testAvailable": {
          "Javadoc": "* Tests skipping past the end of a stream.\n     *\n     * @throws Throwable\n     *             for some failure scenarios."
        },
        "testBase32EmptyInputStreamMimeChuckSize": {
          "Javadoc": "* Tests the Base32InputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testBase32EmptyInputStreamPemChuckSize": {
          "Javadoc": "* Tests the Base32InputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testBase32InputStreamByChunk": {
          "Javadoc": "* Tests the Base32InputStream implementation.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testBase32InputStreamByteByByte": {
          "Javadoc": "* Tests the Base32InputStream implementation.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testByChunk": {
          "Javadoc": "* Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32InputStream wraps itself in encode and decode mode over and over\n     * again.\n     *\n     * @param encoded\n     *            base32 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the base32 encoded data.\n     * @param separator\n     *            Line separator in the base32 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base32 commons-codec implementation."
        },
        "testByteByByte": {
          "Javadoc": "* Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32InputStream wraps itself in encode and decode mode over and over\n     * again.\n     *\n     * @param encoded\n     *            base32 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the base32 encoded data.\n     * @param separator\n     *            Line separator in the base32 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base32 commons-codec implementation."
        },
        "testCodec105": {
          "Javadoc": "* Tests the bug reported in CODEC-105. Bad interactions with InputStream when reading one byte at a time."
        },
        "testCodec130": {
          "Javadoc": "* Tests the problem reported in CODEC-130. Missing / wrong implementation of skip."
        },
        "testMarkSupported": {
          "Javadoc": "* Tests markSupported.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testRead0": {
          "Javadoc": "* Tests read returning 0\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testReadNull": {
          "Javadoc": "* Tests read with null.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testReadOutOfBounds": {
          "Javadoc": "* Tests read throwing IndexOutOfBoundsException\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testSkipBig": {
          "Javadoc": "* Tests skipping number of characters larger than the internal buffer.\n     *\n     * @throws Throwable\n     *             for some failure scenarios."
        },
        "testSkipNone": {
          "Javadoc": "* Tests skipping as a noop\n     *\n     * @throws Throwable\n     *             for some failure scenarios."
        },
        "testSkipPastEnd": {
          "Javadoc": "* Tests skipping past the end of a stream.\n     *\n     * @throws Throwable\n     *             for some failure scenarios."
        },
        "testSkipToEnd": {
          "Javadoc": "* Tests skipping to the end of a stream.\n     *\n     * @throws Throwable\n     *             for some failure scenarios."
        },
        "testSkipWrongArgument": {
          "Javadoc": "* Tests if negative arguments to skip are handled correctly.\n     *\n     * @throws Throwable\n     *             for some failure scenarios."
        },
        "testStrictDecoding": {
          "Javadoc": "* Test strict decoding.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        }
      }
    },
    "org.apache.commons.codec.binary.Base32OutputStreamTest": {
      "Javadoc": "",
      "methods": {
        "testBase32EmptyOutputStreamMimeChunkSize": {
          "Javadoc": "* Test the Base32OutputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testBase32EmptyOutputStreamPemChunkSize": {
          "Javadoc": "* Test the Base32OutputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testBase32OutputStreamByChunk": {
          "Javadoc": "* Test the Base32OutputStream implementation\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testBase32OutputStreamByteByByte": {
          "Javadoc": "* Test the Base32OutputStream implementation\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testByChunk": {
          "Javadoc": "* Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32OutputStream wraps itself in encode and decode\n     * mode over and over again.\n     *\n     * @param encoded\n     *            Base32 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the Base32 encoded data.\n     * @param separator\n     *            Line separator in the Base32 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base32 commons-codec implementation."
        },
        "testByteByByte": {
          "Javadoc": "* Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base32OutputStream wraps itself in encode and decode\n     * mode over and over again.\n     *\n     * @param encoded\n     *            Base32 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the Base32 encoded data.\n     * @param separator\n     *            Line separator in the Base32 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base32 commons-codec implementation."
        },
        "testStrictDecoding": {
          "Javadoc": "* Test strict decoding.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testWriteOutOfBounds": {
          "Javadoc": "* Tests Base32OutputStream.write for expected IndexOutOfBoundsException conditions.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testWriteToNullCoverage": {
          "Javadoc": "* Tests Base32OutputStream.write(null).\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        }
      }
    },
    "org.apache.commons.codec.binary.Base32Test": {
      "Javadoc": "",
      "methods": {
        "assertBase32DecodingOfTrailingBits": {
          "Javadoc": "* Test base 32 decoding of the final trailing bits. Trailing encoded bytes\n     * cannot fit exactly into 5-bit characters so the last character has a limited\n     * alphabet where the final bits are zero. This asserts that illegal final\n     * characters throw an exception when decoding.\n     *\n     * @param nbits the number of trailing bits (must be a factor of 5 and {@code <40})"
        },
        "testEmptyBase32": {
          "Javadoc": "* Test encode and decode of empty byte array."
        }
      }
    },
    "org.apache.commons.codec.binary.Base32TestData": {
      "Javadoc": "\n * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between\n * Commons-Codec and OpenSSL. Notice that OpenSSL creates 64 character lines instead of the 76 of Commons-Codec.\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n "
    },
    "org.apache.commons.codec.binary.Base64Codec13Test": {
      "Javadoc": "\n * Tests to make sure future versions of commons-codec.jar have identical Base64\n * behavior as commons-codec-1.3.jar.\n ",
      "methods": {
        "testBinaryDecoder": {
          "Javadoc": "* Tests to make sure Base64's implementation of the org.apache.commons.codec.BinaryDecoder\n     * interface is behaving identical to commons-codec-1.3.jar.\n     *\n     * @throws DecoderException problem"
        },
        "testBinaryEncoder": {
          "Javadoc": "* Tests to make sure Base64's implementation of the org.apache.commons.codec.BinaryEncoder\n     * interface is behaving identical to commons-codec-1.3.jar.\n     *\n     * @throws EncoderException problem"
        },
        "testDecoder": {
          "Javadoc": "* Tests to make sure Base64's implementation of the org.apache.commons.codec.Decoder\n     * interface is behaving identical to commons-codec-1.3.jar.\n     *\n     * @throws DecoderException problem"
        },
        "testEncoder": {
          "Javadoc": "* Tests to make sure Base64's implementation of the org.apache.commons.codec.Encoder\n     * interface is behaving identical to commons-codec-1.3.jar.\n     *\n     * @throws EncoderException problem"
        },
        "testStaticDecode": {
          "Javadoc": "* Tests to make sure Base64's implementation of Base64.decodeBase64()\n     * static method is behaving identical to commons-codec-1.3.jar."
        },
        "testStaticDecodeChunked": {
          "Javadoc": "* Tests to make sure Base64's implementation of Base64.decodeBase64()\n     * static method is behaving identical to commons-codec-1.3.jar when\n     * supplied with chunked input."
        },
        "testStaticEncode": {
          "Javadoc": "* Tests to make sure Base64's implementation of Base64.encodeBase64()\n     * static method is behaving identical to commons-codec-1.3.jar."
        },
        "testStaticEncodeChunked": {
          "Javadoc": "* Tests to make sure Base64's implementation of Base64.encodeBase64Chunked()\n     * static method is behaving identical to commons-codec-1.3.jar."
        }
      }
    },
    "org.apache.commons.codec.binary.Base64InputStreamTest": {
      "Javadoc": "\n ",
      "methods": {
        "testAvailable": {
          "Javadoc": "* Tests skipping past the end of a stream.\n     *\n     * @throws Throwable\n     *             for some failure scenarios."
        },
        "testBase64EmptyInputStreamMimeChuckSize": {
          "Javadoc": "* Tests the Base64InputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testBase64EmptyInputStreamPemChuckSize": {
          "Javadoc": "* Tests the Base64InputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testBase64InputStreamByChunk": {
          "Javadoc": "* Tests the Base64InputStream implementation.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testBase64InputStreamByteByByte": {
          "Javadoc": "* Tests the Base64InputStream implementation.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testByChunk": {
          "Javadoc": "* Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode over and over\n     * again.\n     *\n     * @param encoded\n     *            base64 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the base64 encoded data.\n     * @param separator\n     *            Line separator in the base64 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base64 commons-codec implementation."
        },
        "testByteByByte": {
          "Javadoc": "* Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded\n     * ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64InputStream wraps itself in encode and decode mode over and over\n     * again.\n     *\n     * @param encoded\n     *            base64 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the base64 encoded data.\n     * @param separator\n     *            Line separator in the base64 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base64 commons-codec implementation."
        },
        "testCodec101": {
          "Javadoc": "* Test for the CODEC-101 bug: InputStream.read(byte[]) should never return 0 because Java's builtin InputStreamReader hates that.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testCodec105": {
          "Javadoc": "* Tests the bug reported in CODEC-105. Bad interactions with InputStream when reading one byte at a time."
        },
        "testCodec130": {
          "Javadoc": "* Tests the problem reported in CODEC-130. Missing / wrong implementation of skip."
        },
        "testCodec98NPE": {
          "Javadoc": "* Test the Base64InputStream implementation against the special NPE inducing input identified in the CODEC-98 bug.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testInputStreamReader": {
          "Javadoc": "* Another test for the CODEC-101 bug: In commons-codec-1.4 this test shows InputStreamReader explicitly hating an\n     * InputStream.read(byte[]) return of 0:\n     *\n     * java.io.IOException: Underlying input stream returned zero bytes at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:268) at\n     * sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158) at\n     * java.io.InputStreamReader.read(InputStreamReader.java:167) at java.io.BufferedReader.fill(BufferedReader.java:136) at\n     * java.io.BufferedReader.readLine(BufferedReader.java:299) at java.io.BufferedReader.readLine(BufferedReader.java:362) at\n     * org.apache.commons.codec.binary.Base64InputStreamTest.testInputStreamReader(Base64InputStreamTest.java:75)\n     *\n     * But in commons-codec-1.5 it's fixed. :-)\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testMarkSupported": {
          "Javadoc": "* Tests markSupported.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testRead0": {
          "Javadoc": "* Tests read returning 0\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testReadMultipleBufferSizes": {
          "Javadoc": "* Tests read using different buffer sizes\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testReadNull": {
          "Javadoc": "* Tests read with null.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testReadOutOfBounds": {
          "Javadoc": "* Tests read throwing IndexOutOfBoundsException\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testSkipBig": {
          "Javadoc": "* Tests skipping number of characters larger than the internal buffer.\n     *\n     * @throws Throwable\n     *             for some failure scenarios."
        },
        "testSkipNone": {
          "Javadoc": "* Tests skipping as a noop\n     *\n     * @throws Throwable\n     *             for some failure scenarios."
        },
        "testSkipPastEnd": {
          "Javadoc": "* Tests skipping past the end of a stream.\n     *\n     * @throws Throwable\n     *             for some failure scenarios."
        },
        "testSkipToEnd": {
          "Javadoc": "* Tests skipping to the end of a stream.\n     *\n     * @throws Throwable\n     *             for some failure scenarios."
        },
        "testSkipWrongArgument": {
          "Javadoc": "* Tests if negative arguments to skip are handled correctly.\n     *\n     * @throws Throwable\n     *             for some failure scenarios."
        },
        "testStrictDecoding": {
          "Javadoc": "* Test strict decoding.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        }
      }
    },
    "org.apache.commons.codec.binary.Base64OutputStreamTest": {
      "Javadoc": "\n ",
      "methods": {
        "testBase64EmptyOutputStreamMimeChunkSize": {
          "Javadoc": "* Test the Base64OutputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testBase64EmptyOutputStreamPemChunkSize": {
          "Javadoc": "* Test the Base64OutputStream implementation against empty input.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testBase64OutputStreamByChunk": {
          "Javadoc": "* Test the Base64OutputStream implementation\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testBase64OutputStreamByteByByte": {
          "Javadoc": "* Test the Base64OutputStream implementation\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testByChunk": {
          "Javadoc": "* Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64OutputStream wraps itself in encode and decode\n     * mode over and over again.\n     *\n     * @param encoded\n     *            base64 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the base64 encoded data.\n     * @param separator\n     *            Line separator in the base64 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base64 commons-codec implementation."
        },
        "testByteByByte": {
          "Javadoc": "* Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->\n     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded\n     * <p/>\n     * By \"[WRAP-WRAP-WRAP-etc...]\" we mean situation where the Base64OutputStream wraps itself in encode and decode\n     * mode over and over again.\n     *\n     * @param encoded\n     *            base64 encoded data\n     * @param decoded\n     *            the data from above, but decoded\n     * @param chunkSize\n     *            chunk size (line-length) of the base64 encoded data.\n     * @param separator\n     *            Line separator in the base64 encoded data.\n     * @throws Exception\n     *             Usually signifies a bug in the Base64 commons-codec implementation."
        },
        "testCodec98NPE": {
          "Javadoc": "* Test the Base64OutputStream implementation against the special NPE inducing input\n     * identified in the CODEC-98 bug.\n     *\n     * @throws Exception for some failure scenarios."
        },
        "testStrictDecoding": {
          "Javadoc": "* Test strict decoding.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testWriteOutOfBounds": {
          "Javadoc": "* Tests Base64OutputStream.write for expected IndexOutOfBoundsException conditions.\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        },
        "testWriteToNullCoverage": {
          "Javadoc": "* Tests Base64OutputStream.write(null).\n     *\n     * @throws Exception\n     *             for some failure scenarios."
        }
      }
    },
    "org.apache.commons.codec.binary.Base64Test": {
      "Javadoc": "\n * Test cases for Base64 class.\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n ",
      "methods": {
        "assertBase64DecodingOfTrailingBits": {
          "Javadoc": "* Test base 64 decoding of the final trailing bits. Trailing encoded bytes\n     * cannot fit exactly into 6-bit characters so the last character has a limited\n     * alphabet where the final bits are zero. This asserts that illegal final\n     * characters throw an exception when decoding.\n     *\n     * @param nbits the number of trailing bits (must be a factor of 6 and {@code <24})"
        },
        "getRandom": {
          "Javadoc": "* @return Returns the random."
        },
        "testBase64": {
          "Javadoc": "* Test the Base64 implementation"
        },
        "testChunkedEncodeMultipleOf76": {
          "Javadoc": "* Tests Base64.encodeBase64()."
        },
        "testCodec263": {
          "Javadoc": "* Tests <a href=\"https://issues.apache.org/jira/browse/CODEC-263\">CODEC-263</a>."
        },
        "testCodec265": {
          "Javadoc": "* Test for CODEC-265: Encode a 1GiB file.\n     *\n     * @see <a href=\"https://issues.apache.org/jira/projects/CODEC/issues/CODEC-265\">CODEC-265</a>"
        },
        "testCodec68": {
          "Javadoc": "* CODEC-68: isBase64 throws ArrayIndexOutOfBoundsException on some\n     * non-BASE64 bytes"
        },
        "testDecodePadMarkerIndex2": {
          "Javadoc": "* Tests conditional true branch for \"marker0\" test."
        },
        "testDecodePadMarkerIndex3": {
          "Javadoc": "* Tests conditional branches for \"marker1\" test."
        },
        "testDecodeWithInnerPad": {
          "Javadoc": "* Test our decode with pad character in the middle. (Our current\n     * implementation: halt decode and return what we've got so far).\n     *\n     * The point of this test is not to say\n     * \"this is the correct way to decode base64.\" The point is simply to keep\n     * us aware of the current logic since 1.4 so we don't accidentally break it\n     * without realizing.\n     *\n     * Note for historians. The 1.3 logic would decode to:\n     * \"Hello World\\u0000Hello World\" -- null in the middle --- and 1.4\n     * unwittingly changed it to current logic."
        },
        "testEmptyBase64": {
          "Javadoc": "* Test encode and decode of empty byte array."
        },
        "testHugeLineSeparator": {
          "Javadoc": "* Tests a lineSeparator much bigger than DEFAULT_BUFFER_SIZE.\n     *\n     * @see \"<a href='https://mail-archives.apache.org/mod_mbox/commons-dev/201202.mbox/%3C4F3C85D7.5060706@snafu.de%3E'>dev@commons.apache.org</a>\""
        },
        "testIsStringBase64": {
          "Javadoc": "* Test the isStringBase64 method."
        },
        "testIsUrlSafe": {
          "Javadoc": "* Tests isUrlSafe."
        },
        "testRfc1421Section6Dot8ChunkSizeDefinition": {
          "Javadoc": "* Tests RFC 1421 section 4.3.2.4 chuck size definition."
        },
        "testRfc2045Section2Dot1CrLfDefinition": {
          "Javadoc": "* Tests RFC 2045 section 2.1 CRLF definition."
        },
        "testRfc2045Section6Dot8ChunkSizeDefinition": {
          "Javadoc": "* Tests RFC 2045 section 6.8 chuck size definition."
        },
        "testRfc4648Section10Decode": {
          "Javadoc": "* Tests RFC 4648 section 10 test vectors.\n     * <ul>\n     * <li>BASE64(\"\") = \"\"</li>\n     * <li>BASE64(\"f\") = \"Zg==\"</li>\n     * <li>BASE64(\"fo\") = \"Zm8=\"</li>\n     * <li>BASE64(\"foo\") = \"Zm9v\"</li>\n     * <li>BASE64(\"foob\") = \"Zm9vYg==\"</li>\n     * <li>BASE64(\"fooba\") = \"Zm9vYmE=\"</li>\n     * <li>BASE64(\"foobar\") = \"Zm9vYmFy\"</li>\n     * </ul>\n     *\n     * @see <a href=\"https://tools.ietf.org/html/rfc4648\">https://tools.ietf.org/\n     *      html/rfc4648</a>"
        },
        "testRfc4648Section10DecodeEncode": {
          "Javadoc": "* Tests RFC 4648 section 10 test vectors.\n     * <ul>\n     * <li>BASE64(\"\") = \"\"</li>\n     * <li>BASE64(\"f\") = \"Zg==\"</li>\n     * <li>BASE64(\"fo\") = \"Zm8=\"</li>\n     * <li>BASE64(\"foo\") = \"Zm9v\"</li>\n     * <li>BASE64(\"foob\") = \"Zm9vYg==\"</li>\n     * <li>BASE64(\"fooba\") = \"Zm9vYmE=\"</li>\n     * <li>BASE64(\"foobar\") = \"Zm9vYmFy\"</li>\n     * </ul>\n     *\n     * @see <a href=\"https://tools.ietf.org/html/rfc4648\">https://tools.ietf.org/\n     *      html/rfc4648</a>"
        },
        "testRfc4648Section10DecodeWithCrLf": {
          "Javadoc": "* Tests RFC 4648 section 10 test vectors.\n     * <ul>\n     * <li>BASE64(\"\") = \"\"</li>\n     * <li>BASE64(\"f\") = \"Zg==\"</li>\n     * <li>BASE64(\"fo\") = \"Zm8=\"</li>\n     * <li>BASE64(\"foo\") = \"Zm9v\"</li>\n     * <li>BASE64(\"foob\") = \"Zm9vYg==\"</li>\n     * <li>BASE64(\"fooba\") = \"Zm9vYmE=\"</li>\n     * <li>BASE64(\"foobar\") = \"Zm9vYmFy\"</li>\n     * </ul>\n     *\n     * @see <a href=\"https://tools.ietf.org/html/rfc4648\">https://tools.ietf.org/\n     *      html/rfc4648</a>"
        },
        "testRfc4648Section10Encode": {
          "Javadoc": "* Tests RFC 4648 section 10 test vectors.\n     * <ul>\n     * <li>BASE64(\"\") = \"\"</li>\n     * <li>BASE64(\"f\") = \"Zg==\"</li>\n     * <li>BASE64(\"fo\") = \"Zm8=\"</li>\n     * <li>BASE64(\"foo\") = \"Zm9v\"</li>\n     * <li>BASE64(\"foob\") = \"Zm9vYg==\"</li>\n     * <li>BASE64(\"fooba\") = \"Zm9vYmE=\"</li>\n     * <li>BASE64(\"foobar\") = \"Zm9vYmFy\"</li>\n     * </ul>\n     *\n     * @see <a href=\"https://tools.ietf.org/html/rfc4648\">https://tools.ietf.org/\n     *      html/rfc4648</a>"
        },
        "testRfc4648Section10EncodeDecode": {
          "Javadoc": "* Tests RFC 4648 section 10 test vectors.\n     * <ul>\n     * <li>BASE64(\"\") = \"\"</li>\n     * <li>BASE64(\"f\") = \"Zg==\"</li>\n     * <li>BASE64(\"fo\") = \"Zm8=\"</li>\n     * <li>BASE64(\"foo\") = \"Zm9v\"</li>\n     * <li>BASE64(\"foob\") = \"Zm9vYg==\"</li>\n     * <li>BASE64(\"fooba\") = \"Zm9vYmE=\"</li>\n     * <li>BASE64(\"foobar\") = \"Zm9vYmFy\"</li>\n     * </ul>\n     *\n     * @see <a href=\"https://tools.ietf.org/html/rfc4648\">https://tools.ietf.org/\n     *      html/rfc4648</a>"
        },
        "testUrlSafe": {
          "Javadoc": "* Tests URL-safe Base64 against random data, sizes 0 to 150."
        },
        "testUUID": {
          "Javadoc": "* Base64 encoding of UUID's is a common use-case, especially in URL-SAFE\n     * mode. This test case ends up being the \"URL-SAFE\" JUnit's.\n     *\n     * @throws DecoderException\n     *             if Hex.decode() fails - a serious problem since Hex comes\n     *             from our own commons-codec!"
        }
      }
    },
    "org.apache.commons.codec.binary.Base64TestData": {
      "Javadoc": "\n * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between\n * Commons-Codec and OpenSSL. Notice that OpenSSL creates 64 character lines instead of the 76 of Commons-Codec.\n *\n * @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a>\n "
    },
    "org.apache.commons.codec.binary.BaseNCodecTest": {
      "Javadoc": "",
      "methods": {
        "assumeCanAllocateBufferSize": {
          "Javadoc": "* Verify this VM can allocate the given size byte array. Otherwise skip the test."
        },
        "getPresumableFreeMemory": {
          "Javadoc": "* Gets the presumable free memory; an estimate of the amount of memory that could be allocated.\n     *\n     * <p>This performs a garbage clean-up and the obtains the presumed amount of free memory\n     * that can be allocated in this VM. This is computed as:<p>\n     *\n     * <pre>\n     * System.gc();\n     * long allocatedMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n     * long presumableFreeMemory = Runtime.getRuntime().maxMemory() - allocatedMemory;\n     * </pre>\n     *\n     * @return the presumable free memory\n     * @see <a href=\"https://stackoverflow.com/a/18366283\">\n     *     Christian Fries StackOverflow answer on Java available memory</a>"
        },
        "testContextToString": {
          "Javadoc": "* Test the Context string representation has debugging info.\n     * This is not part of the API and the test should be changed if the string\n     * format is updated."
        },
        "testEnsureBufferSizeExpandsToBeyondMaxBufferSize": {
          "Javadoc": "* Test to expand to beyond the max buffer size.\n     *\n     * <p>Note: If the buffer is required to expand to above the max buffer size it may not work\n     * on all VMs and may have to be annotated with @Ignore.</p>"
        },
        "testEnsureBufferSizeExpandsToMaxBufferSize": {
          "Javadoc": "* Test to expand to the max buffer size."
        }
      }
    },
    "org.apache.commons.codec.binary.NoOpBaseNCodec": {
      "Javadoc": "\n     * Extend BaseNCodec without implementation (no operations = NoOp).\n     * Used for testing the memory allocation in {@link BaseNCodec#ensureBufferSize(int, Context)}.\n     "
    },
    "org.apache.commons.codec.binary.BaseNTestData": {
      "Javadoc": "\n * Data and functions common to BaseN tests.\n ",
      "methods": {
        "bytesContain": {
          "Javadoc": "* Tests the supplied byte[] array to see if it contains the specified byte c.\n     *\n     * @param bytes byte[] array to test\n     * @param c byte to look for\n     * @return true if bytes contains c, false otherwise"
        },
        "randomData": {
          "Javadoc": "* Returns an encoded and decoded copy of the same random data.\n     *\n     * @param codec the codec to use\n     * @param size amount of random data to generate and encode\n     * @return two byte[] arrays:  [0] = decoded, [1] = encoded"
        },
        "streamToBytes": {
          "Javadoc": "* Read all bytes from an InputStream into a byte array\n     * in chunks of {@code buf.length}.\n     *\n     * @param in the input stream.\n     * @param buf the byte array to use for chunking\n     *\n     * @return the bytes read from the input stream\n     *\n     * @throws IOException if an error occurs whilst reading the input stream"
        }
      }
    },
    "org.apache.commons.codec.binary.BinaryCodecTest": {
      "Javadoc": "\n * TestCase for BinaryCodec class.\n ",
      "methods": {
        "assertDecodeObject": {
          "Javadoc": "* Utility used to assert the encoded and decoded values.\n     *\n     * @param bits\n     *            the pre-encoded data\n     * @param encodeMe\n     *            data to encode and compare"
        },
        "testDecodeObject": {
          "Javadoc": "* Tests for Object decode(Object)"
        },
        "testDecodeObjectException": {
          "Javadoc": "* Tests for Object decode(Object)"
        },
        "testToAsciiString": {
          "Javadoc": "* Tests the toAsciiString(byte[]) method"
        },
        "testToByteArrayFromString": {
          "Javadoc": "* Tests for byte[] toByteArray(String)"
        }
      }
    },
    "org.apache.commons.codec.binary.CharSequenceUtilsTest": {
      "Javadoc": "\n * Tests {@link org.apache.commons.codec.binary.CharSequenceUtils}.\n *\n * <p>Tests copied from Apache Commons Lang 3.11. The implementation in codec is based on\n * an earlier version of Lang and some tests fail. The CharSequenceUtils class is public but\n * the method is package private. The failing tests have been commented out and the\n * implementation left unchanged.\n ",
      "methods": {
        "testConstructor": {
          "Javadoc": "* Test the constructor exists. This is here for code coverage. The class ideally should\n     * be package private, marked as final and have a private constructor to prevent instances."
        }
      }
    },
    "org.apache.commons.codec.binary.RunTest": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.binary.TestData": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.binary.Codec105ErrorInputStream": {
      "Javadoc": "\n * Emits three line-feeds '\\n' in a row, one at a time, and then EOF.\n *\n * Recreates the bug described in CODEC-105.\n *\n * @since 1.5\n "
    },
    "org.apache.commons.codec.binary.HexTest": {
      "Javadoc": "\n * Tests {@link org.apache.commons.codec.binary.Hex}.\n ",
      "methods": {
        "allocate": {
          "Javadoc": "* Allocate a ByteBuffer.\n     *\n     * <p>The default implementation uses {@link ByteBuffer#allocate(int)}.\n     * The method is overridden in AllocateDirectHexTest to use\n     * {@link ByteBuffer#allocateDirect(int)}\n     *\n     * @param capacity the capacity\n     * @return the byte buffer"
        },
        "getByteBufferUtf8": {
          "Javadoc": "* Encodes the given string into a byte buffer using the UTF-8 charset.\n     *\n     * <p>The buffer is allocated using {@link #allocate(int)}.\n     *\n     * @param string the String to encode\n     * @return the byte buffer"
        },
        "testCharset": {
          "Javadoc": "* @param name\n     * @param parent\n     * @throws UnsupportedEncodingException\n     * @throws DecoderException"
        },
        "testEncodeHexReadOnlyByteBuffer": {
          "Javadoc": "* Test encoding of a read only byte buffer.\n     * See CODEC-261."
        }
      }
    },
    "org.apache.commons.codec.binary.StringUtilsTest": {
      "Javadoc": "\n * Tests {@link StringUtils}\n ",
      "methods": {
        "testConstructor": {
          "Javadoc": "* We could make the constructor private but there does not seem to be a point to jumping through extra code hoops\n     * to restrict instantiation right now."
        }
      }
    },
    "org.apache.commons.codec.BinaryEncoderAbstractTest": {
      "Javadoc": "\n "
    },
    "org.apache.commons.codec.CharEncodingTest": {
      "Javadoc": "\n * Sanity checks for {@link CharEncoding}.\n ",
      "methods": {
        "testConstructor": {
          "Javadoc": "* We could make the constructor private in the future, it's a matter a style."
        }
      }
    },
    "org.apache.commons.codec.CharsetsTest": {
      "Javadoc": "\n * Sanity checks for {@link Charsets}.\n "
    },
    "org.apache.commons.codec.cli.DigestTest": {
      "Javadoc": "\n * Tests {@link Digest}.\n ",
      "methods": {
        "testEmptyArguments": {
          "Javadoc": "* Tests if empty arguments are handled correctly."
        },
        "testNullArguments": {
          "Javadoc": "* Tests if null arguments are handled correctly."
        }
      }
    },
    "org.apache.commons.codec.DecoderExceptionTest": {
      "Javadoc": "\n * Tests {@link DecoderException}.\n "
    },
    "org.apache.commons.codec.digest.Apr1CryptTest": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.digest.B64Test": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.digest.Blake3Test": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.digest.Blake3TestVectorsTest": {
      "Javadoc": "\n * Tests the standard test vectors provided by the reference Blake3 implementation. Each test uses as input data the\n * cyclic byte sequence 0, 1, 2, ..., 249, 250, 0, 1, ..., up to a specified length. For each test, the hash of this\n * message up to a specific length is calculated. Then the same hash is calculated in keyed mode using the UTF-8\n * encoding of the string \"whats the Elvish word for friend\". Finally, the same hash is calculated in key derivation\n * mode using the KDF context string with the UTF-8 encoding of \"BLAKE3 2019-12-27 16:29:52 test vectors context\".\n * For each of these hashes, both the extended hash output and the truncated 32-byte hash outputs are validated against\n * these known answer tests (KATs).\n "
    },
    "org.apache.commons.codec.digest.CryptTest": {
      "Javadoc": "",
      "methods": {
        "testCryptWithEmptySalt": {
          "Javadoc": "* An empty string as salt is invalid.\n     *\n     * The C and Perl implementations return an empty string, PHP threads it\n     * as NULL. Our implementation should throw an Exception as any resulting\n     * hash would not be verifiable with other implementations of crypt()."
        }
      }
    },
    "org.apache.commons.codec.digest.DigestUtilsTest": {
      "Javadoc": "\n * Tests {@link DigestUtils}.\n ",
      "methods": {
        "testMd2HexLength": {
          "Javadoc": "* An MD2 hash converted to hexadecimal should always be 32 characters."
        },
        "testMd2Length": {
          "Javadoc": "* An MD2 hash should always be a 16 element byte[]."
        },
        "testMd5HexLengthForBytes": {
          "Javadoc": "* An MD5 hash converted to hexadecimal should always be 32 characters."
        },
        "testMd5LengthForBytes": {
          "Javadoc": "* An MD5 hash should always be a 16 element byte[]."
        }
      }
    },
    "org.apache.commons.codec.digest.HmacAlgorithmsTest": {
      "Javadoc": "\n * Tests {@link HmacAlgorithms}.\n "
    },
    "org.apache.commons.codec.digest.HmacUtilsTest": {
      "Javadoc": "\n * Tests {@link HmacUtils}.\n "
    },
    "org.apache.commons.codec.digest.Md5CryptTest": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.digest.MessageDigestAlgorithmsTest": {
      "Javadoc": "\n * Tests {@link MessageDigestAlgorithms}.\n "
    },
    "org.apache.commons.codec.digest.MurmurHash2Test": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.digest.MurmurHash3Test": {
      "Javadoc": "\n * Test for {@link MurmurHash3}.\n ",
      "methods": {
        "assertIncrementalHash32": {
          "Javadoc": "* Assert {@link IncrementalHash32} returns the same values as\n     * {@link MurmurHash3#hash32(byte[], int, int, int)}.\n     *\n     * <p>The bytes are added to the incremental hash in the given blocks.</p>\n     *\n     * @param bytes the bytes\n     * @param seed the seed\n     * @param blocks the blocks"
        },
        "assertIncrementalHash32x86": {
          "Javadoc": "* Assert {@link IncrementalHash32x86} returns the same values as\n     * {@link MurmurHash3#hash32x86(byte[], int, int, int)}.\n     *\n     * <p>The bytes are added to the incremental hash in the given blocks.</p>\n     *\n     * @param bytes the bytes\n     * @param seed the seed\n     * @param blocks the blocks"
        },
        "createLongTestData": {
          "Javadoc": "* Creates a set of long values to test the hash utility methods.\n     *\n     * @return the data"
        },
        "createRandomBlocks": {
          "Javadoc": "* Creates the random blocks of data to process up to max length.\n     *\n     * @param maxLength the max length\n     * @return the blocks"
        },
        "negativeBytes": {
          "Javadoc": "* Check if the bytes are negative in the given range.\n     *\n     * @param bytes the bytes\n     * @param start the start\n     * @param length the length\n     * @return true, if negative bytes exist"
        },
        "testHash128": {
          "Javadoc": "* Test the {@link MurmurHash3#hash128(byte[])} algorithm.\n     *\n     * <p>Reference data is taken from the Python library {@code mmh3}.</p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>"
        },
        "testHash128String": {
          "Javadoc": "* Test the {@link MurmurHash3#hash128(String)} algorithm. This only tests it can return\n     * the same value as {@link MurmurHash3#hash128(byte[], int, int, int)} if the string\n     * is converted to bytes using the method {@link String#getBytes()}.\n     *\n     * <p>The test uses random strings created with random unicode code points.</p>"
        },
        "testHash128WithOffsetLengthAndNegativeSeed": {
          "Javadoc": "* Test the {@link MurmurHash3#hash128(byte[], int, int, int)} algorithm.\n     *\n     * <p>Explicit test for a negative seed. The original implementation has a sign extension error\n     * for negative seeds. This test is here to maintain behavioral compatibility of the\n     * broken deprecated method."
        },
        "testHash128WithOffsetLengthAndSeed": {
          "Javadoc": "* Test the {@link MurmurHash3#hash128(byte[], int, int, int)} algorithm.\n     *\n     * <p>Reference data is taken from the Python library {@code mmh3}.</p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>"
        },
        "testHash128x64": {
          "Javadoc": "* Test the {@link MurmurHash3#hash128x64(byte[])} algorithm.\n     *\n     * <p>Reference data is taken from the Python library {@code mmh3}.</p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>"
        },
        "testHash128x64WithOffsetLengthAndNegativeSeed": {
          "Javadoc": "* Test the {@link MurmurHash3#hash128x64(byte[], int, int, int)} algorithm.\n     *\n     * <p>Explicit test for a negative seed. The original implementation has a sign extension error\n     * for negative seeds.\n     *\n     * <p>Reference data is taken from the Python library {@code mmh3}.</p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>"
        },
        "testHash128x64WithOffsetLengthAndSeed": {
          "Javadoc": "* Test the {@link MurmurHash3#hash128x64(byte[], int, int, int)} algorithm.\n     *\n     * <p>Reference data is taken from the Python library {@code mmh3}.</p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>"
        },
        "testHash32": {
          "Javadoc": "* Test the {@link MurmurHash3#hash32(byte[])} algorithm.\n     *\n     * <p>\n     * Reference data is taken from the Python library {@code mmh3}.\n     * </p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>"
        },
        "testHash32Long": {
          "Javadoc": "* Test the convenience method {@link MurmurHash3#hash32(long)} works as documented."
        },
        "testHash32LongLong": {
          "Javadoc": "* Test the convenience method {@link MurmurHash3#hash32(long, long)} works as documented."
        },
        "testHash32LongLongSeed": {
          "Javadoc": "* Test the convenience method {@link MurmurHash3#hash32(long, long, int)} works as documented."
        },
        "testHash32LongSeed": {
          "Javadoc": "* Test the convenience method {@link MurmurHash3#hash32(long, int)} works as documented."
        },
        "testHash32String": {
          "Javadoc": "* Test the {@link MurmurHash3#hash32(String)} algorithm. This only tests it can return the same value as {@link MurmurHash3#hash32(byte[], int, int, int)}\n     * if the string is converted to bytes using the method {@link String#getBytes()}.\n     *\n     * <p>\n     * The test uses random strings created with random unicode code points.\n     * </p>"
        },
        "testHash32WithLength": {
          "Javadoc": "* Test the {@link MurmurHash3#hash32(byte[], int)} algorithm.\n     *\n     * <p>\n     * Reference data is taken from the Python library {@code mmh3}.\n     * </p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>"
        },
        "testHash32WithLengthAndSeed": {
          "Javadoc": "* Test the {@link MurmurHash3#hash32(byte[], int, int)} algorithm.\n     *\n     * <p>\n     * Reference data is taken from the Python library {@code mmh3}.\n     * </p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>"
        },
        "testHash32WithOffsetLengthAndSeed": {
          "Javadoc": "* Test the {@link MurmurHash3#hash32(byte[], int, int, int)} algorithm.\n     *\n     * <p>\n     * Reference data is taken from the Python library {@code mmh3}.\n     * </p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>"
        },
        "testHash32WithTrailingNegativeSignedBytesIsInvalid": {
          "Javadoc": "* Test to demonstrate the errors in {@link MurmurHash3#hash32(byte[], int, int, int)} if the final 1, 2, or 3 bytes are negative."
        },
        "testHash32x86": {
          "Javadoc": "* Test the {@link MurmurHash3#hash32x86(byte[])} algorithm.\n     *\n     * <p>\n     * Reference data is taken from the Python library {@code mmh3}.\n     * </p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>"
        },
        "testHash32x86WithOffsetLengthAndSeed": {
          "Javadoc": "* Test the {@link MurmurHash3#hash32x86(byte[], int, int, int)} algorithm.\n     *\n     * <p>\n     * Reference data is taken from the Python library {@code mmh3}.\n     * </p>\n     *\n     * @see <a href=\"https://pypi.org/project/mmh3/\">mmh3</a>"
        },
        "testHash32x86WithTrailingNegativeSignedBytes": {
          "Javadoc": "* Test to demonstrate {@link MurmurHash3#hash32x86(byte[], int, int, int)} is OK if the final 1, 2, or 3 bytes are negative."
        },
        "testHash64": {
          "Javadoc": "* Test the {@link MurmurHash3#hash64(byte[])} algorithm. Unknown origin of test data. It may be from the Apache Hive project."
        },
        "testHash64InNotEqualToHash128": {
          "Javadoc": "* Test the {@link MurmurHash3#hash64(byte[])} method is Murmur3-like but does not match the bits returned from {@link MurmurHash3#hash128(byte[])}.\n     *\n     * <p>\n     * The hash64 method is not in the MurmurHash3 reference code and has been inherited from the port from Apache Hive.\n     * <p>"
        },
        "testHash64WithOffsetAndLength": {
          "Javadoc": "* Test the {@link MurmurHash3#hash64(byte[], int, int)} algorithm. Unknown origin of test data. It may be from the Apache Hive project."
        },
        "testHash64WithPrimitives": {
          "Javadoc": "* Test the hash64() helper methods that work directly on primitives work as documented. This test the methods return the same value as\n     * {@link MurmurHash3#hash64(byte[])} with the byte[] created from the same primitive data via a {@link ByteBuffer}."
        },
        "testIncrementalHash32": {
          "Javadoc": "* Test {@link IncrementalHash32} returns the same values as {@link MurmurHash3#hash32(byte[], int, int, int)}."
        },
        "testIncrementalHash32x86": {
          "Javadoc": "* Test {@link IncrementalHash32x86} returns the same values as {@link MurmurHash3#hash32x86(byte[], int, int, int)}."
        },
        "testIncrementalHashWithUnprocessedBytesAndHugeLengthArray": {
          "Javadoc": "* This test hits an edge case where a very large number of bytes is added to the incremental hash. The data is constructed so that an integer counter of\n     * unprocessed bytes will overflow. If this is not handled correctly then the code throws an exception when it copies more data into the unprocessed bytes\n     * array."
        }
      }
    },
    "org.apache.commons.codec.digest.PureJavaCrc32CTest": {
      "Javadoc": "\n * Tests {@link PureJavaCrc32C}. Test data was derived from https://tools.ietf.org/html/rfc3720#appendix-B.4\n "
    },
    "org.apache.commons.codec.digest.PureJavaCrc32Test": {
      "Javadoc": "\n * Unit test to verify that the pure-Java CRC32 algorithm gives the same results as the built-in implementation.\n *\n * Copied from Hadoop 2.6.3 (Renamed TestPureJavaCrc32 to PureJavaCrc32Test).\n "
    },
    "org.apache.commons.codec.digest.PerformanceTest": {
      "Javadoc": "\n     * Performance tests to compare performance of the Pure Java implementation to the built-in java.util.zip implementation. This can be run from the command\n     * line with:\n     *\n     * java -cp path/to/test/classes:path/to/common/classes \\ 'org.apache.hadoop.util.TestPureJavaCrc32$PerformanceTest'\n     *\n     * The output is in JIRA table format.\n     "
    },
    "org.apache.commons.codec.digest.BenchResult": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.digest.Table": {
      "Javadoc": "\n     * Generate a table to perform checksums based on the same CRC-32 polynomial that java.util.zip.CRC32 uses.\n     ",
      "methods": {
        "main": {
          "Javadoc": "Generate CRC-32 lookup tables"
        }
      }
    },
    "org.apache.commons.codec.digest.Sha256CryptTest": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.digest.Sha2CryptTest": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.digest.Sha512CryptTest": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.digest.UnixCryptTest": {
      "Javadoc": "",
      "methods": {
        "testUnixCryptExplicitCall": {
          "Javadoc": "* Some salts are invalid for crypt(3) but not for unixCrypt()."
        },
        "testUnixCryptInvalidSalt": {
          "Javadoc": "* Unimplemented \"$foo$\" salt prefixes would be treated as UnixCrypt salt."
        },
        "testUnixCryptWithHalfSalt": {
          "Javadoc": "* Single character salts are illegal!\n     * E.g. with glibc 2.13, crypt(\"secret\", \"x\") = \"xxZREZpkHZpkI\" but\n     * crypt(\"secret\", \"xx\") = \"xxWAum7tHdIUw\" which makes it unverifiable."
        }
      }
    },
    "org.apache.commons.codec.digest.XXHash32OverflowTest": {
      "Javadoc": "",
      "methods": {
        "testIncrementalHashWithUnprocessedBytesAndHugeLengthArray": {
          "Javadoc": "* This test hits an edge case where a very large number of bytes is added to the incremental\n     * hash. The data is constructed so that an integer counter of unprocessed bytes will\n     * overflow. If this is not handled correctly then the code throws an exception when it\n     * copies more data into the unprocessed bytes array."
        }
      }
    },
    "org.apache.commons.codec.digest.XXHash32Test": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.EncoderExceptionTest": {
      "Javadoc": "\n * Tests {@link EncoderException}.\n "
    },
    "org.apache.commons.codec.language.bm.BeiderMorseEncoderTest": {
      "Javadoc": "\n * Tests BeiderMorseEncoder.\n ",
      "methods": {
        "testAllChars": {
          "Javadoc": "* Tests we do not blow up.\n     *\n     * @throws EncoderException for some failure scenarios"
        },
        "testEncodeGna": {
          "Javadoc": "* Tests https://issues.apache.org/jira/browse/CODEC-125?focusedCommentId=13071566&page=com.atlassian.jira.plugin.system.issuetabpanels:\n     * comment-tabpanel#comment-13071566\n     *\n     * @throws EncoderException for some failure scenarios"
        },
        "testSpeedCheck": {
          "Javadoc": "* (Un)luckily, the worse performing test because of the data in the test characters.\n     *\n     * @throws EncoderException for some failure scenarios"
        }
      }
    },
    "org.apache.commons.codec.language.bm.CacheSubSequencePerformanceTest": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.language.bm.LanguageGuessingTest": {
      "Javadoc": "\n * Tests guessLanguages API.\n "
    },
    "org.apache.commons.codec.language.bm.PhoneticEnginePerformanceTest": {
      "Javadoc": "\n * Tests performance for {@link PhoneticEngine}.\n * <p>\n * See <a href=\"https://issues.apache.org/jira/browse/CODEC-174\">[CODEC-174] Improve performance of Beider Morse\n * encoder</a>.\n * </p>\n * <p>\n * Results for November 7, 2013, project SVN revision 1539678.\n * </p>\n * <p>\n * Environment:\n * </p>\n * <ul>\n * <li>java version \"1.7.0_45\"</li>\n * <li>Java(TM) SE Runtime Environment (build 1.7.0_45-b18)</li>\n * <li>Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)</li>\n * <li>OS name: \"windows 7\", version: \"6.1\", arch: \"amd64\", family: \"windows\")</li>\n * </ul>\n * <ol>\n * <li>Time for encoding 80,000 times the input 'Angelo': 33,039 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 32,297 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 32,857 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': <b>31,561 millis.</b></li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 32,665 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 32,215 millis.</li>\n * </ol>\n * <p>\n * On this file's revision 1539678, with patch <a\n * href=\"https://issues.apache.org/jira/secure/attachment/12611963/CODEC-174-change-rules-storage-to-Map.patch\"\n * >CODEC-174-change-rules-storage-to-Map</a>:\n * </p>\n * <ol>\n * <li>Time for encoding 80,000 times the input 'Angelo': 18,196 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,858 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,644 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': <b>13,591 millis.</b></li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,861 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,696 millis.</li>\n * </ol>\n * <p>\n * Patch applied, committed revision 1539783.\n * </p>\n * <p>\n * On this file's revision 1539783, with patch <a\n * href=\"https://issues.apache.org/jira/secure/attachment/12611962/CODEC-174-delete-subsequence-cache.patch\"\n * >CODEC-174-delete-subsequence-cache.patch</a>:\n * </p>\n * <ol>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,547 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': <b>13,501 millis.</b></li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,528 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 17,110 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,910 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 16,969 millis.</li>\n * </ol>\n * <p>\n * Patch not applied.\n * </p>\n * <p>\n * On this file's revision 1539787, with patch <a\n * href=\"https://issues.apache.org/jira/secure/attachment/12612178/CODEC-174-reuse-set-in-PhonemeBuilder.patch\"\n * >CODEC-174-reuse-set-in-PhonemeBuilder.patch</a>:\n * </p>\n * <ol>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,724 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,451 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,742 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': <b>13,186 millis.</b></li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,600 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 16,405 millis.</li>\n * </ol>\n * <p>\n * Patch applied, committed revision 1539788.\n * </p>\n * <p>\n * Before patch https://issues.apache.org/jira/secure/attachment/12613371/CODEC-174-refactor-restrictTo-method-in-SomeLanguages.patch\n * </p>\n * <ol>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,133 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,064 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': <b>12,838 millis.</b></li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 12,970 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,122 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 13,293 millis.</li>\n * </ol>\n * <p>\n * After patch https://issues.apache.org/jira/secure/attachment/12613371/CODEC-174-refactor-restrictTo-method-in-SomeLanguages.patch\n * </p>\n * <ol>\n * <li>Time for encoding 80,000 times the input 'Angelo': 11,576 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 11,506 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 11,361 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': <b>11,142 millis.</b></li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 11,430 millis.</li>\n * <li>Time for encoding 80,000 times the input 'Angelo': 11,297 millis.</li>\n * </ol>\n * <p>\n * Patch applied, committed revision 1541234.\n * </p>\n "
    },
    "org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest": {
      "Javadoc": "\n * Tests PhoneticEngine and Languages.LanguageSet in ways very similar to code found in solr-3.6.0.\n ",
      "methods": {
        "encode": {
          "Javadoc": "* This code is similar in style to code found in Solr:\n     * solr/core/src/java/org/apache/solr/analysis/BeiderMorseFilterFactory.java\n     *\n     * Making a JUnit test out of it to protect Solr from possible future\n     * regressions in Commons-Codec."
        }
      }
    },
    "org.apache.commons.codec.language.bm.PhoneticEngineTest": {
      "Javadoc": "\n * Tests PhoneticEngine.\n "
    },
    "org.apache.commons.codec.language.bm.RuleTest": {
      "Javadoc": "\n * Tests Rule.\n "
    },
    "org.apache.commons.codec.language.Caverphone1Test": {
      "Javadoc": "\n * Tests Caverphone1.\n ",
      "methods": {
        "testCaverphoneRevisitedCommonCodeAT1111": {
          "Javadoc": "* Tests example adapted from version 2.0  https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * AT1111 words: add, aid, at, art, eat, earth, head, hit, hot, hold, hard, heart, it, out, old\n     *\n     * @throws EncoderException for some failure scenarios."
        },
        "testIsCaverphoneEquals": {
          "Javadoc": "* Tests some examples from version 2.0 https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * @throws EncoderException for some failure scenarios."
        },
        "testSpecificationV1Examples": {
          "Javadoc": "* Tests example from https://caversham.otago.ac.nz/files/working/ctp060902.pdf\n     *\n     * @throws EncoderException for some failure scenarios."
        },
        "testWikipediaExamples": {
          "Javadoc": "* Tests examples from https://en.wikipedia.org/wiki/Caverphone\n     *\n     * @throws EncoderException for some failure scenarios."
        }
      }
    },
    "org.apache.commons.codec.language.Caverphone2Test": {
      "Javadoc": "\n * Tests Caverphone2.\n ",
      "methods": {
        "testCaverphoneRevisitedCommonCodeAT11111111": {
          "Javadoc": "* See https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * AT11111111 words: add, aid, at, art, eat, earth, head, hit, hot, hold, hard, heart, it, out, old\n     *\n     * @throws EncoderException for some failure scenarios"
        },
        "testCaverphoneRevisitedExamples": {
          "Javadoc": "* See https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * @throws EncoderException for some failure scenarios"
        },
        "testCaverphoneRevisitedRandomNameKLN1111111": {
          "Javadoc": "* See https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * @throws EncoderException for some failure scenarios"
        },
        "testCaverphoneRevisitedRandomNameTN11111111": {
          "Javadoc": "* See https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * @throws EncoderException for some failure scenarios"
        },
        "testCaverphoneRevisitedRandomNameTTA1111111": {
          "Javadoc": "* See https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * @throws EncoderException for some failure scenarios"
        },
        "testCaverphoneRevisitedRandomWords": {
          "Javadoc": "* See https://caversham.otago.ac.nz/files/working/ctp150804.pdf\n     *\n     * @throws EncoderException for some failure scenarios"
        }
      }
    },
    "org.apache.commons.codec.language.ColognePhoneticTest": {
      "Javadoc": "\n * Tests the {@code ColognePhonetic} class.\n *\n * <p>\n * Keep this file in UTF-8 encoding for proper Javadoc processing.\n * </p>\n ",
      "methods": {
        "testAychlmajrForCodec122": {
          "Javadoc": "* Tests [CODEC-122]\n     *\n     * @throws EncoderException for some failure scenarios"
        }
      }
    },
    "org.apache.commons.codec.language.DaitchMokotoffSoundexTest": {
      "Javadoc": "\n * Tests {@link DaitchMokotoffSoundex}.\n * <p>\n * Keep this file in UTF-8 encoding for proper Javadoc processing.\n * </p>\n ",
      "methods": {
        "testEncodeIgnoreHyphens": {
          "Javadoc": "* Test data from http://www.myatt.demon.co.uk/sxalg.htm\n     *\n     * @throws EncoderException for some failure scenarios"
        },
        "testSoundexBasic": {
          "Javadoc": "* Examples from http://www.jewishgen.org/infofiles/soundex.html"
        },
        "testSoundexBasic2": {
          "Javadoc": "* Examples from http://www.avotaynu.com/soundex.htm"
        },
        "testSoundexBasic3": {
          "Javadoc": "* Examples from https://en.wikipedia.org/wiki/Daitch%E2%80%93Mokotoff_Soundex"
        }
      }
    },
    "org.apache.commons.codec.language.DoubleMetaphone2Test": {
      "Javadoc": "\n * Tests {@link DoubleMetaphone}.\n * <p>\n * The test data was extracted from Stephen Woodbridge's <a\n * href=\"https://swoodbridge.com/DoubleMetaPhone/surnames.txt\">PHP test program</a>.\n *\n * @see <a href=\"https://swoodbridge.com/DoubleMetaPhone/surnames.txt\">PHP test program</a>\n ",
      "methods": {
        "testDoubleMetaphoneAlternate": {
          "Javadoc": "* Test alternative encoding."
        },
        "testDoubleMetaphonePrimary": {
          "Javadoc": "* Test primary encoding."
        }
      }
    },
    "org.apache.commons.codec.language.DoubleMetaphoneTest": {
      "Javadoc": "\n * Tests {@link DoubleMetaphone}.\n *\n * <p>Keep this file in UTF-8 encoding for proper Javadoc processing.</p>\n *\n * @see \"http://www.cuj.com/documents/s=8038/cuj0006philips/\"\n ",
      "methods": {
        "assertDoubleMetaphone": {
          "Javadoc": "* Tests encoding APIs in one place."
        },
        "assertDoubleMetaphoneAlt": {
          "Javadoc": "* Tests encoding APIs in one place."
        },
        "testIsDoubleMetaphoneEqualExtended1": {
          "Javadoc": "* Example in the original article but failures in this Java impl:"
        },
        "testIsDoubleMetaphoneEqualExtended3": {
          "Javadoc": "* Used to generate the MATCHES array and test possible matches from the\n     * FIXTURE array."
        },
        "testSetMaxCodeLength": {
          "Javadoc": "* Test setting maximum length"
        }
      }
    },
    "org.apache.commons.codec.language.MatchRatingApproachEncoderTest": {
      "Javadoc": "\n * Series of tests for the Match Rating Approach algorithm.\n *\n * General naming nomenclature for the test is of the form:\n * GeneralMetadataOnTheTestArea_ActualTestValues_ExpectedResult\n *\n * An unusual value is indicated by the term \"corner case\"\n "
    },
    "org.apache.commons.codec.language.MetaphoneTest": {
      "Javadoc": "\n ",
      "methods": {
        "testIsMetaphoneEqual2": {
          "Javadoc": "* Matches computed from http://www.lanw.com/java/phonetic/default.htm"
        },
        "testIsMetaphoneEqualAero": {
          "Javadoc": "* Initial AE case.\n     *\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm"
        },
        "testIsMetaphoneEqualAlbert": {
          "Javadoc": "* Initial A, not followed by an E case.\n     *\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm"
        },
        "testIsMetaphoneEqualGary": {
          "Javadoc": "* Match data computed from http://www.lanw.com/java/phonetic/default.htm"
        },
        "testIsMetaphoneEqualJohn": {
          "Javadoc": "* Match data computed from http://www.lanw.com/java/phonetic/default.htm"
        },
        "testIsMetaphoneEqualKnight": {
          "Javadoc": "* Initial KN case.\n     *\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm"
        },
        "testIsMetaphoneEqualMary": {
          "Javadoc": "* Match data computed from http://www.lanw.com/java/phonetic/default.htm"
        },
        "testIsMetaphoneEqualParis": {
          "Javadoc": "* Match data computed from http://www.lanw.com/java/phonetic/default.htm"
        },
        "testIsMetaphoneEqualPeter": {
          "Javadoc": "* Match data computed from http://www.lanw.com/java/phonetic/default.htm"
        },
        "testIsMetaphoneEqualRay": {
          "Javadoc": "* Match data computed from http://www.lanw.com/java/phonetic/default.htm"
        },
        "testIsMetaphoneEqualSusan": {
          "Javadoc": "* Match data computed from http://www.lanw.com/java/phonetic/default.htm"
        },
        "testIsMetaphoneEqualWhite": {
          "Javadoc": "* Initial WH case.\n     *\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm"
        },
        "testIsMetaphoneEqualWright": {
          "Javadoc": "* Initial WR case.\n     *\n     * Match data computed from http://www.lanw.com/java/phonetic/default.htm"
        },
        "testIsMetaphoneEqualXalan": {
          "Javadoc": "* Match data computed from http://www.lanw.com/java/phonetic/default.htm"
        },
        "testWhy": {
          "Javadoc": "* Tests (CODEC-57) Metaphone.metaphone(String) returns an empty string when passed the word \"why\""
        }
      }
    },
    "org.apache.commons.codec.language.NysiisTest": {
      "Javadoc": "\n * Tests {@link Nysiis}\n ",
      "methods": {
        "assertEncodings": {
          "Javadoc": "* Takes an array of String pairs where each pair's first element is the input and the second element the expected\n     * encoding.\n     *\n     * @param testValues\n     *            an array of String pairs where each pair's first element is the input and the second element the\n     *            expected encoding."
        },
        "testDropBy": {
          "Javadoc": "* Tests data gathered from around the internet.\n     *\n     * @see <a href=\"http://www.dropby.com/NYSIISTextStrings.html\">http://www.dropby.com/NYSIISTextStrings.html</a>"
        },
        "testOthers": {
          "Javadoc": "* Tests data gathered from around the internets."
        },
        "testRule1": {
          "Javadoc": "* Tests rule 1: Translate first characters of name: MAC  MCC, KN  N, K  C, PH, PF  FF, SCH  SSS"
        },
        "testRule2": {
          "Javadoc": "* Tests rule 2: Translate last characters of name: EE  Y, IE  Y, DT, RT, RD, NT, ND  D"
        },
        "testRule4Dot1": {
          "Javadoc": "* Tests rule 4.1: EV  AF else A, E, I, O, U  A"
        },
        "testRule4Dot2": {
          "Javadoc": "* Tests rule 4.2: Q  G, Z  S, M  N"
        },
        "testRule5": {
          "Javadoc": "* Tests rule 5: If last character is S, remove it."
        },
        "testRule6": {
          "Javadoc": "* Tests rule 6: If last characters are AY, replace with Y."
        },
        "testRule7": {
          "Javadoc": "* Tests rule 7: If last character is A, remove it."
        }
      }
    },
    "org.apache.commons.codec.language.RefinedSoundexTest": {
      "Javadoc": "\n * Tests RefinedSoundex.\n "
    },
    "org.apache.commons.codec.language.SoundexTest": {
      "Javadoc": "\n * Tests {@link Soundex}.\n *\n * <p>Keep this file in UTF-8 encoding for proper Javadoc processing.</p>\n ",
      "methods": {
        "testEncodeBatch2": {
          "Javadoc": "* Examples from http://www.bradandkathy.com/genealogy/overviewofsoundex.html"
        },
        "testEncodeBatch3": {
          "Javadoc": "* Examples from http://www.archives.gov/research_room/genealogy/census/soundex.html"
        },
        "testEncodeBatch4": {
          "Javadoc": "* Examples from: http://www.myatt.demon.co.uk/sxalg.htm"
        },
        "testEncodeIgnoreHyphens": {
          "Javadoc": "* Test data from http://www.myatt.demon.co.uk/sxalg.htm\n     *\n     * @throws EncoderException for some failure scenarios"
        },
        "testHWRuleEx1": {
          "Javadoc": "* Consonants from the same code group separated by W or H are treated as one."
        },
        "testHWRuleEx2": {
          "Javadoc": "* Consonants from the same code group separated by W or H are treated as one.\n     *\n     * Test data from http://www.myatt.demon.co.uk/sxalg.htm"
        },
        "testHWRuleEx3": {
          "Javadoc": "* Consonants from the same code group separated by W or H are treated as one.\n     *\n     * @throws EncoderException for some failure scenarios"
        },
        "testMsSqlServer1": {
          "Javadoc": "* Examples for MS SQLServer from\n     * https://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_setu-sus_3o6w.asp"
        },
        "testMsSqlServer2": {
          "Javadoc": "* Examples for MS SQLServer from\n     * https://support.microsoft.com/default.aspx?scid=https://support.microsoft.com:80/support\n     * /kb/articles/Q100/3/65.asp&NoWebContent=1\n     *\n     * @throws EncoderException for some failure scenarios"
        },
        "testMsSqlServer3": {
          "Javadoc": "* Examples for MS SQLServer from https://databases.about.com/library/weekly/aa042901a.htm"
        },
        "testNewInstance": {
          "Javadoc": "* https://issues.apache.org/jira/browse/CODEC-54 https://issues.apache.org/jira/browse/CODEC-56"
        },
        "testUsEnglishStatic": {
          "Javadoc": "* https://issues.apache.org/jira/browse/CODEC-54 https://issues.apache.org/jira/browse/CODEC-56"
        },
        "testUsMappingEWithAcute": {
          "Javadoc": "* Fancy characters are not mapped by the default US mapping.\n     *\n     * https://issues.apache.org/jira/browse/CODEC-30"
        },
        "testUsMappingOWithDiaeresis": {
          "Javadoc": "* Fancy characters are not mapped by the default US mapping.\n     *\n     * https://issues.apache.org/jira/browse/CODEC-30"
        },
        "testWikipediaAmericanSoundex": {
          "Javadoc": "* Tests example from https://en.wikipedia.org/wiki/Soundex#American_Soundex as of 2015-03-22."
        }
      }
    },
    "org.apache.commons.codec.net.BCodecTest": {
      "Javadoc": "\n * Quoted-printable codec test cases\n "
    },
    "org.apache.commons.codec.net.PercentCodecTest": {
      "Javadoc": "\n * Percent codec test cases.\n "
    },
    "org.apache.commons.codec.net.QCodecTest": {
      "Javadoc": "\n * Quoted-printable codec test cases\n "
    },
    "org.apache.commons.codec.net.QuotedPrintableCodecTest": {
      "Javadoc": "\n * Quoted-printable codec test cases\n "
    },
    "org.apache.commons.codec.net.RFC1522CodecTest": {
      "Javadoc": "\n * RFC 1522 compliant codec test cases\n "
    },
    "org.apache.commons.codec.net.RFC1522TestCodec": {
      "Javadoc": ""
    },
    "org.apache.commons.codec.net.RFC1522OverrideTestCodec": {
      "Javadoc": "\n * Tests overriding the package private RFC1522Codec.\n "
    },
    "org.apache.commons.codec.net.URLCodecTest": {
      "Javadoc": "\n * URL codec test cases\n "
    },
    "org.apache.commons.codec.net.UtilsTest": {
      "Javadoc": "\n * Tests Utils.\n * <p>\n * Methods currently get 100%/100% line/branch code coverage from other tests classes.\n * </p>\n ",
      "methods": {
        "testConstructor": {
          "Javadoc": "* We could make the constructor private but there does not seem to be a point to jumping through extra code hoops\n     * to restrict instantiation right now."
        }
      }
    },
    "org.apache.commons.codec.StringEncoderComparatorTest": {
      "Javadoc": "\n * Test cases for the StingEncoderComparator.\n "
    }
  }
}