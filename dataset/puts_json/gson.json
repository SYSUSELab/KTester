{
  "dataset": "gson",
  "classes": {
    "com.google.gson.examples.android.GsonProguardExampleActivity": {
      "Javadoc": "\n * Activity class illustrating how to use proguard with Gson\n *\n * @author Inderjeet Singh\n "
    },
    "com.google.gson.examples.android.model.Cart": {
      "Javadoc": "\n * A model object representing a cart that can be posted to an order-processing server\n * \n * @author Inderjeet Singh\n "
    },
    "com.google.gson.examples.android.model.LineItem": {
      "Javadoc": "\n * A line item in a cart. This is not a rest resource, just a dependent object\n *\n * @author Inderjeet Singh\n "
    },
    "com.google.gson.extras.examples.rawcollections.RawCollectionsExample": {
      "Javadoc": ""
    },
    "com.google.gson.extras.examples.rawcollections.Event": {
      "Javadoc": ""
    },
    "com.google.gson.graph.GraphAdapterBuilder": {
      "Javadoc": ""
    },
    "com.google.gson.graph.Factory": {
      "Javadoc": "",
      "methods": {
        "createInstance": {
          "Javadoc": "* Hook for the graph adapter to get a reference to a deserialized value\n     * before that value is fully populated. This is useful to deserialize\n     * values that directly or indirectly reference themselves: we can hand\n     * out an instance before read() returns.\n     *\n     * <p>Gson should only ever call this method when we're expecting it to;\n     * that is only when we've called back into Gson to deserialize a tree."
        }
      }
    },
    "com.google.gson.graph.Graph": {
      "Javadoc": "",
      "methods": {
        "nextName": {
          "Javadoc": "* Returns a unique name for an element to be inserted into the graph."
        }
      }
    },
    "com.google.gson.graph.Element": {
      "Javadoc": "\n   * An element of the graph during serialization or deserialization.\n   "
    },
    "com.google.gson.interceptors.InterceptorFactory": {
      "Javadoc": "\n * A type adapter factory that implements {@code @Intercept}.\n "
    },
    "com.google.gson.interceptors.InterceptorAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.interceptors.JsonPostDeserializer": {
      "Javadoc": "\n * This interface is implemented by a class that wishes to inspect or modify an object\n * after it has been deserialized. You must define a no-args constructor or register an\n * {@link InstanceCreator} for such a class.\n *\n * @author Inderjeet Singh\n ",
      "methods": {
        "postDeserialize": {
          "Javadoc": "* This method is called by Gson after the object has been deserialized from Json."
        }
      }
    },
    "com.google.gson.typeadapters.PostConstructAdapterFactory": {
      "Javadoc": ""
    },
    "com.google.gson.typeadapters.PostConstructAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.typeadapters.RuntimeTypeAdapterFactory": {
      "Javadoc": "\n * Adapts values whose runtime type may differ from their declaration type. This\n * is necessary when a field's type is not the same type that GSON should create\n * when deserializing that field. For example, consider these types:\n * <pre>   {@code\n *   abstract class Shape {\n *     int x;\n *     int y;\n *   }\n *   class Circle extends Shape {\n *     int radius;\n *   }\n *   class Rectangle extends Shape {\n *     int width;\n *     int height;\n *   }\n *   class Diamond extends Shape {\n *     int width;\n *     int height;\n *   }\n *   class Drawing {\n *     Shape bottomShape;\n *     Shape topShape;\n *   }\n * }</pre>\n * <p>Without additional type information, the serialized JSON is ambiguous. Is\n * the bottom shape in this drawing a rectangle or a diamond? <pre>   {@code\n *   {\n *     \"bottomShape\": {\n *       \"width\": 10,\n *       \"height\": 5,\n *       \"x\": 0,\n *       \"y\": 0\n *     },\n *     \"topShape\": {\n *       \"radius\": 2,\n *       \"x\": 4,\n *       \"y\": 1\n *     }\n *   }}</pre>\n * This class addresses this problem by adding type information to the\n * serialized JSON and honoring that type information when the JSON is\n * deserialized: <pre>   {@code\n *   {\n *     \"bottomShape\": {\n *       \"type\": \"Diamond\",\n *       \"width\": 10,\n *       \"height\": 5,\n *       \"x\": 0,\n *       \"y\": 0\n *     },\n *     \"topShape\": {\n *       \"type\": \"Circle\",\n *       \"radius\": 2,\n *       \"x\": 4,\n *       \"y\": 1\n *     }\n *   }}</pre>\n * Both the type field name ({@code \"type\"}) and the type labels ({@code\n * \"Rectangle\"}) are configurable.\n *\n * <h2>Registering Types</h2>\n * Create a {@code RuntimeTypeAdapterFactory} by passing the base type and type field\n * name to the {@link #of} factory method. If you don't supply an explicit type\n * field name, {@code \"type\"} will be used. <pre>   {@code\n *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory\n *       = RuntimeTypeAdapterFactory.of(Shape.class, \"type\");\n * }</pre>\n * Next register all of your subtypes. Every subtype must be explicitly\n * registered. This protects your application from injection attacks. If you\n * don't supply an explicit type label, the type's simple name will be used.\n * <pre>   {@code\n *   shapeAdapterFactory.registerSubtype(Rectangle.class, \"Rectangle\");\n *   shapeAdapterFactory.registerSubtype(Circle.class, \"Circle\");\n *   shapeAdapterFactory.registerSubtype(Diamond.class, \"Diamond\");\n * }</pre>\n * Finally, register the type adapter factory in your application's GSON builder:\n * <pre>   {@code\n *   Gson gson = new GsonBuilder()\n *       .registerTypeAdapterFactory(shapeAdapterFactory)\n *       .create();\n * }</pre>\n * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code\n *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory = RuntimeTypeAdapterFactory.of(Shape.class)\n *       .registerSubtype(Rectangle.class)\n *       .registerSubtype(Circle.class)\n *       .registerSubtype(Diamond.class);\n * }</pre>\n *\n * <h2>Serialization and deserialization</h2>\n * In order to serialize and deserialize a polymorphic object,\n * you must specify the base type explicitly.\n * <pre>   {@code\n *   Diamond diamond = new Diamond();\n *   String json = gson.toJson(diamond, Shape.class);\n * }</pre>\n * And then:\n * <pre>   {@code\n *   Shape shape = gson.fromJson(json, Shape.class);\n * }</pre>\n ",
      "methods": {
        "of": {
          "Javadoc": "* Creates a new runtime type adapter for {@code baseType} using {@code \"type\"} as\n   * the type field name."
        },
        "recognizeSubtypes": {
          "Javadoc": "* Ensures that this factory will handle not just the given {@code baseType}, but any subtype\n   * of that type."
        },
        "registerSubtype": {
          "Javadoc": "* Registers {@code type} identified by its {@link Class#getSimpleName simple\n   * name}. Labels are case sensitive.\n   *\n   * @throws IllegalArgumentException if either {@code type} or its simple name\n   *     have already been registered on this type adapter."
        }
      }
    },
    "com.google.gson.typeadapters.UtcDateTypeAdapter": {
      "Javadoc": "",
      "methods": {
        "format": {
          "Javadoc": "* Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n   *\n   * @param date the date to format\n   * @param millis true to include millis precision otherwise false\n   * @param tz timezone to use for the formatting (GMT will produce 'Z')\n   * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]"
        },
        "padInt": {
          "Javadoc": "* Zero pad a number to a specified length\n   *\n   * @param buffer buffer to use for padding\n   * @param value the integer value to pad if necessary.\n   * @param length the length of the string we should zero pad"
        },
        "parse": {
          "Javadoc": "* Parse a date from ISO-8601 formatted string. It expects a format\n   * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]\n   *\n   * @param date ISO string to parse in the appropriate format.\n   * @param pos The position to start parsing from, updated to where parsing stopped.\n   * @return the parsed date\n   * @throws ParseException if the date is not in the appropriate format"
        },
        "checkOffset": {
          "Javadoc": "* Check if the expected character exist at the given offset in the value.\n   *\n   * @param value the string to check at the specified offset\n   * @param offset the offset to look for the expected character\n   * @param expected the expected character\n   * @return true if the expected character exist at the given offset"
        },
        "parseInt": {
          "Javadoc": "* Parse an integer located between 2 given offsets in a string\n   *\n   * @param value the string to parse\n   * @param beginIndex the start index for the integer in the string\n   * @param endIndex the end index for the integer in the string\n   * @return the int\n   * @throws NumberFormatException if the value is not a number"
        }
      }
    },
    "com.google.gson.graph.GraphAdapterBuilderTest": {
      "Javadoc": ""
    },
    "com.google.gson.graph.Roshambo": {
      "Javadoc": ""
    },
    "com.google.gson.graph.Employee": {
      "Javadoc": ""
    },
    "com.google.gson.graph.Company": {
      "Javadoc": ""
    },
    "com.google.gson.interceptors.InterceptorTest": {
      "Javadoc": "\n * Unit tests for {@link Intercept} and {@link JsonPostDeserializer}.\n *\n * @author Inderjeet Singh\n "
    },
    "com.google.gson.interceptors.UserGroup": {
      "Javadoc": ""
    },
    "com.google.gson.interceptors.User": {
      "Javadoc": ""
    },
    "com.google.gson.interceptors.UserValidator": {
      "Javadoc": ""
    },
    "com.google.gson.interceptors.Address": {
      "Javadoc": ""
    },
    "com.google.gson.interceptors.AddressValidator": {
      "Javadoc": ""
    },
    "com.google.gson.typeadapters.PostConstructAdapterFactoryTest": {
      "Javadoc": ""
    },
    "com.google.gson.typeadapters.Sandwich": {
      "Javadoc": ""
    },
    "com.google.gson.typeadapters.MultipleSandwiches": {
      "Javadoc": ""
    },
    "com.google.gson.typeadapters.RuntimeTypeAdapterFactoryTest": {
      "Javadoc": ""
    },
    "com.google.gson.typeadapters.BillingInstrumentWrapper": {
      "Javadoc": ""
    },
    "com.google.gson.typeadapters.BillingInstrument": {
      "Javadoc": ""
    },
    "com.google.gson.typeadapters.CreditCard": {
      "Javadoc": ""
    },
    "com.google.gson.typeadapters.BankTransfer": {
      "Javadoc": ""
    },
    "com.google.gson.typeadapters.UtcDateTypeAdapterTest": {
      "Javadoc": "",
      "methods": {
        "testUtcDatesOnJdkBefore1_7": {
          "Javadoc": "* JDK 1.7 introduced support for XXX format to indicate UTC date. But Android is older JDK.\n   * We want to make sure that this date is parseable in Android."
        }
      }
    },
    "com.google.gson.ExclusionStrategy": {
      "Javadoc": "\n * A strategy (or policy) definition that is used to decide whether or not a field or\n * class should be serialized or deserialized as part of the JSON output/input.\n *\n * <p>The following are a few examples that shows how you can use this exclusion mechanism.\n *\n * <p><strong>Exclude fields and objects based on a particular class type:</strong>\n * <pre class=\"code\">\n * private static class SpecificClassExclusionStrategy implements ExclusionStrategy {\n *   private final Class&lt;?&gt; excludedThisClass;\n *\n *   public SpecificClassExclusionStrategy(Class&lt;?&gt; excludedThisClass) {\n *     this.excludedThisClass = excludedThisClass;\n *   }\n *\n *   public boolean shouldSkipClass(Class&lt;?&gt; clazz) {\n *     return excludedThisClass.equals(clazz);\n *   }\n *\n *   public boolean shouldSkipField(FieldAttributes f) {\n *     return excludedThisClass.equals(f.getDeclaredClass());\n *   }\n * }\n * </pre>\n *\n * <p><strong>Excludes fields and objects based on a particular annotation:</strong>\n * <pre class=\"code\">\n * public &#64;interface FooAnnotation {\n *   // some implementation here\n * }\n *\n * // Excludes any field (or class) that is tagged with an \"&#64;FooAnnotation\"\n * private static class FooAnnotationExclusionStrategy implements ExclusionStrategy {\n *   public boolean shouldSkipClass(Class&lt;?&gt; clazz) {\n *     return clazz.getAnnotation(FooAnnotation.class) != null;\n *   }\n *\n *   public boolean shouldSkipField(FieldAttributes f) {\n *     return f.getAnnotation(FooAnnotation.class) != null;\n *   }\n * }\n * </pre>\n *\n * <p>Now if you want to configure {@code Gson} to use a user defined exclusion strategy, then\n * the {@code GsonBuilder} is required. The following is an example of how you can use the\n * {@code GsonBuilder} to configure Gson to use one of the above samples:\n * <pre class=\"code\">\n * ExclusionStrategy excludeStrings = new UserDefinedExclusionStrategy(String.class);\n * Gson gson = new GsonBuilder()\n *     .setExclusionStrategies(excludeStrings)\n *     .create();\n * </pre>\n *\n * <p>For certain model classes, you may only want to serialize a field, but exclude it for\n * deserialization. To do that, you can write an {@code ExclusionStrategy} as per normal;\n * however, you would register it with the\n * {@link GsonBuilder#addDeserializationExclusionStrategy(ExclusionStrategy)} method.\n * For example:\n * <pre class=\"code\">\n * ExclusionStrategy excludeStrings = new UserDefinedExclusionStrategy(String.class);\n * Gson gson = new GsonBuilder()\n *     .addDeserializationExclusionStrategy(excludeStrings)\n *     .create();\n * </pre>\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n *\n * @see GsonBuilder#setExclusionStrategies(ExclusionStrategy...)\n * @see GsonBuilder#addDeserializationExclusionStrategy(ExclusionStrategy)\n * @see GsonBuilder#addSerializationExclusionStrategy(ExclusionStrategy)\n *\n * @since 1.4\n ",
      "methods": {
        "shouldSkipField": {
          "Javadoc": "* @param f the field object that is under test\n   * @return true if the field should be ignored; otherwise false"
        },
        "shouldSkipClass": {
          "Javadoc": "* @param clazz the class object that is under test\n   * @return true if the class should be ignored; otherwise false"
        }
      }
    },
    "com.google.gson.FieldAttributes": {
      "Javadoc": "\n * A data object that stores attributes of a field.\n *\n * <p>This class is immutable; therefore, it can be safely shared across threads.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n *\n * @since 1.4\n ",
      "methods": {
        "getDeclaringClass": {
          "Javadoc": "* @return the declaring class that contains this field"
        },
        "getName": {
          "Javadoc": "* @return the name of the field"
        },
        "getDeclaredType": {
          "Javadoc": "* <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   *\n   * Type listParameterizedType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code listParameterizedType} for the {@code red} field.\n   *\n   * @return the specific type declared for this field"
        },
        "getDeclaredClass": {
          "Javadoc": "* Returns the {@code Class} object that was declared for this field.\n   *\n   * <p>For example, assume the following class definition:\n   * <pre class=\"code\">\n   * public class Foo {\n   *   private String bar;\n   *   private List&lt;String&gt; red;\n   * }\n   * </pre>\n   *\n   * <p>This method would return {@code String.class} for the {@code bar} field and\n   * {@code List.class} for the {@code red} field.\n   *\n   * @return the specific class object that was declared for the field"
        },
        "getAnnotation": {
          "Javadoc": "* Return the {@code T} annotation object from this field if it exist; otherwise returns\n   * {@code null}.\n   *\n   * @param annotation the class of the annotation that will be retrieved\n   * @return the annotation instance if it is bound to the field; otherwise {@code null}"
        },
        "getAnnotations": {
          "Javadoc": "* Return the annotations that are present on this field.\n   *\n   * @return an array of all the annotations set on the field\n   * @since 1.4"
        },
        "hasModifier": {
          "Javadoc": "* Returns {@code true} if the field is defined with the {@code modifier}.\n   *\n   * <p>This method is meant to be called as:\n   * <pre class=\"code\">\n   * boolean hasPublicModifier = fieldAttribute.hasModifier(java.lang.reflect.Modifier.PUBLIC);\n   * </pre>\n   *\n   * @see java.lang.reflect.Modifier"
        }
      }
    },
    "com.google.gson.FieldNamingStrategy": {
      "Javadoc": "\n * A mechanism for providing custom field naming in Gson. This allows the client code to translate\n * field names into a particular convention that is not supported as a normal Java field\n * declaration rules. For example, Java does not support \"-\" characters in a field name.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n * @since 1.3\n ",
      "methods": {
        "translateName": {
          "Javadoc": "* Translates the field name into its JSON field name representation.\n   *\n   * @param f the field object that we are translating\n   * @return the translated field name.\n   * @since 1.3"
        }
      }
    },
    "com.google.gson.Gson": {
      "Javadoc": "\n * This is the main class for using Gson. Gson is typically used by first constructing a\n * Gson instance and then invoking {@link #toJson(Object)} or {@link #fromJson(String, Class)}\n * methods on it. Gson instances are Thread-safe so you can reuse them freely across multiple\n * threads.\n *\n * <p>You can create a Gson instance by invoking {@code new Gson()} if the default configuration\n * is all you need. You can also use {@link GsonBuilder} to build a Gson instance with various\n * configuration options such as versioning support, pretty printing, custom\n * {@link JsonSerializer}s, {@link JsonDeserializer}s, and {@link InstanceCreator}s.</p>\n *\n * <p>Here is an example of how Gson is used for a simple Class:\n *\n * <pre>\n * Gson gson = new Gson(); // Or use new GsonBuilder().create();\n * MyType target = new MyType();\n * String json = gson.toJson(target); // serializes target to JSON\n * MyType target2 = gson.fromJson(json, MyType.class); // deserializes json into target2\n * </pre>\n *\n * <p>If the type of the object that you are converting is a {@code ParameterizedType}\n * (i.e. has at least one type argument, for example {@code List<MyType>}) then for\n * deserialization you must use a {@code fromJson} method with {@link Type} or {@link TypeToken}\n * parameter to specify the parameterized type. For serialization specifying a {@code Type}\n * or {@code TypeToken} is optional, otherwise Gson will use the runtime type of the object.\n * {@link TypeToken} is a class provided by Gson which helps creating parameterized types.\n * Here is an example showing how this can be done:\n * <pre>\n * TypeToken&lt;List&lt;MyType&gt;&gt; listType = new TypeToken&lt;List&lt;MyType&gt;&gt;() {};\n * List&lt;MyType&gt; target = new LinkedList&lt;MyType&gt;();\n * target.add(new MyType(1, \"abc\"));\n *\n * Gson gson = new Gson();\n * // For serialization you normally do not have to specify the type, Gson will use\n * // the runtime type of the objects, however you can also specify it explicitly\n * String json = gson.toJson(target, listType.getType());\n *\n * // But for deserialization you have to specify the type\n * List&lt;MyType&gt; target2 = gson.fromJson(json, listType);\n * </pre>\n *\n * <p>See the <a href=\"https://github.com/google/gson/blob/master/UserGuide.md\">Gson User Guide</a>\n * for a more complete set of examples.</p>\n *\n * <h2>Lenient JSON handling</h2>\n * For legacy reasons most of the {@code Gson} methods allow JSON data which does not\n * comply with the JSON specification, regardless of whether {@link GsonBuilder#setLenient()}\n * is used or not. If this behavior is not desired, the following workarounds can be used:\n *\n * <h3>Serialization</h3>\n * <ol>\n *   <li>Use {@link #getAdapter(Class)} to obtain the adapter for the type to be serialized\n *   <li>When using an existing {@code JsonWriter}, manually apply the writer settings of this\n *       {@code Gson} instance listed by {@link #newJsonWriter(Writer)}.<br>\n *       Otherwise, when not using an existing {@code JsonWriter}, use {@link #newJsonWriter(Writer)}\n *       to construct one.\n *   <li>Call {@link TypeAdapter#write(JsonWriter, Object)}\n * </ol>\n *\n * <h3>Deserialization</h3>\n * <ol>\n *   <li>Use {@link #getAdapter(Class)} to obtain the adapter for the type to be deserialized\n *   <li>When using an existing {@code JsonReader}, manually apply the reader settings of this\n *       {@code Gson} instance listed by {@link #newJsonReader(Reader)}.<br>\n *       Otherwise, when not using an existing {@code JsonReader}, use {@link #newJsonReader(Reader)}\n *       to construct one.\n *   <li>Call {@link TypeAdapter#read(JsonReader)}\n *   <li>Call {@link JsonReader#peek()} and verify that the result is {@link JsonToken#END_DOCUMENT}\n *       to make sure there is no trailing data\n * </ol>\n *\n * @see TypeToken\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n * @author Jesse Wilson\n ",
      "methods": {
        "newBuilder": {
          "Javadoc": "* Returns a new GsonBuilder containing all custom factories and configuration used by the current\n   * instance.\n   *\n   * @return a GsonBuilder instance.\n   * @since 2.8.3"
        },
        "excluder": {
          "Javadoc": "* @deprecated This method by accident exposes an internal Gson class; it might be removed in a\n   * future version."
        },
        "fieldNamingStrategy": {
          "Javadoc": "* Returns the field naming strategy used by this Gson instance.\n   *\n   * @see GsonBuilder#setFieldNamingStrategy(FieldNamingStrategy)"
        },
        "serializeNulls": {
          "Javadoc": "* Returns whether this Gson instance is serializing JSON object properties with\n   * {@code null} values, or just omits them.\n   *\n   * @see GsonBuilder#serializeNulls()"
        },
        "htmlSafe": {
          "Javadoc": "* Returns whether this Gson instance produces JSON output which is\n   * HTML-safe, that means all HTML characters are escaped.\n   *\n   * @see GsonBuilder#disableHtmlEscaping()"
        },
        "getAdapter": {
          "Javadoc": "* Returns the type adapter for {@code type}.\n   *\n   * @throws IllegalArgumentException if this Gson instance cannot serialize and\n   *     deserialize {@code type}."
        },
        "getDelegateAdapter": {
          "Javadoc": "* This method is used to get an alternate type adapter for the specified type. This is used\n   * to access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\n   * may have registered. This features is typically used when you want to register a type\n   * adapter that does a little bit of work but then delegates further processing to the Gson\n   * default type adapter. Here is an example:\n   * <p>Let's say we want to write a type adapter that counts the number of objects being read\n   *  from or written to JSON. We can achieve this by writing a type adapter factory that uses\n   *  the <code>getDelegateAdapter</code> method:\n   *  <pre> {@code\n   *  class StatsTypeAdapterFactory implements TypeAdapterFactory {\n   *    public int numReads = 0;\n   *    public int numWrites = 0;\n   *    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n   *      final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);\n   *      return new TypeAdapter<T>() {\n   *        public void write(JsonWriter out, T value) throws IOException {\n   *          ++numWrites;\n   *          delegate.write(out, value);\n   *        }\n   *        public T read(JsonReader in) throws IOException {\n   *          ++numReads;\n   *          return delegate.read(in);\n   *        }\n   *      };\n   *    }\n   *  }\n   *  } </pre>\n   *  This factory can now be used like this:\n   *  <pre> {@code\n   *  StatsTypeAdapterFactory stats = new StatsTypeAdapterFactory();\n   *  Gson gson = new GsonBuilder().registerTypeAdapterFactory(stats).create();\n   *  // Call gson.toJson() and fromJson methods on objects\n   *  System.out.println(\"Num JSON reads\" + stats.numReads);\n   *  System.out.println(\"Num JSON writes\" + stats.numWrites);\n   *  }</pre>\n   *  Note that this call will skip all factories registered before {@code skipPast}. In case of\n   *  multiple TypeAdapterFactories registered it is up to the caller of this function to insure\n   *  that the order of registration does not prevent this method from reaching a factory they\n   *  would expect to reply from this call.\n   *  Note that since you can not override type adapter factories for String and Java primitive\n   *  types, our stats factory will not count the number of String or primitives that will be\n   *  read or written.\n   * @param skipPast The type adapter factory that needs to be skipped while searching for\n   *   a matching type adapter. In most cases, you should just pass <i>this</i> (the type adapter\n   *   factory from where {@code getDelegateAdapter} method is being invoked).\n   * @param type Type for which the delegate adapter is being searched for.\n   *\n   * @since 2.2"
        },
        "toJsonTree": {
          "Javadoc": "* This method serializes the specified object, including those of generic types, into its\n   * equivalent representation as a tree of {@link JsonElement}s. This method must be used if the\n   * specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)}\n   * instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n   * </pre>\n   * @return Json representation of {@code src}\n   * @since 1.4\n   *\n   * @see #toJsonTree(Object)"
        },
        "toJson": {
          "Javadoc": "* Writes the JSON for {@code jsonElement} to {@code writer}.\n   *\n   * <p>The JSON data is written in {@linkplain JsonWriter#setLenient(boolean) lenient mode},\n   * regardless of the lenient mode setting of the provided writer. The lenient mode setting\n   * of the writer is restored once this method returns.\n   *\n   * <p>The 'HTML-safe' and 'serialize {@code null}' settings of this {@code Gson} instance\n   * (configured by the {@link GsonBuilder}) are applied, and the original settings of the\n   * writer are restored once this method returns.\n   *\n   * @throws JsonIOException if there was a problem writing to the writer"
        },
        "newJsonWriter": {
          "Javadoc": "* Returns a new JSON writer configured for the settings on this Gson instance.\n   *\n   * <p>The following settings are considered:\n   * <ul>\n   *   <li>{@link GsonBuilder#disableHtmlEscaping()}</li>\n   *   <li>{@link GsonBuilder#generateNonExecutableJson()}</li>\n   *   <li>{@link GsonBuilder#serializeNulls()}</li>\n   *   <li>{@link GsonBuilder#setLenient()}</li>\n   *   <li>{@link GsonBuilder#setPrettyPrinting()}</li>\n   * </ul>"
        },
        "newJsonReader": {
          "Javadoc": "* Returns a new JSON reader configured for the settings on this Gson instance.\n   *\n   * <p>The following settings are considered:\n   * <ul>\n   *   <li>{@link GsonBuilder#setLenient()}</li>\n   * </ul>"
        },
        "fromJson": {
          "Javadoc": "* This method deserializes the JSON read from the specified parse tree into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the root of the parse tree of {@link JsonElement}s from which the object is to\n   * be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}\n   * </pre>\n   * @return an object of type T from the JSON. Returns {@code null} if {@code json} is {@code null}\n   * or if {@code json} is empty.\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n   *\n   * @see #fromJson(Reader, TypeToken)\n   * @see #fromJson(JsonElement, Class)\n   * @since 2.10"
        }
      }
    },
    "com.google.gson.FutureTypeAdapter": {
      "Javadoc": "\n   * Proxy type adapter for cyclic type graphs.\n   *\n   * <p><b>Important:</b> Setting the delegate adapter is not thread-safe; instances of\n   * {@code FutureTypeAdapter} must only be published to other threads after the delegate\n   * has been set.\n   *\n   * @see Gson#threadLocalAdapterResults\n   "
    },
    "com.google.gson.GsonBuilder": {
      "Javadoc": "\n * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration\n * options other than the default. For {@link Gson} with default configuration, it is simpler to\n * use {@code new Gson()}. {@code GsonBuilder} is best used by creating it, and then invoking its\n * various configuration methods, and finally calling create.</p>\n *\n * <p>The following is an example shows how to use the {@code GsonBuilder} to construct a Gson\n * instance:\n *\n * <pre>\n * Gson gson = new GsonBuilder()\n *     .registerTypeAdapter(Id.class, new IdTypeAdapter())\n *     .enableComplexMapKeySerialization()\n *     .serializeNulls()\n *     .setDateFormat(DateFormat.LONG)\n *     .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n *     .setPrettyPrinting()\n *     .setVersion(1.0)\n *     .create();\n * </pre>\n *\n * <p>NOTES:\n * <ul>\n * <li> the order of invocation of configuration methods does not matter.</li>\n * <li> The default serialization of {@link Date} and its subclasses in Gson does\n *  not contain time-zone information. So, if you are using date/time instances,\n *  use {@code GsonBuilder} and its {@code setDateFormat} methods.</li>\n * </ul>\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n * @author Jesse Wilson\n ",
      "methods": {
        "setVersion": {
          "Javadoc": "* Configures Gson to enable versioning support. Versioning support works based on the\n   * annotation types {@link Since} and {@link Until}. It allows including or excluding fields\n   * and classes based on the specified version. See the documentation of these annotation\n   * types for more information.\n   *\n   * <p>By default versioning support is disabled and usage of {@code @Since} and {@code @Until}\n   * has no effect.\n   *\n   * @param version the version number to use.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @throws IllegalArgumentException if the version number is NaN or negative\n   * @see Since\n   * @see Until"
        },
        "excludeFieldsWithModifiers": {
          "Javadoc": "* Configures Gson to excludes all class fields that have the specified modifiers. By default,\n   * Gson will exclude all fields marked {@code transient} or {@code static}. This method will\n   * override that behavior.\n   *\n   * <p>This is a convenience method which behaves as if an {@link ExclusionStrategy} which\n   * excludes these fields was {@linkplain #setExclusionStrategies(ExclusionStrategy...) registered with this builder}.\n   *\n   * @param modifiers the field modifiers. You must use the modifiers specified in the\n   * {@link java.lang.reflect.Modifier} class. For example,\n   * {@link java.lang.reflect.Modifier#TRANSIENT},\n   * {@link java.lang.reflect.Modifier#STATIC}.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern"
        },
        "generateNonExecutableJson": {
          "Javadoc": "* Makes the output JSON non-executable in Javascript by prefixing the generated JSON with some\n   * special text. This prevents attacks from third-party sites through script sourcing. See\n   * <a href=\"http://code.google.com/p/google-gson/issues/detail?id=42\">Gson Issue 42</a>\n   * for details.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3"
        },
        "excludeFieldsWithoutExposeAnnotation": {
          "Javadoc": "* Configures Gson to exclude all fields from consideration for serialization and deserialization\n   * that do not have the {@link com.google.gson.annotations.Expose} annotation.\n   *\n   * <p>This is a convenience method which behaves as if an {@link ExclusionStrategy} which excludes\n   * these fields was {@linkplain #setExclusionStrategies(ExclusionStrategy...) registered with this builder}.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern"
        },
        "serializeNulls": {
          "Javadoc": "* Configure Gson to serialize null fields. By default, Gson omits all fields that are null\n   * during serialization.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.2"
        },
        "enableComplexMapKeySerialization": {
          "Javadoc": "* Enabling this feature will only change the serialized form if the map key is\n   * a complex type (i.e. non-primitive) in its <strong>serialized</strong> JSON\n   * form. The default implementation of map serialization uses {@code toString()}\n   * on the key; however, when this is called then one of the following cases\n   * apply:\n   *\n   * <p><b>Maps as JSON objects</b>\n   *\n   * <p>For this case, assume that a type adapter is registered to serialize and\n   * deserialize some {@code Point} class, which contains an x and y coordinate,\n   * to/from the JSON Primitive string value {@code \"(x,y)\"}. The Java map would\n   * then be serialized as a {@link JsonObject}.\n   *\n   * <p>Below is an example:\n   * <pre>  {@code\n   *   Gson gson = new GsonBuilder()\n   *       .register(Point.class, new MyPointTypeAdapter())\n   *       .enableComplexMapKeySerialization()\n   *       .create();\n   *\n   *   Map<Point, String> original = new LinkedHashMap<>();\n   *   original.put(new Point(5, 6), \"a\");\n   *   original.put(new Point(8, 8), \"b\");\n   *   System.out.println(gson.toJson(original, type));\n   * }</pre>\n   * The above code prints this JSON object:<pre>  {@code\n   *   {\n   *     \"(5,6)\": \"a\",\n   *     \"(8,8)\": \"b\"\n   *   }\n   * }</pre>\n   *\n   * <p><b>Maps as JSON arrays</b>\n   *\n   * <p>For this case, assume that a type adapter was NOT registered for some\n   * {@code Point} class, but rather the default Gson serialization is applied.\n   * In this case, some {@code new Point(2,3)} would serialize as {@code\n   * {\"x\":2,\"y\":3}}.\n   *\n   * <p>Given the assumption above, a {@code Map<Point, String>} will be\n   * serialize as an array of arrays (can be viewed as an entry set of pairs).\n   *\n   * <p>Below is an example of serializing complex types as JSON arrays:\n   * <pre> {@code\n   *   Gson gson = new GsonBuilder()\n   *       .enableComplexMapKeySerialization()\n   *       .create();\n   *\n   *   Map<Point, String> original = new LinkedHashMap<>();\n   *   original.put(new Point(5, 6), \"a\");\n   *   original.put(new Point(8, 8), \"b\");\n   *   System.out.println(gson.toJson(original, type));\n   * }\n   * </pre>\n   *\n   * The JSON output would look as follows:\n   * <pre>   {@code\n   *   [\n   *     [\n   *       {\n   *         \"x\": 5,\n   *         \"y\": 6\n   *       },\n   *       \"a\"\n   *     ],\n   *     [\n   *       {\n   *         \"x\": 8,\n   *         \"y\": 8\n   *       },\n   *       \"b\"\n   *     ]\n   *   ]\n   * }</pre>\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.7"
        },
        "disableInnerClassSerialization": {
          "Javadoc": "* Configures Gson to exclude inner classes (= non-{@code static} nested classes) during serialization\n   * and deserialization. This is a convenience method which behaves as if an {@link ExclusionStrategy}\n   * which excludes inner classes was {@linkplain #setExclusionStrategies(ExclusionStrategy...) registered with this builder}.\n   * This means inner classes will be serialized as JSON {@code null}, and will be deserialized as\n   * Java {@code null} with their JSON data being ignored. And fields with an inner class as type will\n   * be ignored during serialization and deserialization.\n   *\n   * <p>By default Gson serializes and deserializes inner classes, but ignores references to the\n   * enclosing instance. Deserialization might not be possible at all when {@link #disableJdkUnsafe()}\n   * is used (and no custom {@link InstanceCreator} is registered), or it can lead to unexpected\n   * {@code NullPointerException}s when the deserialized instance is used afterwards.\n   *\n   * <p>In general using inner classes with Gson should be avoided; they should be converted to {@code static}\n   * nested classes if possible.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3"
        },
        "setLongSerializationPolicy": {
          "Javadoc": "* Configures Gson to apply a specific serialization policy for {@code Long} and {@code long}\n   * objects.\n   *\n   * @param serializationPolicy the particular policy to use for serializing longs.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3"
        },
        "setFieldNamingPolicy": {
          "Javadoc": "* Configures Gson to apply a specific naming policy to an object's fields during serialization\n   * and deserialization.\n   *\n   * <p>This method just delegates to {@link #setFieldNamingStrategy(FieldNamingStrategy)}."
        },
        "setFieldNamingStrategy": {
          "Javadoc": "* Configures Gson to apply a specific naming strategy to an object's fields during\n   * serialization and deserialization.\n   *\n   * <p>The created Gson instance might only use the field naming strategy once for a\n   * field and cache the result. It is not guaranteed that the strategy will be used\n   * again every time the value of a field is serialized or deserialized.\n   *\n   * @param fieldNamingStrategy the naming strategy to apply to the fields\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3"
        },
        "setObjectToNumberStrategy": {
          "Javadoc": "* Configures Gson to apply a specific number strategy during deserialization of {@link Object}.\n   *\n   * @param objectToNumberStrategy the actual object-to-number strategy\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @see ToNumberPolicy#DOUBLE The default object-to-number strategy\n   * @since 2.8.9"
        },
        "setNumberToNumberStrategy": {
          "Javadoc": "* Configures Gson to apply a specific number strategy during deserialization of {@link Number}.\n   *\n   * @param numberToNumberStrategy the actual number-to-number strategy\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @see ToNumberPolicy#LAZILY_PARSED_NUMBER The default number-to-number strategy\n   * @since 2.8.9"
        },
        "setExclusionStrategies": {
          "Javadoc": "* Configures Gson to apply a set of exclusion strategies during both serialization and\n   * deserialization. Each of the {@code strategies} will be applied as a disjunction rule.\n   * This means that if one of the {@code strategies} suggests that a field (or class) should be\n   * skipped then that field (or object) is skipped during serialization/deserialization.\n   * The strategies are added to the existing strategies (if any); the existing strategies\n   * are not replaced.\n   *\n   * <p>Fields are excluded for serialization and deserialization when\n   * {@link ExclusionStrategy#shouldSkipField(FieldAttributes) shouldSkipField} returns {@code true},\n   * or when {@link ExclusionStrategy#shouldSkipClass(Class) shouldSkipClass} returns {@code true}\n   * for the field type. Gson behaves as if the field did not exist; its value is not serialized\n   * and on deserialization if a JSON member with this name exists it is skipped by default.<br>\n   * When objects of an excluded type (as determined by\n   * {@link ExclusionStrategy#shouldSkipClass(Class) shouldSkipClass}) are serialized a\n   * JSON null is written to output, and when deserialized the JSON value is skipped and\n   * {@code null} is returned.\n   *\n   * <p>The created Gson instance might only use an exclusion strategy once for a field or\n   * class and cache the result. It is not guaranteed that the strategy will be used again\n   * every time the value of a field or a class is serialized or deserialized.\n   *\n   * @param strategies the set of strategy object to apply during object (de)serialization.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.4"
        },
        "addSerializationExclusionStrategy": {
          "Javadoc": "* Configures Gson to apply the passed in exclusion strategy during serialization.\n   * If this method is invoked numerous times with different exclusion strategy objects\n   * then the exclusion strategies that were added will be applied as a disjunction rule.\n   * This means that if one of the added exclusion strategies suggests that a field (or\n   * class) should be skipped then that field (or object) is skipped during its\n   * serialization.\n   *\n   * <p>See the documentation of {@link #setExclusionStrategies(ExclusionStrategy...)}\n   * for a detailed description of the effect of exclusion strategies.\n   *\n   * @param strategy an exclusion strategy to apply during serialization.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.7"
        },
        "addDeserializationExclusionStrategy": {
          "Javadoc": "* Configures Gson to apply the passed in exclusion strategy during deserialization.\n   * If this method is invoked numerous times with different exclusion strategy objects\n   * then the exclusion strategies that were added will be applied as a disjunction rule.\n   * This means that if one of the added exclusion strategies suggests that a field (or\n   * class) should be skipped then that field (or object) is skipped during its\n   * deserialization.\n   *\n   * <p>See the documentation of {@link #setExclusionStrategies(ExclusionStrategy...)}\n   * for a detailed description of the effect of exclusion strategies.\n   *\n   * @param strategy an exclusion strategy to apply during deserialization.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.7"
        },
        "setPrettyPrinting": {
          "Javadoc": "* Configures Gson to output Json that fits in a page for pretty printing. This option only\n   * affects Json serialization.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern"
        },
        "setLenient": {
          "Javadoc": "* Configures Gson to allow JSON data which does not strictly comply with the JSON specification.\n   *\n   * <p>Note: Due to legacy reasons most methods of Gson are always lenient, regardless of\n   * whether this builder method is used.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @see JsonReader#setLenient(boolean)\n   * @see JsonWriter#setLenient(boolean)"
        },
        "disableHtmlEscaping": {
          "Javadoc": "* By default, Gson escapes HTML characters such as &lt; &gt; etc. Use this option to configure\n   * Gson to pass-through HTML characters as is.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3"
        },
        "setDateFormat": {
          "Javadoc": "* Configures Gson to to serialize {@code Date} objects according to the style value provided.\n   * You can call this method or {@link #setDateFormat(String)} multiple times, but only the last\n   * invocation will be used to decide the serialization format.\n   *\n   * <p>Note that this style value should be one of the predefined constants in the\n   * {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more\n   * information on the valid style constants.</p>\n   *\n   * @param dateStyle the predefined date style that date objects will be serialized/deserialized\n   * to/from\n   * @param timeStyle the predefined style for the time portion of the date objects\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.2"
        },
        "registerTypeAdapter": {
          "Javadoc": "* Configures Gson for custom serialization or deserialization. This method combines the\n   * registration of an {@link TypeAdapter}, {@link InstanceCreator}, {@link JsonSerializer}, and a\n   * {@link JsonDeserializer}. It is best used when a single object {@code typeAdapter} implements\n   * all the required interfaces for custom serialization with Gson. If a type adapter was\n   * previously registered for the specified {@code type}, it is overwritten.\n   *\n   * <p>This registers the type specified and no other types: you must manually register related\n   * types! For example, applications registering {@code boolean.class} should also register {@code\n   * Boolean.class}.\n   *\n   * <p>{@link JsonSerializer} and {@link JsonDeserializer} are made \"{@code null}-safe\". This\n   * means when trying to serialize {@code null}, Gson will write a JSON {@code null} and the\n   * serializer is not called. Similarly when deserializing a JSON {@code null}, Gson will emit\n   * {@code null} without calling the deserializer. If it is desired to handle {@code null} values,\n   * a {@link TypeAdapter} should be used instead.\n   *\n   * @param type the type definition for the type adapter being registered\n   * @param typeAdapter This object must implement at least one of the {@link TypeAdapter},\n   * {@link InstanceCreator}, {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern"
        },
        "registerTypeAdapterFactory": {
          "Javadoc": "* Register a factory for type adapters. Registering a factory is useful when the type\n   * adapter needs to be configured based on the type of the field being processed. Gson\n   * is designed to handle a large number of factories, so you should consider registering\n   * them to be at par with registering an individual type adapter.\n   *\n   * <p>The created Gson instance might only use the factory once to create an adapter for\n   * a specific type and cache the result. It is not guaranteed that the factory will be used\n   * again every time the type is serialized or deserialized.\n   *\n   * @since 2.1"
        },
        "registerTypeHierarchyAdapter": {
          "Javadoc": "* Configures Gson for custom serialization or deserialization for an inheritance type hierarchy.\n   * This method combines the registration of a {@link TypeAdapter}, {@link JsonSerializer} and\n   * a {@link JsonDeserializer}. If a type adapter was previously registered for the specified\n   * type hierarchy, it is overridden. If a type adapter is registered for a specific type in\n   * the type hierarchy, it will be invoked instead of the one registered for the type hierarchy.\n   *\n   * @param baseType the class definition for the type adapter being registered for the base class\n   *        or interface\n   * @param typeAdapter This object must implement at least one of {@link TypeAdapter},\n   *        {@link JsonSerializer} or {@link JsonDeserializer} interfaces.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.7"
        },
        "serializeSpecialFloatingPointValues": {
          "Javadoc": "* Section 2.4 of <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a> disallows\n   * special double values (NaN, Infinity, -Infinity). However,\n   * <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\">Javascript\n   * specification</a> (see section 4.3.20, 4.3.22, 4.3.23) allows these values as valid Javascript\n   * values. Moreover, most JavaScript engines will accept these special values in JSON without\n   * problem. So, at a practical level, it makes sense to accept these values as valid JSON even\n   * though JSON specification disallows them.\n   *\n   * <p>Gson always accepts these special values during deserialization. However, it outputs\n   * strictly compliant JSON. Hence, if it encounters a float value {@link Float#NaN},\n   * {@link Float#POSITIVE_INFINITY}, {@link Float#NEGATIVE_INFINITY}, or a double value\n   * {@link Double#NaN}, {@link Double#POSITIVE_INFINITY}, {@link Double#NEGATIVE_INFINITY}, it\n   * will throw an {@link IllegalArgumentException}. This method provides a way to override the\n   * default behavior when you know that the JSON receiver will be able to handle these special\n   * values.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3"
        },
        "disableJdkUnsafe": {
          "Javadoc": "* Disables usage of JDK's {@code sun.misc.Unsafe}.\n   *\n   * <p>By default Gson uses {@code Unsafe} to create instances of classes which don't have\n   * a no-args constructor. However, {@code Unsafe} might not be available for all Java\n   * runtimes. For example Android does not provide {@code Unsafe}, or only with limited\n   * functionality. Additionally {@code Unsafe} creates instances without executing any\n   * constructor or initializer block, or performing initialization of field values. This can\n   * lead to surprising and difficult to debug errors.\n   * Therefore, to get reliable behavior regardless of which runtime is used, and to detect\n   * classes which cannot be deserialized in an early stage of development, this method allows\n   * disabling usage of {@code Unsafe}.\n   *\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 2.9.0"
        },
        "addReflectionAccessFilter": {
          "Javadoc": "* Adds a reflection access filter. A reflection access filter prevents Gson from using\n   * reflection for the serialization and deserialization of certain classes. The logic in\n   * the filter specifies which classes those are.\n   *\n   * <p>Filters will be invoked in reverse registration order, that is, the most recently\n   * added filter will be invoked first.\n   *\n   * <p>By default Gson has no filters configured and will try to use reflection for\n   * all classes for which no {@link TypeAdapter} has been registered, and for which no\n   * built-in Gson {@code TypeAdapter} exists.\n   *\n   * <p>The created Gson instance might only use an access filter once for a class or its\n   * members and cache the result. It is not guaranteed that the filter will be used again\n   * every time a class or its members are accessed during serialization or deserialization.\n   *\n   * @param filter filter to add\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 2.9.1"
        },
        "create": {
          "Javadoc": "* Creates a {@link Gson} instance based on the current configuration. This method is free of\n   * side-effects to this {@code GsonBuilder} instance and hence can be called multiple times.\n   *\n   * @return an instance of Gson configured with the options currently set in this builder"
        }
      }
    },
    "com.google.gson.InstanceCreator": {
      "Javadoc": "\n * This interface is implemented to create instances of a class that does not define a no-args\n * constructor. If you can modify the class, you should instead add a private, or public\n * no-args constructor. However, that is not possible for library classes, such as JDK classes, or\n * a third-party library that you do not have source-code of. In such cases, you should define an\n * instance creator for the class. Implementations of this interface should be registered with\n * {@link GsonBuilder#registerTypeAdapter(Type, Object)} method before Gson will be able to use\n * them.\n * <p>Let us look at an example where defining an InstanceCreator might be useful. The\n * {@code Id} class defined below does not have a default no-args constructor.</p>\n *\n * <pre>\n * public class Id&lt;T&gt; {\n *   private final Class&lt;T&gt; clazz;\n *   private final long value;\n *   public Id(Class&lt;T&gt; clazz, long value) {\n *     this.clazz = clazz;\n *     this.value = value;\n *   }\n * }\n * </pre>\n *\n * <p>If Gson encounters an object of type {@code Id} during deserialization, it will throw an\n * exception. The easiest way to solve this problem will be to add a (public or private) no-args\n * constructor as follows:</p>\n *\n * <pre>\n * private Id() {\n *   this(Object.class, 0L);\n * }\n * </pre>\n *\n * <p>However, let us assume that the developer does not have access to the source-code of the\n * {@code Id} class, or does not want to define a no-args constructor for it. The developer\n * can solve this problem by defining an {@code InstanceCreator} for {@code Id}:</p>\n *\n * <pre>\n * class IdInstanceCreator implements InstanceCreator&lt;Id&gt; {\n *   public Id createInstance(Type type) {\n *     return new Id(Object.class, 0L);\n *   }\n * }\n * </pre>\n *\n * <p>Note that it does not matter what the fields of the created instance contain since Gson will\n * overwrite them with the deserialized values specified in Json. You should also ensure that a\n * <i>new</i> object is returned, not a common object since its fields will be overwritten.\n * The developer will need to register {@code IdInstanceCreator} with Gson as follows:</p>\n *\n * <pre>\n * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdInstanceCreator()).create();\n * </pre>\n *\n * @param <T> the type of object that will be created by this implementation.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "createInstance": {
          "Javadoc": "* Gson invokes this call-back method during deserialization to create an instance of the\n   * specified type. The fields of the returned instance are overwritten with the data present\n   * in the Json. Since the prior contents of the object are destroyed and overwritten, do not\n   * return an instance that is useful elsewhere. In particular, do not return a common instance,\n   * always use {@code new} to create a new instance.\n   *\n   * @param type the parameterized T represented as a {@link Type}.\n   * @return a default object instance of type T."
        }
      }
    },
    "com.google.gson.internal.$Gson$Preconditions": {
      "Javadoc": "\r\n * A simple utility class used to check method Preconditions.\r\n *\r\n * <pre>\r\n * public long divideBy(long value) {\r\n *   Preconditions.checkArgument(value != 0);\r\n *   return this.value / value;\r\n * }\r\n * </pre>\r\n *\r\n * @author Inderjeet Singh\r\n * @author Joel Leitch\r\n "
    },
    "com.google.gson.internal.$Gson$Types": {
      "Javadoc": "\n * Static methods for working with types.\n *\n * @author Bob Lee\n * @author Jesse Wilson\n ",
      "methods": {
        "newParameterizedTypeWithOwner": {
          "Javadoc": "* Returns a new parameterized type, applying {@code typeArguments} to\n   * {@code rawType} and enclosed by {@code ownerType}.\n   *\n   * @return a {@link java.io.Serializable serializable} parameterized type."
        },
        "arrayOf": {
          "Javadoc": "* Returns an array type whose elements are all instances of\n   * {@code componentType}.\n   *\n   * @return a {@link java.io.Serializable serializable} generic array type."
        },
        "subtypeOf": {
          "Javadoc": "* Returns a type that represents an unknown type that extends {@code bound}.\n   * For example, if {@code bound} is {@code CharSequence.class}, this returns\n   * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},\n   * this returns {@code ?}, which is shorthand for {@code ? extends Object}."
        },
        "supertypeOf": {
          "Javadoc": "* Returns a type that represents an unknown supertype of {@code bound}. For\n   * example, if {@code bound} is {@code String.class}, this returns {@code ?\n   * super String}."
        },
        "canonicalize": {
          "Javadoc": "* Returns a type that is functionally equal but not necessarily equal\n   * according to {@link Object#equals(Object) Object.equals()}. The returned\n   * type is {@link java.io.Serializable}."
        },
        "equals": {
          "Javadoc": "* Returns true if {@code a} and {@code b} are equal."
        },
        "getGenericSupertype": {
          "Javadoc": "* Returns the generic supertype for {@code supertype}. For example, given a class {@code\n   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\n   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}."
        },
        "getSupertype": {
          "Javadoc": "* Returns the generic form of {@code supertype}. For example, if this is {@code\n   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\n   * Iterable.class}.\n   *\n   * @param supertype a superclass of, or interface implemented by, this."
        },
        "getArrayComponentType": {
          "Javadoc": "* Returns the component type of this array type.\n   * @throws ClassCastException if this type is not an array."
        },
        "getCollectionElementType": {
          "Javadoc": "* Returns the element type of this collection type.\n   * @throws IllegalArgumentException if this type is not a collection."
        },
        "getMapKeyAndValueTypes": {
          "Javadoc": "* Returns a two element array containing this map's key and value types in\n   * positions 0 and 1 respectively."
        },
        "declaringClassOf": {
          "Javadoc": "* Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n   * a class."
        }
      }
    },
    "com.google.gson.internal.ParameterizedTypeImpl": {
      "Javadoc": ""
    },
    "com.google.gson.internal.GenericArrayTypeImpl": {
      "Javadoc": ""
    },
    "com.google.gson.internal.WildcardTypeImpl": {
      "Javadoc": "\n   * The WildcardType interface supports multiple upper bounds and multiple\n   * lower bounds. We only support what the target Java version supports - at most one\n   * bound, see also https://bugs.openjdk.java.net/browse/JDK-8250660. If a lower bound\n   * is set, the upper bound must be Object.class.\n   "
    },
    "com.google.gson.internal.bind.ArrayTypeAdapter": {
      "Javadoc": "\n * Adapt an array of objects.\n "
    },
    "com.google.gson.internal.bind.CollectionTypeAdapterFactory": {
      "Javadoc": "\n * Adapt a homogeneous collection of objects.\n "
    },
    "com.google.gson.internal.bind.Adapter": {
      "Javadoc": "",
      "methods": {
        "createAccumulator": {
          "Javadoc": "Create the Object that will be used to collect each field value"
        },
        "readField": {
          "Javadoc": "* Read a single BoundField into the accumulator. The JsonReader will be pointed at the\n     * start of the value for the BoundField to read from."
        },
        "finalize": {
          "Javadoc": "Convert the accumulator to a final instance of T."
        }
      }
    },
    "com.google.gson.internal.bind.DateTypeAdapter": {
      "Javadoc": "\n * Adapter for Date. Although this class appears stateless, it is not.\n * DateFormat captures its time zone and locale when it is created, which gives\n * this class state. DateFormat isn't thread safe either, so this class has\n * to synchronize its read and write methods.\n "
    },
    "com.google.gson.internal.bind.DefaultDateTypeAdapter": {
      "Javadoc": "\n * This type adapter supports subclasses of date by defining a\n * {@link DefaultDateTypeAdapter.DateType} and then using its {@code createAdapterFactory}\n * methods.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.internal.bind.DateType": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory": {
      "Javadoc": "\n * Given a type T, looks for the annotation {@link JsonAdapter} and uses an instance of the\n * specified class as the default type adapter.\n *\n * @since 2.3\n "
    },
    "com.google.gson.internal.bind.JsonTreeReader": {
      "Javadoc": "\n * This reader walks the elements of a JsonElement as if it was coming from a\n * character stream.\n *\n * @author Jesse Wilson\n "
    },
    "com.google.gson.internal.bind.JsonTreeWriter": {
      "Javadoc": "\n * This writer creates a JsonElement.\n ",
      "methods": {
        "get": {
          "Javadoc": "* Returns the top level object produced by this writer."
        }
      }
    },
    "com.google.gson.internal.bind.MapTypeAdapterFactory": {
      "Javadoc": "\n * Adapts maps to either JSON objects or JSON arrays.\n *\n * <h2>Maps as JSON objects</h2>\n * For primitive keys or when complex map key serialization is not enabled, this\n * converts Java {@link Map Maps} to JSON Objects. This requires that map keys\n * can be serialized as strings; this is insufficient for some key types. For\n * example, consider a map whose keys are points on a grid. The default JSON\n * form encodes reasonably: <pre>   {@code\n *   Map<Point, String> original = new LinkedHashMap<>();\n *   original.put(new Point(5, 6), \"a\");\n *   original.put(new Point(8, 8), \"b\");\n *   System.out.println(gson.toJson(original, type));\n * }</pre>\n * The above code prints this JSON object:<pre>   {@code\n *   {\n *     \"(5,6)\": \"a\",\n *     \"(8,8)\": \"b\"\n *   }\n * }</pre>\n * But GSON is unable to deserialize this value because the JSON string name is\n * just the {@link Object#toString() toString()} of the map key. Attempting to\n * convert the above JSON to an object fails with a parse exception:\n * <pre>com.google.gson.JsonParseException: Expecting object found: \"(5,6)\"\n *   at com.google.gson.JsonObjectDeserializationVisitor.visitFieldUsingCustomHandler\n *   at com.google.gson.ObjectNavigator.navigateClassFields\n *   ...</pre>\n *\n * <h2>Maps as JSON arrays</h2>\n * An alternative approach taken by this type adapter when it is required and\n * complex map key serialization is enabled is to encode maps as arrays of map\n * entries. Each map entry is a two element array containing a key and a value.\n * This approach is more flexible because any type can be used as the map's key;\n * not just strings. But it's also less portable because the receiver of such\n * JSON must be aware of the map entry convention.\n *\n * <p>Register this adapter when you are creating your GSON instance.\n * <pre>   {@code\n *   Gson gson = new GsonBuilder()\n *     .registerTypeAdapter(Map.class, new MapAsArrayTypeAdapter())\n *     .create();\n * }</pre>\n * This will change the structure of the JSON emitted by the code above. Now we\n * get an array. In this case the arrays elements are map entries:\n * <pre>   {@code\n *   [\n *     [\n *       {\n *         \"x\": 5,\n *         \"y\": 6\n *       },\n *       \"a\",\n *     ],\n *     [\n *       {\n *         \"x\": 8,\n *         \"y\": 8\n *       },\n *       \"b\"\n *     ]\n *   ]\n * }</pre>\n * This format will serialize and deserialize just fine as long as this adapter\n * is registered.\n ",
      "methods": {
        "getKeyAdapter": {
          "Javadoc": "* Returns a type adapter that writes the value as a string."
        }
      }
    },
    "com.google.gson.internal.bind.NumberTypeAdapter": {
      "Javadoc": "\n * Type adapter for {@link Number}.\n "
    },
    "com.google.gson.internal.bind.ObjectTypeAdapter": {
      "Javadoc": "\n * Adapts types whose static type is only 'Object'. Uses getClass() on\n * serialization and a primitive/Map/List on deserialization.\n ",
      "methods": {
        "tryBeginNesting": {
          "Javadoc": "* Tries to begin reading a JSON array or JSON object, returning {@code null} if\n   * the next element is neither of those."
        },
        "readTerminal": {
          "Javadoc": "Reads an {@code Object} which cannot have any nested elements"
        }
      }
    },
    "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory": {
      "Javadoc": "\n * Type adapter that reflects over the fields and methods of a class.\n ",
      "methods": {
        "getFieldNames": {
          "Javadoc": "first element holds the default name"
        }
      }
    },
    "com.google.gson.internal.bind.BoundField": {
      "Javadoc": "",
      "methods": {
        "write": {
          "Javadoc": "Read this field value from the source, and append its JSON value to the writer"
        },
        "readIntoArray": {
          "Javadoc": "Read the value into the target array, used to provide constructor arguments for records"
        },
        "readIntoField": {
          "Javadoc": "Read the value from the reader, and set it on the corresponding field on target via reflection"
        }
      }
    },
    "com.google.gson.internal.bind.FieldReflectionAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.RecordAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.SerializationDelegatingTypeAdapter": {
      "Javadoc": "\n * Type adapter which might delegate serialization to another adapter.\n ",
      "methods": {
        "getSerializationDelegate": {
          "Javadoc": "* Returns the adapter used for serialization, might be {@code this} or another adapter.\n   * That other adapter might itself also be a {@code SerializationDelegatingTypeAdapter}."
        }
      }
    },
    "com.google.gson.internal.bind.TreeTypeAdapter": {
      "Javadoc": "\n * Adapts a Gson 1.x tree-style adapter as a streaming TypeAdapter. Since the\n * tree adapter may be serialization-only or deserialization-only, this class\n * has a facility to lookup a delegate type adapter on demand.\n ",
      "methods": {
        "getSerializationDelegate": {
          "Javadoc": "* Returns the type adapter which is used for serialization. Returns {@code this}\n   * if this {@code TreeTypeAdapter} has a {@link #serializer}; otherwise returns\n   * the delegate."
        },
        "newFactory": {
          "Javadoc": "* Returns a new factory that will match each type against {@code exactType}."
        },
        "newFactoryWithMatchRawType": {
          "Javadoc": "* Returns a new factory that will match each type and its raw type against\n   * {@code exactType}."
        },
        "newTypeHierarchyFactory": {
          "Javadoc": "* Returns a new factory that will match each type's raw type for assignability\n   * to {@code hierarchyType}."
        }
      }
    },
    "com.google.gson.internal.bind.SingleTypeFactory": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.GsonContextImpl": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper": {
      "Javadoc": "",
      "methods": {
        "isReflective": {
          "Javadoc": "* Returns whether the type adapter uses reflection.\r\n   *\r\n   * @param typeAdapter the type adapter to check."
        },
        "getRuntimeTypeIfMoreSpecific": {
          "Javadoc": "* Finds a compatible runtime type if it is more specific"
        }
      }
    },
    "com.google.gson.internal.bind.TypeAdapters": {
      "Javadoc": "\n * Type adapters for basic types.\n ",
      "methods": {
        "newTypeHierarchyFactory": {
          "Javadoc": "* Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested."
        }
      }
    },
    "com.google.gson.internal.bind.EnumTypeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.util.ISO8601Utils": {
      "Javadoc": "",
      "methods": {
        "format": {
          "Javadoc": "* Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n     * \n     * @param date the date to format\n     * @param millis true to include millis precision otherwise false\n     * @param tz timezone to use for the formatting (UTC will produce 'Z')\n     * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]"
        },
        "parse": {
          "Javadoc": "* Parse a date from ISO-8601 formatted string. It expects a format\n     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n     * \n     * @param date ISO string to parse in the appropriate format.\n     * @param pos The position to start parsing from, updated to where parsing stopped.\n     * @return the parsed date\n     * @throws ParseException if the date is not in the appropriate format"
        },
        "checkOffset": {
          "Javadoc": "* Check if the expected character exist at the given offset in the value.\n     * \n     * @param value the string to check at the specified offset\n     * @param offset the offset to look for the expected character\n     * @param expected the expected character\n     * @return true if the expected character exist at the given offset"
        },
        "parseInt": {
          "Javadoc": "* Parse an integer located between 2 given offsets in a string\n     * \n     * @param value the string to parse\n     * @param beginIndex the start index for the integer in the string\n     * @param endIndex the end index for the integer in the string\n     * @return the int\n     * @throws NumberFormatException if the value is not a number"
        },
        "padInt": {
          "Javadoc": "* Zero pad a number to a specified length\n     * \n     * @param buffer buffer to use for padding\n     * @param value the integer value to pad if necessary.\n     * @param length the length of the string we should zero pad"
        },
        "indexOfNonDigit": {
          "Javadoc": "* Returns the index of the first character in the string that is not a digit, starting at offset."
        }
      }
    },
    "com.google.gson.internal.ConstructorConstructor": {
      "Javadoc": "\n * Returns a function that can construct an instance of a requested type.\n ",
      "methods": {
        "checkInstantiable": {
          "Javadoc": "* Check if the class can be instantiated by Unsafe allocator. If the instance has interface or abstract modifiers\n   * return an exception message.\n   * @param c instance of the class to be checked\n   * @return if instantiable {@code null}, else a non-{@code null} exception message"
        },
        "newSpecialCollectionConstructor": {
          "Javadoc": "* Creates constructors for special JDK collection types which do not have a public no-args constructor."
        },
        "newDefaultImplementationConstructor": {
          "Javadoc": "* Constructors for common interface types like Map and List and their\n   * subtypes."
        }
      }
    },
    "com.google.gson.internal.Excluder": {
      "Javadoc": "\n * This class selects which fields and types to omit. It is configurable,\n * supporting version attributes {@link Since} and {@link Until}, modifiers,\n * synthetic fields, anonymous and local classes, inner classes, and fields with\n * the {@link Expose} annotation.\n *\n * <p>This class is a type adapter factory; types that are excluded will be\n * adapted to null. It may delegate to another type adapter if only one\n * direction is excluded.\n *\n * @author Joel Leitch\n * @author Jesse Wilson\n "
    },
    "com.google.gson.internal.JavaVersion": {
      "Javadoc": "\n * Utility to check the major Java version of the current JVM.\n ",
      "methods": {
        "getMajorJavaVersion": {
          "Javadoc": "* @return the major Java version, i.e. '8' for Java 1.8, '9' for Java 9 etc."
        },
        "isJava9OrLater": {
          "Javadoc": "* @return {@code true} if the application is running on Java 9 or later; and {@code false} otherwise."
        }
      }
    },
    "com.google.gson.internal.JsonReaderInternalAccess": {
      "Javadoc": "\n * Internal-only APIs of JsonReader available only to other classes in Gson.\n ",
      "methods": {
        "promoteNameToValue": {
          "Javadoc": "* Changes the type of the current property name token to a string value."
        }
      }
    },
    "com.google.gson.internal.LazilyParsedNumber": {
      "Javadoc": "\n * This class holds a number value that is lazily converted to a specific number type\n *\n * @author Inderjeet Singh\n ",
      "methods": {
        "writeReplace": {
          "Javadoc": "* If somebody is unlucky enough to have to serialize one of these, serialize\n   * it as a BigDecimal so that they won't need Gson on the other side to\n   * deserialize it."
        }
      }
    },
    "com.google.gson.internal.LinkedTreeMap": {
      "Javadoc": "\n * A map of comparable keys to values. Unlike {@code TreeMap}, this class uses\n * insertion order for iteration order. Comparison order is only used as an\n * optimization for efficient insertion and removal.\n *\n * <p>This implementation was derived from Android 4.1's TreeMap class.\n ",
      "methods": {
        "find": {
          "Javadoc": "* Returns the node at or adjacent to the given key, creating it if requested.\n   *\n   * @throws ClassCastException if {@code key} and the tree's keys aren't\n   *     mutually comparable."
        },
        "findByEntry": {
          "Javadoc": "* Returns this map's entry that has the same key and value as {@code\n   * entry}, or null if this map has no such entry.\n   *\n   * <p>This method uses the comparator for key equality rather than {@code\n   * equals}. If this map's comparator isn't consistent with equals (such as\n   * {@code String.CASE_INSENSITIVE_ORDER}), then {@code remove()} and {@code\n   * contains()} will violate the collections API."
        },
        "removeInternal": {
          "Javadoc": "* Removes {@code node} from this tree, rearranging the tree's structure as\n   * necessary.\n   *\n   * @param unlink true to also unlink this node from the iteration linked list."
        },
        "rebalance": {
          "Javadoc": "* Rebalances the tree by making any AVL rotations necessary between the\n   * newly-unbalanced node and the tree's root.\n   *\n   * @param insert true if the node was unbalanced by an insert; false if it\n   *     was by a removal."
        },
        "rotateLeft": {
          "Javadoc": "* Rotates the subtree so that its root's right child is the new root."
        },
        "rotateRight": {
          "Javadoc": "* Rotates the subtree so that its root's left child is the new root."
        },
        "writeReplace": {
          "Javadoc": "* If somebody is unlucky enough to have to serialize one of these, serialize\n   * it as a LinkedHashMap so that they won't need Gson on the other side to\n   * deserialize it. Using serialization defeats our DoS defence, so most apps\n   * shouldn't use it."
        }
      }
    },
    "com.google.gson.internal.Node": {
      "Javadoc": "",
      "methods": {
        "first": {
          "Javadoc": "* Returns the first node in this subtree."
        },
        "last": {
          "Javadoc": "* Returns the last node in this subtree."
        }
      }
    },
    "com.google.gson.internal.LinkedTreeMapIterator": {
      "Javadoc": ""
    },
    "com.google.gson.internal.EntrySet": {
      "Javadoc": ""
    },
    "com.google.gson.internal.KeySet": {
      "Javadoc": ""
    },
    "com.google.gson.internal.NonNullElementWrapperList": {
      "Javadoc": "\n * {@link List} which wraps another {@code List} but prevents insertion of\n * {@code null} elements. Methods which only perform checks with the element\n * argument (e.g. {@link #contains(Object)}) do not throw exceptions for\n * {@code null} arguments.\n "
    },
    "com.google.gson.internal.ObjectConstructor": {
      "Javadoc": "\n * Defines a generic object construction factory.  The purpose of this class\n * is to construct a default instance of a class that can be used for object\n * navigation while deserialization from its JSON representation.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "construct": {
          "Javadoc": "* Returns a new instance."
        }
      }
    },
    "com.google.gson.internal.PreJava9DateFormatProvider": {
      "Javadoc": "\n * Provides DateFormats for US locale with patterns which were the default ones before Java 9.\n ",
      "methods": {
        "getUSDateFormat": {
          "Javadoc": "* Returns the same DateFormat as {@code DateFormat.getDateInstance(style, Locale.US)} in Java 8 or below."
        },
        "getUSDateTimeFormat": {
          "Javadoc": "* Returns the same DateFormat as {@code DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US)}\n   * in Java 8 or below."
        }
      }
    },
    "com.google.gson.internal.Primitives": {
      "Javadoc": "\n * Contains static utility methods pertaining to primitive types and their\n * corresponding wrapper types.\n *\n * @author Kevin Bourrillion\n ",
      "methods": {
        "isPrimitive": {
          "Javadoc": "* Returns true if this type is a primitive."
        },
        "isWrapperType": {
          "Javadoc": "* Returns {@code true} if {@code type} is one of the nine\n   * primitive-wrapper types, such as {@link Integer}.\n   *\n   * @see Class#isPrimitive"
        },
        "wrap": {
          "Javadoc": "* Returns the corresponding wrapper type of {@code type} if it is a primitive\n   * type; otherwise returns {@code type} itself. Idempotent.\n   * <pre>\n   *     wrap(int.class) == Integer.class\n   *     wrap(Integer.class) == Integer.class\n   *     wrap(String.class) == String.class\n   * </pre>"
        },
        "unwrap": {
          "Javadoc": "* Returns the corresponding primitive type of {@code type} if it is a\n   * wrapper type; otherwise returns {@code type} itself. Idempotent.\n   * <pre>\n   *     unwrap(Integer.class) == int.class\n   *     unwrap(int.class) == int.class\n   *     unwrap(String.class) == String.class\n   * </pre>"
        }
      }
    },
    "com.google.gson.internal.reflect.ReflectionHelper": {
      "Javadoc": "",
      "methods": {
        "makeAccessible": {
          "Javadoc": "* Internal implementation of making an {@link AccessibleObject} accessible.\n   *\n   * @param object the object that {@link AccessibleObject#setAccessible(boolean)} should be called on.\n   * @throws JsonIOException if making the object accessible fails"
        },
        "getAccessibleObjectDescription": {
          "Javadoc": "* Returns a short string describing the {@link AccessibleObject} in a human-readable way.\n   * The result is normally shorter than {@link AccessibleObject#toString()} because it omits\n   * modifiers (e.g. {@code final}) and uses simple names for constructor and method parameter\n   * types.\n   *\n   * @param object object to describe\n   * @param uppercaseFirstLetter whether the first letter of the description should be uppercased"
        },
        "fieldToString": {
          "Javadoc": "* Creates a string representation for a field, omitting modifiers and\n   * the field type."
        },
        "constructorToString": {
          "Javadoc": "* Creates a string representation for a constructor.\n   * E.g.: {@code java.lang.String(char[], int, int)}"
        },
        "tryMakeAccessible": {
          "Javadoc": "* Tries making the constructor accessible, returning an exception message\n   * if this fails.\n   *\n   * @param constructor constructor to make accessible\n   * @return exception message; {@code null} if successful, non-{@code null} if\n   *    unsuccessful"
        },
        "isRecord": {
          "Javadoc": "If records are supported on the JVM, this is equivalent to a call to Class.isRecord()"
        },
        "getAccessor": {
          "Javadoc": "Looks up the record accessor method that corresponds to the given record field"
        }
      }
    },
    "com.google.gson.internal.reflect.RecordHelper": {
      "Javadoc": "\n   * Internal abstraction over reflection when Records are supported.\n   "
    },
    "com.google.gson.internal.reflect.RecordSupportedHelper": {
      "Javadoc": ""
    },
    "com.google.gson.internal.reflect.RecordNotSupportedHelper": {
      "Javadoc": "\n   * Instance used when records are not supported\n   "
    },
    "com.google.gson.internal.ReflectionAccessFilterHelper": {
      "Javadoc": "\n * Internal helper class for {@link ReflectionAccessFilter}.\n ",
      "methods": {
        "getFilterResult": {
          "Javadoc": "* Gets the result of applying all filters until the first one returns a result\n   * other than {@link FilterResult#INDECISIVE}, or {@link FilterResult#ALLOW} if\n   * the list of filters is empty or all returned {@code INDECISIVE}."
        },
        "canAccess": {
          "Javadoc": "* See {@link AccessibleObject#canAccess(Object)} (Java >= 9)"
        }
      }
    },
    "com.google.gson.internal.AccessChecker": {
      "Javadoc": ""
    },
    "com.google.gson.internal.sql.SqlDateTypeAdapter": {
      "Javadoc": "\n * Adapter for java.sql.Date. Although this class appears stateless, it is not.\n * DateFormat captures its time zone and locale when it is created, which gives\n * this class state. DateFormat isn't thread safe either, so this class has\n * to synchronize its read and write methods.\n "
    },
    "com.google.gson.internal.sql.SqlTimestampTypeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.internal.sql.SqlTimeTypeAdapter": {
      "Javadoc": "\n * Adapter for java.sql.Time. Although this class appears stateless, it is not.\n * DateFormat captures its time zone and locale when it is created, which gives\n * this class state. DateFormat isn't thread safe either, so this class has\n * to synchronize its read and write methods.\n "
    },
    "com.google.gson.internal.sql.SqlTypesSupport": {
      "Javadoc": "\n * Encapsulates access to {@code java.sql} types, to allow Gson to\n * work without the {@code java.sql} module being present.\n * No {@link ClassNotFoundException}s will be thrown in case\n * the {@code java.sql} module is not present.\n *\n * <p>If {@link #SUPPORTS_SQL_TYPES} is {@code true}, all other\n * constants of this class will be non-{@code null}. However, if\n * it is {@code false} all other constants will be {@code null} and\n * there will be no support for {@code java.sql} types.\n "
    },
    "com.google.gson.internal.Streams": {
      "Javadoc": "\n * Reads and writes GSON parse trees over streams.\n ",
      "methods": {
        "parse": {
          "Javadoc": "* Takes a reader in any state and returns the next value as a JsonElement."
        },
        "write": {
          "Javadoc": "* Writes the JSON element to the writer, recursively."
        }
      }
    },
    "com.google.gson.internal.AppendableWriter": {
      "Javadoc": "\n   * Adapts an {@link Appendable} so it can be passed anywhere a {@link Writer}\n   * is used.\n   "
    },
    "com.google.gson.internal.CurrentWrite": {
      "Javadoc": "\n     * A mutable char sequence pointing at a single char[].\n     "
    },
    "com.google.gson.internal.UnsafeAllocator": {
      "Javadoc": "\n * Do sneaky things to allocate objects without invoking their constructors.\n *\n * @author Joel Leitch\n * @author Jesse Wilson\n ",
      "methods": {
        "assertInstantiable": {
          "Javadoc": "* Asserts that the class is instantiable. This check should have already occurred\n   * in {@link ConstructorConstructor}; this check here acts as safeguard since trying\n   * to use Unsafe for non-instantiable classes might crash the JVM on some devices."
        }
      }
    },
    "com.google.gson.JsonArray": {
      "Javadoc": "\n * A class representing an array type in JSON. An array is a list of {@link JsonElement}s each of\n * which can be of a different type. This is an ordered list, meaning that the order in which\n * elements are added is preserved. This class does not support {@code null} values. If {@code null}\n * is provided as element argument to any of the methods, it is converted to a {@link JsonNull}.\n *\n * <p>{@code JsonArray} only implements the {@link Iterable} interface but not the {@link List}\n * interface. A {@code List} view of it can be obtained with {@link #asList()}.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "deepCopy": {
          "Javadoc": "* Creates a deep copy of this element and all its children.\n   *\n   * @since 2.8.2"
        },
        "add": {
          "Javadoc": "* Adds the specified element to self.\n   *\n   * @param element the element that needs to be added to the array."
        },
        "addAll": {
          "Javadoc": "* Adds all the elements of the specified array to self.\n   *\n   * @param array the array whose elements need to be added to the array."
        },
        "set": {
          "Javadoc": "* Replaces the element at the specified position in this array with the specified element.\n   *\n   * @param index index of the element to replace\n   * @param element element to be stored at the specified position\n   * @return the element previously at the specified position\n   * @throws IndexOutOfBoundsException if the specified index is outside the array bounds"
        },
        "remove": {
          "Javadoc": "* Removes the element at the specified position in this array. Shifts any subsequent elements\n   * to the left (subtracts one from their indices). Returns the element that was removed from\n   * the array.\n   *\n   * @param index index the index of the element to be removed\n   * @return the element previously at the specified position\n   * @throws IndexOutOfBoundsException if the specified index is outside the array bounds\n   * @since 2.3"
        },
        "contains": {
          "Javadoc": "* Returns true if this array contains the specified element.\n   *\n   * @return true if this array contains the specified element.\n   * @param element whose presence in this array is to be tested\n   * @since 2.3"
        },
        "size": {
          "Javadoc": "* Returns the number of elements in the array.\n   *\n   * @return the number of elements in the array."
        },
        "isEmpty": {
          "Javadoc": "* Returns true if the array is empty.\n   *\n   * @return true if the array is empty.\n   * @since 2.8.7"
        },
        "iterator": {
          "Javadoc": "* Returns an iterator to navigate the elements of the array. Since the array is an ordered list,\n   * the iterator navigates the elements in the order they were inserted.\n   *\n   * @return an iterator to navigate the elements of the array."
        },
        "get": {
          "Javadoc": "* Returns the i-th element of the array.\n   *\n   * @param i the index of the element that is being sought.\n   * @return the element present at the i-th index.\n   * @throws IndexOutOfBoundsException if i is negative or greater than or equal to the\n   * {@link #size()} of the array."
        },
        "getAsNumber": {
          "Javadoc": "* Convenience method to get this array as a {@link Number} if it contains a single element.\n   * This method calls {@link JsonElement#getAsNumber()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a number if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element."
        },
        "getAsString": {
          "Javadoc": "* Convenience method to get this array as a {@link String} if it contains a single element.\n   * This method calls {@link JsonElement#getAsString()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a String if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element."
        },
        "getAsDouble": {
          "Javadoc": "* Convenience method to get this array as a double if it contains a single element.\n   * This method calls {@link JsonElement#getAsDouble()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a double if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element."
        },
        "getAsBigDecimal": {
          "Javadoc": "* Convenience method to get this array as a {@link BigDecimal} if it contains a single element.\n   * This method calls {@link JsonElement#getAsBigDecimal()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a {@link BigDecimal} if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element.\n   * @since 1.2"
        },
        "getAsBigInteger": {
          "Javadoc": "* Convenience method to get this array as a {@link BigInteger} if it contains a single element.\n   * This method calls {@link JsonElement#getAsBigInteger()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a {@link BigInteger} if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element.\n   * @since 1.2"
        },
        "getAsFloat": {
          "Javadoc": "* Convenience method to get this array as a float if it contains a single element.\n   * This method calls {@link JsonElement#getAsFloat()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a float if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element."
        },
        "getAsLong": {
          "Javadoc": "* Convenience method to get this array as a long if it contains a single element.\n   * This method calls {@link JsonElement#getAsLong()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a long if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element."
        },
        "getAsInt": {
          "Javadoc": "* Convenience method to get this array as an integer if it contains a single element.\n   * This method calls {@link JsonElement#getAsInt()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as an integer if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element."
        },
        "getAsByte": {
          "Javadoc": "* Convenience method to get this array as a primitive byte if it contains a single element.\n   * This method calls {@link JsonElement#getAsByte()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a primitive byte if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element."
        },
        "getAsCharacter": {
          "Javadoc": "* Convenience method to get this array as a character if it contains a single element.\n   * This method calls {@link JsonElement#getAsCharacter()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a primitive short if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element.\n   * @deprecated This method is misleading, as it does not get this element as a char but rather as\n   * a string's first character."
        },
        "getAsShort": {
          "Javadoc": "* Convenience method to get this array as a primitive short if it contains a single element.\n   * This method calls {@link JsonElement#getAsShort()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a primitive short if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element."
        },
        "getAsBoolean": {
          "Javadoc": "* Convenience method to get this array as a boolean if it contains a single element.\n   * This method calls {@link JsonElement#getAsBoolean()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a boolean if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element."
        },
        "asList": {
          "Javadoc": "* Returns a mutable {@link List} view of this {@code JsonArray}. Changes to the {@code List}\n   * are visible in this {@code JsonArray} and the other way around.\n   *\n   * <p>The {@code List} does not permit {@code null} elements. Unlike {@code JsonArray}'s\n   * {@code null} handling, a {@link NullPointerException} is thrown when trying to add {@code null}.\n   * Use {@link JsonNull} for JSON null values.\n   *\n   * @return mutable {@code List} view\n   * @since 2.10"
        },
        "equals": {
          "Javadoc": "* Returns whether the other object is equal to this. This method only considers\n   * the other object to be equal if it is an instance of {@code JsonArray} and has\n   * equal elements in the same order."
        },
        "hashCode": {
          "Javadoc": "* Returns the hash code of this array. This method calculates the hash code based\n   * on the elements of this array."
        }
      }
    },
    "com.google.gson.JsonDeserializationContext": {
      "Javadoc": "\n * Context for deserialization that is passed to a custom deserializer during invocation of its\n * {@link JsonDeserializer#deserialize(JsonElement, Type, JsonDeserializationContext)}\n * method.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "deserialize": {
          "Javadoc": "* Invokes default deserialization on the specified object. It should never be invoked on\n   * the element received as a parameter of the\n   * {@link JsonDeserializer#deserialize(JsonElement, Type, JsonDeserializationContext)} method. Doing\n   * so will result in an infinite loop since Gson will in-turn call the custom deserializer again.\n   *\n   * @param json the parse tree.\n   * @param typeOfT type of the expected return value.\n   * @param <T> The type of the deserialized object.\n   * @return An object of type typeOfT.\n   * @throws JsonParseException if the parse tree does not contain expected data."
        }
      }
    },
    "com.google.gson.JsonDeserializer": {
      "Javadoc": "\n * <p>Interface representing a custom deserializer for JSON. You should write a custom\n * deserializer, if you are not happy with the default deserialization done by Gson. You will\n * also need to register this deserializer through\n * {@link GsonBuilder#registerTypeAdapter(Type, Object)}.</p>\n *\n * <p>Let us look at example where defining a deserializer will be useful. The {@code Id} class\n * defined below has two fields: {@code clazz} and {@code value}.</p>\n *\n * <pre>\n * public class Id&lt;T&gt; {\n *   private final Class&lt;T&gt; clazz;\n *   private final long value;\n *   public Id(Class&lt;T&gt; clazz, long value) {\n *     this.clazz = clazz;\n *     this.value = value;\n *   }\n *   public long getValue() {\n *     return value;\n *   }\n * }\n * </pre>\n *\n * <p>The default deserialization of {@code Id(com.foo.MyObject.class, 20L)} will require the\n * JSON string to be <code>{\"clazz\":\"com.foo.MyObject\",\"value\":20}</code>. Suppose, you already know\n * the type of the field that the {@code Id} will be deserialized into, and hence just want to\n * deserialize it from a JSON string {@code 20}. You can achieve that by writing a custom\n * deserializer:</p>\n *\n * <pre>\n * class IdDeserializer implements JsonDeserializer&lt;Id&gt; {\n *   public Id deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n *       throws JsonParseException {\n *     long idValue = json.getAsJsonPrimitive().getAsLong();\n *     return new Id((Class) typeOfT, idValue);\n *   }\n * }\n * </pre>\n *\n * <p>You will also need to register {@code IdDeserializer} with Gson as follows:</p>\n *\n * <pre>\n * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdDeserializer()).create();\n * </pre>\n *\n * <p>Deserializers should be stateless and thread-safe, otherwise the thread-safety\n * guarantees of {@link Gson} might not apply.\n *\n * <p>New applications should prefer {@link TypeAdapter}, whose streaming API\n * is more efficient than this interface's tree API.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n *\n * @param <T> type for which the deserializer is being registered. It is possible that a\n * deserializer may be asked to deserialize a specific generic type of the T.\n ",
      "methods": {
        "deserialize": {
          "Javadoc": "* Gson invokes this call-back method during deserialization when it encounters a field of the\n   * specified type.\n   * <p>In the implementation of this call-back method, you should consider invoking\n   * {@link JsonDeserializationContext#deserialize(JsonElement, Type)} method to create objects\n   * for any non-trivial field of the returned object. However, you should never invoke it on the\n   * same type passing {@code json} since that will cause an infinite loop (Gson will call your\n   * call-back method again).\n   *\n   * @param json The Json data being deserialized\n   * @param typeOfT The type of the Object to deserialize to\n   * @return a deserialized object of the specified type typeOfT which is a subclass of {@code T}\n   * @throws JsonParseException if json is not in the expected format of {@code typeofT}"
        }
      }
    },
    "com.google.gson.JsonElement": {
      "Javadoc": "\n * A class representing an element of JSON. It could either be a {@link JsonObject}, a\n * {@link JsonArray}, a {@link JsonPrimitive} or a {@link JsonNull}.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "deepCopy": {
          "Javadoc": "* Returns a deep copy of this element. Immutable elements like primitives\n   * and nulls are not copied.\n   *\n   * @since 2.8.2"
        },
        "isJsonArray": {
          "Javadoc": "* Provides a check for verifying if this element is a JSON array or not.\n   *\n   * @return true if this element is of type {@link JsonArray}, false otherwise."
        },
        "isJsonObject": {
          "Javadoc": "* Provides a check for verifying if this element is a JSON object or not.\n   *\n   * @return true if this element is of type {@link JsonObject}, false otherwise."
        },
        "isJsonPrimitive": {
          "Javadoc": "* Provides a check for verifying if this element is a primitive or not.\n   *\n   * @return true if this element is of type {@link JsonPrimitive}, false otherwise."
        },
        "isJsonNull": {
          "Javadoc": "* Provides a check for verifying if this element represents a null value or not.\n   *\n   * @return true if this element is of type {@link JsonNull}, false otherwise.\n   * @since 1.2"
        },
        "getAsJsonObject": {
          "Javadoc": "* Convenience method to get this element as a {@link JsonObject}. If this element is of some\n   * other type, an {@link IllegalStateException} will result. Hence it is best to use this method\n   * after ensuring that this element is of the desired type by calling {@link #isJsonObject()}\n   * first.\n   *\n   * @return this element as a {@link JsonObject}.\n   * @throws IllegalStateException if this element is of another type."
        },
        "getAsJsonArray": {
          "Javadoc": "* Convenience method to get this element as a {@link JsonArray}. If this element is of some\n   * other type, an {@link IllegalStateException} will result. Hence it is best to use this method\n   * after ensuring that this element is of the desired type by calling {@link #isJsonArray()}\n   * first.\n   *\n   * @return this element as a {@link JsonArray}.\n   * @throws IllegalStateException if this element is of another type."
        },
        "getAsJsonPrimitive": {
          "Javadoc": "* Convenience method to get this element as a {@link JsonPrimitive}. If this element is of some\n   * other type, an {@link IllegalStateException} will result. Hence it is best to use this method\n   * after ensuring that this element is of the desired type by calling {@link #isJsonPrimitive()}\n   * first.\n   *\n   * @return this element as a {@link JsonPrimitive}.\n   * @throws IllegalStateException if this element is of another type."
        },
        "getAsJsonNull": {
          "Javadoc": "* Convenience method to get this element as a {@link JsonNull}. If this element is of some\n   * other type, an {@link IllegalStateException} will result. Hence it is best to use this method\n   * after ensuring that this element is of the desired type by calling {@link #isJsonNull()}\n   * first.\n   *\n   * @return this element as a {@link JsonNull}.\n   * @throws IllegalStateException if this element is of another type.\n   * @since 1.2"
        },
        "getAsBoolean": {
          "Javadoc": "* Convenience method to get this element as a boolean value.\n   *\n   * @return this element as a primitive boolean value.\n   * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\n   * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\n   * more than a single element."
        },
        "getAsNumber": {
          "Javadoc": "* Convenience method to get this element as a {@link Number}.\n   *\n   * @return this element as a {@link Number}.\n   * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray},\n   * or cannot be converted to a number.\n   * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\n   * more than a single element."
        },
        "getAsString": {
          "Javadoc": "* Convenience method to get this element as a string value.\n   *\n   * @return this element as a string value.\n   * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\n   * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\n   * more than a single element."
        },
        "getAsDouble": {
          "Javadoc": "* Convenience method to get this element as a primitive double value.\n   *\n   * @return this element as a primitive double value.\n   * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\n   * @throws NumberFormatException if the value contained is not a valid double.\n   * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\n   * more than a single element."
        },
        "getAsFloat": {
          "Javadoc": "* Convenience method to get this element as a primitive float value.\n   *\n   * @return this element as a primitive float value.\n   * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\n   * @throws NumberFormatException if the value contained is not a valid float.\n   * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\n   * more than a single element."
        },
        "getAsLong": {
          "Javadoc": "* Convenience method to get this element as a primitive long value.\n   *\n   * @return this element as a primitive long value.\n   * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\n   * @throws NumberFormatException if the value contained is not a valid long.\n   * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\n   * more than a single element."
        },
        "getAsInt": {
          "Javadoc": "* Convenience method to get this element as a primitive integer value.\n   *\n   * @return this element as a primitive integer value.\n   * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\n   * @throws NumberFormatException if the value contained is not a valid integer.\n   * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\n   * more than a single element."
        },
        "getAsByte": {
          "Javadoc": "* Convenience method to get this element as a primitive byte value.\n   *\n   * @return this element as a primitive byte value.\n   * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\n   * @throws NumberFormatException if the value contained is not a valid byte.\n   * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   * @since 1.3"
        },
        "getAsCharacter": {
          "Javadoc": "* Convenience method to get the first character of the string value of this element.\n   *\n   * @return the first character of the string value.\n   * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray},\n   * or if its string value is empty.\n   * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   * @since 1.3\n   * @deprecated This method is misleading, as it does not get this element as a char but rather as\n   * a string's first character."
        },
        "getAsBigDecimal": {
          "Javadoc": "* Convenience method to get this element as a {@link BigDecimal}.\n   *\n   * @return this element as a {@link BigDecimal}.\n   * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\n   * @throws NumberFormatException if this element is not a valid {@link BigDecimal}.\n   * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   * @since 1.2"
        },
        "getAsBigInteger": {
          "Javadoc": "* Convenience method to get this element as a {@link BigInteger}.\n   *\n   * @return this element as a {@link BigInteger}.\n   * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\n   * @throws NumberFormatException if this element is not a valid {@link BigInteger}.\n   * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\n   * more than a single element.\n   * @since 1.2"
        },
        "getAsShort": {
          "Javadoc": "* Convenience method to get this element as a primitive short value.\n   *\n   * @return this element as a primitive short value.\n   * @throws UnsupportedOperationException if this element is not a {@link JsonPrimitive} or {@link JsonArray}.\n   * @throws NumberFormatException if the value contained is not a valid short.\n   * @throws IllegalStateException if this element is of the type {@link JsonArray} but contains\n   * more than a single element."
        },
        "toString": {
          "Javadoc": "* Returns a String representation of this element."
        }
      }
    },
    "com.google.gson.JsonIOException": {
      "Javadoc": "\n * This exception is raised when Gson was unable to read an input stream\n * or write to one.\n * \n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.JsonNull": {
      "Javadoc": "\r\n * A class representing a JSON {@code null} value.\r\n *\r\n * @author Inderjeet Singh\r\n * @author Joel Leitch\r\n * @since 1.2\r\n ",
      "methods": {
        "deepCopy": {
          "Javadoc": "* Returns the same instance since it is an immutable value.\r\n   *\r\n   * @since 2.8.2"
        },
        "hashCode": {
          "Javadoc": "* All instances of {@code JsonNull} have the same hash code since they are indistinguishable."
        },
        "equals": {
          "Javadoc": "* All instances of {@code JsonNull} are considered equal."
        }
      }
    },
    "com.google.gson.JsonObject": {
      "Javadoc": "\n * A class representing an object type in Json. An object consists of name-value pairs where names\n * are strings, and values are any other type of {@link JsonElement}. This allows for a creating a\n * tree of JsonElements. The member elements of this object are maintained in order they were added.\n * This class does not support {@code null} values. If {@code null} is provided as value argument\n * to any of the methods, it is converted to a {@link JsonNull}.\n *\n * <p>{@code JsonObject} does not implement the {@link Map} interface, but a {@code Map} view\n * of it can be obtained with {@link #asMap()}.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "deepCopy": {
          "Javadoc": "* Creates a deep copy of this element and all its children.\n   *\n   * @since 2.8.2"
        },
        "add": {
          "Javadoc": "* Adds a member, which is a name-value pair, to self. The name must be a String, but the value\n   * can be an arbitrary {@link JsonElement}, thereby allowing you to build a full tree of JsonElements\n   * rooted at this node.\n   *\n   * @param property name of the member.\n   * @param value the member object."
        },
        "remove": {
          "Javadoc": "* Removes the {@code property} from this object.\n   *\n   * @param property name of the member that should be removed.\n   * @return the {@link JsonElement} object that is being removed, or {@code null} if no\n   *   member with this name exists.\n   * @since 1.3"
        },
        "addProperty": {
          "Javadoc": "* Convenience method to add a char member. The specified value is converted to a\n   * {@link JsonPrimitive} of Character.\n   *\n   * @param property name of the member.\n   * @param value the char value associated with the member."
        },
        "entrySet": {
          "Javadoc": "* Returns a set of members of this object. The set is ordered, and the order is in which the\n   * elements were added.\n   *\n   * @return a set of members of this object."
        },
        "keySet": {
          "Javadoc": "* Returns a set of members key values.\n   *\n   * @return a set of member keys as Strings\n   * @since 2.8.1"
        },
        "size": {
          "Javadoc": "* Returns the number of key/value pairs in the object.\n   *\n   * @return the number of key/value pairs in the object.\n   * @since 2.7"
        },
        "isEmpty": {
          "Javadoc": "* Returns true if the number of key/value pairs in the object is zero.\n   *\n   * @return true if the number of key/value pairs in the object is zero.\n   * @since 2.10.1"
        },
        "has": {
          "Javadoc": "* Convenience method to check if a member with the specified name is present in this object.\n   *\n   * @param memberName name of the member that is being checked for presence.\n   * @return true if there is a member with the specified name, false otherwise."
        },
        "get": {
          "Javadoc": "* Returns the member with the specified name.\n   *\n   * @param memberName name of the member that is being requested.\n   * @return the member matching the name, or {@code null} if no such member exists."
        },
        "getAsJsonPrimitive": {
          "Javadoc": "* Convenience method to get the specified member as a {@link JsonPrimitive}.\n   *\n   * @param memberName name of the member being requested.\n   * @return the {@code JsonPrimitive} corresponding to the specified member, or {@code null} if no\n   *   member with this name exists.\n   * @throws ClassCastException if the member is not of type {@code JsonPrimitive}."
        },
        "getAsJsonArray": {
          "Javadoc": "* Convenience method to get the specified member as a {@link JsonArray}.\n   *\n   * @param memberName name of the member being requested.\n   * @return the {@code JsonArray} corresponding to the specified member, or {@code null} if no\n   *   member with this name exists.\n   * @throws ClassCastException if the member is not of type {@code JsonArray}."
        },
        "getAsJsonObject": {
          "Javadoc": "* Convenience method to get the specified member as a {@link JsonObject}.\n   *\n   * @param memberName name of the member being requested.\n   * @return the {@code JsonObject} corresponding to the specified member, or {@code null} if no\n   *   member with this name exists.\n   * @throws ClassCastException if the member is not of type {@code JsonObject}."
        },
        "asMap": {
          "Javadoc": "* Returns a mutable {@link Map} view of this {@code JsonObject}. Changes to the {@code Map}\n   * are visible in this {@code JsonObject} and the other way around.\n   *\n   * <p>The {@code Map} does not permit {@code null} keys or values. Unlike {@code JsonObject}'s\n   * {@code null} handling, a {@link NullPointerException} is thrown when trying to add {@code null}.\n   * Use {@link JsonNull} for JSON null values.\n   *\n   * @return mutable {@code Map} view\n   * @since 2.10"
        },
        "equals": {
          "Javadoc": "* Returns whether the other object is equal to this. This method only considers\n   * the other object to be equal if it is an instance of {@code JsonObject} and has\n   * equal members, ignoring order."
        },
        "hashCode": {
          "Javadoc": "* Returns the hash code of this object. This method calculates the hash code based\n   * on the members of this object, ignoring order."
        }
      }
    },
    "com.google.gson.JsonParseException": {
      "Javadoc": "\n * This exception is raised if there is a serious issue that occurs during parsing of a Json\n * string. One of the main usages for this class is for the Gson infrastructure. If the incoming\n * Json is bad/malicious, an instance of this exception is raised.\n *\n * <p>This exception is a {@link RuntimeException} because it is exposed to the client. Using a\n * {@link RuntimeException} avoids bad coding practices on the client side where they catch the\n * exception and do nothing. It is often the case that you want to blow up if there is a parsing\n * error (i.e. often clients do not know how to recover from a {@link JsonParseException}.</p>\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.JsonParser": {
      "Javadoc": "\r\n * A parser to parse JSON into a parse tree of {@link JsonElement}s.\r\n *\r\n * @author Inderjeet Singh\r\n * @author Joel Leitch\r\n * @since 1.3\r\n ",
      "methods": {
        "parseString": {
          "Javadoc": "* Parses the specified JSON string into a parse tree.\r\n   * An exception is thrown if the JSON string has multiple top-level JSON elements,\r\n   * or if there is trailing data.\r\n   *\r\n   * <p>The JSON string is parsed in {@linkplain JsonReader#setLenient(boolean) lenient mode}.\r\n   *\r\n   * @param json JSON text\r\n   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON\r\n   * @throws JsonParseException if the specified text is not valid JSON\r\n   * @since 2.8.6"
        },
        "parseReader": {
          "Javadoc": "* Returns the next value from the JSON stream as a parse tree.\r\n   * Unlike the other {@code parse} methods, no exception is thrown if the JSON data has\r\n   * multiple top-level JSON elements, or if there is trailing data.\r\n   *\r\n   * <p>The JSON data is parsed in {@linkplain JsonReader#setLenient(boolean) lenient mode},\r\n   * regardless of the lenient mode setting of the provided reader. The lenient mode setting\r\n   * of the reader is restored once this method returns.\r\n   *\r\n   * @throws JsonParseException if there is an IOException or if the specified\r\n   *     text is not valid JSON\r\n   * @since 2.8.6"
        },
        "parse": {
          "Javadoc": "@deprecated Use {@link JsonParser#parseReader(JsonReader)}"
        }
      }
    },
    "com.google.gson.JsonPrimitive": {
      "Javadoc": "\n * A class representing a JSON primitive value. A primitive value\n * is either a String, a Java primitive, or a Java primitive\n * wrapper type.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "deepCopy": {
          "Javadoc": "* Returns the same value as primitives are immutable.\n   *\n   * @since 2.8.2"
        },
        "isBoolean": {
          "Javadoc": "* Check whether this primitive contains a boolean value.\n   *\n   * @return true if this primitive contains a boolean value, false otherwise."
        },
        "getAsBoolean": {
          "Javadoc": "* Convenience method to get this element as a boolean value.\n   * If this primitive {@linkplain #isBoolean() is not a boolean}, the string value\n   * is parsed using {@link Boolean#parseBoolean(String)}. This means {@code \"true\"} (ignoring\n   * case) is considered {@code true} and any other value is considered {@code false}."
        },
        "isNumber": {
          "Javadoc": "* Check whether this primitive contains a Number.\n   *\n   * @return true if this primitive contains a Number, false otherwise."
        },
        "getAsNumber": {
          "Javadoc": "* Convenience method to get this element as a {@link Number}.\n   * If this primitive {@linkplain #isString() is a string}, a lazily parsed {@code Number}\n   * is constructed which parses the string when any of its methods are called (which can\n   * lead to a {@link NumberFormatException}).\n   *\n   * @throws UnsupportedOperationException if this primitive is neither a number nor a string."
        },
        "isString": {
          "Javadoc": "* Check whether this primitive contains a String value.\n   *\n   * @return true if this primitive contains a String value, false otherwise."
        },
        "getAsDouble": {
          "Javadoc": "* @throws NumberFormatException {@inheritDoc}"
        },
        "getAsBigDecimal": {
          "Javadoc": "* @throws NumberFormatException {@inheritDoc}"
        },
        "getAsBigInteger": {
          "Javadoc": "* @throws NumberFormatException {@inheritDoc}"
        },
        "getAsFloat": {
          "Javadoc": "* @throws NumberFormatException {@inheritDoc}"
        },
        "getAsLong": {
          "Javadoc": "* Convenience method to get this element as a primitive long.\n   *\n   * @return this element as a primitive long.\n   * @throws NumberFormatException {@inheritDoc}"
        },
        "getAsShort": {
          "Javadoc": "* @throws NumberFormatException {@inheritDoc}"
        },
        "getAsInt": {
          "Javadoc": "* @throws NumberFormatException {@inheritDoc}"
        },
        "getAsByte": {
          "Javadoc": "* @throws NumberFormatException {@inheritDoc}"
        },
        "getAsCharacter": {
          "Javadoc": "* @throws UnsupportedOperationException if the string value of this\n   * primitive is empty.\n   * @deprecated This method is misleading, as it does not get this element as a char but rather as\n   * a string's first character."
        },
        "hashCode": {
          "Javadoc": "* Returns the hash code of this object."
        },
        "equals": {
          "Javadoc": "* Returns whether the other object is equal to this. This method only considers\n   * the other object to be equal if it is an instance of {@code JsonPrimitive} and\n   * has an equal value."
        },
        "isIntegral": {
          "Javadoc": "* Returns true if the specified number is an integral type\n   * (Long, Integer, Short, Byte, BigInteger)"
        }
      }
    },
    "com.google.gson.JsonSerializationContext": {
      "Javadoc": "\n * Context for serialization that is passed to a custom serializer during invocation of its\n * {@link JsonSerializer#serialize(Object, Type, JsonSerializationContext)} method.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "serialize": {
          "Javadoc": "* Invokes default serialization on the specified object passing the specific type information.\n   * It should never be invoked on the element received as a parameter of the\n   * {@link JsonSerializer#serialize(Object, Type, JsonSerializationContext)} method. Doing\n   * so will result in an infinite loop since Gson will in-turn call the custom serializer again.\n   *\n   * @param src the object that needs to be serialized.\n   * @param typeOfSrc the actual genericized type of src object.\n   * @return a tree of {@link JsonElement}s corresponding to the serialized form of {@code src}."
        }
      }
    },
    "com.google.gson.JsonSerializer": {
      "Javadoc": "\n * Interface representing a custom serializer for JSON. You should write a custom serializer, if\n * you are not happy with the default serialization done by Gson. You will also need to register\n * this serializer through {@link com.google.gson.GsonBuilder#registerTypeAdapter(Type, Object)}.\n *\n * <p>Let us look at example where defining a serializer will be useful. The {@code Id} class\n * defined below has two fields: {@code clazz} and {@code value}.</p>\n *\n * <pre>\n * public class Id&lt;T&gt; {\n *   private final Class&lt;T&gt; clazz;\n *   private final long value;\n *\n *   public Id(Class&lt;T&gt; clazz, long value) {\n *     this.clazz = clazz;\n *     this.value = value;\n *   }\n *\n *   public long getValue() {\n *     return value;\n *   }\n * }\n * </pre>\n *\n * <p>The default serialization of {@code Id(com.foo.MyObject.class, 20L)} will be\n * <code>{\"clazz\":\"com.foo.MyObject\",\"value\":20}</code>. Suppose, you just want the output to be\n * the value instead, which is {@code 20} in this case. You can achieve that by writing a custom\n * serializer:</p>\n *\n * <pre>\n * class IdSerializer implements JsonSerializer&lt;Id&gt; {\n *   public JsonElement serialize(Id id, Type typeOfId, JsonSerializationContext context) {\n *     return new JsonPrimitive(id.getValue());\n *   }\n * }\n * </pre>\n *\n * <p>You will also need to register {@code IdSerializer} with Gson as follows:</p>\n * <pre>\n * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdSerializer()).create();\n * </pre>\n *\n * <p>Serializers should be stateless and thread-safe, otherwise the thread-safety\n * guarantees of {@link Gson} might not apply.\n *\n * <p>New applications should prefer {@link TypeAdapter}, whose streaming API\n * is more efficient than this interface's tree API.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n *\n * @param <T> type for which the serializer is being registered. It is possible that a serializer\n *        may be asked to serialize a specific generic type of the T.\n ",
      "methods": {
        "serialize": {
          "Javadoc": "* Gson invokes this call-back method during serialization when it encounters a field of the\n   * specified type.\n   *\n   * <p>In the implementation of this call-back method, you should consider invoking\n   * {@link JsonSerializationContext#serialize(Object, Type)} method to create JsonElements for any\n   * non-trivial field of the {@code src} object. However, you should never invoke it on the\n   * {@code src} object itself since that will cause an infinite loop (Gson will call your\n   * call-back method again).</p>\n   *\n   * @param src the object that needs to be converted to Json.\n   * @param typeOfSrc the actual type (fully genericized version) of the source object.\n   * @return a JsonElement corresponding to the specified object."
        }
      }
    },
    "com.google.gson.JsonStreamParser": {
      "Javadoc": "\n * A streaming parser that allows reading of multiple {@link JsonElement}s from the specified reader\n * asynchronously. The JSON data is parsed in lenient mode, see also\n * {@link JsonReader#setLenient(boolean)}.\n *\n * <p>This class is conditionally thread-safe (see Item 70, Effective Java second edition). To\n * properly use this class across multiple threads, you will need to add some external\n * synchronization. For example:\n * \n * <pre>\n * JsonStreamParser parser = new JsonStreamParser(\"['first'] {'second':10} 'third'\");\n * JsonElement element;\n * synchronized (parser) {  // synchronize on an object shared by threads\n *   if (parser.hasNext()) {\n *     element = parser.next();\n *   }\n * }\n * </pre>\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n * @since 1.4\n ",
      "methods": {
        "next": {
          "Javadoc": "* Returns the next available {@link JsonElement} on the reader. Throws a\n   * {@link NoSuchElementException} if no element is available.\n   *\n   * @return the next available {@code JsonElement} on the reader.\n   * @throws JsonParseException if the incoming stream is malformed JSON.\n   * @throws NoSuchElementException if no {@code JsonElement} is available.\n   * @since 1.4"
        },
        "hasNext": {
          "Javadoc": "* Returns true if a {@link JsonElement} is available on the input for consumption\n   * @return true if a {@link JsonElement} is available on the input, false otherwise\n   * @throws JsonParseException if the incoming stream is malformed JSON.\n   * @since 1.4"
        },
        "remove": {
          "Javadoc": "* This optional {@link Iterator} method is not relevant for stream parsing and hence is not\n   * implemented.\n   * @since 1.4"
        }
      }
    },
    "com.google.gson.JsonSyntaxException": {
      "Javadoc": "\n * This exception is raised when Gson attempts to read (or write) a malformed\n * JSON element.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.reflect.TypeToken": {
      "Javadoc": "\n * Represents a generic type {@code T}. Java doesn't yet provide a way to\n * represent generic types, so this class does. Forces clients to create a\n * subclass of this class which enables retrieval the type information even at\n * runtime.\n *\n * <p>For example, to create a type literal for {@code List<String>}, you can\n * create an empty anonymous class:\n *\n * <p>\n * {@code TypeToken<List<String>> list = new TypeToken<List<String>>() {};}\n *\n * <p>Capturing a type variable as type argument of a {@code TypeToken} should\n * be avoided. Due to type erasure the runtime type of a type variable is not\n * available to Gson and therefore it cannot provide the functionality one\n * might expect, which gives a false sense of type-safety at compilation time\n * and can lead to an unexpected {@code ClassCastException} at runtime.\n *\n * <p>If the type arguments of the parameterized type are only available at\n * runtime, for example when you want to create a {@code List<E>} based on\n * a {@code Class<E>} representing the element type, the method\n * {@link #getParameterized(Type, Type...)} can be used.\n *\n * @author Bob Lee\n * @author Sven Mawson\n * @author Jesse Wilson\n ",
      "methods": {
        "getTypeTokenTypeArgument": {
          "Javadoc": "* Verifies that {@code this} is an instance of a direct subclass of TypeToken and\n   * returns the type argument for {@code T} in {@link $Gson$Types#canonicalize\n   * canonical form}."
        },
        "getRawType": {
          "Javadoc": "* Returns the raw (non-generic) type for this type."
        },
        "getType": {
          "Javadoc": "* Gets underlying {@code Type} instance."
        },
        "isAssignableFrom": {
          "Javadoc": "* Private recursive helper function to actually do the type-safe checking\n   * of assignability."
        },
        "typeEquals": {
          "Javadoc": "* Checks if two parameterized types are exactly equal, under the variable\n   * replacement described in the typeVarMap."
        },
        "matches": {
          "Javadoc": "* Checks if two types are the same or are equivalent under a variable mapping\n   * given in the type map that was provided."
        },
        "get": {
          "Javadoc": "* Gets type literal for the given {@code Class} instance."
        },
        "getParameterized": {
          "Javadoc": "* Gets a type literal for the parameterized type represented by applying {@code typeArguments} to\n   * {@code rawType}. This is mainly intended for situations where the type arguments are not\n   * available at compile time. The following example shows how a type token for {@code Map<K, V>}\n   * can be created:\n   * <pre>{@code\n   * Class<K> keyClass = ...;\n   * Class<V> valueClass = ...;\n   * TypeToken<?> mapTypeToken = TypeToken.getParameterized(Map.class, keyClass, valueClass);\n   * }</pre>\n   * As seen here the result is a {@code TypeToken<?>}; this method cannot provide any type safety,\n   * and care must be taken to pass in the correct number of type arguments.\n   *\n   * @throws IllegalArgumentException\n   *   If {@code rawType} is not of type {@code Class}, or if the type arguments are invalid for\n   *   the raw type"
        },
        "getArray": {
          "Javadoc": "* Gets type literal for the array type whose elements are all instances of {@code componentType}."
        }
      }
    },
    "com.google.gson.ReflectionAccessFilter": {
      "Javadoc": "\n * Filter for determining whether reflection based serialization and\n * deserialization is allowed for a class.\n *\n * <p>A filter can be useful in multiple scenarios, for example when\n * upgrading to newer Java versions which use the Java Platform Module\n * System (JPMS). A filter then allows to {@linkplain FilterResult#BLOCK_INACCESSIBLE\n * prevent making inaccessible members accessible}, even if the used\n * Java version might still allow illegal access (but logs a warning),\n * or if {@code java} command line arguments are used to open the inaccessible\n * packages to other parts of the application. This interface defines some\n * convenience filters for this task, such as {@link #BLOCK_INACCESSIBLE_JAVA}.\n *\n * <p>A filter can also be useful to prevent mixing model classes of a\n * project with other non-model classes; the filter could\n * {@linkplain FilterResult#BLOCK_ALL block all reflective access} to\n * non-model classes.\n *\n * <p>A reflection access filter is similar to an {@link ExclusionStrategy}\n * with the major difference that a filter will cause an exception to be\n * thrown when access is disallowed while an exclusion strategy just skips\n * fields and classes.\n *\n * @see GsonBuilder#addReflectionAccessFilter(ReflectionAccessFilter)\n * @since 2.9.1\n ",
      "methods": {
        "check": {
          "Javadoc": "* Checks if reflection access should be allowed for a class.\n   *\n   * @param rawClass\n   *    Class to check\n   * @return\n   *    Result indicating whether reflection access is allowed"
        }
      }
    },
    "com.google.gson.stream.JsonReader": {
      "Javadoc": "\n * Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n * encoded value as a stream of tokens. This stream includes both literal\n * values (strings, numbers, booleans, and nulls) as well as the begin and\n * end delimiters of objects and arrays. The tokens are traversed in\n * depth-first order, the same order that they appear in the JSON document.\n * Within JSON objects, name/value pairs are represented by a single token.\n *\n * <h2>Parsing JSON</h2>\n * To create a recursive descent parser for your own JSON streams, first create\n * an entry point method that creates a {@code JsonReader}.\n *\n * <p>Next, create handler methods for each structure in your JSON text. You'll\n * need a method for each object type and for each array type.\n * <ul>\n *   <li>Within <strong>array handling</strong> methods, first call {@link\n *       #beginArray} to consume the array's opening bracket. Then create a\n *       while loop that accumulates values, terminating when {@link #hasNext}\n *       is false. Finally, read the array's closing bracket by calling {@link\n *       #endArray}.\n *   <li>Within <strong>object handling</strong> methods, first call {@link\n *       #beginObject} to consume the object's opening brace. Then create a\n *       while loop that assigns values to local variables based on their name.\n *       This loop should terminate when {@link #hasNext} is false. Finally,\n *       read the object's closing brace by calling {@link #endObject}.\n * </ul>\n * <p>When a nested object or array is encountered, delegate to the\n * corresponding handler method.\n *\n * <p>When an unknown name is encountered, strict parsers should fail with an\n * exception. Lenient parsers should call {@link #skipValue()} to recursively\n * skip the value's nested tokens, which may otherwise conflict.\n *\n * <p>If a value may be null, you should first check using {@link #peek()}.\n * Null literals can be consumed using either {@link #nextNull()} or {@link\n * #skipValue()}.\n *\n * <h2>Example</h2>\n * Suppose we'd like to parse a stream of messages such as the following: <pre> {@code\n * [\n *   {\n *     \"id\": 912345678901,\n *     \"text\": \"How do I read a JSON stream in Java?\",\n *     \"geo\": null,\n *     \"user\": {\n *       \"name\": \"json_newb\",\n *       \"followers_count\": 41\n *      }\n *   },\n *   {\n *     \"id\": 912345678902,\n *     \"text\": \"@json_newb just use JsonReader!\",\n *     \"geo\": [50.454722, -104.606667],\n *     \"user\": {\n *       \"name\": \"jesse\",\n *       \"followers_count\": 2\n *     }\n *   }\n * ]}</pre>\n * This code implements the parser for the above structure: <pre>   {@code\n *\n *   public List<Message> readJsonStream(InputStream in) throws IOException {\n *     JsonReader reader = new JsonReader(new InputStreamReader(in, \"UTF-8\"));\n *     try {\n *       return readMessagesArray(reader);\n *     } finally {\n *       reader.close();\n *     }\n *   }\n *\n *   public List<Message> readMessagesArray(JsonReader reader) throws IOException {\n *     List<Message> messages = new ArrayList<>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       messages.add(readMessage(reader));\n *     }\n *     reader.endArray();\n *     return messages;\n *   }\n *\n *   public Message readMessage(JsonReader reader) throws IOException {\n *     long id = -1;\n *     String text = null;\n *     User user = null;\n *     List<Double> geo = null;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"id\")) {\n *         id = reader.nextLong();\n *       } else if (name.equals(\"text\")) {\n *         text = reader.nextString();\n *       } else if (name.equals(\"geo\") && reader.peek() != JsonToken.NULL) {\n *         geo = readDoublesArray(reader);\n *       } else if (name.equals(\"user\")) {\n *         user = readUser(reader);\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new Message(id, text, user, geo);\n *   }\n *\n *   public List<Double> readDoublesArray(JsonReader reader) throws IOException {\n *     List<Double> doubles = new ArrayList<>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       doubles.add(reader.nextDouble());\n *     }\n *     reader.endArray();\n *     return doubles;\n *   }\n *\n *   public User readUser(JsonReader reader) throws IOException {\n *     String username = null;\n *     int followersCount = -1;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"name\")) {\n *         username = reader.nextString();\n *       } else if (name.equals(\"followers_count\")) {\n *         followersCount = reader.nextInt();\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new User(username, followersCount);\n *   }}</pre>\n *\n * <h2>Number Handling</h2>\n * This reader permits numeric values to be read as strings and string values to\n * be read as numbers. For example, both elements of the JSON array {@code\n * [1, \"1\"]} may be read using either {@link #nextInt} or {@link #nextString}.\n * This behavior is intended to prevent lossy numeric conversions: double is\n * JavaScript's only numeric type and very large values like {@code\n * 9007199254740993} cannot be represented exactly on that platform. To minimize\n * precision loss, extremely large values should be written and read as strings\n * in JSON.\n *\n * <h2 id=\"nonexecuteprefix\">Non-Execute Prefix</h2>\n * Web servers that serve private data using JSON may be vulnerable to <a\n * href=\"http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery\">Cross-site\n * request forgery</a> attacks. In such an attack, a malicious site gains access\n * to a private JSON file by executing it with an HTML {@code <script>} tag.\n *\n * <p>Prefixing JSON files with <code>\")]}'\\n\"</code> makes them non-executable\n * by {@code <script>} tags, disarming the attack. Since the prefix is malformed\n * JSON, strict parsing fails when it is encountered. This class permits the\n * non-execute prefix when {@link #setLenient(boolean) lenient parsing} is\n * enabled.\n *\n * <p>Each {@code JsonReader} may be used to read a single JSON stream. Instances\n * of this class are not thread safe.\n *\n * @author Jesse Wilson\n * @since 1.6\n ",
      "methods": {
        "setLenient": {
          "Javadoc": "* Configure this parser to be liberal in what it accepts. By default,\n   * this parser is strict and only accepts JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n   * parser to lenient causes it to ignore the following syntax errors:\n   *\n   * <ul>\n   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n   *       prefix</a>, <code>\")]}'\\n\"</code>.\n   *   <li>Streams that include multiple top-level values. With strict parsing,\n   *       each stream must contain exactly one top-level value.\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   *   <li>End of line comments starting with {@code //} or {@code #} and\n   *       ending with a newline character.\n   *   <li>C-style comments starting with {@code /*} and ending with\n   *       {@code *}{@code /}. Such comments may not be nested.\n   *   <li>Names that are unquoted or {@code 'single quoted'}.\n   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n   *   <li>Unnecessary array separators. These are interpreted as if null\n   *       was the omitted value.\n   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n   *       {@code :}.\n   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n   * </ul>\n   *\n   * <p>Note: Even in strict mode there are slight derivations from the JSON\n   * specification:\n   * <ul>\n   *   <li>JsonReader allows the literals {@code true}, {@code false} and {@code null}\n   *       to have any capitalization, for example {@code fAlSe}\n   *   <li>JsonReader supports the escape sequence {@code \\'}, representing a {@code '}\n   *   <li>JsonReader supports the escape sequence <code>\\<i>LF</i></code> (with {@code LF}\n   *       being the Unicode character U+000A), resulting in a {@code LF} within the\n   *       read JSON string\n   *   <li>JsonReader allows unescaped control characters (U+0000 through U+001F)\n   * </ul>"
        },
        "isLenient": {
          "Javadoc": "* Returns true if this parser is liberal in what it accepts."
        },
        "beginArray": {
          "Javadoc": "* Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new array."
        },
        "endArray": {
          "Javadoc": "* Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current array."
        },
        "beginObject": {
          "Javadoc": "* Consumes the next token from the JSON stream and asserts that it is the\n   * beginning of a new object."
        },
        "endObject": {
          "Javadoc": "* Consumes the next token from the JSON stream and asserts that it is the\n   * end of the current object."
        },
        "hasNext": {
          "Javadoc": "* Returns true if the current array or object has another element."
        },
        "peek": {
          "Javadoc": "* Returns the type of the next token without consuming it."
        },
        "nextName": {
          "Javadoc": "* Returns the next token, a {@link JsonToken#NAME property name}, and consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name."
        },
        "nextString": {
          "Javadoc": "* Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed."
        },
        "nextBoolean": {
          "Javadoc": "* Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed."
        },
        "nextNull": {
          "Javadoc": "* Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed."
        },
        "nextDouble": {
          "Javadoc": "* Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double using {@link Double#parseDouble(String)}.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double.\n   * @throws MalformedJsonException if the next literal value is NaN or Infinity\n   *     and this reader is not {@link #setLenient(boolean) lenient}."
        },
        "nextLong": {
          "Javadoc": "* Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long."
        },
        "nextQuotedValue": {
          "Javadoc": "* Returns the string up to but not including {@code quote}, unescaping any\n   * character escape sequences encountered along the way. The opening quote\n   * should have already been read. This consumes the closing quote, but does\n   * not include it in the returned string.\n   *\n   * @param quote either ' or \".\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed."
        },
        "nextUnquotedValue": {
          "Javadoc": "* Returns an unquoted value as a string."
        },
        "nextInt": {
          "Javadoc": "* Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int."
        },
        "close": {
          "Javadoc": "* Closes this JSON reader and the underlying {@link Reader}."
        },
        "skipValue": {
          "Javadoc": "* Skips the next value recursively. This method is intended for use when\n   * the JSON token stream contains unrecognized or unhandled values.\n   *\n   * <p>The behavior depends on the type of the next JSON token:\n   * <ul>\n   *   <li>Start of a JSON array or object: It and all of its nested values are skipped.</li>\n   *   <li>Primitive value (for example a JSON number): The primitive value is skipped.</li>\n   *   <li>Property name: Only the name but not the value of the property is skipped.\n   *   {@code skipValue()} has to be called again to skip the property value as well.</li>\n   *   <li>End of a JSON array or object: Only this end token is skipped.</li>\n   *   <li>End of JSON document: Skipping has no effect, the next token continues to be the\n   *   end of the document.</li>\n   * </ul>"
        },
        "fillBuffer": {
          "Javadoc": "* Returns true once {@code limit - pos >= minimum}. If the data is\n   * exhausted before that many characters are available, this returns\n   * false."
        },
        "nextNonWhitespace": {
          "Javadoc": "* Returns the next character in the stream that is neither whitespace nor a\n   * part of a comment. When this returns, the returned character is always at\n   * {@code buffer[pos-1]}; this means the caller can always push back the\n   * returned character by decrementing {@code pos}."
        },
        "skipToEndOfLine": {
          "Javadoc": "* Advances the position until after the next newline character. If the line\n   * is terminated by \"\\r\\n\", the '\\n' must be consumed as whitespace by the\n   * caller."
        },
        "skipTo": {
          "Javadoc": "* @param toFind a string to search for. Must not contain a newline."
        },
        "getPreviousPath": {
          "Javadoc": "* Returns a <a href=\"https://goessner.net/articles/JsonPath/\">JSONPath</a>\n   * in <i>dot-notation</i> to the previous (or current) location in the JSON document:\n   * <ul>\n   *   <li>For JSON arrays the path points to the index of the previous element.<br>\n   *   If no element has been consumed yet it uses the index 0 (even if there are no elements).</li>\n   *   <li>For JSON objects the path points to the last property, or to the current\n   *   property if its name has already been consumed.</li>\n   * </ul>\n   *\n   * <p>This method can be useful to add additional context to exception messages\n   * <i>after</i> a value has been consumed."
        },
        "getPath": {
          "Javadoc": "* Returns a <a href=\"https://goessner.net/articles/JsonPath/\">JSONPath</a>\n   * in <i>dot-notation</i> to the next (or current) location in the JSON document:\n   * <ul>\n   *   <li>For JSON arrays the path points to the index of the next element (even\n   *   if there are no further elements).</li>\n   *   <li>For JSON objects the path points to the last property, or to the current\n   *   property if its name has already been consumed.</li>\n   * </ul>\n   *\n   * <p>This method can be useful to add additional context to exception messages\n   * <i>before</i> a value is consumed, for example when the {@linkplain #peek() peeked}\n   * token is unexpected."
        },
        "readEscapeCharacter": {
          "Javadoc": "* Unescapes the character identified by the character or characters that\n   * immediately follow a backslash. The backslash '\\' should have already\n   * been read. This supports both unicode escapes \"u000A\" and two-character\n   * escapes \"\\n\".\n   *\n   * @throws NumberFormatException if any unicode escape sequences are\n   *     malformed."
        },
        "syntaxError": {
          "Javadoc": "* Throws a new IO exception with the given message and a context snippet\n   * with this reader's content."
        },
        "consumeNonExecutePrefix": {
          "Javadoc": "* Consumes the non-execute prefix if it exists."
        }
      }
    },
    "com.google.gson.stream.JsonScope": {
      "Javadoc": "\n * Lexical scoping elements within a JSON reader or writer.\n *\n * @author Jesse Wilson\n * @since 1.6\n "
    },
    "com.google.gson.stream.JsonWriter": {
      "Javadoc": "\n * Writes a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n * encoded value to a stream, one token at a time. The stream includes both\n * literal values (strings, numbers, booleans and nulls) as well as the begin\n * and end delimiters of objects and arrays.\n *\n * <h2>Encoding JSON</h2>\n * To encode your data as JSON, create a new {@code JsonWriter}. Call methods\n * on the writer as you walk the structure's contents, nesting arrays and objects\n * as necessary:\n * <ul>\n *   <li>To write <strong>arrays</strong>, first call {@link #beginArray()}.\n *       Write each of the array's elements with the appropriate {@link #value}\n *       methods or by nesting other arrays and objects. Finally close the array\n *       using {@link #endArray()}.\n *   <li>To write <strong>objects</strong>, first call {@link #beginObject()}.\n *       Write each of the object's properties by alternating calls to\n *       {@link #name} with the property's value. Write property values with the\n *       appropriate {@link #value} method or by nesting other objects or arrays.\n *       Finally close the object using {@link #endObject()}.\n * </ul>\n *\n * <h2>Example</h2>\n * Suppose we'd like to encode a stream of messages such as the following: <pre> {@code\n * [\n *   {\n *     \"id\": 912345678901,\n *     \"text\": \"How do I stream JSON in Java?\",\n *     \"geo\": null,\n *     \"user\": {\n *       \"name\": \"json_newb\",\n *       \"followers_count\": 41\n *      }\n *   },\n *   {\n *     \"id\": 912345678902,\n *     \"text\": \"@json_newb just use JsonWriter!\",\n *     \"geo\": [50.454722, -104.606667],\n *     \"user\": {\n *       \"name\": \"jesse\",\n *       \"followers_count\": 2\n *     }\n *   }\n * ]}</pre>\n * This code encodes the above structure: <pre>   {@code\n *   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {\n *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, \"UTF-8\"));\n *     writer.setIndent(\"    \");\n *     writeMessagesArray(writer, messages);\n *     writer.close();\n *   }\n *\n *   public void writeMessagesArray(JsonWriter writer, List<Message> messages) throws IOException {\n *     writer.beginArray();\n *     for (Message message : messages) {\n *       writeMessage(writer, message);\n *     }\n *     writer.endArray();\n *   }\n *\n *   public void writeMessage(JsonWriter writer, Message message) throws IOException {\n *     writer.beginObject();\n *     writer.name(\"id\").value(message.getId());\n *     writer.name(\"text\").value(message.getText());\n *     if (message.getGeo() != null) {\n *       writer.name(\"geo\");\n *       writeDoublesArray(writer, message.getGeo());\n *     } else {\n *       writer.name(\"geo\").nullValue();\n *     }\n *     writer.name(\"user\");\n *     writeUser(writer, message.getUser());\n *     writer.endObject();\n *   }\n *\n *   public void writeUser(JsonWriter writer, User user) throws IOException {\n *     writer.beginObject();\n *     writer.name(\"name\").value(user.getName());\n *     writer.name(\"followers_count\").value(user.getFollowersCount());\n *     writer.endObject();\n *   }\n *\n *   public void writeDoublesArray(JsonWriter writer, List<Double> doubles) throws IOException {\n *     writer.beginArray();\n *     for (Double value : doubles) {\n *       writer.value(value);\n *     }\n *     writer.endArray();\n *   }}</pre>\n *\n * <p>Each {@code JsonWriter} may be used to write a single JSON stream.\n * Instances of this class are not thread safe. Calls that would result in a\n * malformed JSON string will fail with an {@link IllegalStateException}.\n *\n * @author Jesse Wilson\n * @since 1.6\n ",
      "methods": {
        "setIndent": {
          "Javadoc": "* Sets the indentation string to be repeated for each level of indentation\n   * in the encoded document. If {@code indent.isEmpty()} the encoded document\n   * will be compact. Otherwise the encoded document will be more\n   * human-readable.\n   *\n   * @param indent a string containing only whitespace."
        },
        "setLenient": {
          "Javadoc": "* Configure this writer to relax its syntax rules. By default, this writer\n   * only emits well-formed JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>. Setting the writer\n   * to lenient permits the following:\n   * <ul>\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   * </ul>"
        },
        "isLenient": {
          "Javadoc": "* Returns true if this writer has relaxed syntax rules."
        },
        "setHtmlSafe": {
          "Javadoc": "* Configure this writer to emit JSON that's safe for direct inclusion in HTML\n   * and XML documents. This escapes the HTML characters {@code <}, {@code >},\n   * {@code &} and {@code =} before writing them to the stream. Without this\n   * setting, your XML/HTML encoder should replace these characters with the\n   * corresponding escape sequences."
        },
        "isHtmlSafe": {
          "Javadoc": "* Returns true if this writer writes JSON that's safe for inclusion in HTML\n   * and XML documents."
        },
        "setSerializeNulls": {
          "Javadoc": "* Sets whether object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true."
        },
        "getSerializeNulls": {
          "Javadoc": "* Returns true if object members are serialized when their value is null.\n   * This has no impact on array elements. The default is true."
        },
        "beginArray": {
          "Javadoc": "* Begins encoding a new array. Each call to this method must be paired with\n   * a call to {@link #endArray}.\n   *\n   * @return this writer."
        },
        "endArray": {
          "Javadoc": "* Ends encoding the current array.\n   *\n   * @return this writer."
        },
        "beginObject": {
          "Javadoc": "* Begins encoding a new object. Each call to this method must be paired\n   * with a call to {@link #endObject}.\n   *\n   * @return this writer."
        },
        "endObject": {
          "Javadoc": "* Ends encoding the current object.\n   *\n   * @return this writer."
        },
        "open": {
          "Javadoc": "* Enters a new scope by appending any necessary whitespace and the given\n   * bracket."
        },
        "close": {
          "Javadoc": "* Flushes and closes this writer and the underlying {@link Writer}.\n   *\n   * @throws IOException if the JSON document is incomplete."
        },
        "peek": {
          "Javadoc": "* Returns the value on the top of the stack."
        },
        "replaceTop": {
          "Javadoc": "* Replace the value on the top of the stack with the given value."
        },
        "name": {
          "Javadoc": "* Encodes the property name.\n   *\n   * @param name the name of the forthcoming value. May not be null.\n   * @return this writer."
        },
        "value": {
          "Javadoc": "* Encodes {@code value}. The value is written by directly writing the {@link Number#toString()}\n   * result to JSON. Implementations must make sure that the result represents a valid JSON number.\n   *\n   * @param value a finite value, or if {@link #setLenient(boolean) lenient},\n   *     also {@link Double#isNaN() NaN} or {@link Double#isInfinite() infinity}.\n   * @return this writer.\n   * @throws IllegalArgumentException if the value is NaN or Infinity and this writer is\n   *     not {@link #setLenient(boolean) lenient}; or if the {@code toString()} result is not a\n   *     valid JSON number."
        },
        "jsonValue": {
          "Javadoc": "* Writes {@code value} directly to the writer without quoting or\n   * escaping. This might not be supported by all implementations, if\n   * not supported an {@code UnsupportedOperationException} is thrown.\n   *\n   * @param value the literal string value, or null to encode a null literal.\n   * @return this writer.\n   * @throws UnsupportedOperationException if this writer does not support\n   *    writing raw JSON values.\n   * @since 2.4"
        },
        "nullValue": {
          "Javadoc": "* Encodes {@code null}.\n   *\n   * @return this writer."
        },
        "isTrustedNumberType": {
          "Javadoc": "* Returns whether the {@code toString()} of {@code c} can be trusted to return\n   * a valid JSON number."
        },
        "flush": {
          "Javadoc": "* Ensures all buffered data is written to the underlying {@link Writer}\n   * and flushes that writer."
        },
        "beforeName": {
          "Javadoc": "* Inserts any necessary separators and whitespace before a name. Also\n   * adjusts the stack to expect the name's value."
        },
        "beforeValue": {
          "Javadoc": "* Inserts any necessary separators and whitespace before a literal value,\n   * inline array, or inline object. Also adjusts the stack to expect either a\n   * closing bracket or another element."
        }
      }
    },
    "com.google.gson.stream.MalformedJsonException": {
      "Javadoc": "\n * Thrown when a reader encounters malformed JSON. Some syntax errors can be\n * ignored by calling {@link JsonReader#setLenient(boolean)}.\n "
    },
    "com.google.gson.ToNumberStrategy": {
      "Javadoc": "\n * A strategy that is used to control how numbers should be deserialized for {@link Object} and {@link Number}\n * when a concrete type of the deserialized number is unknown in advance. By default, Gson uses the following\n * deserialization strategies:\n *\n * <ul>\n * <li>{@link Double} values are returned for JSON numbers if the deserialization type is declared as\n * {@code Object}, see {@link ToNumberPolicy#DOUBLE};</li>\n * <li>Lazily parsed number values are returned if the deserialization type is declared as {@code Number},\n * see {@link ToNumberPolicy#LAZILY_PARSED_NUMBER}.</li>\n * </ul>\n *\n * <p>For historical reasons, Gson does not support deserialization of arbitrary-length numbers for\n * {@code Object} and {@code Number} by default, potentially causing precision loss. However,\n * <a href=\"https://tools.ietf.org/html/rfc8259#section-6\">RFC 8259</a> permits this:\n *\n * <pre>\n *   This specification allows implementations to set limits on the range\n *   and precision of numbers accepted.  Since software that implements\n *   IEEE 754 binary64 (double precision) numbers [IEEE754] is generally\n *   available and widely used, good interoperability can be achieved by\n *   implementations that expect no more precision or range than these\n *   provide, in the sense that implementations will approximate JSON\n *   numbers within the expected precision.  A JSON number such as 1E400\n *   or 3.141592653589793238462643383279 may indicate potential\n *   interoperability problems, since it suggests that the software that\n *   created it expects receiving software to have greater capabilities\n *   for numeric magnitude and precision than is widely available.\n * </pre>\n *\n * <p>To overcome the precision loss, use for example {@link ToNumberPolicy#LONG_OR_DOUBLE} or\n * {@link ToNumberPolicy#BIG_DECIMAL}.</p>\n *\n * @see ToNumberPolicy\n * @see GsonBuilder#setObjectToNumberStrategy(ToNumberStrategy)\n * @see GsonBuilder#setNumberToNumberStrategy(ToNumberStrategy)\n * @since 2.8.9\n ",
      "methods": {
        "readNumber": {
          "Javadoc": "* Reads a number from the given JSON reader. A strategy is supposed to read a single value from the\n   * reader, and the read value is guaranteed never to be {@code null}.\n   *\n   * @param in JSON reader to read a number from\n   * @return number read from the JSON reader."
        }
      }
    },
    "com.google.gson.TypeAdapter": {
      "Javadoc": "",
      "methods": {
        "write": {
          "Javadoc": "* Writes one JSON value (an array, object, string, number, boolean or null)\n   * for {@code value}.\n   *\n   * @param value the Java object to write. May be null."
        },
        "toJson": {
          "Javadoc": "* Converts {@code value} to a JSON document. Unlike Gson's similar {@link\n   * Gson#toJson(Object) toJson} method, this write is strict. Create a {@link\n   * JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call\n   * {@link #write(JsonWriter, Object)} for lenient writing.\n   *\n   * @throws JsonIOException wrapping {@code IOException}s thrown by {@link #write(JsonWriter, Object)}\n   * @param value the Java object to convert. May be null.\n   * @since 2.2"
        },
        "nullSafe": {
          "Javadoc": "* This wrapper method is used to make a type adapter null tolerant. In general, a\n   * type adapter is required to handle nulls in write and read methods. Here is how this\n   * is typically done:<br>\n   * <pre>   {@code\n   *\n   * Gson gson = new GsonBuilder().registerTypeAdapter(Foo.class,\n   *   new TypeAdapter<Foo>() {\n   *     public Foo read(JsonReader in) throws IOException {\n   *       if (in.peek() == JsonToken.NULL) {\n   *         in.nextNull();\n   *         return null;\n   *       }\n   *       // read a Foo from in and return it\n   *     }\n   *     public void write(JsonWriter out, Foo src) throws IOException {\n   *       if (src == null) {\n   *         out.nullValue();\n   *         return;\n   *       }\n   *       // write src as JSON to out\n   *     }\n   *   }).create();\n   * }</pre>\n   * You can avoid this boilerplate handling of nulls by wrapping your type adapter with\n   * this method. Here is how we will rewrite the above example:\n   * <pre>   {@code\n   *\n   * Gson gson = new GsonBuilder().registerTypeAdapter(Foo.class,\n   *   new TypeAdapter<Foo>() {\n   *     public Foo read(JsonReader in) throws IOException {\n   *       // read a Foo from in and return it\n   *     }\n   *     public void write(JsonWriter out, Foo src) throws IOException {\n   *       // write src as JSON to out\n   *     }\n   *   }.nullSafe()).create();\n   * }</pre>\n   * Note that we didn't need to check for nulls in our type adapter after we used nullSafe."
        },
        "toJsonTree": {
          "Javadoc": "* Converts {@code value} to a JSON tree.\n   *\n   * @param value the Java object to convert. May be null.\n   * @return the converted JSON tree. May be {@link JsonNull}.\n   * @throws JsonIOException wrapping {@code IOException}s thrown by {@link #write(JsonWriter, Object)}\n   * @since 2.2"
        },
        "read": {
          "Javadoc": "* Reads one JSON value (an array, object, string, number, boolean or null)\n   * and converts it to a Java object. Returns the converted object.\n   *\n   * @return the converted Java object. May be null."
        },
        "fromJson": {
          "Javadoc": "* Converts the JSON document in {@code json} to a Java object. Unlike Gson's\n   * similar {@link Gson#fromJson(String, Class) fromJson} method, this read is\n   * strict. Create a {@link JsonReader#setLenient(boolean) lenient} {@code\n   * JsonReader} and call {@link #read(JsonReader)} for lenient reading.\n   *\n   * <p>No exception is thrown if the JSON data has multiple top-level JSON elements,\n   * or if there is trailing data.\n   *\n   * @return the converted Java object. May be null.\n   * @since 2.2"
        },
        "fromJsonTree": {
          "Javadoc": "* Converts {@code jsonTree} to a Java object.\n   *\n   * @param jsonTree the JSON element to convert. May be {@link JsonNull}.\n   * @return the converted Java object. May be null.\n   * @throws JsonIOException wrapping {@code IOException}s thrown by {@link #read(JsonReader)}\n   * @since 2.2"
        }
      }
    },
    "com.google.gson.TypeAdapterFactory": {
      "Javadoc": "\n * Creates type adapters for set of related types. Type adapter factories are\n * most useful when several types share similar structure in their JSON form.\n *\n * <h2>Examples</h2>\n * <h3>Example: Converting enums to lowercase</h3>\n * In this example, we implement a factory that creates type adapters for all\n * enums. The type adapters will write enums in lowercase, despite the fact\n * that they're defined in {@code CONSTANT_CASE} in the corresponding Java\n * model: <pre>   {@code\n *\n *   public class LowercaseEnumTypeAdapterFactory implements TypeAdapterFactory {\n *     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n *       Class<T> rawType = (Class<T>) type.getRawType();\n *       if (!rawType.isEnum()) {\n *         return null;\n *       }\n *\n *       final Map<String, T> lowercaseToConstant = new HashMap<>();\n *       for (T constant : rawType.getEnumConstants()) {\n *         lowercaseToConstant.put(toLowercase(constant), constant);\n *       }\n *\n *       return new TypeAdapter<T>() {\n *         public void write(JsonWriter out, T value) throws IOException {\n *           if (value == null) {\n *             out.nullValue();\n *           } else {\n *             out.value(toLowercase(value));\n *           }\n *         }\n *\n *         public T read(JsonReader reader) throws IOException {\n *           if (reader.peek() == JsonToken.NULL) {\n *             reader.nextNull();\n *             return null;\n *           } else {\n *             return lowercaseToConstant.get(reader.nextString());\n *           }\n *         }\n *       };\n *     }\n *\n *     private String toLowercase(Object o) {\n *       return o.toString().toLowerCase(Locale.US);\n *     }\n *   }\n * }</pre>\n *\n * <p>Type adapter factories select which types they provide type adapters\n * for. If a factory cannot support a given type, it must return null when\n * that type is passed to {@link #create}. Factories should expect {@code\n * create()} to be called on them for many types and should return null for\n * most of those types. In the above example the factory returns null for\n * calls to {@code create()} where {@code type} is not an enum.\n *\n * <p>A factory is typically called once per type, but the returned type\n * adapter may be used many times. It is most efficient to do expensive work\n * like reflection in {@code create()} so that the type adapter's {@code\n * read()} and {@code write()} methods can be very fast. In this example the\n * mapping from lowercase name to enum value is computed eagerly.\n *\n * <p>As with type adapters, factories must be <i>registered</i> with a {@link\n * com.google.gson.GsonBuilder} for them to take effect: <pre>   {@code\n *\n *  GsonBuilder builder = new GsonBuilder();\n *  builder.registerTypeAdapterFactory(new LowercaseEnumTypeAdapterFactory());\n *  ...\n *  Gson gson = builder.create();\n * }</pre>\n * If multiple factories support the same type, the factory registered earlier\n * takes precedence.\n *\n * <h3>Example: Composing other type adapters</h3>\n * In this example we implement a factory for Guava's {@code Multiset}\n * collection type. The factory can be used to create type adapters for\n * multisets of any element type: the type adapter for {@code\n * Multiset<String>} is different from the type adapter for {@code\n * Multiset<URL>}.\n *\n * <p>The type adapter <i>delegates</i> to another type adapter for the\n * multiset elements. It figures out the element type by reflecting on the\n * multiset's type token. A {@code Gson} is passed in to {@code create} for\n * just this purpose: <pre>   {@code\n *\n *   public class MultisetTypeAdapterFactory implements TypeAdapterFactory {\n *     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n *       Type type = typeToken.getType();\n *       if (typeToken.getRawType() != Multiset.class\n *           || !(type instanceof ParameterizedType)) {\n *         return null;\n *       }\n *\n *       Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\n *       TypeAdapter<?> elementAdapter = gson.getAdapter(TypeToken.get(elementType));\n *       return (TypeAdapter<T>) newMultisetAdapter(elementAdapter);\n *     }\n *\n *     private <E> TypeAdapter<Multiset<E>> newMultisetAdapter(\n *         final TypeAdapter<E> elementAdapter) {\n *       return new TypeAdapter<Multiset<E>>() {\n *         public void write(JsonWriter out, Multiset<E> value) throws IOException {\n *           if (value == null) {\n *             out.nullValue();\n *             return;\n *           }\n *\n *           out.beginArray();\n *           for (Multiset.Entry<E> entry : value.entrySet()) {\n *             out.value(entry.getCount());\n *             elementAdapter.write(out, entry.getElement());\n *           }\n *           out.endArray();\n *         }\n *\n *         public Multiset<E> read(JsonReader in) throws IOException {\n *           if (in.peek() == JsonToken.NULL) {\n *             in.nextNull();\n *             return null;\n *           }\n *\n *           Multiset<E> result = LinkedHashMultiset.create();\n *           in.beginArray();\n *           while (in.hasNext()) {\n *             int count = in.nextInt();\n *             E element = elementAdapter.read(in);\n *             result.add(element, count);\n *           }\n *           in.endArray();\n *           return result;\n *         }\n *       };\n *     }\n *   }\n * }</pre>\n * Delegating from one type adapter to another is extremely powerful; it's\n * the foundation of how Gson converts Java objects and collections. Whenever\n * possible your factory should retrieve its delegate type adapter in the\n * {@code create()} method; this ensures potentially-expensive type adapter\n * creation happens only once.\n *\n * @since 2.1\n ",
      "methods": {
        "create": {
          "Javadoc": "* Returns a type adapter for {@code type}, or null if this factory doesn't\n   * support {@code type}."
        }
      }
    },
    "com.google.gson.internal.GsonBuildConfig": {
      "Javadoc": "\n * Build configuration for Gson. This file is automatically populated by\n * templating-maven-plugin and .java/.class files are generated for use in Gson.\n *\n * @author Inderjeet Singh\n "
    },
    "com.google.gson.CommentsTest": {
      "Javadoc": "\n * @author Jesse Wilson\n ",
      "methods": {
        "testParseComments": {
          "Javadoc": "* Test for issue 212."
        }
      }
    },
    "com.google.gson.common.MoreAsserts": {
      "Javadoc": "\n * Handy asserts that we wish were present in {@link Assert}\n * so that we didn't have to write them.\n *\n * @author Inderjeet Singh\n ",
      "methods": {
        "assertContains": {
          "Javadoc": "* Asserts that the specified {@code value} is not present in {@code collection}\n   * @param collection the collection to look into\n   * @param value the value that needs to be checked for presence"
        },
        "assertOverridesMethods": {
          "Javadoc": "* Asserts that {@code subClass} overrides all protected and public methods declared by\n   * {@code baseClass} except for the ones whose signatures are in {@code ignoredMethods}."
        }
      }
    },
    "com.google.gson.common.TestTypes": {
      "Javadoc": "\n * Types used for testing JSON serialization and deserialization\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.common.Base": {
      "Javadoc": ""
    },
    "com.google.gson.common.Sub": {
      "Javadoc": ""
    },
    "com.google.gson.common.ClassWithBaseField": {
      "Javadoc": ""
    },
    "com.google.gson.common.ClassWithBaseArrayField": {
      "Javadoc": ""
    },
    "com.google.gson.common.ClassWithBaseCollectionField": {
      "Javadoc": ""
    },
    "com.google.gson.common.BaseSerializer": {
      "Javadoc": ""
    },
    "com.google.gson.common.SubSerializer": {
      "Javadoc": ""
    },
    "com.google.gson.common.StringWrapper": {
      "Javadoc": ""
    },
    "com.google.gson.common.BagOfPrimitives": {
      "Javadoc": ""
    },
    "com.google.gson.common.BagOfPrimitiveWrappers": {
      "Javadoc": ""
    },
    "com.google.gson.common.PrimitiveArray": {
      "Javadoc": ""
    },
    "com.google.gson.common.ClassWithNoFields": {
      "Javadoc": ""
    },
    "com.google.gson.common.Nested": {
      "Javadoc": ""
    },
    "com.google.gson.common.ClassWithTransientFields": {
      "Javadoc": ""
    },
    "com.google.gson.common.ClassWithCustomTypeConverter": {
      "Javadoc": ""
    },
    "com.google.gson.common.ArrayOfObjects": {
      "Javadoc": ""
    },
    "com.google.gson.common.ClassOverridingEquals": {
      "Javadoc": ""
    },
    "com.google.gson.common.ClassWithArray": {
      "Javadoc": ""
    },
    "com.google.gson.common.ClassWithObjects": {
      "Javadoc": ""
    },
    "com.google.gson.common.ClassWithSerializedNameFields": {
      "Javadoc": ""
    },
    "com.google.gson.common.CrazyLongTypeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.DefaultInetAddressTypeAdapterTest": {
      "Javadoc": "\n * Unit tests for the default serializer/deserializer for the {@code InetAddress} type.\n * \n * @author Joel Leitch\n "
    },
    "com.google.gson.DefaultMapJsonSerializerTest": {
      "Javadoc": "\n * Unit test for the default JSON map serialization object located in the\n * {@link DefaultTypeAdapters} class.\n *\n * @author Joel Leitch\n "
    },
    "com.google.gson.ExposeAnnotationExclusionStrategyTest": {
      "Javadoc": "\n * Unit tests for GsonBuilder.REQUIRE_EXPOSE_DESERIALIZE.\n *\n * @author Joel Leitch\n "
    },
    "com.google.gson.MockObject": {
      "Javadoc": ""
    },
    "com.google.gson.FieldAttributesTest": {
      "Javadoc": "\n * Unit tests for the {@link FieldAttributes} class.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.Foo": {
      "Javadoc": ""
    },
    "com.google.gson.FieldNamingPolicyTest": {
      "Javadoc": "\n * Performs tests directly against {@link FieldNamingPolicy}; for integration tests\n * see {@link FieldNamingTest}.\n ",
      "methods": {
        "testUpperCasingLocaleIndependent": {
          "Javadoc": "* Upper casing policies should be unaffected by default Locale."
        },
        "testLowerCasingLocaleIndependent": {
          "Javadoc": "* Lower casing policies should be unaffected by default Locale."
        }
      }
    },
    "com.google.gson.Dummy": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ArrayTest": {
      "Javadoc": "\n * Functional tests for Json serialization and deserialization of arrays.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "testMultidimensionalArraysSerialization": {
          "Javadoc": "* Regression tests for Issue 272"
        },
        "testMixingTypesInObjectArraySerialization": {
          "Javadoc": "* Regression test for Issue 205"
        },
        "testMultidimensionalArraysDeserialization": {
          "Javadoc": "* Regression tests for Issue 272"
        },
        "testArrayElementsAreArrays": {
          "Javadoc": "http://code.google.com/p/google-gson/issues/detail?id=342"
        }
      }
    },
    "com.google.gson.functional.CircularReferenceTest": {
      "Javadoc": "\n * Functional tests related to circular reference detection and error reporting.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.ContainsReferenceToSelfType": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithSelfReference": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithSelfReferenceArray": {
      "Javadoc": ""
    },
    "com.google.gson.functional.CollectionTest": {
      "Javadoc": "\n * Functional tests for Json serialization and deserialization of collections.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.HasArrayListField": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ObjectWithWildcardCollection": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Entry": {
      "Javadoc": ""
    },
    "com.google.gson.functional.BigClass": {
      "Javadoc": ""
    },
    "com.google.gson.functional.SmallClass": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ConcurrencyTest": {
      "Javadoc": "\r\n * Tests for ensuring Gson thread-safety.\r\n * \r\n * @author Inderjeet Singh\r\n * @author Joel Leitch\r\n ",
      "methods": {
        "testSingleThreadSerialization": {
          "Javadoc": "* Source-code based on\r\n   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081"
        },
        "testSingleThreadDeserialization": {
          "Javadoc": "* Source-code based on\r\n   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081"
        },
        "testMultiThreadSerialization": {
          "Javadoc": "* Source-code based on\r\n   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081"
        },
        "testMultiThreadDeserialization": {
          "Javadoc": "* Source-code based on\r\n   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081"
        }
      }
    },
    "com.google.gson.functional.MyObject": {
      "Javadoc": ""
    },
    "com.google.gson.functional.CustomDeserializerTest": {
      "Javadoc": "\n * Functional Test exercising custom deserialization only. When test applies to both\n * serialization and deserialization then add it to CustomTypeAdapterTest.\n *\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.DataHolder": {
      "Javadoc": ""
    },
    "com.google.gson.functional.DataHolderWrapper": {
      "Javadoc": ""
    },
    "com.google.gson.functional.DataHolderDeserializer": {
      "Javadoc": ""
    },
    "com.google.gson.functional.MyBase": {
      "Javadoc": ""
    },
    "com.google.gson.functional.SubType1": {
      "Javadoc": ""
    },
    "com.google.gson.functional.SubType2": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithBaseArray": {
      "Javadoc": ""
    },
    "com.google.gson.functional.CustomSerializerTest": {
      "Javadoc": "\n * Functional Test exercising custom serialization only.  When test applies to both\n * serialization and deserialization then add it to CustomTypeAdapterTest.\n *\n * @author Inderjeet Singh\n "
    },
    "com.google.gson.functional.CustomTypeAdaptersTest": {
      "Javadoc": "\n * Functional tests for the support of custom serializer and deserializers.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.Base": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Derived": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Foo": {
      "Javadoc": ""
    },
    "com.google.gson.functional.FooTypeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.StringHolder": {
      "Javadoc": ""
    },
    "com.google.gson.functional.StringHolderTypeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.DataHolderSerializer": {
      "Javadoc": ""
    },
    "com.google.gson.functional.DateTypeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.DefaultTypeAdaptersTest": {
      "Javadoc": "\n * Functional test for Json serialization and deserialization for common classes for which default\n * support is provided in Gson. The tests for Map types are available in {@link MapTest}.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.ClassWithUrlField": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithBigDecimal": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithBigInteger": {
      "Javadoc": ""
    },
    "com.google.gson.functional.MyClassTypeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.NumberAsStringAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.DelegateTypeAdapterTest": {
      "Javadoc": "\n * Functional tests for {@link Gson#getDelegateAdapter(TypeAdapterFactory, TypeToken)} method.\n *\n * @author Inderjeet Singh\n "
    },
    "com.google.gson.functional.StatsTypeAdapterFactory": {
      "Javadoc": ""
    },
    "com.google.gson.functional.EnumTest": {
      "Javadoc": "\n * Functional tests for Java 5.0 enums.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "testEnumSubclass": {
          "Javadoc": "* Test for issue 226."
        },
        "testEnumToStringReadInterchanged": {
          "Javadoc": "* Test that enum constant names have higher precedence than {@code toString()}\n   * result."
        }
      }
    },
    "com.google.gson.functional.ClassWithEnumFields": {
      "Javadoc": ""
    },
    "com.google.gson.functional.MyEnumTypeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.EnumWithObfuscatedTest": {
      "Javadoc": "\n * Functional tests for enums with Proguard.\n *\n * @author Young Cha\n "
    },
    "com.google.gson.functional.EscapingTest": {
      "Javadoc": "\n * Performs some functional test involving JSON output escaping.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.ExclusionStrategyFunctionalTest": {
      "Javadoc": "\n * Performs some functional tests when Gson is instantiated with some common user defined\n * {@link ExclusionStrategy} objects.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.SampleObjectForTest": {
      "Javadoc": ""
    },
    "com.google.gson.functional.MyExclusionStrategy": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ExposeFieldsTest": {
      "Javadoc": "\n * Unit tests for the regarding functional \"@Expose\" type tests.\n *\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.ClassWithExposedFields": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithNoExposedFields": {
      "Javadoc": ""
    },
    "com.google.gson.functional.SomeInterface": {
      "Javadoc": ""
    },
    "com.google.gson.functional.SomeObject": {
      "Javadoc": ""
    },
    "com.google.gson.functional.SomeInterfaceInstanceCreator": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithInterfaceField": {
      "Javadoc": ""
    },
    "com.google.gson.functional.FieldExclusionTest": {
      "Javadoc": "\n * Performs some functional testing to ensure GSON infrastructure properly serializes/deserializes\n * fields that either should or should not be included in the output based on the GSON\n * configuration.\n *\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.Outer": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Inner": {
      "Javadoc": ""
    },
    "com.google.gson.functional.NestedClass": {
      "Javadoc": ""
    },
    "com.google.gson.functional.FieldNamingTest": {
      "Javadoc": ""
    },
    "com.google.gson.functional.TestNames": {
      "Javadoc": ""
    },
    "com.google.gson.functional.GsonVersionDiagnosticsTest": {
      "Javadoc": "\n * Functional tests to validate printing of Gson version on AssertionErrors\n *\n * @author Inderjeet Singh\n "
    },
    "com.google.gson.functional.TestType": {
      "Javadoc": ""
    },
    "com.google.gson.functional.InheritanceTest": {
      "Javadoc": "\n * Functional tests for Json serialization and deserialization of classes with \n * inheritance hierarchies.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.SubTypeOfNested": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithSubInterfacesOfCollection": {
      "Javadoc": ""
    },
    "com.google.gson.functional.InstanceCreatorTest": {
      "Javadoc": "\n * Functional Test exercising custom serialization only. When test applies to both\n * serialization and deserialization then add it to CustomTypeAdapterTest.\n *\n * @author Inderjeet Singh\n "
    },
    "com.google.gson.functional.SubArrayList": {
      "Javadoc": ""
    },
    "com.google.gson.functional.SubTreeSet": {
      "Javadoc": ""
    },
    "com.google.gson.functional.InterfaceTest": {
      "Javadoc": "\n * Functional tests involving interfaces.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.TestObjectInterface": {
      "Javadoc": ""
    },
    "com.google.gson.functional.TestObject": {
      "Javadoc": ""
    },
    "com.google.gson.functional.TestObjectWrapper": {
      "Javadoc": ""
    },
    "com.google.gson.functional.InternationalizationTest": {
      "Javadoc": "\r\n * Functional tests for internationalized strings.\r\n *\r\n * @author Inderjeet Singh\r\n "
    },
    "com.google.gson.functional.JavaUtilConcurrentAtomicTest": {
      "Javadoc": "\n * Functional test for Json serialization and deserialization for classes in java.util.concurrent.atomic\n "
    },
    "com.google.gson.functional.AtomicLongHolder": {
      "Javadoc": ""
    },
    "com.google.gson.functional.JavaUtilTest": {
      "Javadoc": "\n * Functional test for Json serialization and deserialization for classes in java.util\n "
    },
    "com.google.gson.functional.CurrencyHolder": {
      "Javadoc": ""
    },
    "com.google.gson.functional.JsonAdapterAnnotationOnClassesTest": {
      "Javadoc": "\n * Functional tests for the {@link com.google.gson.annotations.JsonAdapter} annotation on classes.\n ",
      "methods": {
        "testRegisteredSerializerOverridesJsonAdapter": {
          "Javadoc": "* The serializer overrides field adapter, but for deserializer the fieldAdapter is used."
        },
        "testRegisteredDeserializerOverridesJsonAdapter": {
          "Javadoc": "* The deserializer overrides Json adapter, but for serializer the jsonAdapter is used."
        }
      }
    },
    "com.google.gson.functional.A": {
      "Javadoc": ""
    },
    "com.google.gson.functional.JsonAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.C": {
      "Javadoc": ""
    },
    "com.google.gson.functional.JsonAdapterFactory": {
      "Javadoc": ""
    },
    "com.google.gson.functional.B": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithIncorrectJsonAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.User": {
      "Javadoc": ""
    },
    "com.google.gson.functional.UserJsonAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.NullableClass": {
      "Javadoc": ""
    },
    "com.google.gson.functional.NullableClassJsonAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.FooJsonAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.D": {
      "Javadoc": ""
    },
    "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest": {
      "Javadoc": "\n * Functional tests for the {@link com.google.gson.annotations.JsonAdapter} annotation on fields.\n ",
      "methods": {
        "testNonPrimitiveFieldAnnotationTakesPrecedenceOverDefault": {
          "Javadoc": "Regression test contributed through https://github.com/google/gson/issues/831"
        },
        "testPrimitiveFieldAnnotationTakesPrecedenceOverDefault": {
          "Javadoc": "Regression test contributed through https://github.com/google/gson/issues/831"
        }
      }
    },
    "com.google.gson.functional.Gadget": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Gizmo": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Part": {
      "Javadoc": ""
    },
    "com.google.gson.functional.PartJsonFieldAnnotationAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.GizmoPartTypeAdapterFactory": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Computer": {
      "Javadoc": ""
    },
    "com.google.gson.functional.UserClassAnnotationAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Computer2": {
      "Javadoc": ""
    },
    "com.google.gson.functional.UserFieldAnnotationAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.RegisteredUserAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.GadgetWithTwoParts": {
      "Javadoc": ""
    },
    "com.google.gson.functional.GadgetWithOptionalPart": {
      "Javadoc": ""
    },
    "com.google.gson.functional.GadgetWithPrimitivePart": {
      "Javadoc": ""
    },
    "com.google.gson.functional.LongToStringTypeAdapterFactory": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Gizmo2": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Gizmo2PartTypeAdapterFactory": {
      "Javadoc": ""
    },
    "com.google.gson.functional.JsonAdapterSerializerDeserializerTest": {
      "Javadoc": "\n * Functional tests for the {@link JsonAdapter} annotation on fields where the value is of\n * type {@link JsonSerializer} or {@link JsonDeserializer}.\n "
    },
    "com.google.gson.functional.UserSerializer": {
      "Javadoc": ""
    },
    "com.google.gson.functional.UserDeserializer": {
      "Javadoc": ""
    },
    "com.google.gson.functional.UserSerializerDeserializer": {
      "Javadoc": ""
    },
    "com.google.gson.functional.User2": {
      "Javadoc": ""
    },
    "com.google.gson.functional.UserSerializerDeserializer2": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Container": {
      "Javadoc": ""
    },
    "com.google.gson.functional.BaseStringAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.BaseIntegerAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Computer3": {
      "Javadoc": ""
    },
    "com.google.gson.functional.JsonParserTest": {
      "Javadoc": "\n * Functional tests for that use JsonParser and related Gson methods\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.JsonTreeTest": {
      "Javadoc": "\n * Functional tests for {@link Gson#toJsonTree(Object)} and \n * {@link Gson#toJsonTree(Object, java.lang.reflect.Type)}\n * \n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.SubTypeOfBagOfPrimitives": {
      "Javadoc": ""
    },
    "com.google.gson.functional.LeniencyTest": {
      "Javadoc": "\n * Functional tests for leniency option.\n "
    },
    "com.google.gson.functional.MapAsArrayTypeAdapterTest": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Point": {
      "Javadoc": ""
    },
    "com.google.gson.functional.PointWithProperty": {
      "Javadoc": ""
    },
    "com.google.gson.functional.MapTest": {
      "Javadoc": "\n * Functional test for Json serialization and deserialization for Maps\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "testMapSerializationWithNullValues": {
          "Javadoc": "* Created in response to http://code.google.com/p/google-gson/issues/detail?id=99"
        },
        "testMapSerializationWithNullValuesSerialized": {
          "Javadoc": "* Created in response to http://code.google.com/p/google-gson/issues/detail?id=99"
        },
        "testMapOfMapSerialization": {
          "Javadoc": "* From bug report http://code.google.com/p/google-gson/issues/detail?id=95"
        },
        "testMapOfMapDeserialization": {
          "Javadoc": "* From bug report http://code.google.com/p/google-gson/issues/detail?id=95"
        },
        "testMapWithQuotes": {
          "Javadoc": "* From bug report http://code.google.com/p/google-gson/issues/detail?id=178"
        },
        "testWriteMapsWithEmptyStringKey": {
          "Javadoc": "* From issue 227."
        },
        "testSerializeMaps": {
          "Javadoc": "* From bug report http://code.google.com/p/google-gson/issues/detail?id=204"
        }
      }
    },
    "com.google.gson.functional.MyParameterizedMap": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithAMap": {
      "Javadoc": "\n   * Created in response to http://code.google.com/p/google-gson/issues/detail?id=99\n   "
    },
    "com.google.gson.functional.MyMap": {
      "Javadoc": ""
    },
    "com.google.gson.functional.MapClass": {
      "Javadoc": ""
    },
    "com.google.gson.functional.MapWithGeneralMapParameters": {
      "Javadoc": ""
    },
    "com.google.gson.functional.MoreSpecificTypeSerializationTest": {
      "Javadoc": "\n * Tests for Gson serialization of a sub-class object while encountering a base-class type\n *\n * @author Inderjeet Singh\n ",
      "methods": {
        "testParameterizedSubclassFields": {
          "Javadoc": "* For parameterized type, Gson ignores the more-specific type and sticks to the declared type"
        },
        "testListOfParameterizedSubclassFields": {
          "Javadoc": "* For parameterized type in a List, Gson ignores the more-specific type and sticks to\n   * the declared type"
        },
        "testMapOfParameterizedSubclassFields": {
          "Javadoc": "* For parameterized type in a map, Gson ignores the more-specific type and sticks to the\n   * declared type"
        }
      }
    },
    "com.google.gson.functional.Sub": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithBaseFields": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithContainersOfBaseFields": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ParameterizedBase": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ParameterizedSub": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithParameterizedBaseFields": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithContainersOfParameterizedBaseFields": {
      "Javadoc": ""
    },
    "com.google.gson.functional.NamingPolicyTest": {
      "Javadoc": "\n * Functional tests for naming policies.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "testAtSignInSerializedName": {
          "Javadoc": "http://code.google.com/p/google-gson/issues/detail?id=349"
        }
      }
    },
    "com.google.gson.functional.AtName": {
      "Javadoc": ""
    },
    "com.google.gson.functional.UpperCaseNamingStrategy": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithDuplicateFields": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithComplexFieldName": {
      "Javadoc": ""
    },
    "com.google.gson.functional.NullObjectAndFieldTest": {
      "Javadoc": "\r\n * Functional tests for the different cases for serializing (or ignoring) null fields and object.\r\n *\r\n * @author Inderjeet Singh\r\n * @author Joel Leitch\r\n ",
      "methods": {
        "testNullWrappedPrimitiveMemberSerialization": {
          "Javadoc": "* Added to verify http://code.google.com/p/google-gson/issues/detail?id=68"
        },
        "testNullWrappedPrimitiveMemberDeserialization": {
          "Javadoc": "* Added to verify http://code.google.com/p/google-gson/issues/detail?id=68"
        }
      }
    },
    "com.google.gson.functional.ClassWithInitializedMembers": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithNullWrappedPrimitive": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithMembers": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithObjectsSerializer": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ObjectWithField": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ObjectTest": {
      "Javadoc": "\n * Functional tests for Json serialization and deserialization of regular classes.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "testNullArraysDeserialization": {
          "Javadoc": "* Created in response to Issue 14: http://code.google.com/p/google-gson/issues/detail?id=14"
        },
        "testNullObjectFieldsDeserialization": {
          "Javadoc": "* Created in response to Issue 14: http://code.google.com/p/google-gson/issues/detail?id=14"
        },
        "testNullPrimitiveFieldsDeserialization": {
          "Javadoc": "* Created in response to Issue 14: http://code.google.com/p/google-gson/issues/detail?id=14"
        },
        "testClassWithObjectFieldSerialization": {
          "Javadoc": "* Tests that a class field with type Object can be serialized properly.\n   * See issue 54"
        },
        "testObjectFieldNamesWithoutQuotesDeserialization": {
          "Javadoc": "* In response to Issue 41 http://code.google.com/p/google-gson/issues/detail?id=41"
        },
        "testStringFieldWithEmptyValueSerialization": {
          "Javadoc": "* Created to reproduce issue 140"
        },
        "testStringFieldWithEmptyValueDeserialization": {
          "Javadoc": "* Created to reproduce issue 140"
        },
        "testSingletonLists": {
          "Javadoc": "* Test for issue 215."
        },
        "testStaticFieldSerialization": {
          "Javadoc": "* Tests serialization of a class with {@code static} field.\n   *\n   * <p>Important: It is not documented that this is officially supported; this\n   * test just checks the current behavior."
        },
        "testStaticFieldDeserialization": {
          "Javadoc": "* Tests deserialization of a class with {@code static} field.\n   *\n   * <p>Important: It is not documented that this is officially supported; this\n   * test just checks the current behavior."
        }
      }
    },
    "com.google.gson.functional.Subclass": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Superclass1": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Superclass2": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithCollectionField": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithObjectField": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Parent": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Child": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ArrayOfArrays": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithPrivateNoArgsConstructor": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithEmptyStringFields": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Department": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Product": {
      "Javadoc": ""
    },
    "com.google.gson.functional.HasObjectMap": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithStaticField": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithStaticFinalField": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithThrowingConstructor": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ParameterizedTypesTest": {
      "Javadoc": "\n * Functional tests for the serialization and deserialization of parameterized types in Gson.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.ObjectWithTypeVariables": {
      "Javadoc": "\n   * An test object that has fields that are type variables.\n   *\n   * @param <T> Enforce T to be a string to make writing the \"toExpectedJson\" method easier.\n   "
    },
    "com.google.gson.functional.MultiParameters": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Quantity": {
      "Javadoc": ""
    },
    "com.google.gson.functional.MyQuantity": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Measurable": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Field": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Immutable": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Amount": {
      "Javadoc": ""
    },
    "com.google.gson.functional.PrettyPrintingTest": {
      "Javadoc": "\n * Functional tests for pretty printing option.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.ClassWithMap": {
      "Javadoc": ""
    },
    "com.google.gson.functional.PrimitiveCharacterTest": {
      "Javadoc": "\n * Functional tests for Java Character values.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.PrimitiveTest": {
      "Javadoc": "\n * Functional tests for Json primitive values: integers, and floating point numbers.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.ClassWithIntegerField": {
      "Javadoc": ""
    },
    "com.google.gson.functional.PrintFormattingTest": {
      "Javadoc": "\n * Functional tests for print formatting.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.RawSerializationTest": {
      "Javadoc": "\n * Unit tests to validate serialization of parameterized types without explicit types\n *\n * @author Inderjeet Singh\n "
    },
    "com.google.gson.functional.Bar": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ReadersWritersTest": {
      "Javadoc": "\n * Functional tests for the support of {@link Reader}s and {@link Writer}s.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "testToJsonAppendable": {
          "Javadoc": "* Verifies that passing an {@link Appendable} which is not an instance of {@link Writer}\n   * to {@code Gson.toJson} works correctly."
        }
      }
    },
    "com.google.gson.functional.CustomAppendable": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ReflectionAccessFilterTest": {
      "Javadoc": "",
      "methods": {
        "testBlockAllPartial": {
          "Javadoc": "* When using {@link FilterResult#BLOCK_ALL}, registering only a {@link JsonSerializer}\n   * but not performing any deserialization should not throw any exception."
        },
        "testBlockAllCollectionInterface": {
          "Javadoc": "* Should not fail when deserializing collection interface\n   * (Even though this goes through {@link ConstructorConstructor} as well)"
        },
        "testBlockAllCollectionImplementation": {
          "Javadoc": "* Should not fail when deserializing specific collection implementation\n   * (Even though this goes through {@link ConstructorConstructor} as well)"
        },
        "testBlockInaccessibleInterface": {
          "Javadoc": "* When trying to deserialize interface an exception for that should\n   * be thrown, even if {@link FilterResult#BLOCK_INACCESSIBLE} is used"
        }
      }
    },
    "com.google.gson.functional.ClassExtendingJdkClass": {
      "Javadoc": ""
    },
    "com.google.gson.functional.SuperTestClass": {
      "Javadoc": ""
    },
    "com.google.gson.functional.SubTestClass": {
      "Javadoc": ""
    },
    "com.google.gson.functional.OtherClass": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithPrivateField": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ExtendingClassWithPrivateField": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ClassWithoutNoArgsConstructor": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ReflectionAccessTest": {
      "Javadoc": "",
      "methods": {
        "testSerializeInternalImplementationObject": {
          "Javadoc": "* Test serializing an instance of a non-accessible internal class, but where\n   * Gson supports serializing one of its superinterfaces.\n   *\n   * <p>Here {@link Collections#emptyList()} is used which returns an instance\n   * of the internal class {@code java.util.Collections.EmptyList}. Gson should\n   * serialize the object as {@code List} despite the internal class not being\n   * accessible.\n   *\n   * <p>See https://github.com/google/gson/issues/1875"
        }
      }
    },
    "com.google.gson.functional.ClassWithPrivateMembers": {
      "Javadoc": ""
    },
    "com.google.gson.functional.ReusedTypeVariablesFullyResolveTest": {
      "Javadoc": "\n * This test covers the scenario described in #1390 where a type variable needs to be used\n * by a type definition multiple times.  Both type variable references should resolve to the\n * same underlying concrete type.\n "
    },
    "com.google.gson.functional.TestEnumSetCollection": {
      "Javadoc": ""
    },
    "com.google.gson.functional.SetCollection": {
      "Javadoc": ""
    },
    "com.google.gson.functional.BaseCollection": {
      "Javadoc": ""
    },
    "com.google.gson.functional.RuntimeTypeAdapterFactoryFunctionalTest": {
      "Javadoc": "\n * Functional tests for the RuntimeTypeAdapterFactory feature in extras.\n ",
      "methods": {
        "testSubclassesAutomaticallySerialized": {
          "Javadoc": "* This test also ensures that {@link TypeAdapterFactory} registered through {@link JsonAdapter}\n   * work correctly for {@link Gson#getDelegateAdapter(TypeAdapterFactory, TypeToken)}."
        }
      }
    },
    "com.google.gson.functional.Shape": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Circle": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Square": {
      "Javadoc": ""
    },
    "com.google.gson.functional.RuntimeTypeAdapterFactory": {
      "Javadoc": "",
      "methods": {
        "of": {
          "Javadoc": "* Creates a new runtime type adapter for {@code baseType} using {@code \"type\"} as\n     * the type field name."
        },
        "registerSubtype": {
          "Javadoc": "* Registers {@code type} identified by its {@link Class#getSimpleName simple\n     * name}. Labels are case sensitive.\n     *\n     * @throws IllegalArgumentException if either {@code type} or its simple name\n     *     have already been registered on this type adapter."
        }
      }
    },
    "com.google.gson.functional.SecurityTest": {
      "Javadoc": "\n * Tests for security-related aspects of Gson\n * \n * @author Inderjeet Singh\n ",
      "methods": {
        "testJsonWithNonExectuableTokenWithRegularGsonDeserialization": {
          "Javadoc": "*  Gson should be able to deserialize a stream with non-exectuable token even if it is created\n   *  without {@link GsonBuilder#generateNonExecutableJson()}."
        },
        "testJsonWithNonExectuableTokenWithConfiguredGsonDeserialization": {
          "Javadoc": "*  Gson should be able to deserialize a stream with non-exectuable token if it is created\n   *  with {@link GsonBuilder#generateNonExecutableJson()}."
        }
      }
    },
    "com.google.gson.functional.SerializedNameTest": {
      "Javadoc": ""
    },
    "com.google.gson.functional.MyClass": {
      "Javadoc": ""
    },
    "com.google.gson.functional.StreamingTypeAdaptersTest": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Truck": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Person": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Node": {
      "Javadoc": ""
    },
    "com.google.gson.functional.StringTest": {
      "Javadoc": "\n * Functional tests for Json serialization and deserialization of strings.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "testAssignmentCharSerialization": {
          "Javadoc": "* Created in response to http://groups.google.com/group/google-gson/browse_thread/thread/2431d4a3d0d6cb23"
        },
        "testAssignmentCharDeserialization": {
          "Javadoc": "* Created in response to http://groups.google.com/group/google-gson/browse_thread/thread/2431d4a3d0d6cb23"
        }
      }
    },
    "com.google.gson.functional.ToNumberPolicyFunctionalTest": {
      "Javadoc": ""
    },
    "com.google.gson.functional.TreeTypeAdaptersTest": {
      "Javadoc": "\n * Collection of functional tests for DOM tree based type adapters.\n "
    },
    "com.google.gson.functional.Id": {
      "Javadoc": ""
    },
    "com.google.gson.functional.IdTreeTypeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Student": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Course": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Assignment": {
      "Javadoc": ""
    },
    "com.google.gson.functional.HistoryCourse": {
      "Javadoc": ""
    },
    "com.google.gson.functional.TypeAdapterPrecedenceTest": {
      "Javadoc": ""
    },
    "com.google.gson.functional.TypeAdapterRuntimeTypeWrapperTest": {
      "Javadoc": "",
      "methods": {
        "testJsonSerializer": {
          "Javadoc": "* When custom {@link JsonSerializer} is registered for Base should\n   * prefer that over reflective adapter for Subclass for serialization."
        },
        "testJsonDeserializer_ReflectiveSerializerDelegate": {
          "Javadoc": "* When only {@link JsonDeserializer} is registered for Base, then on\n   * serialization should prefer reflective adapter for Subclass since\n   * Base would use reflective adapter as delegate."
        },
        "testJsonDeserializer_CustomSerializerDelegate": {
          "Javadoc": "* When {@link JsonDeserializer} with custom adapter as delegate is\n   * registered for Base, then on serialization should prefer custom adapter\n   * delegate for Base over reflective adapter for Subclass."
        },
        "testJsonDeserializer_ReflectiveTreeSerializerDelegate": {
          "Javadoc": "* When two (or more) {@link JsonDeserializer}s are registered for Base\n   * which eventually fall back to reflective adapter as delegate, then on\n   * serialization should prefer reflective adapter for Subclass."
        },
        "testJsonDeserializer_JsonSerializerDelegate": {
          "Javadoc": "* When {@link JsonDeserializer} with {@link JsonSerializer} as delegate\n   * is registered for Base, then on serialization should prefer\n   * {@code JsonSerializer} over reflective adapter for Subclass."
        },
        "testJsonDeserializer_SubclassBackwardCompatibility": {
          "Javadoc": "* When a {@link JsonDeserializer} is registered for Subclass, and a custom\n   * {@link JsonSerializer} is registered for Base, then Gson should prefer\n   * the reflective adapter for Subclass for backward compatibility (see\n   * https://github.com/google/gson/pull/1787#issuecomment-1222175189) even\n   * though normally TypeAdapterRuntimeTypeWrapper should prefer the custom\n   * serializer for Base."
        },
        "testGsonFutureAdapter": {
          "Javadoc": "* Tests behavior when the type of a field refers to a type whose adapter is\n   * currently in the process of being created. For these cases {@link Gson}\n   * uses a future adapter for the type. That adapter later uses the actual\n   * adapter as delegate."
        }
      }
    },
    "com.google.gson.functional.Deserializer": {
      "Javadoc": ""
    },
    "com.google.gson.functional.CyclicBase": {
      "Javadoc": ""
    },
    "com.google.gson.functional.CyclicSub": {
      "Javadoc": ""
    },
    "com.google.gson.functional.TypeHierarchyAdapterTest": {
      "Javadoc": "\n * Test that the hierarchy adapter works when subtypes are used.\n ",
      "methods": {
        "testRegisterSubTypeFirstAllowed": {
          "Javadoc": "This behaviour changed in Gson 2.1; it used to throw."
        }
      }
    },
    "com.google.gson.functional.ManagerAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.EmployeeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Employee": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Manager": {
      "Javadoc": ""
    },
    "com.google.gson.functional.CEO": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Company": {
      "Javadoc": ""
    },
    "com.google.gson.functional.TypeVariableTest": {
      "Javadoc": "\n * Functional test for Gson serialization and deserialization of\n * classes with type variables.\n *\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.Blue": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Red": {
      "Javadoc": ""
    },
    "com.google.gson.functional.UncategorizedTest": {
      "Javadoc": "\n * Functional tests that do not fall neatly into any of the existing classification.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "testReturningDerivedClassesDuringDeserialization": {
          "Javadoc": "* This test ensures that a custom deserializer is able to return a derived class instance for a\n   * base class object. For a motivation for this test, see Issue 37 and\n   * http://groups.google.com/group/google-gson/browse_thread/thread/677d56e9976d7761"
        },
        "testTrailingWhitespace": {
          "Javadoc": "* Test that trailing whitespace is ignored.\n   * http://code.google.com/p/google-gson/issues/detail?id=302"
        }
      }
    },
    "com.google.gson.functional.Derived1": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Derived2": {
      "Javadoc": ""
    },
    "com.google.gson.functional.BaseTypeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.functional.VersioningTest": {
      "Javadoc": "\n * Functional tests for versioning support in Gson.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.functional.Version1": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Version1_1": {
      "Javadoc": ""
    },
    "com.google.gson.functional.Version1_2": {
      "Javadoc": ""
    },
    "com.google.gson.functional.SinceUntilMixing": {
      "Javadoc": ""
    },
    "com.google.gson.GenericArrayTypeTest": {
      "Javadoc": "\n * Unit tests for the {@code GenericArrayType}s created by the {@link $Gson$Types} class.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.GsonBuilderTest": {
      "Javadoc": "\r\n * Unit tests for {@link GsonBuilder}.\r\n *\r\n * @author Inderjeet Singh\r\n ",
      "methods": {
        "testModificationAfterCreate": {
          "Javadoc": "* Gson instances should not be affected by subsequent modification of GsonBuilder\r\n   * which created them."
        }
      }
    },
    "com.google.gson.CustomClass1": {
      "Javadoc": ""
    },
    "com.google.gson.CustomClass2": {
      "Javadoc": ""
    },
    "com.google.gson.CustomClass3": {
      "Javadoc": ""
    },
    "com.google.gson.HasModifiers": {
      "Javadoc": ""
    },
    "com.google.gson.HasTransients": {
      "Javadoc": ""
    },
    "com.google.gson.ClassWithoutNoArgsConstructor": {
      "Javadoc": ""
    },
    "com.google.gson.GsonTest": {
      "Javadoc": "\n * Unit tests for {@link Gson}.\n *\n * @author Ryan Harter\n ",
      "methods": {
        "testGetAdapter_FutureAdapterConcurrency": {
          "Javadoc": "* Verifies that two threads calling {@link Gson#getAdapter(TypeToken)} do not see the\n   * same unresolved {@link FutureTypeAdapter} instance, since that would not be thread-safe.\n   *\n   * This test constructs the cyclic dependency {@literal CustomClass1 -> CustomClass2 -> CustomClass1}\n   * and lets one thread wait after the adapter for CustomClass2 has been obtained (which still\n   * refers to the nested unresolved FutureTypeAdapter for CustomClass1)."
        },
        "testDefaultGsonNewBuilderModification": {
          "Javadoc": "* Modifying a GsonBuilder obtained from {@link Gson#newBuilder()} of a\n   * {@code new Gson()} should not affect the Gson instance it came from."
        },
        "testNewBuilderModification": {
          "Javadoc": "* Modifying a GsonBuilder obtained from {@link Gson#newBuilder()} of a custom\n   * Gson instance (created using a GsonBuilder) should not affect the Gson instance\n   * it came from."
        }
      }
    },
    "com.google.gson.TestTypeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.DummyAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.WrappingAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.GsonTypeAdapterTest": {
      "Javadoc": "\n * Contains numerous tests involving registered type converters with a Gson instance.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.ExceptionTypeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.AtomicIntegerTypeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.Abstract": {
      "Javadoc": ""
    },
    "com.google.gson.Concrete": {
      "Javadoc": ""
    },
    "com.google.gson.InnerClassExclusionStrategyTest": {
      "Javadoc": "\n * Unit test for GsonBuilder.EXCLUDE_INNER_CLASSES.\n *\n * @author Joel Leitch\n "
    },
    "com.google.gson.InnerClass": {
      "Javadoc": ""
    },
    "com.google.gson.StaticNestedClass": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.DefaultDateTypeAdapterTest": {
      "Javadoc": "\n * A simple unit test for the {@link DefaultDateTypeAdapter} class.\n *\n * @author Joel Leitch\n "
    },
    "com.google.gson.internal.bind.Java17ReflectiveTypeAdapterFactoryTest": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.DummyClass": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.PrincipalTypeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.JsonElementReaderTest": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.JsonTreeReaderTest": {
      "Javadoc": "",
      "methods": {
        "testOverrides": {
          "Javadoc": "* {@link JsonTreeReader} effectively replaces the complete reading logic of {@link JsonReader} to\n   * read from a {@link JsonElement} instead of a {@link Reader}. Therefore all relevant methods of\n   * {@code JsonReader} must be overridden."
        }
      }
    },
    "com.google.gson.internal.bind.CustomSubclass": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.JsonTreeWriterTest": {
      "Javadoc": "",
      "methods": {
        "testOverrides": {
          "Javadoc": "* {@link JsonTreeWriter} effectively replaces the complete writing logic of {@link JsonWriter} to\n   * create a {@link JsonElement} tree instead of writing to a {@link Writer}. Therefore all relevant\n   * methods of {@code JsonWriter} must be overridden."
        }
      }
    },
    "com.google.gson.internal.bind.RecursiveTypesResolveTest": {
      "Javadoc": "\n * Test fixes for infinite recursion on {@link $Gson$Types#resolve(java.lang.reflect.Type, Class,\n * java.lang.reflect.Type)}, described at <a href=\"https://github.com/google/gson/issues/440\">Issue #440</a>\n * and similar issues.\n * <p>\n * These tests originally caused {@link StackOverflowError} because of infinite recursion on attempts to\n * resolve generics on types, with an intermediate types like 'Foo2&lt;? extends ? super ? extends ... ? extends A&gt;'\n "
    },
    "com.google.gson.internal.bind.Foo1": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.Foo2": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.TestType": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.TestType2": {
      "Javadoc": ""
    },
    "com.google.gson.internal.bind.util.ISO8601UtilsTest": {
      "Javadoc": ""
    },
    "com.google.gson.internal.ConstructorConstructorTest": {
      "Javadoc": "",
      "methods": {
        "testGet_AbstractClassNoArgConstructor": {
          "Javadoc": "* Verify that ConstructorConstructor does not try to invoke no-arg constructor\n   * of abstract class."
        }
      }
    },
    "com.google.gson.internal.AbstractClass": {
      "Javadoc": ""
    },
    "com.google.gson.internal.Interface": {
      "Javadoc": ""
    },
    "com.google.gson.internal.GsonBuildConfigTest": {
      "Javadoc": "\n * Unit tests for {@code GsonBuildConfig}\n *\n * @author Inderjeet Singh\n "
    },
    "com.google.gson.internal.GsonTypesTest": {
      "Javadoc": "",
      "methods": {
        "getFirstTypeArgument": {
          "Javadoc": "* Given a parameterized type A&lt;B,C&gt;, returns B. If the specified type is not\n   * a generic type, returns null."
        }
      }
    },
    "com.google.gson.internal.D": {
      "Javadoc": ""
    },
    "com.google.gson.internal.A": {
      "Javadoc": ""
    },
    "com.google.gson.internal.B": {
      "Javadoc": ""
    },
    "com.google.gson.internal.C": {
      "Javadoc": ""
    },
    "com.google.gson.internal.JavaVersionTest": {
      "Javadoc": "\n * Unit and functional tests for {@link JavaVersion}\n *\n * @author Inderjeet Singh\n "
    },
    "com.google.gson.internal.LazilyParsedNumberTest": {
      "Javadoc": ""
    },
    "com.google.gson.internal.LinkedTreeMapTest": {
      "Javadoc": ""
    },
    "com.google.gson.internal.reflect.Java17ReflectionHelperTest": {
      "Javadoc": ""
    },
    "com.google.gson.internal.reflect.PrincipalImpl": {
      "Javadoc": " Implementation of {@link UserPrincipal} and {@link GroupPrincipal} just for record tests. "
    },
    "com.google.gson.internal.sql.SqlTypesGsonTest": {
      "Javadoc": ""
    },
    "com.google.gson.internal.sql.SqlTypesSupportTest": {
      "Javadoc": ""
    },
    "com.google.gson.internal.StreamsTest": {
      "Javadoc": ""
    },
    "com.google.gson.internal.UnsafeAllocatorInstantiationTest": {
      "Javadoc": "\n * Test unsafe allocator instantiation\n * @author Ugljesa Jovanovic\n ",
      "methods": {
        "testInterfaceInstantiation": {
          "Javadoc": "* Ensure that an {@link AssertionError} is thrown when trying\n   * to instantiate an interface"
        },
        "testAbstractClassInstantiation": {
          "Javadoc": "* Ensure that an {@link AssertionError} is thrown when trying\n   * to instantiate an abstract class"
        },
        "testConcreteClassInstantiation": {
          "Javadoc": "* Ensure that no exception is thrown when trying to instantiate a concrete class"
        }
      }
    },
    "com.google.gson.internal.ConcreteClass": {
      "Javadoc": ""
    },
    "com.google.gson.JavaSerializationTest": {
      "Javadoc": "\n * Check that Gson doesn't return non-serializable data types.\n *\n * @author Jesse Wilson\n "
    },
    "com.google.gson.JsonArrayAsListTest": {
      "Javadoc": "\n * Tests for {@link JsonArray#asList()}.\n ",
      "methods": {
        "testViewUpdates": {
          "Javadoc": "Verify that {@code JsonArray} updates are visible to view and vice versa"
        }
      }
    },
    "com.google.gson.JsonArrayTest": {
      "Javadoc": "\n * @author Jesse Wilson\n "
    },
    "com.google.gson.JsonNullTest": {
      "Javadoc": "\n * @author Jesse Wilson\n "
    },
    "com.google.gson.JsonObjectAsMapTest": {
      "Javadoc": "\n * Tests for {@link JsonObject#asMap()}.\n ",
      "methods": {
        "testViewUpdates": {
          "Javadoc": "Verify that {@code JsonObject} updates are visible to view and vice versa"
        }
      }
    },
    "com.google.gson.JsonObjectTest": {
      "Javadoc": "\n * Unit test for the {@link JsonObject} class.\n *\n * @author Joel Leitch\n ",
      "methods": {
        "testPropertyWithQuotes": {
          "Javadoc": "* From bug report http://code.google.com/p/google-gson/issues/detail?id=182"
        },
        "testWritePropertyWithEmptyStringName": {
          "Javadoc": "* From issue 227."
        },
        "testKeySet": {
          "Javadoc": "* From issue 941"
        }
      }
    },
    "com.google.gson.JsonParserParameterizedTest": {
      "Javadoc": ""
    },
    "com.google.gson.JsonParserTest": {
      "Javadoc": "\n * Unit test for {@link JsonParser}\n *\n * @author Inderjeet Singh\n ",
      "methods": {
        "testParseDeeplyNestedArrays": {
          "Javadoc": "Deeply nested JSON arrays should not cause {@link StackOverflowError}"
        },
        "testParseDeeplyNestedObjects": {
          "Javadoc": "Deeply nested JSON objects should not cause {@link StackOverflowError}"
        }
      }
    },
    "com.google.gson.JsonPrimitiveTest": {
      "Javadoc": "\n * Unit test for the {@link JsonPrimitive} class.\n *\n * @author Joel Leitch\n "
    },
    "com.google.gson.JsonStreamParserTest": {
      "Javadoc": "\n * Unit tests for {@link JsonStreamParser}\n *\n * @author Inderjeet Singh\n "
    },
    "com.google.gson.LongSerializationPolicyTest": {
      "Javadoc": "\n * Unit test for the {@link LongSerializationPolicy} class.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.metrics.PerformanceTest": {
      "Javadoc": "\n * Tests to measure performance for Gson. All tests in this file will be disabled in code. To run\n * them remove disabled_ prefix from the tests and run them.\n * \n * @author Inderjeet Singh\n * @author Joel Leitch\n ",
      "methods": {
        "disabled_testLargeCollectionSerialization": {
          "Javadoc": "* Created in response to http://code.google.com/p/google-gson/issues/detail?id=96"
        },
        "disabled_testLargeCollectionDeserialization": {
          "Javadoc": "* Created in response to http://code.google.com/p/google-gson/issues/detail?id=96"
        }
      }
    },
    "com.google.gson.metrics.ExceptionHolder": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.CollectionEntry": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.ClassWithList": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.ClassWithField": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.ClassWithListOfObjects": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.ClassWithExposedField": {
      "Javadoc": ""
    },
    "com.google.gson.MixedStreamTest": {
      "Javadoc": ""
    },
    "com.google.gson.Car": {
      "Javadoc": ""
    },
    "com.google.gson.MockExclusionStrategy": {
      "Javadoc": "\n * This is a configurable {@link ExclusionStrategy} that can be used for\n * unit testing.\n *\n * @author Joel Leitch\n "
    },
    "com.google.gson.ObjectTypeAdapterParameterizedTest": {
      "Javadoc": ""
    },
    "com.google.gson.ObjectTypeAdapterTest": {
      "Javadoc": "",
      "methods": {
        "testDeserializeDeeplyNestedArrays": {
          "Javadoc": "Deeply nested JSON arrays should not cause {@link StackOverflowError}"
        },
        "testDeserializeDeeplyNestedObjects": {
          "Javadoc": "Deeply nested JSON objects should not cause {@link StackOverflowError}"
        }
      }
    },
    "com.google.gson.RuntimeType": {
      "Javadoc": ""
    },
    "com.google.gson.OverrideCoreTypeAdaptersTest": {
      "Javadoc": "\n * @author Jesse Wilson\n "
    },
    "com.google.gson.ParameterizedTypeFixtures": {
      "Javadoc": "\n * This class contains some test fixtures for Parameterized types. These classes should ideally\n * belong either in the common or functional package, but they are placed here because they need\n * access to package protected elements of com.google.gson.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.MyParameterizedType": {
      "Javadoc": ""
    },
    "com.google.gson.MyParameterizedTypeInstanceCreator": {
      "Javadoc": ""
    },
    "com.google.gson.MyParameterizedTypeAdapter": {
      "Javadoc": ""
    },
    "com.google.gson.ParameterizedTypeTest": {
      "Javadoc": "\n * Unit tests for {@code ParameterizedType}s created by the {@link $Gson$Types} class.\n *\n * @author Inderjeet Singh\n * @author Joel Leitch\n "
    },
    "com.google.gson.PrimitiveTypeAdapter": {
      "Javadoc": "\n * Handles type conversion from some object to some primitive (or primitive\n * wrapper instance).\n *\n * @author Joel Leitch\n "
    },
    "com.google.gson.reflect.TypeTokenTest": {
      "Javadoc": "\n * @author Jesse Wilson\n ",
      "methods": {
        "testTypeTokenSubSubClass": {
          "Javadoc": "* User must only create direct subclasses of TypeToken, but not subclasses\n   * of subclasses (...) of TypeToken."
        }
      }
    },
    "com.google.gson.reflect.CustomTypeToken": {
      "Javadoc": ""
    },
    "com.google.gson.reflect.SubTypeToken": {
      "Javadoc": ""
    },
    "com.google.gson.reflect.SubSubTypeToken1": {
      "Javadoc": ""
    },
    "com.google.gson.reflect.SubSubTypeToken2": {
      "Javadoc": ""
    },
    "com.google.gson.reflect.GenericWithBound": {
      "Javadoc": ""
    },
    "com.google.gson.reflect.GenericWithMultiBound": {
      "Javadoc": ""
    },
    "com.google.gson.reflect.ClassSatisfyingBounds": {
      "Javadoc": ""
    },
    "com.google.gson.regression.JsonAdapterNullSafeTest": {
      "Javadoc": ""
    },
    "com.google.gson.regression.Device": {
      "Javadoc": ""
    },
    "com.google.gson.regression.JsonAdapterFactory": {
      "Javadoc": ""
    },
    "com.google.gson.regression.OSGiTest": {
      "Javadoc": ""
    },
    "com.google.gson.stream.JsonReaderPathTest": {
      "Javadoc": ""
    },
    "com.google.gson.stream.JsonReaderTest": {
      "Javadoc": "",
      "methods": {
        "testNegativeZero": {
          "Javadoc": "* Issue 1053, negative zero.\n   * @throws Exception"
        },
        "disabled_testPeekLargerThanLongMaxValue": {
          "Javadoc": "* This test fails because there's no double for 9223372036854775808, and our\n   * long parsing uses Double.parseDouble() for fractional values."
        },
        "disabled_testPeekLargerThanLongMinValue": {
          "Javadoc": "* This test fails because there's no double for -9223372036854775809, and our\n   * long parsing uses Double.parseDouble() for fractional values."
        },
        "disabled_testHighPrecisionLong": {
          "Javadoc": "* This test fails because there's no double for 9223372036854775806, and\n   * our long parsing uses Double.parseDouble() for fractional values."
        },
        "testUnterminatedStringFailure": {
          "Javadoc": "* This test behave slightly differently in Gson 2.2 and earlier. It fails\n   * during peek rather than during nextString()."
        },
        "testReadAcrossBuffers": {
          "Javadoc": "* Regression test for an issue with buffer filling and consumeNonExecutePrefix."
        },
        "reader": {
          "Javadoc": "* Returns a reader that returns one character at a time."
        }
      }
    },
    "com.google.gson.stream.JsonWriterTest": {
      "Javadoc": "",
      "methods": {
        "testNumbersCustomClass": {
          "Javadoc": "* Tests writing {@code Number} instances which are not one of the standard JDK ones."
        }
      }
    },
    "com.google.gson.ToNumberPolicyTest": {
      "Javadoc": ""
    },
    "com.google.gson.TypeAdapterTest": {
      "Javadoc": "",
      "methods": {
        "testToJson_ThrowingIOException": {
          "Javadoc": "* Tests behavior when {@link TypeAdapter#write(JsonWriter, Object)} manually throws\n   * {@link IOException} which is not caused by writer usage."
        }
      }
    },
    "com.google.gson.VersionExclusionStrategyTest": {
      "Javadoc": "\n * Unit tests for the {@link Excluder} class.\n *\n * @author Joel Leitch\n "
    },
    "com.google.gson.MockClassSince": {
      "Javadoc": ""
    },
    "com.google.gson.MockClassUntil": {
      "Javadoc": ""
    },
    "com.google.gson.MockClassBoth": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.BagOfPrimitives": {
      "Javadoc": "\n * Class with a bunch of primitive fields\n *\n * @author Inderjeet Singh\n "
    },
    "com.google.gson.metrics.BagOfPrimitivesDeserializationBenchmark": {
      "Javadoc": "\n * Caliper based micro benchmarks for Gson\n *\n * @author Inderjeet Singh\n * @author Jesse Wilson\n * @author Joel Leitch\n ",
      "methods": {
        "timeBagOfPrimitivesDefault": {
          "Javadoc": "* Benchmark to measure Gson performance for deserializing an object"
        },
        "timeBagOfPrimitivesStreaming": {
          "Javadoc": "* Benchmark to measure deserializing objects by hand"
        },
        "timeBagOfPrimitivesReflectionStreaming": {
          "Javadoc": "* This benchmark measures the ideal Gson performance: the cost of parsing a JSON stream and\n   * setting object values by reflection. We should strive to reduce the discrepancy between this\n   * and {@link #timeBagOfPrimitivesDefault(int)} ."
        }
      }
    },
    "com.google.gson.metrics.CollectionsDeserializationBenchmark": {
      "Javadoc": "\n * Caliper based micro benchmarks for Gson\n *\n * @author Inderjeet Singh\n ",
      "methods": {
        "timeCollectionsDefault": {
          "Javadoc": "* Benchmark to measure Gson performance for deserializing an object"
        },
        "timeCollectionsStreaming": {
          "Javadoc": "* Benchmark to measure deserializing objects by hand"
        },
        "timeCollectionsReflectionStreaming": {
          "Javadoc": "* This benchmark measures the ideal Gson performance: the cost of parsing a JSON stream and\n   * setting object values by reflection. We should strive to reduce the discrepancy between this\n   * and {@link #timeCollectionsDefault(int)} ."
        }
      }
    },
    "com.google.gson.metrics.NonUploadingCaliperRunner": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.ParseBenchmark": {
      "Javadoc": "\n * Measure Gson and Jackson parsing and binding performance.\n *\n * <p>This benchmark requires that ParseBenchmarkData.zip is on the classpath.\n * That file contains Twitter feed data, which is representative of what\n * applications will be parsing.\n "
    },
    "com.google.gson.metrics.Parser": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.GsonStreamParser": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.GsonSkipParser": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.JacksonStreamParser": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.GsonDomParser": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.GsonBindParser": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.JacksonBindParser": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.Tweet": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.User": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.Feed": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.Link": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.Item": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.Content": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.ReaderUser": {
      "Javadoc": ""
    },
    "com.google.gson.metrics.SerializationBenchmark": {
      "Javadoc": "\n * Caliper based micro benchmarks for Gson serialization\n *\n * @author Inderjeet Singh\n * @author Jesse Wilson\n * @author Joel Leitch\n "
    },
    "com.google.gson.protobuf.ProtoTypeAdapter": {
      "Javadoc": "\n * GSON type adapter for protocol buffers that knows how to serialize enums either by using their\n * values or their names, and also supports custom proto field names.\n * <p>\n * You can specify which case representation is used for the proto fields when writing/reading the\n * JSON payload by calling {@link Builder#setFieldNameSerializationFormat(CaseFormat, CaseFormat)}.\n * <p>\n * An example of default serialization/deserialization using custom proto field names is shown\n * below:\n *\n * <pre>\n * message MyMessage {\n *   // Will be serialized as 'osBuildID' instead of the default 'osBuildId'.\n *   string os_build_id = 1 [(serialized_name) = \"osBuildID\"];\n * }\n * </pre>\n *\n * @author Inderjeet Singh\n * @author Emmanuel Cron\n * @author Stanley Wang\n ",
      "methods": {
        "newBuilder": {
          "Javadoc": "* Creates a new {@link ProtoTypeAdapter} builder, defaulting enum serialization to\n   * {@link EnumSerialization#NAME} and converting field serialization from\n   * {@link CaseFormat#LOWER_UNDERSCORE} to {@link CaseFormat#LOWER_CAMEL}."
        },
        "getCustSerializedName": {
          "Javadoc": "* Retrieves the custom field name from the given options, and if not found, returns the specified\n   * default name."
        },
        "getCustSerializedEnumValue": {
          "Javadoc": "* Retrieves the custom enum value name from the given options, and if not found, returns the\n   * specified default value."
        },
        "getEnumValue": {
          "Javadoc": "* Returns the enum value to use for serialization, depending on the value of\n   * {@link EnumSerialization} that was given to this adapter."
        },
        "findValueByNameAndExtension": {
          "Javadoc": "* Finds an enum value in the given {@link EnumDescriptor} that matches the given JSON element,\n   * either by name if the current adapter is using {@link EnumSerialization#NAME}, otherwise by\n   * number. If matching by name, it uses the extension value if it is defined, otherwise it uses\n   * its default value.\n   *\n   * @throws IllegalArgumentException if a matching name/number was not found"
        }
      }
    },
    "com.google.gson.protobuf.Builder": {
      "Javadoc": "\n   * Builder for {@link ProtoTypeAdapter}s.\n   ",
      "methods": {
        "setFieldNameSerializationFormat": {
          "Javadoc": "* Sets the field names serialization format. The first parameter defines how to read the format\n     * of the proto field names you are converting to JSON. The second parameter defines which\n     * format to use when serializing them.\n     * <p>\n     * For example, if you use the following parameters: {@link CaseFormat#LOWER_UNDERSCORE},\n     * {@link CaseFormat#LOWER_CAMEL}, the following conversion will occur:\n     *\n     * <pre>{@code\n     * PROTO     <->  JSON\n     * my_field       myField\n     * foo            foo\n     * n__id_ct       nIdCt\n     * }</pre>"
        },
        "addSerializedNameExtension": {
          "Javadoc": "* Adds a field proto annotation that, when set, overrides the default field name\n     * serialization/deserialization. For example, if you add the '{@code serialized_name}'\n     * annotation and you define a field in your proto like the one below:\n     *\n     * <pre>\n     * string client_app_id = 1 [(serialized_name) = \"appId\"];\n     * </pre>\n     *\n     * ...the adapter will serialize the field using '{@code appId}' instead of the default '\n     * {@code clientAppId}'. This lets you customize the name serialization of any proto field."
        },
        "addSerializedEnumValueExtension": {
          "Javadoc": "* Adds an enum value proto annotation that, when set, overrides the default <b>enum</b> value\n     * serialization/deserialization of this adapter. For example, if you add the '\n     * {@code serialized_value}' annotation and you define an enum in your proto like the one below:\n     *\n     * <pre>\n     * enum MyEnum {\n     *   UNKNOWN = 0;\n     *   CLIENT_APP_ID = 1 [(serialized_value) = \"APP_ID\"];\n     *   TWO = 2 [(serialized_value) = \"2\"];\n     * }\n     * </pre>\n     *\n     * ...the adapter will serialize the value {@code CLIENT_APP_ID} as \"{@code APP_ID}\" and the\n     * value {@code TWO} as \"{@code 2}\". This works for both serialization and deserialization.\n     * <p>\n     * Note that you need to set the enum serialization of this adapter to\n     * {@link EnumSerialization#NAME}, otherwise these annotations will be ignored."
        }
      }
    },
    "com.google.gson.protobuf.functional.ProtosWithAnnotationsTest": {
      "Javadoc": "\n * Functional tests for protocol buffers using annotations for field names and enum values.\n *\n * @author Emmanuel Cron\n "
    },
    "com.google.gson.protobuf.functional.ProtosWithComplexAndRepeatedFieldsTest": {
      "Javadoc": "\n * Functional tests for protocol buffers using complex and repeated fields\n *\n * @author Inderjeet Singh\n "
    },
    "com.google.gson.protobuf.functional.ProtosWithPrimitiveTypesTest": {
      "Javadoc": ""
    },
    "com.google.gson.protobuf.generated.Annotations": {
      "Javadoc": ""
    },
    "com.google.gson.protobuf.generated.Bag": {
      "Javadoc": ""
    },
    "com.google.gson.protobuf.generated.SimpleProtoOrBuilder": {
      "Javadoc": "",
      "methods": {
        "hasMsg": {
          "Javadoc": "* <code>optional string msg = 1;</code>\n     * @return Whether the msg field is set."
        },
        "getMsg": {
          "Javadoc": "* <code>optional string msg = 1;</code>\n     * @return The msg."
        },
        "getMsgBytes": {
          "Javadoc": "* <code>optional string msg = 1;</code>\n     * @return The bytes for msg."
        },
        "hasCount": {
          "Javadoc": "* <code>optional int32 count = 2;</code>\n     * @return Whether the count field is set."
        },
        "getCount": {
          "Javadoc": "* <code>optional int32 count = 2;</code>\n     * @return The count."
        }
      }
    },
    "com.google.gson.protobuf.generated.SimpleProto": {
      "Javadoc": "\n   * Protobuf type {@code google.gson.protobuf.generated.SimpleProto}\n   ",
      "methods": {
        "hasMsg": {
          "Javadoc": "* <code>optional string msg = 1;</code>\n     * @return Whether the msg field is set."
        },
        "getMsg": {
          "Javadoc": "* <code>optional string msg = 1;</code>\n     * @return The msg."
        },
        "getMsgBytes": {
          "Javadoc": "* <code>optional string msg = 1;</code>\n     * @return The bytes for msg."
        },
        "hasCount": {
          "Javadoc": "* <code>optional int32 count = 2;</code>\n     * @return Whether the count field is set."
        },
        "getCount": {
          "Javadoc": "* <code>optional int32 count = 2;</code>\n     * @return The count."
        }
      }
    },
    "com.google.gson.protobuf.generated.Builder": {
      "Javadoc": "\n     * Protobuf type {@code google.gson.protobuf.generated.ProtoWithAnnotations}\n     ",
      "methods": {
        "hasId": {
          "Javadoc": "* <code>optional string id = 1;</code>\n       * @return Whether the id field is set."
        },
        "getId": {
          "Javadoc": "* <code>optional string id = 1;</code>\n       * @return The id."
        },
        "getIdBytes": {
          "Javadoc": "* <code>optional string id = 1;</code>\n       * @return The bytes for id."
        },
        "setId": {
          "Javadoc": "* <code>optional string id = 1;</code>\n       * @param value The id to set.\n       * @return This builder for chaining."
        },
        "clearId": {
          "Javadoc": "* <code>optional string id = 1;</code>\n       * @return This builder for chaining."
        },
        "setIdBytes": {
          "Javadoc": "* <code>optional string id = 1;</code>\n       * @param value The bytes for id to set.\n       * @return This builder for chaining."
        },
        "hasOuterMessage": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.OuterMessage outer_message = 2 [(.google.gson.protobuf.generated.serialized_name) = \"expiration_date\"];</code>\n       * @return Whether the outerMessage field is set."
        },
        "getOuterMessage": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.OuterMessage outer_message = 2 [(.google.gson.protobuf.generated.serialized_name) = \"expiration_date\"];</code>\n       * @return The outerMessage."
        },
        "setOuterMessage": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.OuterMessage outer_message = 2 [(.google.gson.protobuf.generated.serialized_name) = \"expiration_date\"];</code>"
        },
        "mergeOuterMessage": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.OuterMessage outer_message = 2 [(.google.gson.protobuf.generated.serialized_name) = \"expiration_date\"];</code>"
        },
        "clearOuterMessage": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.OuterMessage outer_message = 2 [(.google.gson.protobuf.generated.serialized_name) = \"expiration_date\"];</code>"
        },
        "getOuterMessageBuilder": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.OuterMessage outer_message = 2 [(.google.gson.protobuf.generated.serialized_name) = \"expiration_date\"];</code>"
        },
        "getOuterMessageOrBuilder": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.OuterMessage outer_message = 2 [(.google.gson.protobuf.generated.serialized_name) = \"expiration_date\"];</code>"
        },
        "getOuterMessageFieldBuilder": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.OuterMessage outer_message = 2 [(.google.gson.protobuf.generated.serialized_name) = \"expiration_date\"];</code>"
        },
        "hasInnerMessage1": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 = 3;</code>\n       * @return Whether the innerMessage1 field is set."
        },
        "getInnerMessage1": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 = 3;</code>\n       * @return The innerMessage1."
        },
        "setInnerMessage1": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 = 3;</code>"
        },
        "mergeInnerMessage1": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 = 3;</code>"
        },
        "clearInnerMessage1": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 = 3;</code>"
        },
        "getInnerMessage1Builder": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 = 3;</code>"
        },
        "getInnerMessage1OrBuilder": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 = 3;</code>"
        },
        "getInnerMessage1FieldBuilder": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 = 3;</code>"
        },
        "hasInnerMessage2": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 = 4;</code>\n       * @return Whether the innerMessage2 field is set."
        },
        "getInnerMessage2": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 = 4;</code>\n       * @return The innerMessage2."
        },
        "setInnerMessage2": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 = 4;</code>"
        },
        "mergeInnerMessage2": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 = 4;</code>"
        },
        "clearInnerMessage2": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 = 4;</code>"
        },
        "getInnerMessage2Builder": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 = 4;</code>"
        },
        "getInnerMessage2OrBuilder": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 = 4;</code>"
        },
        "getInnerMessage2FieldBuilder": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 = 4;</code>"
        }
      }
    },
    "com.google.gson.protobuf.generated.ProtoWithDifferentCaseFormatOrBuilder": {
      "Javadoc": "",
      "methods": {
        "getNameThatTestsCaseFormatList": {
          "Javadoc": "* <code>repeated string name_that_tests_case_format = 1;</code>\n     * @return A list containing the nameThatTestsCaseFormat."
        },
        "getNameThatTestsCaseFormatCount": {
          "Javadoc": "* <code>repeated string name_that_tests_case_format = 1;</code>\n     * @return The count of nameThatTestsCaseFormat."
        },
        "getNameThatTestsCaseFormat": {
          "Javadoc": "* <code>repeated string name_that_tests_case_format = 1;</code>\n     * @param index The index of the element to return.\n     * @return The nameThatTestsCaseFormat at the given index."
        },
        "getNameThatTestsCaseFormatBytes": {
          "Javadoc": "* <code>repeated string name_that_tests_case_format = 1;</code>\n     * @param index The index of the value to return.\n     * @return The bytes of the nameThatTestsCaseFormat at the given index."
        },
        "hasAnotherField": {
          "Javadoc": "* <code>optional string another_field = 2;</code>\n     * @return Whether the anotherField field is set."
        },
        "getAnotherField": {
          "Javadoc": "* <code>optional string another_field = 2;</code>\n     * @return The anotherField."
        },
        "getAnotherFieldBytes": {
          "Javadoc": "* <code>optional string another_field = 2;</code>\n     * @return The bytes for anotherField."
        }
      }
    },
    "com.google.gson.protobuf.generated.ProtoWithDifferentCaseFormat": {
      "Javadoc": "\n   * Protobuf type {@code google.gson.protobuf.generated.ProtoWithDifferentCaseFormat}\n   ",
      "methods": {
        "getNameThatTestsCaseFormatList": {
          "Javadoc": "* <code>repeated string name_that_tests_case_format = 1;</code>\n     * @return A list containing the nameThatTestsCaseFormat."
        },
        "getNameThatTestsCaseFormatCount": {
          "Javadoc": "* <code>repeated string name_that_tests_case_format = 1;</code>\n     * @return The count of nameThatTestsCaseFormat."
        },
        "getNameThatTestsCaseFormat": {
          "Javadoc": "* <code>repeated string name_that_tests_case_format = 1;</code>\n     * @param index The index of the element to return.\n     * @return The nameThatTestsCaseFormat at the given index."
        },
        "getNameThatTestsCaseFormatBytes": {
          "Javadoc": "* <code>repeated string name_that_tests_case_format = 1;</code>\n     * @param index The index of the value to return.\n     * @return The bytes of the nameThatTestsCaseFormat at the given index."
        },
        "hasAnotherField": {
          "Javadoc": "* <code>optional string another_field = 2;</code>\n     * @return Whether the anotherField field is set."
        },
        "getAnotherField": {
          "Javadoc": "* <code>optional string another_field = 2;</code>\n     * @return The anotherField."
        },
        "getAnotherFieldBytes": {
          "Javadoc": "* <code>optional string another_field = 2;</code>\n     * @return The bytes for anotherField."
        }
      }
    },
    "com.google.gson.protobuf.generated.ProtoWithRepeatedFieldsOrBuilder": {
      "Javadoc": "",
      "methods": {
        "getNumbersList": {
          "Javadoc": "* <code>repeated int64 numbers = 1;</code>\n     * @return A list containing the numbers."
        },
        "getNumbersCount": {
          "Javadoc": "* <code>repeated int64 numbers = 1;</code>\n     * @return The count of numbers."
        },
        "getNumbers": {
          "Javadoc": "* <code>repeated int64 numbers = 1;</code>\n     * @param index The index of the element to return.\n     * @return The numbers at the given index."
        },
        "getSimplesList": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.SimpleProto simples = 2;</code>"
        },
        "getSimples": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.SimpleProto simples = 2;</code>"
        },
        "getSimplesCount": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.SimpleProto simples = 2;</code>"
        },
        "getSimplesOrBuilderList": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.SimpleProto simples = 2;</code>"
        },
        "getSimplesOrBuilder": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.SimpleProto simples = 2;</code>"
        },
        "hasName": {
          "Javadoc": "* <code>optional string name = 3;</code>\n     * @return Whether the name field is set."
        },
        "getName": {
          "Javadoc": "* <code>optional string name = 3;</code>\n     * @return The name."
        },
        "getNameBytes": {
          "Javadoc": "* <code>optional string name = 3;</code>\n     * @return The bytes for name."
        }
      }
    },
    "com.google.gson.protobuf.generated.ProtoWithRepeatedFields": {
      "Javadoc": "\n   * Protobuf type {@code google.gson.protobuf.generated.ProtoWithRepeatedFields}\n   ",
      "methods": {
        "getNumbersList": {
          "Javadoc": "* <code>repeated int64 numbers = 1;</code>\n     * @return A list containing the numbers."
        },
        "getNumbersCount": {
          "Javadoc": "* <code>repeated int64 numbers = 1;</code>\n     * @return The count of numbers."
        },
        "getNumbers": {
          "Javadoc": "* <code>repeated int64 numbers = 1;</code>\n     * @param index The index of the element to return.\n     * @return The numbers at the given index."
        },
        "getSimplesList": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.SimpleProto simples = 2;</code>"
        },
        "getSimplesOrBuilderList": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.SimpleProto simples = 2;</code>"
        },
        "getSimplesCount": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.SimpleProto simples = 2;</code>"
        },
        "getSimples": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.SimpleProto simples = 2;</code>"
        },
        "getSimplesOrBuilder": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.SimpleProto simples = 2;</code>"
        },
        "hasName": {
          "Javadoc": "* <code>optional string name = 3;</code>\n     * @return Whether the name field is set."
        },
        "getName": {
          "Javadoc": "* <code>optional string name = 3;</code>\n     * @return The name."
        },
        "getNameBytes": {
          "Javadoc": "* <code>optional string name = 3;</code>\n     * @return The bytes for name."
        }
      }
    },
    "com.google.gson.protobuf.generated.OuterMessageOrBuilder": {
      "Javadoc": "",
      "methods": {
        "hasMonth": {
          "Javadoc": "* <code>optional int32 month = 1;</code>\n     * @return Whether the month field is set."
        },
        "getMonth": {
          "Javadoc": "* <code>optional int32 month = 1;</code>\n     * @return The month."
        },
        "hasYear": {
          "Javadoc": "* <code>optional int32 year = 2;</code>\n     * @return Whether the year field is set."
        },
        "getYear": {
          "Javadoc": "* <code>optional int32 year = 2;</code>\n     * @return The year."
        },
        "hasLongTimestamp": {
          "Javadoc": "* <code>optional int64 long_timestamp = 3 [(.google.gson.protobuf.generated.serialized_name) = \"timeStamp\"];</code>\n     * @return Whether the longTimestamp field is set."
        },
        "getLongTimestamp": {
          "Javadoc": "* <code>optional int64 long_timestamp = 3 [(.google.gson.protobuf.generated.serialized_name) = \"timeStamp\"];</code>\n     * @return The longTimestamp."
        },
        "hasCountryCode5F55": {
          "Javadoc": "* <code>optional string country_code_5f55 = 4;</code>\n     * @return Whether the countryCode5f55 field is set."
        },
        "getCountryCode5F55": {
          "Javadoc": "* <code>optional string country_code_5f55 = 4;</code>\n     * @return The countryCode5f55."
        },
        "getCountryCode5F55Bytes": {
          "Javadoc": "* <code>optional string country_code_5f55 = 4;</code>\n     * @return The bytes for countryCode5f55."
        }
      }
    },
    "com.google.gson.protobuf.generated.OuterMessage": {
      "Javadoc": "\n   * Protobuf type {@code google.gson.protobuf.generated.OuterMessage}\n   ",
      "methods": {
        "hasMonth": {
          "Javadoc": "* <code>optional int32 month = 1;</code>\n     * @return Whether the month field is set."
        },
        "getMonth": {
          "Javadoc": "* <code>optional int32 month = 1;</code>\n     * @return The month."
        },
        "hasYear": {
          "Javadoc": "* <code>optional int32 year = 2;</code>\n     * @return Whether the year field is set."
        },
        "getYear": {
          "Javadoc": "* <code>optional int32 year = 2;</code>\n     * @return The year."
        },
        "hasLongTimestamp": {
          "Javadoc": "* <code>optional int64 long_timestamp = 3 [(.google.gson.protobuf.generated.serialized_name) = \"timeStamp\"];</code>\n     * @return Whether the longTimestamp field is set."
        },
        "getLongTimestamp": {
          "Javadoc": "* <code>optional int64 long_timestamp = 3 [(.google.gson.protobuf.generated.serialized_name) = \"timeStamp\"];</code>\n     * @return The longTimestamp."
        },
        "hasCountryCode5F55": {
          "Javadoc": "* <code>optional string country_code_5f55 = 4;</code>\n     * @return Whether the countryCode5f55 field is set."
        },
        "getCountryCode5F55": {
          "Javadoc": "* <code>optional string country_code_5f55 = 4;</code>\n     * @return The countryCode5f55."
        },
        "getCountryCode5F55Bytes": {
          "Javadoc": "* <code>optional string country_code_5f55 = 4;</code>\n     * @return The bytes for countryCode5f55."
        }
      }
    },
    "com.google.gson.protobuf.generated.ProtoWithAnnotationsOrBuilder": {
      "Javadoc": "",
      "methods": {
        "hasId": {
          "Javadoc": "* <code>optional string id = 1;</code>\n     * @return Whether the id field is set."
        },
        "getId": {
          "Javadoc": "* <code>optional string id = 1;</code>\n     * @return The id."
        },
        "getIdBytes": {
          "Javadoc": "* <code>optional string id = 1;</code>\n     * @return The bytes for id."
        },
        "hasOuterMessage": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.OuterMessage outer_message = 2 [(.google.gson.protobuf.generated.serialized_name) = \"expiration_date\"];</code>\n     * @return Whether the outerMessage field is set."
        },
        "getOuterMessage": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.OuterMessage outer_message = 2 [(.google.gson.protobuf.generated.serialized_name) = \"expiration_date\"];</code>\n     * @return The outerMessage."
        },
        "getOuterMessageOrBuilder": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.OuterMessage outer_message = 2 [(.google.gson.protobuf.generated.serialized_name) = \"expiration_date\"];</code>"
        },
        "hasInnerMessage1": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 = 3;</code>\n     * @return Whether the innerMessage1 field is set."
        },
        "getInnerMessage1": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 = 3;</code>\n     * @return The innerMessage1."
        },
        "getInnerMessage1OrBuilder": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 = 3;</code>"
        },
        "hasInnerMessage2": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 = 4;</code>\n     * @return Whether the innerMessage2 field is set."
        },
        "getInnerMessage2": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 = 4;</code>\n     * @return The innerMessage2."
        },
        "getInnerMessage2OrBuilder": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 = 4;</code>"
        }
      }
    },
    "com.google.gson.protobuf.generated.ProtoWithAnnotations": {
      "Javadoc": "\n   * Protobuf type {@code google.gson.protobuf.generated.ProtoWithAnnotations}\n   ",
      "methods": {
        "hasId": {
          "Javadoc": "* <code>optional string id = 1;</code>\n     * @return Whether the id field is set."
        },
        "getId": {
          "Javadoc": "* <code>optional string id = 1;</code>\n     * @return The id."
        },
        "getIdBytes": {
          "Javadoc": "* <code>optional string id = 1;</code>\n     * @return The bytes for id."
        },
        "hasOuterMessage": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.OuterMessage outer_message = 2 [(.google.gson.protobuf.generated.serialized_name) = \"expiration_date\"];</code>\n     * @return Whether the outerMessage field is set."
        },
        "getOuterMessage": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.OuterMessage outer_message = 2 [(.google.gson.protobuf.generated.serialized_name) = \"expiration_date\"];</code>\n     * @return The outerMessage."
        },
        "getOuterMessageOrBuilder": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.OuterMessage outer_message = 2 [(.google.gson.protobuf.generated.serialized_name) = \"expiration_date\"];</code>"
        },
        "hasInnerMessage1": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 = 3;</code>\n     * @return Whether the innerMessage1 field is set."
        },
        "getInnerMessage1": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 = 3;</code>\n     * @return The innerMessage1."
        },
        "getInnerMessage1OrBuilder": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_1 = 3;</code>"
        },
        "hasInnerMessage2": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 = 4;</code>\n     * @return Whether the innerMessage2 field is set."
        },
        "getInnerMessage2": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 = 4;</code>\n     * @return The innerMessage2."
        },
        "getInnerMessage2OrBuilder": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage inner_message_2 = 4;</code>"
        }
      }
    },
    "com.google.gson.protobuf.generated.InnerMessageOrBuilder": {
      "Javadoc": "",
      "methods": {
        "hasNIdCt": {
          "Javadoc": "* <code>optional int32 n__id_ct = 1;</code>\n       * @return Whether the nIdCt field is set."
        },
        "getNIdCt": {
          "Javadoc": "* <code>optional int32 n__id_ct = 1;</code>\n       * @return The nIdCt."
        },
        "hasContent": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Type content = 2;</code>\n       * @return Whether the content field is set."
        },
        "getContent": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Type content = 2;</code>\n       * @return The content."
        },
        "getDataList": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data = 3 [(.google.gson.protobuf.generated.serialized_name) = \"$binary_data$\"];</code>"
        },
        "getData": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data = 3 [(.google.gson.protobuf.generated.serialized_name) = \"$binary_data$\"];</code>"
        },
        "getDataCount": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data = 3 [(.google.gson.protobuf.generated.serialized_name) = \"$binary_data$\"];</code>"
        },
        "getDataOrBuilderList": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data = 3 [(.google.gson.protobuf.generated.serialized_name) = \"$binary_data$\"];</code>"
        },
        "getDataOrBuilder": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data = 3 [(.google.gson.protobuf.generated.serialized_name) = \"$binary_data$\"];</code>"
        }
      }
    },
    "com.google.gson.protobuf.generated.InnerMessage": {
      "Javadoc": "\n     * Protobuf type {@code google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage}\n     ",
      "methods": {
        "hasNIdCt": {
          "Javadoc": "* <code>optional int32 n__id_ct = 1;</code>\n       * @return Whether the nIdCt field is set."
        },
        "getNIdCt": {
          "Javadoc": "* <code>optional int32 n__id_ct = 1;</code>\n       * @return The nIdCt."
        },
        "hasContent": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Type content = 2;</code>\n       * @return Whether the content field is set."
        },
        "getContent": {
          "Javadoc": "* <code>optional .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Type content = 2;</code>\n       * @return The content."
        },
        "getDataList": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data = 3 [(.google.gson.protobuf.generated.serialized_name) = \"$binary_data$\"];</code>"
        },
        "getDataOrBuilderList": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data = 3 [(.google.gson.protobuf.generated.serialized_name) = \"$binary_data$\"];</code>"
        },
        "getDataCount": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data = 3 [(.google.gson.protobuf.generated.serialized_name) = \"$binary_data$\"];</code>"
        },
        "getData": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data = 3 [(.google.gson.protobuf.generated.serialized_name) = \"$binary_data$\"];</code>"
        },
        "getDataOrBuilder": {
          "Javadoc": "* <code>repeated .google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data data = 3 [(.google.gson.protobuf.generated.serialized_name) = \"$binary_data$\"];</code>"
        }
      }
    },
    "com.google.gson.protobuf.generated.DataOrBuilder": {
      "Javadoc": "",
      "methods": {
        "hasData": {
          "Javadoc": "* <code>optional string data = 1;</code>\n         * @return Whether the data field is set."
        },
        "getData": {
          "Javadoc": "* <code>optional string data = 1;</code>\n         * @return The data."
        },
        "getDataBytes": {
          "Javadoc": "* <code>optional string data = 1;</code>\n         * @return The bytes for data."
        },
        "hasWidth": {
          "Javadoc": "* <code>optional int32 width = 2;</code>\n         * @return Whether the width field is set."
        },
        "getWidth": {
          "Javadoc": "* <code>optional int32 width = 2;</code>\n         * @return The width."
        },
        "hasHeight": {
          "Javadoc": "* <code>optional int32 height = 3;</code>\n         * @return Whether the height field is set."
        },
        "getHeight": {
          "Javadoc": "* <code>optional int32 height = 3;</code>\n         * @return The height."
        }
      }
    },
    "com.google.gson.protobuf.generated.Data": {
      "Javadoc": "\n       * Protobuf type {@code google.gson.protobuf.generated.ProtoWithAnnotations.InnerMessage.Data}\n       ",
      "methods": {
        "hasData": {
          "Javadoc": "* <code>optional string data = 1;</code>\n         * @return Whether the data field is set."
        },
        "getData": {
          "Javadoc": "* <code>optional string data = 1;</code>\n         * @return The data."
        },
        "getDataBytes": {
          "Javadoc": "* <code>optional string data = 1;</code>\n         * @return The bytes for data."
        },
        "hasWidth": {
          "Javadoc": "* <code>optional int32 width = 2;</code>\n         * @return Whether the width field is set."
        },
        "getWidth": {
          "Javadoc": "* <code>optional int32 width = 2;</code>\n         * @return The width."
        },
        "hasHeight": {
          "Javadoc": "* <code>optional int32 height = 3;</code>\n         * @return Whether the height field is set."
        },
        "getHeight": {
          "Javadoc": "* <code>optional int32 height = 3;</code>\n         * @return The height."
        }
      }
    }
  }
}